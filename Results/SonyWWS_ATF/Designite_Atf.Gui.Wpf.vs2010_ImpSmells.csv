Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The method has 108 lines of code.
Long Method,Sce.Atf.Wpf,WpfResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\WpfResourceUtil.cs,Register,The method has 102 lines of code.
Long Method,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,MeasureOverride,The method has 106 lines of code.
Long Method,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The method has 108 lines of code.
Long Method,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ApplyLayout,The method has 128 lines of code.
Long Method,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The method has 161 lines of code.
Complex Method,Sce.Atf.Wpf.Applications,AtfScriptVariables,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\AtfScriptVariables.cs,Initialize,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Wpf.Applications,AutoDocumentService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\AutoDocumentService.cs,mainWindow_Loaded,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Wpf.Applications,CommandComparer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\CommandComparer.cs,CompareTags,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Wpf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\VersionControl\SourceControlCommands.cs,DoReconcile,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Applications,WindowLayoutServiceCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\WindowLayoutServiceCommands.cs,ShowManageLayoutsDialog,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Behaviors,AtfTreeViewBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\AtfTreeViewBehavior.cs,EnsureVisiblePath_PropertyChanged,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Behaviors,AtfTreeViewBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\AtfTreeViewBehavior.cs,ExtendSelection,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,Cyclomatic complexity of the method is 16
Complex Method,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetNodesIntersecting,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetNodesInside,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf,DebugUtils,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\DebugUtils.cs,GetDataContext,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ResourceUtil.cs,TryGetImageResource,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Wpf,WpfResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\WpfResourceUtil.cs,Register,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Wpf.Controls,ValueChangedEventManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ValueChangedEventManager.cs,Purge,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyView.cs,SortPropertiesFromPropertyNamesList,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyView.cs,BuildProperty,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyView.cs,BuildCategories,Cyclomatic complexity of the method is 16
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,EditorTemplateSelector,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\EditorTemplateSelector.cs,SelectTemplate,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,EditorTemplateSelector,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\EditorTemplateSelector.cs,GetEditorKey,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGrid.cs,RebuildPropertyNodesImpl,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf.Controls.PropertyEditing,DynamicPropertyNode,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyNode.cs,InitializeInternal,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,FindElementsAt,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,HasChild,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,HasDescendant,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,FindParentLayout,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,FloatingWindow_MouseMove,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Docking,TabLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\TabLayout.cs,Content_PropertyChanged,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Dom\DomRecorder.cs,AnalyzeListeners,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Wpf.Models,TreeViewModel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\TreeViewModel.cs,UpdateChangedParents,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Wpf.Models,TreeViewModel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\TreeViewModel.cs,ExpandPath,Cyclomatic complexity of the method is 8
Long Parameter List,Sce.Atf.Wpf.Applications,CommandDef,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\CommandDef.cs,CommandDef,The method has 5 parameters. Parameters: commandTag' menuTag' groupTag' text' description
Long Parameter List,Sce.Atf.Wpf.Applications,CommandDef,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\CommandDef.cs,CommandDef,The method has 9 parameters. Parameters: commandTag' menuTag' groupTag' text' menuPath' description' imageSourceKey' inputGestures' visibility
Long Parameter List,Sce.Atf.Wpf.Applications,ControlInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ControlInfo.cs,ControlInfo,The method has 6 parameters. Parameters: name' description' id' group' dockContent' client
Long Parameter List,Sce.Atf.Wpf.Applications,ControlInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ControlInfo.cs,ControlInfo,The method has 7 parameters. Parameters: name' description' id' group' imageKey' dockContent' client
Long Parameter List,Sce.Atf.Wpf.Applications,ControlHostServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\IControlHostService.cs,RegisterControl,The method has 7 parameters. Parameters: controlHostService' control' name' description' group' id' client
Long Parameter List,Sce.Atf.Wpf.Applications,ControlHostServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\IControlHostService.cs,RegisterControl,The method has 8 parameters. Parameters: controlHostService' control' name' description' group' imageSourceKey' id' client
Long Parameter List,Sce.Atf.Wpf.Applications,IStatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\IStatusService.cs,RunProgressDialog,The method has 5 parameters. Parameters: message' canCancel' argument' workHandler' autoIncrement
Long Parameter List,Sce.Atf.Wpf.Applications,IStatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\IStatusService.cs,RunProgressInStatusBarAsync,The method has 5 parameters. Parameters: message' argument' workHandler' progressCompleteHandler' autoIncrement
Long Parameter List,Sce.Atf.Wpf.Applications,StatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\StatusService.cs,RunProgressDialog,The method has 5 parameters. Parameters: message' canCancel' argument' workHandler' autoIncrement
Long Parameter List,Sce.Atf.Wpf.Applications,StatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\StatusService.cs,RunProgressInStatusBarAsync,The method has 5 parameters. Parameters: message' argument' workHandler' progressCompleteHandler' autoIncrement
Long Parameter List,Sce.Atf.Wpf.Applications,TcpIpTarget,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\TcpIpTarget.cs,TcpIpTarget,The method has 5 parameters. Parameters: name' protocol' protocolName' ip' port
Long Parameter List,Sce.Atf.Wpf,WpfMessageBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\WpfMessageBox.cs,Show,The method has 5 parameters. Parameters: owner' messageBoxText' caption' button' icon
Long Parameter List,Sce.Atf.Wpf,WpfMessageBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\WpfMessageBox.cs,ShowDefault,The method has 5 parameters. Parameters: owner' messageBoxText' caption' button' icon
Long Parameter List,Sce.Atf.Wpf.Controls,BalancedWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\BalancedWrapPanel.cs,ArrangeLine,The method has 6 parameters. Parameters: lineStart' lineEnd' directDelta' directMaximum' indirectOffset' indirectGrowth
Long Parameter List,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,Log,The method has 5 parameters. Parameters: inputMinimum' inputMaximum' outputMinimum' outputMaximum' value
Long Parameter List,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,Exp,The method has 5 parameters. Parameters: inputMinimum' inputMaximum' outputMinimum' outputMaximum' value
Long Parameter List,Sce.Atf.Wpf.Controls,SnappingBitmap,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SnappingBitmap.cs,TryApplyVisualTransform,The method has 5 parameters. Parameters: point' v' inverse' throwOnError' success
Long Parameter List,Sce.Atf.Wpf.Controls.PropertyEditing,CustomizeAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyView.cs,CustomizeAttribute,The method has 9 parameters. Parameters: propertyName' columnWidth' disableSort' disableDragging' disableResize' disableEditing' hideDisplayName' horizontalEditorOffset' nameHasWholeRow
Long Parameter List,Sce.Atf.Wpf.Controls.PropertyEditing,NumberRangesAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\Attributes.cs,NumberRangesAttribute,The method has 5 parameters. Parameters: minimum' maximum' center' hardMin' hardMax
Long Parameter List,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,RegisterContent,The method has 5 parameters. Parameters: content' ucid' dockSide' header' icon
Long Parameter List,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,CreateDoubleAnimation,The method has 5 parameters. Parameters: from' to' duration' property' target
Long Parameter List,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,WndProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,Sce.Atf.Wpf.Models,NodeTypePaletteItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\NodeTypePaletteItem.cs,NodeTypePaletteItem,The method has 5 parameters. Parameters: nodeType' name' description' category' imageKey
Long Parameter List,Sce.Atf.Wpf.Models,NodeTypePaletteItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\NodeTypePaletteItem.cs,NodeTypePaletteItem,The method has 6 parameters. Parameters: nodeType' name' description' category' imageKey' protoType
Long Identifier,Sce.Atf.Wpf.Applications,CommandService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\CommandService.cs,,The length of the parameter m_cachedRequerySuggestedHandler is 31.
Long Identifier,Sce.Atf.Wpf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ControlHostService.cs,,The length of the parameter m_contentToShowOnMainWindowLoad is 31.
Long Identifier,Sce.Atf.Wpf.Applications,HelpCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\HelpCommands.cs,,The length of the parameter m_enableContextHelpUserSetting is 30.
Long Identifier,Sce.Atf.Wpf.Behaviors,AtfTreeViewBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\AtfTreeViewBehavior.cs,,The length of the parameter SynchronisingSelectionProperty is 30.
Long Identifier,Sce.Atf.Wpf.Behaviors,TreeViewItemLabelEditBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TreeViewItemLabelEditBehavior.cs,,The length of the parameter s_isInLabelEditModePropertyName is 31.
Long Identifier,Sce.Atf.Wpf,Resources,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Resources.cs,,The length of the parameter DefaultTreeViewItemTemplateKey is 30.
Long Identifier,Sce.Atf.Wpf,Resources,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Resources.cs,,The length of the parameter TreeViewLabelTextBlockStyleKey is 30.
Long Identifier,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,,The length of the parameter DeselectedDrawingBrushProperty is 30.
Long Identifier,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,,The length of the parameter ShowSelectedIconOnMouseOverProperty is 35.
Long Identifier,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGrid.cs,,The length of the parameter CustomPropertyDescriptorsProperty is 33.
Long Identifier,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGrid.cs,,The length of the parameter EditorTemplateSelectorProperty is 30.
Long Identifier,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGrid.cs,,The length of the parameter PropertyDetailsVisibilityProperty is 33.
Long Identifier,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGrid.cs,,The length of the parameter ListBoxItemContainerStyleProperty is 33.
Long Statement,Sce.Atf.Wpf.Applications,ThemesValueEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\AppearanceService.cs,GetCustomContext,The length of the statement  "            return (node == null) ? null : new StandardValuesEditorContext(node' AppearanceService.RegisteredSkins.Select(x => x.Name)); " is 124.
Long Statement,Sce.Atf.Wpf.Applications,CommandInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\CommandInfos.cs,GetCommandItem,The length of the statement  "                throw new InvalidTransactionException("CommandInfo was registered to an ICommandService' but not specifically to a CommandService."); " is 133.
Long Statement,Sce.Atf.Wpf.Applications,CommandInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\CommandInfos.cs,GetCommandItem,The length of the statement  "                throw new InvalidTransactionException("CommandService to which CommandInfo thinks it's registered has no record of it."); " is 121.
Long Statement,Sce.Atf.Wpf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ControlHostService.cs,RegisterControl,The length of the statement  "            ControlInfo contentInfo = new ControlInfo(def.Name' def.Description' def.Id' def.Group' def.ImageSourceKey' dockContent' client); " is 129.
Long Statement,Sce.Atf.Wpf.Applications,HelpCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\HelpCommands.cs,Initialize,The length of the statement  "                   new BoundPropertyDescriptor(this' () => ShowContextHelp' "Show Context Help".Localize()' "Help".Localize()' "Uncheck this to hide help commands in context menus".Localize())); " is 175.
Long Statement,Sce.Atf.Wpf.Applications,ControlHostServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\IControlHostService.cs,RegisterControl,The length of the statement  "            var def = new ControlDef() { Name = name' Description = description' Group = group' Id = id' ImageSourceKey = imageSourceKey }; " is 127.
Long Statement,Sce.Atf.Wpf.Applications,OutputService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\OutputService.cs,CanDoCommand,The length of the statement  "            Requires.NotNull(command' "Object specified is from class that doesn't implement ICommandItem.  Most likely' this is a not a command from WPF' and it should be."); " is 163.
Long Statement,Sce.Atf.Wpf.Applications,OutputService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\OutputService.cs,DoCommand,The length of the statement  "            Requires.NotNull(command' "Object specified is from class that doesn't implement ICommandItem.  Most likely' this is a not a command from WPF' and it should be."); " is 163.
Long Statement,Sce.Atf.Wpf.Applications,SynchronizeInvoke,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\SynchronizeInvoke.cs,EndInvoke,The length of the statement  "            while (res.Operation.Status != DispatcherOperationStatus.Completed || res.Operation.Status == DispatcherOperationStatus.Aborted) " is 128.
Long Statement,Sce.Atf.Wpf.Applications.VersionControl,CheckInDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\VersionControl\CheckInDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/applications/versioncontrol/checkindialog.xaml"' System.UriKind.Relative); " is 142.
Long Statement,Sce.Atf.Wpf.Applications.VersionControl,ReconcileDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\VersionControl\ReconcileDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/applications/versioncontrol/reconciledialog.xaml"' System.UriKind.Relative); " is 144.
Long Statement,Sce.Atf.Wpf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\WebServices\FeedbackForm.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/applications/webservices/feedbackform.xaml"' System.UriKind.Relative); " is 138.
Long Statement,Sce.Atf.Wpf.Applications.WebServices,VersionUpdateService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\WebServices\VersionUpdateService.cs,updateCheck_CheckComplete,The length of the statement  "                    WpfMessageBox.Show(val' "Error".Localize()' System.Windows.MessageBoxButton.OK' System.Windows.MessageBoxImage.Warning); " is 120.
Long Statement,Sce.Atf.Wpf.Behaviors,AtfTreeViewBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\AtfTreeViewBehavior.cs,EnsureVisiblePath_PropertyChanged,The length of the statement  "                        System.Diagnostics.Debug.WriteLineIf(nextTreeViewItem != null && nextTreeViewItem.DataContext != node' "Error in TreeView expand"); " is 131.
Long Statement,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The length of the statement  "                while (text.Length > 1 && text[0] == '0' && string.Empty + text[1] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator) " is 122.
Long Statement,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The length of the statement  "                while (text.Length > 2 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign && text[1] == '0' && string.Empty + text[2] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator) " is 193.
Long Statement,Sce.Atf.Wpf.Collections,RectExtensions,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,IsDefined,The length of the statement  "            return rect.Width >= 0.0 && rect.Height >= 0.0 && rect.Top < double.PositiveInfinity && rect.Left < double.PositiveInfinity && " is 126.
Long Statement,Sce.Atf.Wpf,DispatcherExtensions,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Extensions\DispatcherExtensions.cs,WaitForPriority,The length of the statement  "            DispatcherOperation dispatcherOperation = dispatcher.BeginInvoke(priority' new DispatcherOperationCallback(ExitFrameOperation)' frame); " is 135.
Long Statement,Sce.Atf.Wpf,MiscExtensions,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Extensions\MiscExtensions.cs,GuidTryParse,The length of the statement  "                "^({)?[0xA-Fa-f0-9]{3'10}(' {0'1}[0xA-Fa-f0-9]{3'6}){2}' {0'1}({)([0xA-Fa-f0-9]{3'4}' {0'1}){7}[0xA-Fa-f0-9]{3'4}(}})$"); " is 121.
Long Statement,Sce.Atf.Wpf,ImageUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ImageUtil.cs,RenderToBitmapSource,The length of the statement  "                drawingContext.DrawRectangle(sourceBrush' null' new Rect(new Point(0' 0)' new Point(visual.RenderSize.Width' visual.RenderSize.Height))); " is 137.
Long Statement,Sce.Atf.Wpf,ImageUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ImageUtil.cs,BitmapToSource,The length of the statement  "            destination = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(hBitmap' IntPtr.Zero' Int32Rect.Empty' sizeOptions); " is 127.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The length of the statement  "                this.m_topLeftClip.RadiusX = this.m_topLeftClip.RadiusY = newCornerRadius.TopLeft - (Math.Min(this.BorderThickness.Left' this.BorderThickness.Top) / 2); " is 152.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The length of the statement  "                this.m_topRightClip.RadiusX = this.m_topRightClip.RadiusY = newCornerRadius.TopRight - (Math.Min(this.BorderThickness.Top' this.BorderThickness.Right) / 2); " is 156.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The length of the statement  "                this.m_bottomRightClip.RadiusX = this.m_bottomRightClip.RadiusY = newCornerRadius.BottomRight - (Math.Min(this.BorderThickness.Right' this.BorderThickness.Bottom) / 2); " is 168.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The length of the statement  "                this.m_bottomLeftClip.RadiusX = this.m_bottomLeftClip.RadiusY = newCornerRadius.BottomLeft - (Math.Min(this.BorderThickness.Bottom' this.BorderThickness.Left) / 2); " is 164.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateClipSize,The length of the statement  "                    this.m_topLeftClip.Rect = new Rect(0' 0' contentWidth + (this.CornerRadius.TopLeft * 2)' contentHeight + (this.CornerRadius.TopLeft * 2)); " is 138.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateClipSize,The length of the statement  "                    this.m_topRightClip.Rect = new Rect(0 - this.CornerRadius.TopRight' 0' contentWidth + this.CornerRadius.TopRight' contentHeight + this.CornerRadius.TopRight); " is 158.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateClipSize,The length of the statement  "                    this.m_bottomRightClip.Rect = new Rect(0 - this.CornerRadius.BottomRight' 0 - this.CornerRadius.BottomRight' contentWidth + this.CornerRadius.BottomRight' contentHeight + this.CornerRadius.BottomRight); " is 202.
Long Statement,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateClipSize,The length of the statement  "                    this.m_bottomLeftClip.Rect = new Rect(0' 0 - this.CornerRadius.BottomLeft' contentWidth + this.CornerRadius.BottomLeft' contentHeight + this.CornerRadius.BottomLeft); " is 166.
Long Statement,Sce.Atf.Wpf.Controls,ConfirmationDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ConfirmationDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/confirmationdialog.xaml"' System.UriKind.Relative); " is 128.
Long Statement,Sce.Atf.Wpf.Controls,BrowseForFolderDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DirectoryPicker.cs,BrowseEventHandler,The length of the statement  "                        // lParam   A pointer to a string containing the invalid name. An application can use this data in an error dialog informing the user that the name was not valid. " is 162.
Long Statement,Sce.Atf.Wpf.Controls,BrowseForFolderDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DirectoryPicker.cs,BrowseEventHandler,The length of the statement  "                        // lParam   A pointer to a string containing the invalid name. An application can use this data in an error dialog informing the user that the name was not valid. " is 162.
Long Statement,Sce.Atf.Wpf.Controls,DomRecorderView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DomRecorderView.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/domrecorderview.xaml"' System.UriKind.Relative); " is 125.
Long Statement,Sce.Atf.Wpf.Controls,FindFileDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\FindFileDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/findfiledialog.xaml"' System.UriKind.Relative); " is 124.
Long Statement,Sce.Atf.Wpf.Controls,FindTargetsDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\FindTargetsDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/findtargetsdialog.xaml"' System.UriKind.Relative); " is 127.
Long Statement,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The length of the statement  "            if ((this.SourceBrush == null) || (((source != null) && IsClose(source.Width' base.RenderSize.Width)) && IsClose(source.Height' base.RenderSize.Height))) " is 153.
Long Statement,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,ScaleColor,The length of the statement  "            return Color.FromArgb((byte)((alpha * color.A) / 0xff)' (byte)(((((double)color.R) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.G) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.B) / 255.0) * (primary - white)) + white)); " is 257.
Long Statement,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "UnexpectedImageSourceType"' new object[] { imageSource.GetType().Name })); " is 145.
Long Statement,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The length of the statement  "                FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold); " is 126.
Long Statement,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The length of the statement  "                source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride); " is 135.
Long Statement,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColorsWithoutCloning,The length of the statement  "                                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "UnexpectedBrushType"' new object[] { brush.GetType().Name })); " is 133.
Long Statement,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColorsWithoutCloning,The length of the statement  "                                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "UnexpectedDrawingType"' new object[] { drawing.GetType().Name })); " is 137.
Long Statement,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColorsWithoutCloningIfPossible,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "UnexpectedImageSourceType"' new object[] { imageSource.GetType().Name })); " is 145.
Long Statement,Sce.Atf.Wpf.Controls,WindowLayoutManageDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ManageWindowLayoutsDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/managewindowlayoutsdialog.xaml"' System.UriKind.Relative); " is 135.
Long Statement,Sce.Atf.Wpf.Controls,SettingsDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SettingsDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/settingsdialog.xaml"' System.UriKind.Relative); " is 124.
Long Statement,Sce.Atf.Wpf.Controls,SettingsLoadSaveDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SettingsLoadSaveDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/settingsloadsavedialog.xaml"' System.UriKind.Relative); " is 132.
Long Statement,Sce.Atf.Wpf.Controls,SizeBasedTemplateSelector,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SizeBasedTemplateSelector.cs,FindTemplateBySize,The length of the statement  "                    //System.Diagnostics.Debug.WriteLine("An appropriately sized template was found for width {0} and height {1}"' actualWidth' actualHeight); " is 138.
Long Statement,Sce.Atf.Wpf.Controls,SizeBasedTemplateSelector,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SizeBasedTemplateSelector.cs,FindTemplateBySize,The length of the statement  "            //System.Diagnostics.Debug.WriteLine("No appropriately sized template was found for {0} {1} - using the first template instead"' actualWidth' actualHeight); " is 156.
Long Statement,Sce.Atf.Wpf.Controls,SwitchToDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SwitchToDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/switchtodialog.xaml"' System.UriKind.Relative); " is 124.
Long Statement,Sce.Atf.Wpf.Controls,TargetDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TargetDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/targetdialog.xaml"' System.UriKind.Relative); " is 122.
Long Statement,Sce.Atf.Wpf.Controls,TcpIpTargetEditDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TcpIpTargetEditDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/tcpiptargeteditdialog.xaml"' System.UriKind.Relative); " is 131.
Long Statement,Sce.Atf.Wpf.Controls,WindowLayoutNewDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\WindowLayoutNameDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/windowlayoutnamedialog.xaml"' System.UriKind.Relative); " is 132.
Long Statement,Sce.Atf.Wpf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\AboutDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/aboutdialog.xaml"' System.UriKind.Relative); " is 121.
Long Statement,Sce.Atf.Wpf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\AboutDialog.xaml.cs,Connect,The length of the statement  "            this.hyperlink.RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.hyperlink_RequestNavigate); " is 124.
Long Statement,Sce.Atf.Wpf.Controls,CommonDialogHost,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,OnClosing,The length of the statement  "                // http://stackoverflow.com/questions/13209526/main-window-disappears-behind-other-applications-windows-after-a-sub-window-use " is 126.
Long Statement,Sce.Atf.Wpf.Controls,CommonDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,OnClosing,The length of the statement  "            // http://stackoverflow.com/questions/13209526/main-window-disappears-behind-other-applications-windows-after-a-sub-window-use " is 126.
Long Statement,Sce.Atf.Wpf.Controls,ErrorDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ErrorDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/errordialog.xaml"' System.UriKind.Relative); " is 121.
Long Statement,Sce.Atf.Wpf.Controls,MainWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MainWindow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/mainwindow.xaml"' System.UriKind.Relative); " is 120.
Long Statement,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/messageboxdialog.xaml"' System.UriKind.Relative); " is 126.
Long Statement,Sce.Atf.Wpf.Controls,ProgressDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ProgressDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/progressdialog.xaml"' System.UriKind.Relative); " is 124.
Long Statement,Sce.Atf.Wpf.Controls,TreeGridViewRowPresenter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TreeListView.cs,ArrangeOverride,The length of the statement  "                double w = Math.Min(max' (Double.IsNaN(column.Width)) ? (double)DesiredWidthProperty.GetValue(column' null) : column.Width); " is 124.
Long Statement,Sce.Atf.Wpf.Controls,UnhandledExceptionDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\UnhandledExceptionDialog.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/unhandledexceptiondialog.xaml"' System.UriKind.Relative); " is 134.
Long Statement,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGridView.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/controls/propertyediting/propertygridview.xaml"' System.UriKind.Relative); " is 142.
Long Statement,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyView.cs,MultiLevelSort,The length of the statement  "                result = string.Compare(pathA[pathA.Count - depth - 1].Descriptor.Name' pathB[pathB.Count - depth - 1].Descriptor.Name); " is 120.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,TitleBarMouseMove,The length of the statement  "                if ((Math.Abs(delta.X) > SystemParameters.MinimumHorizontalDragDistance) || (Math.Abs(delta.Y) > SystemParameters.MinimumVerticalDragDistance)) " is 143.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The length of the statement  "            m_dockLeftIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2 - Root.DockIconSize.Width - space' offset.Y + center.Y - Root.DockIconSize.Height / 2); " is 171.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The length of the statement  "            m_dockRightIcon.Offset = new Point(offset.X + center.X + Root.DockIconSize.Width / 2 + space' offset.Y + center.Y - Root.DockIconSize.Height / 2); " is 146.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The length of the statement  "            m_dockTopIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y - Root.DockIconSize.Height / 2 - Root.DockIconSize.Height - space); " is 171.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The length of the statement  "            m_dockBottomIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y + Root.DockIconSize.Height / 2 + space); " is 147.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The length of the statement  "            m_dockTabIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y - Root.DockIconSize.Height / 2); " is 136.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The length of the statement  "                    ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings; " is 141.
Long Statement,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,ReadXml,The length of the statement  "                if (reader.LocalName == typeof(TabLayout).Name || reader.LocalName == "MultiContent") // MultiContent is old name and is used here for compatibility with old saved layouts " is 171.
Long Statement,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Drag,The length of the statement  "            ContentSettings settings = (content is TabLayout) ? ((TabLayout)content).Children[0].Settings : ((DockContent)content).Settings; " is 128.
Long Statement,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Collapse,The length of the statement  "                    RenderTargetBitmap bitmap = new RenderTargetBitmap((int)rectFrom.Width' (int)rectFrom.Height' 96' 96' PixelFormats.Default); " is 124.
Long Statement,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The length of the statement  "                    ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings; " is 141.
Long Statement,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDrop,The length of the statement  "                ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings; " is 141.
Long Statement,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,ReadXml,The length of the statement  "                if (reader.LocalName == typeof(TabLayout).Name || reader.LocalName == "MultiContent") // MultiContent is old name and is used here for compatibility with old saved layouts " is 171.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,NewGridSplitter,The length of the statement  "            splitter.ResizeDirection = orientation == Orientation.Horizontal ? GridResizeDirection.Columns : GridResizeDirection.Rows; " is 122.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                        ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings; " is 144.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                        double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5); " is 132.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width); " is 151.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width); " is 152.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width); " is 151.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width); " is 152.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                        ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings; " is 144.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                        double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5); " is 138.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height); " is 138.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height); " is 140.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height); " is 138.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The length of the statement  "                            RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height); " is 141.
Long Statement,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,WriteXml,The length of the statement  "                        writer.WriteAttributeString("Width"' ColumnDefinitions[Grid.GetColumn((FrameworkElement)layout)].Width.Value.ToString()); " is 121.
Long Statement,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Atf.Gui.Wpf;component/docking/resizablepopup.xaml"' System.UriKind.Relative); " is 123.
Long Statement,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,Timer_Elapsed,The length of the statement  "                if (m_lastItemOver != null && new Rect(0' 0' m_lastItemOver.ActualWidth' m_lastItemOver.ActualHeight).Contains(curMousePos)) " is 124.
Long Statement,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,CreateHeader,The length of the statement  "            StackPanel header = new StackPanel() { Orientation = System.Windows.Controls.Orientation.Horizontal /*this.Orientation*/ }; " is 123.
Long Statement,Sce.Atf.Wpf.Docking,TabLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\TabLayout.cs,TabControl_MouseMove,The length of the statement  "                if ((Math.Abs(delta.X) > SystemParameters.MinimumHorizontalDragDistance) || (Math.Abs(delta.Y) > SystemParameters.MinimumVerticalDragDistance)) " is 143.
Long Statement,Sce.Atf.Wpf.Docking,TabLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\TabLayout.cs,ReadXml,The length of the statement  "            if (reader.LocalName == this.GetType().Name || reader.LocalName == "MultiContent") // MultiContent is old name and is used here for compatibility with old saved layouts " is 168.
Long Statement,Sce.Atf.Wpf.Interop,CommandClientAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Interop\CommandClientAdapter.cs,CanDoCommand,The length of the statement  "            Requires.NotNull(command' "Object specified is from class that doesn't implement ICommandItem.  Most likely' this is a not a command from WPF' and it should be."); " is 163.
Long Statement,Sce.Atf.Wpf.Interop,CommandClientAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Interop\CommandClientAdapter.cs,DoCommand,The length of the statement  "            Requires.NotNull(command' "Object specified is from class that doesn't implement ICommandItem.  Most likely' this is a not a command from WPF' and it should be."); " is 163.
Long Statement,Sce.Atf.Wpf.Interop,CommandClientAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Interop\CommandClientAdapter.cs,UpdateCommand,The length of the statement  "            throw new InvalidOperationException("CommandClientAdapter.UpdateCommand() - WPF shouldn't ever be calling this method' and suggests a non-WPF app is erroneously using CommandClientAdapter."); " is 191.
Long Statement,Sce.Atf.Wpf.Interop,ControlHostServiceAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Interop\ControlHostServiceAdapter.cs,RegisterControl,The length of the statement  "            IControlInfo contentInfo = m_adaptee.RegisterControl(control' controlInfo.Name' controlInfo.Description' controlInfo.Group' uniqueId.ToString()' clientAdapter); " is 160.
Long Statement,Sce.Atf.Wpf.Interop,MainWindowAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Interop\MainWindowAdapter.cs,Initialize,The length of the statement  "                m_settingsService.RegisterSettings(this' new BoundPropertyDescriptor(this' () => MainFormBounds' "MainFormBounds"' null' null)' new BoundPropertyDescriptor(this' () => MainFormWindowState' "MainFormWindowState"' null' null)); " is 225.
Long Statement,Sce.Atf.Wpf.Interop,MainWindowAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Interop\MainWindowAdapter.cs,StoreBounds,The length of the statement  "                m_mainFormBounds = new Rect(wnd.RestoreBounds.Left' wnd.RestoreBounds.Top' wnd.RestoreBounds.Width' wnd.RestoreBounds.Height); " is 126.
Long Statement,Sce.Atf.Wpf.Models,BindingAdapterObject,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\BindingAdapterObject.cs,GetDescriptorsFromBaseTypes,The length of the statement  "                        System.Diagnostics.Debug.WriteLine("Warning: Ignoring multiple base types with the same simple name: " + baseType.Name); " is 120.
Long Statement,Sce.Atf.Wpf.ValueConverters,TimeSpanFormatConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,Convert,The length of the statement  "            return string.Format("{0:D2}:{1:D2}:{2:D2}.{3:D3}"' timespan.Hours' timespan.Minutes' timespan.Seconds' timespan.Milliseconds); " is 127.
Long Statement,Sce.Atf.Wpf.ValueConverters,EnumDescriptionConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,Convert,The length of the statement  "            var field = value.GetType().GetFields(BindingFlags.Static | BindingFlags.GetField | BindingFlags.Public).FirstOrDefault(f => f.GetValue(null).Equals(value)); " is 157.
Long Statement,Sce.Atf.Wpf.ValueConverters,EnumDescriptionConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,Convert,The length of the statement  "                var descriptionAttribute = field.GetCustomAttributes(typeof(DescriptionAttribute)' true).FirstOrDefault() as DescriptionAttribute; " is 130.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\obj\Debug.vs2010\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The conditional expression  "text.Length > 2 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign && text[1] == '0' && string.Empty + text[2] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator"  is complex.
Complex Conditional,Sce.Atf.Wpf.Collections,PriorityQuadTree<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Insert,The conditional expression  "bounds.Top.IsNaN() || bounds.Left.IsNaN() || bounds.Width.IsNaN() || bounds.Height.IsNaN()"  is complex.
Complex Conditional,Sce.Atf.Wpf.Collections,PriorityQuadTree<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,HasItemsInside,The conditional expression  "bounds.Top.IsNaN() || bounds.Left.IsNaN() || bounds.Width.IsNaN() || bounds.Height.IsNaN()"  is complex.
Complex Conditional,Sce.Atf.Wpf.Collections,PriorityQuadTree<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetItemsInside,The conditional expression  "bounds.Top.IsNaN() || bounds.Left.IsNaN() || bounds.Width.IsNaN() || bounds.Height.IsNaN()"  is complex.
Complex Conditional,Sce.Atf.Wpf.Collections,PriorityQuadTree<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,HasItemsIntersecting,The conditional expression  "bounds.Top.IsNaN() || bounds.Left.IsNaN() || bounds.Width.IsNaN() || bounds.Height.IsNaN()"  is complex.
Complex Conditional,Sce.Atf.Wpf.Collections,PriorityQuadTree<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetItemsIntersecting,The conditional expression  "bounds.Top.IsNaN() || bounds.Left.IsNaN() || bounds.Width.IsNaN() || bounds.Height.IsNaN()"  is complex.
Complex Conditional,Sce.Atf.Wpf.Collections,PriorityQuadTree<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Remove,The conditional expression  "bounds.Top.IsNaN() || bounds.Left.IsNaN() || bounds.Width.IsNaN() || bounds.Height.IsNaN()"  is complex.
Complex Conditional,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The conditional expression  "(this.SourceBrush == null) || (((source != null) && IsClose(source.Width' base.RenderSize.Width)) && IsClose(source.Height' base.RenderSize.Height))"  is complex.
Complex Conditional,Sce.Atf.Wpf.Controls.PropertyEditing,NumberRangesAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\Attributes.cs,Equals,The conditional expression  "(attribute.m_minimum == m_minimum)                       && (attribute.m_maximum == m_maximum)                      && (attribute.m_hardMinimum == m_hardMinimum)                      && (attribute.m_hardMaximum == m_hardMaximum)                      && (attribute.m_center == m_center)"  is complex.
Complex Conditional,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The conditional expression  "dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right)"  is complex.
Complex Conditional,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The conditional expression  "dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left)"  is complex.
Complex Conditional,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The conditional expression  "dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom)"  is complex.
Complex Conditional,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The conditional expression  "dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top)"  is complex.
Complex Conditional,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The conditional expression  "dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom"  is complex.
Virtual Method Call from Constructor,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,SliderValueEditorContext,The constructor "SliderValueEditorContext" calls a virtual method "Update".
Virtual Method Call from Constructor,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,SliderValueEditorContext,The constructor "SliderValueEditorContext" calls a virtual method "Update".
Empty Catch Block,Sce.Atf.Wpf.Applications,AutoDocumentService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\AutoDocumentService.cs,mainWindow_Loaded,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,ValidateValue,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,ValidateValue,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Controls,SwitchToDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SwitchToDialog.xaml.cs,OnLoaded,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Controls,CommonDialogHost,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,RequestClose,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Controls,CommonDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,ViewModel_CloseDialog,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,Update,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,Update,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,Update,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ApplyLayout,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ApplyLayout,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,Timer_Elapsed,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.Models,ManageWindowLayoutsDialogViewModel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\WindowLayoutViewModels.cs,SlotRenamed,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.ValueConverters,EnumToBooleanConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,ConvertBack,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Wpf.ValueConverters,EnumToBooleanConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,ConvertBack,The method has an empty catch block.
Magic Number,Sce.Atf.Wpf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ControlHostService.cs,SetDockPanelState,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  m_dockPanel.ApplyLayout(null);              }              else              {                  using (var stream = new MemoryStream())                  {                      var writer = new StreamWriter(stream);                        if (string.Compare(value' 0' "<?xml"' 0' 5) != 0)                      {                          // prepend an xml header' as it is stripped off by the settings service                          writer.Write(@"<?xml version=""1.0"" encoding=""utf-8""?>");                      }                      writer.Write(value);                      writer.Flush();                      stream.Seek(0' SeekOrigin.Begin);                        var reader = XmlReader.Create(stream);                        try                      {                          m_dockPanel.ApplyLayout(reader);                      }                      catch                      {                          Sce.Atf.Outputs.WriteLine(OutputMessageType.Error' "Could not load window layout".Localize());                      }                  }              }
Magic Number,Sce.Atf.Wpf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point topLeft = new Point(                  center.X - oldBounds.Width / 2'                  center.Y - oldBounds.Height / 2);
Magic Number,Sce.Atf.Wpf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point topLeft = new Point(                  center.X - oldBounds.Width / 2'                  center.Y - oldBounds.Height / 2);
Magic Number,Sce.Atf.Wpf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point offset = new Point(                  center.X - (bounds.Left + bounds.Width / 2)'                  center.Y - (bounds.Top + bounds.Height / 2));
Magic Number,Sce.Atf.Wpf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point offset = new Point(                  center.X - (bounds.Left + bounds.Width / 2)'                  center.Y - (bounds.Top + bounds.Height / 2));
Magic Number,Sce.Atf.Wpf.Applications,SynchronizeInvoke,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\SynchronizeInvoke.cs,EndInvoke,The following statement contains a magic number: while (res.Operation.Status != DispatcherOperationStatus.Completed || res.Operation.Status == DispatcherOperationStatus.Aborted)              {                  Thread.Sleep(50);              }
Magic Number,Sce.Atf.Wpf.Applications,TcpIpProtocol,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\TcpIpProtocol.cs,TcpIpProtocol,The following statement contains a magic number: DefaultPortNumber = 4001;
Magic Number,Sce.Atf.Wpf.Applications.WebServices,VersionCheck,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\WebServices\VersionCheck.cs,DoCheck,The following statement contains a magic number: try              {                  if (ms_checkInProgress)                      return;                                    ms_checkInProgress = true;                  var checker = new VersionCheckerService();                  object[] versionInfo = checker.getLatestVersionInfo(m_appMappingName);                  string strServerVersion = ((string)versionInfo[0]).Trim();                  string[] arrStr = strServerVersion.Split(' ');                  ServerVersion = new Version(arrStr[arrStr.Length - 1]);                    string url = null;                    if (ServerVersion > AppVersion)                  {                      url = ((string)versionInfo[2]).Trim();                  }                    NotifyClients(url' false);                }              catch (Exception e)              {                  NotifyClients("Version check failed.\nError: " + e.Message' true);              }              finally              {                  ms_checkInProgress = false;              }
Magic Number,Sce.Atf.Wpf.Behaviors,DragAutoScrollBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\DragAutoScrollBehavior.cs,DragAutoScrollBehavior,The following statement contains a magic number: Tolerance = 10;
Magic Number,Sce.Atf.Wpf.Behaviors,DragAutoScrollBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\DragAutoScrollBehavior.cs,DragAutoScrollBehavior,The following statement contains a magic number: Offset = 10;
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,textBlock_PreviewMouseLeftButtonDown,The following statement contains a magic number: if (e.ClickCount == 2)              {                  (sender as TextBlock).SetValue(IsInEditModeProperty' true);                  e.Handled = true;              }
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,textBlock_MouseLeftButtonUp,The following statement contains a magic number: if (e.ClickCount == 2)              {                  (sender as TextBlock).SetValue(IsInEditModeProperty' true);              }
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,MeasureOverride,The following statement contains a magic number: m_textBox.MinWidth = Math.Max(45.0' AdornedElement.DesiredSize.Width + 4);
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,MeasureOverride,The following statement contains a magic number: m_textBox.MinWidth = Math.Max(45.0' AdornedElement.DesiredSize.Width + 4);
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,MeasureOverride,The following statement contains a magic number: m_textBox.Measure(new Size(double.PositiveInfinity' constraint.Height + 4));
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,ArrangeOverride,The following statement contains a magic number: var rect = new Rect(-4' -2' m_textBox.DesiredSize.Width' m_textBox.DesiredSize.Height + 2 + 4);
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,ArrangeOverride,The following statement contains a magic number: var rect = new Rect(-4' -2' m_textBox.DesiredSize.Width' m_textBox.DesiredSize.Height + 2 + 4);
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,ArrangeOverride,The following statement contains a magic number: var rect = new Rect(-4' -2' m_textBox.DesiredSize.Width' m_textBox.DesiredSize.Height + 2 + 4);
Magic Number,Sce.Atf.Wpf.Behaviors,EditableTextBlockAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\EditableTextBlockBehavior.cs,ArrangeOverride,The following statement contains a magic number: var rect = new Rect(-4' -2' m_textBox.DesiredSize.Width' m_textBox.DesiredSize.Height + 2 + 4);
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,InsertionAdorner,The following statement contains a magic number: pen = new Pen { Brush = Brushes.Gray' Thickness = 2 };
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,InsertionAdorner,The following statement contains a magic number: LineSegment firstLine = new LineSegment(new Point(0' -5)' false);
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,InsertionAdorner,The following statement contains a magic number: LineSegment secondLine = new LineSegment(new Point(0' 5)' false);
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,InsertionAdorner,The following statement contains a magic number: PathFigure figure = new PathFigure { StartPoint = new Point(5' 0) };
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,OnRender,The following statement contains a magic number: if (isSeparatorHorizontal)              {                  DrawTriangle(drawingContext' startPoint' 0);                  DrawTriangle(drawingContext' endPoint' 180);              }              else              {                  DrawTriangle(drawingContext' startPoint' 90);                  DrawTriangle(drawingContext' endPoint' -90);              }
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,OnRender,The following statement contains a magic number: if (isSeparatorHorizontal)              {                  DrawTriangle(drawingContext' startPoint' 0);                  DrawTriangle(drawingContext' endPoint' 180);              }              else              {                  DrawTriangle(drawingContext' startPoint' 90);                  DrawTriangle(drawingContext' endPoint' -90);              }
Magic Number,Sce.Atf.Wpf.Behaviors,InsertionAdorner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ItemsControlDropTargetBehavior.cs,OnRender,The following statement contains a magic number: if (isSeparatorHorizontal)              {                  DrawTriangle(drawingContext' startPoint' 0);                  DrawTriangle(drawingContext' endPoint' 180);              }              else              {                  DrawTriangle(drawingContext' startPoint' 90);                  DrawTriangle(drawingContext' endPoint' -90);              }
Magic Number,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The following statement contains a magic number: if (isValid)              {                  int caret = tb.CaretIndex;                  string text = tb.Text;                  bool textInserted = false;                  int selectionLength = 0;                    if (tb.SelectionLength > 0)                  {                      text = text.Substring(0' tb.SelectionStart) +                              text.Substring(tb.SelectionStart + tb.SelectionLength);                      caret = tb.SelectionStart;                  }                    if (e.Text == NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      while (true)                      {                          int ind = text.IndexOf(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator);                          if (ind == -1)                              break;                            text = text.Substring(0' ind) + text.Substring(ind + 1);                          if (caret > ind)                              caret--;                      }                        if (caret == 0)                      {                          text = "0" + text;                          caret++;                      }                      else                      {                          if (caret == 1 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign)                          {                              text = NumberFormatInfo.CurrentInfo.NegativeSign + "0" + text.Substring(1);                              caret++;                          }                      }                        if (caret == text.Length)                      {                          selectionLength = 1;                          textInserted = true;                          text = text + NumberFormatInfo.CurrentInfo.NumberDecimalSeparator + "0";                          caret++;                      }                  }                  else if (e.Text == NumberFormatInfo.CurrentInfo.NegativeSign)                  {                      textInserted = true;                      if (tb.Text.Contains(NumberFormatInfo.CurrentInfo.NegativeSign))                      {                          text = text.Replace(NumberFormatInfo.CurrentInfo.NegativeSign' string.Empty);                          if (caret != 0)                              caret--;                      }                      else                      {                          text = NumberFormatInfo.CurrentInfo.NegativeSign + tb.Text;                          caret++;                      }                  }                    if (!textInserted)                  {                      text = text.Substring(0' caret) + e.Text +                          ((caret < tb.Text.Length) ? text.Substring(caret) : string.Empty);                        caret++;                  }                    try                  {                      double val = Convert.ToDouble(text);                      double newVal = ValidateLimits(GetMinimumValue(tb)' GetMaximumValue(tb)' val);                      if (val != newVal)                      {                          text = newVal.ToString();                      }                      else if (val == 0)                      {                          if (!text.Contains(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator))                              text = "0";                      }                  }                  catch                  {                      text = "0";                  }                    while (text.Length > 1 && text[0] == '0' && string.Empty + text[1] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      text = text.Substring(1);                      if (caret > 0)                          caret--;                  }                    while (text.Length > 2 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign && text[1] == '0' && string.Empty + text[2] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      text = NumberFormatInfo.CurrentInfo.NegativeSign + text.Substring(2);                      if (caret > 1)                          caret--;                  }                    if (caret > text.Length)                      caret = text.Length;                    tb.Text = text;                  tb.CaretIndex = caret;                  tb.SelectionStart = caret;                  tb.SelectionLength = selectionLength;                  e.Handled = true;              }
Magic Number,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The following statement contains a magic number: if (isValid)              {                  int caret = tb.CaretIndex;                  string text = tb.Text;                  bool textInserted = false;                  int selectionLength = 0;                    if (tb.SelectionLength > 0)                  {                      text = text.Substring(0' tb.SelectionStart) +                              text.Substring(tb.SelectionStart + tb.SelectionLength);                      caret = tb.SelectionStart;                  }                    if (e.Text == NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      while (true)                      {                          int ind = text.IndexOf(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator);                          if (ind == -1)                              break;                            text = text.Substring(0' ind) + text.Substring(ind + 1);                          if (caret > ind)                              caret--;                      }                        if (caret == 0)                      {                          text = "0" + text;                          caret++;                      }                      else                      {                          if (caret == 1 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign)                          {                              text = NumberFormatInfo.CurrentInfo.NegativeSign + "0" + text.Substring(1);                              caret++;                          }                      }                        if (caret == text.Length)                      {                          selectionLength = 1;                          textInserted = true;                          text = text + NumberFormatInfo.CurrentInfo.NumberDecimalSeparator + "0";                          caret++;                      }                  }                  else if (e.Text == NumberFormatInfo.CurrentInfo.NegativeSign)                  {                      textInserted = true;                      if (tb.Text.Contains(NumberFormatInfo.CurrentInfo.NegativeSign))                      {                          text = text.Replace(NumberFormatInfo.CurrentInfo.NegativeSign' string.Empty);                          if (caret != 0)                              caret--;                      }                      else                      {                          text = NumberFormatInfo.CurrentInfo.NegativeSign + tb.Text;                          caret++;                      }                  }                    if (!textInserted)                  {                      text = text.Substring(0' caret) + e.Text +                          ((caret < tb.Text.Length) ? text.Substring(caret) : string.Empty);                        caret++;                  }                    try                  {                      double val = Convert.ToDouble(text);                      double newVal = ValidateLimits(GetMinimumValue(tb)' GetMaximumValue(tb)' val);                      if (val != newVal)                      {                          text = newVal.ToString();                      }                      else if (val == 0)                      {                          if (!text.Contains(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator))                              text = "0";                      }                  }                  catch                  {                      text = "0";                  }                    while (text.Length > 1 && text[0] == '0' && string.Empty + text[1] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      text = text.Substring(1);                      if (caret > 0)                          caret--;                  }                    while (text.Length > 2 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign && text[1] == '0' && string.Empty + text[2] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      text = NumberFormatInfo.CurrentInfo.NegativeSign + text.Substring(2);                      if (caret > 1)                          caret--;                  }                    if (caret > text.Length)                      caret = text.Length;                    tb.Text = text;                  tb.CaretIndex = caret;                  tb.SelectionStart = caret;                  tb.SelectionLength = selectionLength;                  e.Handled = true;              }
Magic Number,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,TextBox_PreviewTextInput,The following statement contains a magic number: if (isValid)              {                  int caret = tb.CaretIndex;                  string text = tb.Text;                  bool textInserted = false;                  int selectionLength = 0;                    if (tb.SelectionLength > 0)                  {                      text = text.Substring(0' tb.SelectionStart) +                              text.Substring(tb.SelectionStart + tb.SelectionLength);                      caret = tb.SelectionStart;                  }                    if (e.Text == NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      while (true)                      {                          int ind = text.IndexOf(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator);                          if (ind == -1)                              break;                            text = text.Substring(0' ind) + text.Substring(ind + 1);                          if (caret > ind)                              caret--;                      }                        if (caret == 0)                      {                          text = "0" + text;                          caret++;                      }                      else                      {                          if (caret == 1 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign)                          {                              text = NumberFormatInfo.CurrentInfo.NegativeSign + "0" + text.Substring(1);                              caret++;                          }                      }                        if (caret == text.Length)                      {                          selectionLength = 1;                          textInserted = true;                          text = text + NumberFormatInfo.CurrentInfo.NumberDecimalSeparator + "0";                          caret++;                      }                  }                  else if (e.Text == NumberFormatInfo.CurrentInfo.NegativeSign)                  {                      textInserted = true;                      if (tb.Text.Contains(NumberFormatInfo.CurrentInfo.NegativeSign))                      {                          text = text.Replace(NumberFormatInfo.CurrentInfo.NegativeSign' string.Empty);                          if (caret != 0)                              caret--;                      }                      else                      {                          text = NumberFormatInfo.CurrentInfo.NegativeSign + tb.Text;                          caret++;                      }                  }                    if (!textInserted)                  {                      text = text.Substring(0' caret) + e.Text +                          ((caret < tb.Text.Length) ? text.Substring(caret) : string.Empty);                        caret++;                  }                    try                  {                      double val = Convert.ToDouble(text);                      double newVal = ValidateLimits(GetMinimumValue(tb)' GetMaximumValue(tb)' val);                      if (val != newVal)                      {                          text = newVal.ToString();                      }                      else if (val == 0)                      {                          if (!text.Contains(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator))                              text = "0";                      }                  }                  catch                  {                      text = "0";                  }                    while (text.Length > 1 && text[0] == '0' && string.Empty + text[1] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      text = text.Substring(1);                      if (caret > 0)                          caret--;                  }                    while (text.Length > 2 && string.Empty + text[0] == NumberFormatInfo.CurrentInfo.NegativeSign && text[1] == '0' && string.Empty + text[2] != NumberFormatInfo.CurrentInfo.NumberDecimalSeparator)                  {                      text = NumberFormatInfo.CurrentInfo.NegativeSign + text.Substring(2);                      if (caret > 1)                          caret--;                  }                    if (caret > text.Length)                      caret = text.Length;                    tb.Text = text;                  tb.CaretIndex = caret;                  tb.SelectionStart = caret;                  tb.SelectionLength = selectionLength;                  e.Handled = true;              }
Magic Number,Sce.Atf.Wpf.Behaviors,TreeViewDragHoverExpandBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TreeViewDragHoverExpandBehavior.cs,TreeViewDragHoverExpandBehavior,The following statement contains a magic number: m_timer = new DispatcherTimer(TimeSpan.FromMilliseconds(1000)' DispatcherPriority.Normal' TimerElapsed' Dispatcher.CurrentDispatcher);
Magic Number,Sce.Atf.Wpf.Behaviors,TreeViewItemLabelEditBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TreeViewItemLabelEditBehavior.cs,AssociatedObject_PreviewMouseUp,The following statement contains a magic number: if (m_mouseDown == true)              {                  m_mouseDown = false;                    if (AssociatedObject.IsMouseOver && AssociatedObject.IsFocused)                  {                      if (m_timer == null)                      {                          m_timer = new DispatcherTimer();                          m_timer.Interval = TimeSpan.FromMilliseconds(s_doubleClickTime + 100);                          m_timer.Tick += Tick;                          m_timer.Start();                      }                  }                  else                  {                      StopTimer();                  }              }
Magic Number,Sce.Atf.Wpf.Collections,RectExtensions,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetCenter,The following statement contains a magic number: return new Point(rect.X + rect.Width / 2.0' rect.Y + rect.Height / 2.0);
Magic Number,Sce.Atf.Wpf.Collections,RectExtensions,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetCenter,The following statement contains a magic number: return new Point(rect.X + rect.Width / 2.0' rect.Y + rect.Height / 2.0);
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Insert,The following statement contains a magic number: if (depth <= 50 && (bounds.Width > 0.0 || bounds.Height > 0.0))                  {                      double num = _bounds.Width / 2.0;                      double num2 = _bounds.Height / 2.0;                      Rect bounds2 = new Rect(_bounds.Left' _bounds.Top' num' num2);                      Rect bounds3 = new Rect(_bounds.Left + num' _bounds.Top' num' num2);                      Rect bounds4 = new Rect(_bounds.Left' _bounds.Top + num2' num' num2);                      Rect bounds5 = new Rect(_bounds.Left + num' _bounds.Top + num2' num' num2);                      if (bounds2.Contains(bounds))                      {                          if (_topLeft == null)                          {                              _topLeft = new Quadrant(bounds2);                          }                          quadrant = _topLeft;                      }                      else                      {                          if (bounds3.Contains(bounds))                          {                              if (_topRight == null)                              {                                  _topRight = new Quadrant(bounds3);                              }                              quadrant = _topRight;                          }                          else                          {                              if (bounds4.Contains(bounds))                              {                                  if (_bottomLeft == null)                                  {                                      _bottomLeft = new Quadrant(bounds4);                                  }                                  quadrant = _bottomLeft;                              }                              else                              {                                  if (bounds5.Contains(bounds))                                  {                                      if (_bottomRight == null)                                      {                                          _bottomRight = new Quadrant(bounds5);                                      }                                      quadrant = _bottomRight;                                  }                              }                          }                      }                  }
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Insert,The following statement contains a magic number: if (depth <= 50 && (bounds.Width > 0.0 || bounds.Height > 0.0))                  {                      double num = _bounds.Width / 2.0;                      double num2 = _bounds.Height / 2.0;                      Rect bounds2 = new Rect(_bounds.Left' _bounds.Top' num' num2);                      Rect bounds3 = new Rect(_bounds.Left + num' _bounds.Top' num' num2);                      Rect bounds4 = new Rect(_bounds.Left' _bounds.Top + num2' num' num2);                      Rect bounds5 = new Rect(_bounds.Left + num' _bounds.Top + num2' num' num2);                      if (bounds2.Contains(bounds))                      {                          if (_topLeft == null)                          {                              _topLeft = new Quadrant(bounds2);                          }                          quadrant = _topLeft;                      }                      else                      {                          if (bounds3.Contains(bounds))                          {                              if (_topRight == null)                              {                                  _topRight = new Quadrant(bounds3);                              }                              quadrant = _topRight;                          }                          else                          {                              if (bounds4.Contains(bounds))                              {                                  if (_bottomLeft == null)                                  {                                      _bottomLeft = new Quadrant(bounds4);                                  }                                  quadrant = _bottomLeft;                              }                              else                              {                                  if (bounds5.Contains(bounds))                                  {                                      if (_bottomRight == null)                                      {                                          _bottomRight = new Quadrant(bounds5);                                      }                                      quadrant = _bottomRight;                                  }                              }                          }                      }                  }
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Insert,The following statement contains a magic number: if (depth <= 50 && (bounds.Width > 0.0 || bounds.Height > 0.0))                  {                      double num = _bounds.Width / 2.0;                      double num2 = _bounds.Height / 2.0;                      Rect bounds2 = new Rect(_bounds.Left' _bounds.Top' num' num2);                      Rect bounds3 = new Rect(_bounds.Left + num' _bounds.Top' num' num2);                      Rect bounds4 = new Rect(_bounds.Left' _bounds.Top + num2' num' num2);                      Rect bounds5 = new Rect(_bounds.Left + num' _bounds.Top + num2' num' num2);                      if (bounds2.Contains(bounds))                      {                          if (_topLeft == null)                          {                              _topLeft = new Quadrant(bounds2);                          }                          quadrant = _topLeft;                      }                      else                      {                          if (bounds3.Contains(bounds))                          {                              if (_topRight == null)                              {                                  _topRight = new Quadrant(bounds3);                              }                              quadrant = _topRight;                          }                          else                          {                              if (bounds4.Contains(bounds))                              {                                  if (_bottomLeft == null)                                  {                                      _bottomLeft = new Quadrant(bounds4);                                  }                                  quadrant = _bottomLeft;                              }                              else                              {                                  if (bounds5.Contains(bounds))                                  {                                      if (_bottomRight == null)                                      {                                          _bottomRight = new Quadrant(bounds5);                                      }                                      quadrant = _bottomRight;                                  }                              }                          }                      }                  }
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Remove,The following statement contains a magic number: if (RemoveNode(node))                  {                      flag = true;                  }                  else                  {                      double num = _bounds.Width / 2.0;                      double num2 = _bounds.Height / 2.0;                      Rect self = new Rect(_bounds.Left' _bounds.Top' num' num2);                      Rect self2 = new Rect(_bounds.Left + num' _bounds.Top' num' num2);                      Rect self3 = new Rect(_bounds.Left' _bounds.Top + num2' num' num2);                      Rect self4 = new Rect(_bounds.Left + num' _bounds.Top + num2' num' num2);                      if (_topLeft != null && self.Intersects(bounds) && _topLeft.Remove(node' bounds))                      {                          if (_topLeft._count == 0)                          {                              _topLeft = null;                          }                          flag = true;                      }                      else                      {                          if (_topRight != null && self2.Intersects(bounds) && _topRight.Remove(node' bounds))                          {                              if (_topRight._count == 0)                              {                                  _topRight = null;                              }                              flag = true;                          }                          else                          {                              if (_bottomLeft != null && self3.Intersects(bounds) && _bottomLeft.Remove(node' bounds))                              {                                  if (_bottomLeft._count == 0)                                  {                                      _bottomLeft = null;                                  }                                  flag = true;                              }                              else                              {                                  if (_bottomRight != null && self4.Intersects(bounds) && _bottomRight.Remove(node' bounds))                                  {                                      if (_bottomRight._count == 0)                                      {                                          _bottomRight = null;                                      }                                      flag = true;                                  }                              }                          }                      }                  }
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,Remove,The following statement contains a magic number: if (RemoveNode(node))                  {                      flag = true;                  }                  else                  {                      double num = _bounds.Width / 2.0;                      double num2 = _bounds.Height / 2.0;                      Rect self = new Rect(_bounds.Left' _bounds.Top' num' num2);                      Rect self2 = new Rect(_bounds.Left + num' _bounds.Top' num' num2);                      Rect self3 = new Rect(_bounds.Left' _bounds.Top + num2' num' num2);                      Rect self4 = new Rect(_bounds.Left + num' _bounds.Top + num2' num' num2);                      if (_topLeft != null && self.Intersects(bounds) && _topLeft.Remove(node' bounds))                      {                          if (_topLeft._count == 0)                          {                              _topLeft = null;                          }                          flag = true;                      }                      else                      {                          if (_topRight != null && self2.Intersects(bounds) && _topRight.Remove(node' bounds))                          {                              if (_topRight._count == 0)                              {                                  _topRight = null;                              }                              flag = true;                          }                          else                          {                              if (_bottomLeft != null && self3.Intersects(bounds) && _bottomLeft.Remove(node' bounds))                              {                                  if (_bottomLeft._count == 0)                                  {                                      _bottomLeft = null;                                  }                                  flag = true;                              }                              else                              {                                  if (_bottomRight != null && self4.Intersects(bounds) && _bottomRight.Remove(node' bounds))                                  {                                      if (_bottomRight._count == 0)                                      {                                          _bottomRight = null;                                      }                                      flag = true;                                  }                              }                          }                      }                  }
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetNodesIntersecting,The following statement contains a magic number: double num = _bounds.Width / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetNodesIntersecting,The following statement contains a magic number: double num2 = _bounds.Height / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetNodesInside,The following statement contains a magic number: double num = _bounds.Width / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,GetNodesInside,The following statement contains a magic number: double num2 = _bounds.Height / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,HasNodesInside,The following statement contains a magic number: double num = _bounds.Width / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,HasNodesInside,The following statement contains a magic number: double num2 = _bounds.Height / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,HasNodesIntersecting,The following statement contains a magic number: double num = _bounds.Width / 2.0;
Magic Number,Sce.Atf.Wpf.Collections,Quadrant,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Collections\PriorityQuadTree.cs,HasNodesIntersecting,The following statement contains a magic number: double num2 = _bounds.Height / 2.0;
Magic Number,Sce.Atf.Wpf,ColorUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ColorUtil.cs,GetShade,The following statement contains a magic number: byte r = (byte)Math.Min(255' color.R * amount);
Magic Number,Sce.Atf.Wpf,ColorUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ColorUtil.cs,GetShade,The following statement contains a magic number: byte g = (byte)Math.Min(255' color.G * amount);
Magic Number,Sce.Atf.Wpf,ColorUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ColorUtil.cs,GetShade,The following statement contains a magic number: byte b = (byte)Math.Min(255' color.B * amount);
Magic Number,Sce.Atf.Wpf,MiscExtensions,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Extensions\MiscExtensions.cs,BinarySearchIndexOf,The following statement contains a magic number: while (lower <= upper)              {                  int middle = lower + (upper - lower) / 2;                  int comparisonResult = comparer.Compare(value' list[middle]);                  if (comparisonResult == 0)                      return middle;                                    if (comparisonResult < 0)                      upper = middle - 1;                  else                      lower = middle + 1;              }
Magic Number,Sce.Atf.Wpf,ImageUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ImageUtil.cs,RenderToBitmapSource,The following statement contains a magic number: var renderTarget = new RenderTargetBitmap(renderWidth' renderHeight'  96'  96' PixelFormats.Pbgra32);
Magic Number,Sce.Atf.Wpf,ImageUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ImageUtil.cs,RenderToBitmapSource,The following statement contains a magic number: var renderTarget = new RenderTargetBitmap(renderWidth' renderHeight'  96'  96' PixelFormats.Pbgra32);
Magic Number,Sce.Atf.Wpf,ImageUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ImageUtil.cs,RenderToJpeg,The following statement contains a magic number: visual.RenderToJpeg(stream' 1' 100);
Magic Number,Sce.Atf.Wpf,ImageUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ImageUtil.cs,RenderToJpeg,The following statement contains a magic number: visual.RenderToJpeg(stream' scale' 75);
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,Frame,The following statement contains a magic number: const double MarginScale = 0.86;
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,Frame,The following statement contains a magic number: Point worldBoundsCenter = new Point(                  worldBounds.X + worldBounds.Width / 2'                  worldBounds.Y + worldBounds.Height / 2);
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,Frame,The following statement contains a magic number: Point worldBoundsCenter = new Point(                  worldBounds.X + worldBounds.Width / 2'                  worldBounds.Y + worldBounds.Height / 2);
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,Frame,The following statement contains a magic number: Point translation = new Point(                  (clientBounds.Width / 2 - worldBoundsCenter.X * scale.X)'                  (clientBounds.Height / 2 - worldBoundsCenter.Y * scale.Y));
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,Frame,The following statement contains a magic number: Point translation = new Point(                  (clientBounds.Width / 2 - worldBoundsCenter.X * scale.X)'                  (clientBounds.Height / 2 - worldBoundsCenter.Y * scale.Y));
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,ZoomAboutCenter,The following statement contains a magic number: Point worldBoundsCenter = new Point(                  worldBounds.X + worldBounds.Width / 2'                  worldBounds.Y + worldBounds.Height / 2);
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,ZoomAboutCenter,The following statement contains a magic number: Point worldBoundsCenter = new Point(                  worldBounds.X + worldBounds.Width / 2'                  worldBounds.Y + worldBounds.Height / 2);
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,ZoomAboutCenter,The following statement contains a magic number: Point translation = new Point(                  clientBounds.Width / 2 - worldBoundsCenter.X * scale.X'                  clientBounds.Height / 2 - worldBoundsCenter.Y * scale.Y);
Magic Number,Sce.Atf.Wpf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Adaptable\ITransformAdapter.cs,ZoomAboutCenter,The following statement contains a magic number: Point translation = new Point(                  clientBounds.Width / 2 - worldBoundsCenter.X * scale.X'                  clientBounds.Height / 2 - worldBoundsCenter.Y * scale.Y);
Magic Number,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The following statement contains a magic number: if (this.m_topLeftClip != null)              {                  this.m_topLeftClip.RadiusX = this.m_topLeftClip.RadiusY = newCornerRadius.TopLeft - (Math.Min(this.BorderThickness.Left' this.BorderThickness.Top) / 2);              }
Magic Number,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The following statement contains a magic number: if (this.m_topRightClip != null)              {                  this.m_topRightClip.RadiusX = this.m_topRightClip.RadiusY = newCornerRadius.TopRight - (Math.Min(this.BorderThickness.Top' this.BorderThickness.Right) / 2);              }
Magic Number,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The following statement contains a magic number: if (this.m_bottomRightClip != null)              {                  this.m_bottomRightClip.RadiusX = this.m_bottomRightClip.RadiusY = newCornerRadius.BottomRight - (Math.Min(this.BorderThickness.Right' this.BorderThickness.Bottom) / 2);              }
Magic Number,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateCornerRadius,The following statement contains a magic number: if (this.m_bottomLeftClip != null)              {                  this.m_bottomLeftClip.RadiusX = this.m_bottomLeftClip.RadiusY = newCornerRadius.BottomLeft - (Math.Min(this.BorderThickness.Bottom' this.BorderThickness.Left) / 2);              }
Magic Number,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateClipSize,The following statement contains a magic number: if (size.Width > 0 || size.Height > 0)              {                  double contentWidth = Math.Max(0' size.Width - this.BorderThickness.Left - this.BorderThickness.Right);                  double contentHeight = Math.Max(0' size.Height - this.BorderThickness.Top - this.BorderThickness.Bottom);                    if (this.m_topLeftClip != null)                  {                      this.m_topLeftClip.Rect = new Rect(0' 0' contentWidth + (this.CornerRadius.TopLeft * 2)' contentHeight + (this.CornerRadius.TopLeft * 2));                  }                    if (this.m_topRightClip != null)                  {                      this.m_topRightClip.Rect = new Rect(0 - this.CornerRadius.TopRight' 0' contentWidth + this.CornerRadius.TopRight' contentHeight + this.CornerRadius.TopRight);                  }                    if (this.m_bottomRightClip != null)                  {                      this.m_bottomRightClip.Rect = new Rect(0 - this.CornerRadius.BottomRight' 0 - this.CornerRadius.BottomRight' contentWidth + this.CornerRadius.BottomRight' contentHeight + this.CornerRadius.BottomRight);                  }                    if (this.m_bottomLeftClip != null)                  {                      this.m_bottomLeftClip.Rect = new Rect(0' 0 - this.CornerRadius.BottomLeft' contentWidth + this.CornerRadius.BottomLeft' contentHeight + this.CornerRadius.BottomLeft);                  }              }
Magic Number,Sce.Atf.Wpf.Controls,ClippingBorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ClippingBorder.cs,UpdateClipSize,The following statement contains a magic number: if (size.Width > 0 || size.Height > 0)              {                  double contentWidth = Math.Max(0' size.Width - this.BorderThickness.Left - this.BorderThickness.Right);                  double contentHeight = Math.Max(0' size.Height - this.BorderThickness.Top - this.BorderThickness.Bottom);                    if (this.m_topLeftClip != null)                  {                      this.m_topLeftClip.Rect = new Rect(0' 0' contentWidth + (this.CornerRadius.TopLeft * 2)' contentHeight + (this.CornerRadius.TopLeft * 2));                  }                    if (this.m_topRightClip != null)                  {                      this.m_topRightClip.Rect = new Rect(0 - this.CornerRadius.TopRight' 0' contentWidth + this.CornerRadius.TopRight' contentHeight + this.CornerRadius.TopRight);                  }                    if (this.m_bottomRightClip != null)                  {                      this.m_bottomRightClip.Rect = new Rect(0 - this.CornerRadius.BottomRight' 0 - this.CornerRadius.BottomRight' contentWidth + this.CornerRadius.BottomRight' contentHeight + this.CornerRadius.BottomRight);                  }                    if (this.m_bottomLeftClip != null)                  {                      this.m_bottomLeftClip.Rect = new Rect(0' 0 - this.CornerRadius.BottomLeft' contentWidth + this.CornerRadius.BottomLeft' contentHeight + this.CornerRadius.BottomLeft);                  }              }
Magic Number,Sce.Atf.Wpf.Controls,BrowseForFolderDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DirectoryPicker.cs,BrowseForFolderDialog,The following statement contains a magic number: BrowseInfo.pszDisplayName = new string(' '' 260);
Magic Number,Sce.Atf.Wpf.Controls,BrowseForFolderDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DirectoryPicker.cs,PInvokeSHBrowseForFolder,The following statement contains a magic number: if (IntPtr.Zero != pidl)              {                  var pathsb = new StringBuilder(260);                  if (SHGetPathFromIDList(pidl' pathsb))                  {                      SelectedFolder = pathsb.ToString();                      Marshal.FreeCoTaskMem(pidl);                      return true;                  }              }
Magic Number,Sce.Atf.Wpf.Controls,BrowseForFolderDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DirectoryPicker.cs,BrowseEventHandler,The following statement contains a magic number: switch (uMsg)              {                  case MessageFromBrowser.BFFM_INITIALIZED:                      {                          // The dialog box has finished initializing.                          // lParam   Not used' value is NULL.                          if (!string.IsNullOrEmpty(InitialExpandedFolder))                          {                              SendMessageW(hwnd' MessageToBrowser.BFFM_SETEXPANDED' new IntPtr(1)' InitialExpandedFolder);                          }                          else if (!string.IsNullOrEmpty(InitialFolder))                          {                              SendMessageW(hwnd' MessageToBrowser.BFFM_SETSELECTIONW' new IntPtr(1)' InitialFolder);                          }                            if (!string.IsNullOrEmpty(OKButtonText))                          {                              SendMessageW(hwnd' MessageToBrowser.BFFM_SETOKTEXT' new IntPtr(1)' OKButtonText);                          }                            break;                      }                    case MessageFromBrowser.BFFM_SELCHANGED:                      {                          // The selection has changed in the dialog box.                          // lParam   A pointer to an item identifier list (PIDL) identifying the newly selected item.                          var pathsb = new StringBuilder(260);                          if (SHGetPathFromIDList(lParam' pathsb))                          {                              SelectedFolder = pathsb.ToString();                          }                            break;                      }                    case MessageFromBrowser.BFFM_VALIDATEFAILEDA:                      {                          // ANSI                          // The user typed an invalid name into the dialog's edit box. A nonexistent folder is considered an invalid name.                          // lParam   A pointer to a string containing the invalid name. An application can use this data in an error dialog informing the user that the name was not valid.                          // Return zero to dismiss the dialog or nonzero to keep the dialog displayed                          break;                      }                    case MessageFromBrowser.BFFM_VALIDATEFAILEDW:                      {                          // Unicode                          // The user typed an invalid name into the dialog's edit box. A nonexistent folder is considered an invalid name.                          // lParam   A pointer to a string containing the invalid name. An application can use this data in an error dialog informing the user that the name was not valid.                          // Return zero to dismiss the dialog or nonzero to keep the dialog displayed                          break;                      }                    case MessageFromBrowser.BFFM_IUNKNOWN:                      {                          // An IUnknown interface is available to the dialog box.                          // lParam   A pointer to an IUnknown interface.                          break;                      }              }
Magic Number,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: if ((this.SourceBrush == null) || (((source != null) && IsClose(source.Width' base.RenderSize.Width)) && IsClose(source.Height' base.RenderSize.Height)))              {                  ImageSource renderSource = this.RenderSource;                  if (renderSource != null)                  {                      drawingContext.DrawImage(renderSource' rectangle);                  }              }              else              {                  if (GetUseShadow(this))                  {                      // Test shadow                      var shadowRectangle = new Rect(1.5' 1.5' base.RenderSize.Width' base.RenderSize.Height);                      var shadowBrush = ColorSwapper.SwapColors(SourceBrush' GetShadowColor);                      drawingContext.DrawRectangle(shadowBrush' null' shadowRectangle);                  }                    drawingContext.DrawRectangle(this.RenderSourceBrush' null' rectangle);              }
Magic Number,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: if ((this.SourceBrush == null) || (((source != null) && IsClose(source.Width' base.RenderSize.Width)) && IsClose(source.Height' base.RenderSize.Height)))              {                  ImageSource renderSource = this.RenderSource;                  if (renderSource != null)                  {                      drawingContext.DrawImage(renderSource' rectangle);                  }              }              else              {                  if (GetUseShadow(this))                  {                      // Test shadow                      var shadowRectangle = new Rect(1.5' 1.5' base.RenderSize.Width' base.RenderSize.Height);                      var shadowBrush = ColorSwapper.SwapColors(SourceBrush' GetShadowColor);                      drawingContext.DrawRectangle(shadowBrush' null' shadowRectangle);                  }                    drawingContext.DrawRectangle(this.RenderSourceBrush' null' rectangle);              }
Magic Number,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,IsClose,The following statement contains a magic number: return (num1 > (num2 * 0.9));
Magic Number,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,ScaleColor,The following statement contains a magic number: return Color.FromArgb((byte)((alpha * color.A) / 0xff)' (byte)(((((double)color.R) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.G) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.B) / 255.0) * (primary - white)) + white));
Magic Number,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,ScaleColor,The following statement contains a magic number: return Color.FromArgb((byte)((alpha * color.A) / 0xff)' (byte)(((((double)color.R) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.G) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.B) / 255.0) * (primary - white)) + white));
Magic Number,Sce.Atf.Wpf.Controls,Icon,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,ScaleColor,The following statement contains a magic number: return Color.FromArgb((byte)((alpha * color.A) / 0xff)' (byte)(((((double)color.R) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.G) / 255.0) * (primary - white)) + white)' (byte)(((((double)color.B) / 255.0) * (primary - white)) + white));
Magic Number,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The following statement contains a magic number: if (bitmapSource != null)              {                  PixelFormat destinationFormat = PixelFormats.Bgra32;                  BitmapPalette destinationPalette = null;                  double alphaThreshold = 0.0;                  FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold);                  int pixelWidth = bitmap.PixelWidth;                  int pixelHeight = bitmap.PixelHeight;                  int stride = 4 * pixelWidth;                  byte[] pixels = new byte[stride * pixelHeight];                  bitmap.CopyPixels(pixels' stride' 0);                  for (int i = 0; i < pixels.Length; i += 4)                  {                      Color color = Color.FromArgb(pixels[i + 3]' pixels[i + 2]' pixels[i + 1]' pixels[i]);                      Color color2 = colorCallback(color);                      if (color2 != color)                      {                          pixels[i] = color2.B;                          pixels[i + 1] = color2.G;                          pixels[i + 2] = color2.R;                          pixels[i + 3] = color2.A;                      }                  }                  source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride);                  source.Freeze();              }
Magic Number,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The following statement contains a magic number: if (bitmapSource != null)              {                  PixelFormat destinationFormat = PixelFormats.Bgra32;                  BitmapPalette destinationPalette = null;                  double alphaThreshold = 0.0;                  FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold);                  int pixelWidth = bitmap.PixelWidth;                  int pixelHeight = bitmap.PixelHeight;                  int stride = 4 * pixelWidth;                  byte[] pixels = new byte[stride * pixelHeight];                  bitmap.CopyPixels(pixels' stride' 0);                  for (int i = 0; i < pixels.Length; i += 4)                  {                      Color color = Color.FromArgb(pixels[i + 3]' pixels[i + 2]' pixels[i + 1]' pixels[i]);                      Color color2 = colorCallback(color);                      if (color2 != color)                      {                          pixels[i] = color2.B;                          pixels[i + 1] = color2.G;                          pixels[i + 2] = color2.R;                          pixels[i + 3] = color2.A;                      }                  }                  source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride);                  source.Freeze();              }
Magic Number,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The following statement contains a magic number: if (bitmapSource != null)              {                  PixelFormat destinationFormat = PixelFormats.Bgra32;                  BitmapPalette destinationPalette = null;                  double alphaThreshold = 0.0;                  FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold);                  int pixelWidth = bitmap.PixelWidth;                  int pixelHeight = bitmap.PixelHeight;                  int stride = 4 * pixelWidth;                  byte[] pixels = new byte[stride * pixelHeight];                  bitmap.CopyPixels(pixels' stride' 0);                  for (int i = 0; i < pixels.Length; i += 4)                  {                      Color color = Color.FromArgb(pixels[i + 3]' pixels[i + 2]' pixels[i + 1]' pixels[i]);                      Color color2 = colorCallback(color);                      if (color2 != color)                      {                          pixels[i] = color2.B;                          pixels[i + 1] = color2.G;                          pixels[i + 2] = color2.R;                          pixels[i + 3] = color2.A;                      }                  }                  source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride);                  source.Freeze();              }
Magic Number,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The following statement contains a magic number: if (bitmapSource != null)              {                  PixelFormat destinationFormat = PixelFormats.Bgra32;                  BitmapPalette destinationPalette = null;                  double alphaThreshold = 0.0;                  FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold);                  int pixelWidth = bitmap.PixelWidth;                  int pixelHeight = bitmap.PixelHeight;                  int stride = 4 * pixelWidth;                  byte[] pixels = new byte[stride * pixelHeight];                  bitmap.CopyPixels(pixels' stride' 0);                  for (int i = 0; i < pixels.Length; i += 4)                  {                      Color color = Color.FromArgb(pixels[i + 3]' pixels[i + 2]' pixels[i + 1]' pixels[i]);                      Color color2 = colorCallback(color);                      if (color2 != color)                      {                          pixels[i] = color2.B;                          pixels[i + 1] = color2.G;                          pixels[i + 2] = color2.R;                          pixels[i + 3] = color2.A;                      }                  }                  source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride);                  source.Freeze();              }
Magic Number,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The following statement contains a magic number: if (bitmapSource != null)              {                  PixelFormat destinationFormat = PixelFormats.Bgra32;                  BitmapPalette destinationPalette = null;                  double alphaThreshold = 0.0;                  FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold);                  int pixelWidth = bitmap.PixelWidth;                  int pixelHeight = bitmap.PixelHeight;                  int stride = 4 * pixelWidth;                  byte[] pixels = new byte[stride * pixelHeight];                  bitmap.CopyPixels(pixels' stride' 0);                  for (int i = 0; i < pixels.Length; i += 4)                  {                      Color color = Color.FromArgb(pixels[i + 3]' pixels[i + 2]' pixels[i + 1]' pixels[i]);                      Color color2 = colorCallback(color);                      if (color2 != color)                      {                          pixels[i] = color2.B;                          pixels[i + 1] = color2.G;                          pixels[i + 2] = color2.R;                          pixels[i + 3] = color2.A;                      }                  }                  source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride);                  source.Freeze();              }
Magic Number,Sce.Atf.Wpf.Controls,ColorSwapper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,SwapColors,The following statement contains a magic number: if (bitmapSource != null)              {                  PixelFormat destinationFormat = PixelFormats.Bgra32;                  BitmapPalette destinationPalette = null;                  double alphaThreshold = 0.0;                  FormatConvertedBitmap bitmap = new FormatConvertedBitmap(bitmapSource' destinationFormat' destinationPalette' alphaThreshold);                  int pixelWidth = bitmap.PixelWidth;                  int pixelHeight = bitmap.PixelHeight;                  int stride = 4 * pixelWidth;                  byte[] pixels = new byte[stride * pixelHeight];                  bitmap.CopyPixels(pixels' stride' 0);                  for (int i = 0; i < pixels.Length; i += 4)                  {                      Color color = Color.FromArgb(pixels[i + 3]' pixels[i + 2]' pixels[i + 1]' pixels[i]);                      Color color2 = colorCallback(color);                      if (color2 != color)                      {                          pixels[i] = color2.B;                          pixels[i + 1] = color2.G;                          pixels[i + 2] = color2.R;                          pixels[i + 3] = color2.A;                      }                  }                  source = BitmapSource.Create(pixelWidth' pixelHeight' bitmap.DpiX' bitmap.DpiY' destinationFormat' destinationPalette' pixels' stride);                  source.Freeze();              }
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: if (shadowSize <= 0 || this.ActualWidth < shadowSize * 2 || this.ActualHeight < shadowSize * 2)                  return;
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: if (shadowSize <= 0 || this.ActualWidth < shadowSize * 2 || this.ActualHeight < shadowSize * 2)                  return;
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: Rect rightRect = new Rect(this.ActualWidth' shadowSize * 2' shadowSize' this.ActualHeight - shadowSize * 2);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: Rect rightRect = new Rect(this.ActualWidth' shadowSize * 2' shadowSize' this.ActualHeight - shadowSize * 2);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: Rect bottomRect = new Rect(shadowSize * 2' this.ActualHeight' this.ActualWidth - shadowSize * 2' shadowSize);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,OnRender,The following statement contains a magic number: Rect bottomRect = new Rect(shadowSize * 2' this.ActualHeight' this.ActualWidth - shadowSize * 2' shadowSize);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,CreateBrushes,The following statement contains a magic number: Color shadowColor = Color.FromArgb(128' 0' 0' 0);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,CreateBrushes,The following statement contains a magic number: Color transparentColor = Color.FromArgb(16' 0' 0' 0);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,CreateBrushes,The following statement contains a magic number: GradientStopCollection gradient = new GradientStopCollection(2);
Magic Number,Sce.Atf.Wpf.Controls,ShadowChrome,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\Icon.cs,CreateBrushes,The following statement contains a magic number: gradient.Add(new GradientStop(shadowColor' 0.5));
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,RangeBaseEx,The following statement contains a magic number: SmallChangeProperty.OverrideMetadata(typeof(RangeBaseEx)' new FrameworkPropertyMetadata(0.001));
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,RangeBaseEx,The following statement contains a magic number: LargeChangeProperty.OverrideMetadata(typeof(RangeBaseEx)' new FrameworkPropertyMetadata(0.1));
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,ProportionOfLengthToValue,The following statement contains a magic number: if (Math.Abs(SkewFactor - 1.0) > 0.000001 && proportion > 0.0)                  proportion = Math.Exp(Math.Log(proportion) / SkewFactor);
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,ValueToProportionOfLength,The following statement contains a magic number: return Math.Abs(SkewFactor - 1.0) < 0.000001 ? n : Math.Pow(n' SkewFactor);
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,Log,The following statement contains a magic number: var inputRange = (Math.Exp(2.0) - 1.0) / (inputMaximum - inputMinimum);
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,Log,The following statement contains a magic number: return outputMinimum + outputRange * (Math.Log(1.0 + inputRange * (value - inputMinimum)) / 2.0);
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,Exp,The following statement contains a magic number: var inputRange = 2.0 / (inputMaximum - inputMinimum);
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,Exp,The following statement contains a magic number: return outputMinimum + outputRange * ((Math.Exp(inputRange * (value - inputMinimum)) - 1.0) / (Math.Exp(2.0) - 1.0));
Magic Number,Sce.Atf.Wpf.Controls,RangeBaseEx,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeBaseEx.cs,RecalculateSkewFactor,The following statement contains a magic number: if (!double.IsNaN(centerValue) && maximum > minimum)              {                  var scale = (centerValue - minimum) / (maximum - minimum);                  if (scale > 0.0)                  {                      SkewFactor = Math.Log(0.5) / Math.Log((centerValue - minimum) / (maximum - minimum));                  }                  else                  {                      SkewFactor = 1.0;                  }              }
Magic Number,Sce.Atf.Wpf.Controls,RangeSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\RangeSlider.cs,ZoomToSpan,The following statement contains a magic number: double rightChange = (span - (RangeStop - RangeStart)) / 2;
Magic Number,Sce.Atf.Wpf.Controls,SnappingBitmap,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SnappingBitmap.cs,AreClose,The following statement contains a magic number: return ((delta < 1.53E-06) && (delta > -1.53E-06));
Magic Number,Sce.Atf.Wpf.Controls,SnappingBitmap,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SnappingBitmap.cs,AreClose,The following statement contains a magic number: return ((delta < 1.53E-06) && (delta > -1.53E-06));
Magic Number,Sce.Atf.Wpf.Controls,SwitchToDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SwitchToDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.SwitchToLabel = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:              this.ControlList = ((System.Windows.Controls.ListBox)(target));              return;              case 3:              this.CurrentSelection = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,SwitchToDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SwitchToDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.SwitchToLabel = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:              this.ControlList = ((System.Windows.Controls.ListBox)(target));              return;              case 3:              this.CurrentSelection = ((System.Windows.Controls.TextBlock)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,TcpIpTargetEditDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TcpIpTargetEditDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.button_OK = ((System.Windows.Controls.Button)(target));              return;              case 2:              this.button_Cancel = ((System.Windows.Controls.Button)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,LineDown,The following statement contains a magic number: if (Orientation == Orientation.Vertical)                  SetVerticalOffset(VerticalOffset + 20);              else                  SetVerticalOffset(VerticalOffset + 1);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,LineLeft,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)                  SetHorizontalOffset(HorizontalOffset - 20);              else                  SetHorizontalOffset(HorizontalOffset - 1);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,LineRight,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)                  SetHorizontalOffset(HorizontalOffset + 20);              else                  SetHorizontalOffset(HorizontalOffset + 1);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,LineUp,The following statement contains a magic number: if (Orientation == Orientation.Vertical)                  SetVerticalOffset(VerticalOffset - 20);              else                  SetVerticalOffset(VerticalOffset - 1);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,PageDown,The following statement contains a magic number: SetVerticalOffset(VerticalOffset + m_viewport.Height * 0.8);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,PageLeft,The following statement contains a magic number: SetHorizontalOffset(HorizontalOffset - m_viewport.Width * 0.8);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,PageRight,The following statement contains a magic number: SetHorizontalOffset(HorizontalOffset + m_viewport.Width * 0.8);
Magic Number,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,PageUp,The following statement contains a magic number: SetVerticalOffset(VerticalOffset - m_viewport.Height * 0.8);
Magic Number,Sce.Atf.Wpf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\AboutDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:                            #line 44 "..\..\..\Controls\AboutDialog.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              case 2:              this.hyperlink = ((System.Windows.Documents.Hyperlink)(target));                            #line 48 "..\..\..\Controls\AboutDialog.xaml"              this.hyperlink.RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.hyperlink_RequestNavigate);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,EmbeddedDialogContentHost,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,EmbeddedDialogContentHost,The following statement contains a magic number: contentWrapper.Margin = new Thickness(12);
Magic Number,Sce.Atf.Wpf.Controls,DialogManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,SetupAndOpenDialog,The following statement contains a magic number: dialog.MinHeight = window.Site.ActualHeight / 4.0;
Magic Number,Sce.Atf.Wpf.Controls,DialogManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\CommonDialog.cs,SetupAndOpenDialog,The following statement contains a magic number: sizeHandler = (sender' args) =>                  {                      dialog.MinHeight = window.Site.ActualHeight / 4.0;                      dialog.MaxHeight = window.Site.ActualHeight;                  };
Magic Number,Sce.Atf.Wpf.Controls,FormattingTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\FormattingTextBox.cs,UnFormat,The following statement contains a magic number: if (match.Groups.Count > 3 && !String.IsNullOrEmpty(match.Groups[3].Value))                  s = s.Replace(match.Groups[3].Value' "");
Magic Number,Sce.Atf.Wpf.Controls,FormattingTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\FormattingTextBox.cs,UnFormat,The following statement contains a magic number: if (match.Groups.Count > 3 && !String.IsNullOrEmpty(match.Groups[3].Value))                  s = s.Replace(match.Groups[3].Value' "");
Magic Number,Sce.Atf.Wpf.Controls,FormattingTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\FormattingTextBox.cs,UnFormat,The following statement contains a magic number: if (match.Groups.Count > 3 && !String.IsNullOrEmpty(match.Groups[3].Value))                  s = s.Replace(match.Groups[3].Value' "");
Magic Number,Sce.Atf.Wpf.Controls,MainWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.me = ((Sce.Atf.Wpf.Controls.MainWindow)(target));              return;              case 2:              this.dockPanel = ((System.Windows.Controls.DockPanel)(target));              return;              case 3:              this.menuBar = ((System.Windows.Controls.Menu)(target));              return;              case 4:              this.toolBarTray = ((System.Windows.Controls.ToolBarTray)(target));              return;              case 5:              this.statusBar = ((System.Windows.Controls.Primitives.StatusBar)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MainWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.me = ((Sce.Atf.Wpf.Controls.MainWindow)(target));              return;              case 2:              this.dockPanel = ((System.Windows.Controls.DockPanel)(target));              return;              case 3:              this.menuBar = ((System.Windows.Controls.Menu)(target));              return;              case 4:              this.toolBarTray = ((System.Windows.Controls.ToolBarTray)(target));              return;              case 5:              this.statusBar = ((System.Windows.Controls.Primitives.StatusBar)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MainWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.me = ((Sce.Atf.Wpf.Controls.MainWindow)(target));              return;              case 2:              this.dockPanel = ((System.Windows.Controls.DockPanel)(target));              return;              case 3:              this.menuBar = ((System.Windows.Controls.Menu)(target));              return;              case 4:              this.toolBarTray = ((System.Windows.Controls.ToolBarTray)(target));              return;              case 5:              this.statusBar = ((System.Windows.Controls.Primitives.StatusBar)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MainWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.me = ((Sce.Atf.Wpf.Controls.MainWindow)(target));              return;              case 2:              this.dockPanel = ((System.Windows.Controls.DockPanel)(target));              return;              case 3:              this.menuBar = ((System.Windows.Controls.Menu)(target));              return;              case 4:              this.toolBarTray = ((System.Windows.Controls.ToolBarTray)(target));              return;              case 5:              this.statusBar = ((System.Windows.Controls.Primitives.StatusBar)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Image = ((Sce.Atf.Wpf.Controls.Icon)(target));              return;              case 2:              this.MessageText = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.OkButton = ((System.Windows.Controls.Button)(target));                            #line 36 "..\..\..\Controls\MessageBoxDialog.xaml"              this.OkButton.Click += new System.Windows.RoutedEventHandler(this.OkButton_Click);                            #line default              #line hidden              return;              case 4:              this.YesButton = ((System.Windows.Controls.Button)(target));                            #line 37 "..\..\..\Controls\MessageBoxDialog.xaml"              this.YesButton.Click += new System.Windows.RoutedEventHandler(this.YesButton_Click);                            #line default              #line hidden              return;              case 5:              this.NoButton = ((System.Windows.Controls.Button)(target));                            #line 38 "..\..\..\Controls\MessageBoxDialog.xaml"              this.NoButton.Click += new System.Windows.RoutedEventHandler(this.NoButton_Click);                            #line default              #line hidden              return;              case 6:              this.CancelButton = ((System.Windows.Controls.Button)(target));                            #line 39 "..\..\..\Controls\MessageBoxDialog.xaml"              this.CancelButton.Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Image = ((Sce.Atf.Wpf.Controls.Icon)(target));              return;              case 2:              this.MessageText = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.OkButton = ((System.Windows.Controls.Button)(target));                            #line 36 "..\..\..\Controls\MessageBoxDialog.xaml"              this.OkButton.Click += new System.Windows.RoutedEventHandler(this.OkButton_Click);                            #line default              #line hidden              return;              case 4:              this.YesButton = ((System.Windows.Controls.Button)(target));                            #line 37 "..\..\..\Controls\MessageBoxDialog.xaml"              this.YesButton.Click += new System.Windows.RoutedEventHandler(this.YesButton_Click);                            #line default              #line hidden              return;              case 5:              this.NoButton = ((System.Windows.Controls.Button)(target));                            #line 38 "..\..\..\Controls\MessageBoxDialog.xaml"              this.NoButton.Click += new System.Windows.RoutedEventHandler(this.NoButton_Click);                            #line default              #line hidden              return;              case 6:              this.CancelButton = ((System.Windows.Controls.Button)(target));                            #line 39 "..\..\..\Controls\MessageBoxDialog.xaml"              this.CancelButton.Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Image = ((Sce.Atf.Wpf.Controls.Icon)(target));              return;              case 2:              this.MessageText = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.OkButton = ((System.Windows.Controls.Button)(target));                            #line 36 "..\..\..\Controls\MessageBoxDialog.xaml"              this.OkButton.Click += new System.Windows.RoutedEventHandler(this.OkButton_Click);                            #line default              #line hidden              return;              case 4:              this.YesButton = ((System.Windows.Controls.Button)(target));                            #line 37 "..\..\..\Controls\MessageBoxDialog.xaml"              this.YesButton.Click += new System.Windows.RoutedEventHandler(this.YesButton_Click);                            #line default              #line hidden              return;              case 5:              this.NoButton = ((System.Windows.Controls.Button)(target));                            #line 38 "..\..\..\Controls\MessageBoxDialog.xaml"              this.NoButton.Click += new System.Windows.RoutedEventHandler(this.NoButton_Click);                            #line default              #line hidden              return;              case 6:              this.CancelButton = ((System.Windows.Controls.Button)(target));                            #line 39 "..\..\..\Controls\MessageBoxDialog.xaml"              this.CancelButton.Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Image = ((Sce.Atf.Wpf.Controls.Icon)(target));              return;              case 2:              this.MessageText = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.OkButton = ((System.Windows.Controls.Button)(target));                            #line 36 "..\..\..\Controls\MessageBoxDialog.xaml"              this.OkButton.Click += new System.Windows.RoutedEventHandler(this.OkButton_Click);                            #line default              #line hidden              return;              case 4:              this.YesButton = ((System.Windows.Controls.Button)(target));                            #line 37 "..\..\..\Controls\MessageBoxDialog.xaml"              this.YesButton.Click += new System.Windows.RoutedEventHandler(this.YesButton_Click);                            #line default              #line hidden              return;              case 5:              this.NoButton = ((System.Windows.Controls.Button)(target));                            #line 38 "..\..\..\Controls\MessageBoxDialog.xaml"              this.NoButton.Click += new System.Windows.RoutedEventHandler(this.NoButton_Click);                            #line default              #line hidden              return;              case 6:              this.CancelButton = ((System.Windows.Controls.Button)(target));                            #line 39 "..\..\..\Controls\MessageBoxDialog.xaml"              this.CancelButton.Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Image = ((Sce.Atf.Wpf.Controls.Icon)(target));              return;              case 2:              this.MessageText = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.OkButton = ((System.Windows.Controls.Button)(target));                            #line 36 "..\..\..\Controls\MessageBoxDialog.xaml"              this.OkButton.Click += new System.Windows.RoutedEventHandler(this.OkButton_Click);                            #line default              #line hidden              return;              case 4:              this.YesButton = ((System.Windows.Controls.Button)(target));                            #line 37 "..\..\..\Controls\MessageBoxDialog.xaml"              this.YesButton.Click += new System.Windows.RoutedEventHandler(this.YesButton_Click);                            #line default              #line hidden              return;              case 5:              this.NoButton = ((System.Windows.Controls.Button)(target));                            #line 38 "..\..\..\Controls\MessageBoxDialog.xaml"              this.NoButton.Click += new System.Windows.RoutedEventHandler(this.NoButton_Click);                            #line default              #line hidden              return;              case 6:              this.CancelButton = ((System.Windows.Controls.Button)(target));                            #line 39 "..\..\..\Controls\MessageBoxDialog.xaml"              this.CancelButton.Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,ProgressDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ProgressDialog.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.lblStatus = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:                            #line 39 "..\..\..\Controls\ProgressDialog.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Magic Number,Sce.Atf.Wpf.Controls,SliderBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SliderBox.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.PositionSlider = ((System.Windows.Controls.Slider)(target));              return;              case 2:              this.TextBox = ((Sce.Atf.Wpf.Controls.FormattingTextBox)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Controls,LevelToIndentConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TreeListView.cs,Convert,The following statement contains a magic number: double indentScale = 20.0;
Magic Number,Sce.Atf.Wpf.Controls.PropertyEditing,NumberRangesAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\Attributes.cs,NumberRangesAttribute,The following statement contains a magic number: m_center = minimum + ((maximum - minimum) / 2.0);
Magic Number,Sce.Atf.Wpf.Controls.PropertyEditing,NumberIncrementsAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\Attributes.cs,NumberIncrementsAttribute,The following statement contains a magic number: m_smallChange = 0.1;
Magic Number,Sce.Atf.Wpf.Controls.PropertyEditing,NumberIncrementsAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\Attributes.cs,NumberIncrementsAttribute,The following statement contains a magic number: m_largeChange = 10.0;
Magic Number,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,SliderValueEditorContext,The following statement contains a magic number: if (numberRange != null)              {                  m_max = numberRange.Maximum;                  m_min = numberRange.Minimum;                  m_center = numberRange.Center;                  m_hardMin = numberRange.HardMinimum;                  m_hardMax = numberRange.HardMaximum;              }              else              {                  var dataRange = Node.Descriptor.Attributes[typeof(RangeAttribute)] as RangeAttribute;                  if (dataRange != null)                  {                      m_max = Convert.ToDouble(dataRange.Minimum);                      m_min = Convert.ToDouble(dataRange.Maximum);                      m_center = (m_max - m_min) / 2.0;                    }              }
Magic Number,Sce.Atf.Wpf.Controls.PropertyEditing,SliderValueEditorContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\ValueEditors\SliderEditor.cs,SliderValueEditorContext,The following statement contains a magic number: m_center = (m_max - m_min) / 2.0;
Magic Number,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: m_bindingUpdateTimer.Interval = TimeSpan.FromMilliseconds(50);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,HitTest,The following statement contains a magic number: if (new Rect(0' 20' ActualWidth' ActualHeight).Contains(PointFromScreen(position)))              {                  return DockedContent.Children[0];              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: Point center = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: Point center = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: int space = (int)Root.DockIconSize.Width / 4;
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockLeftIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2 - Root.DockIconSize.Width - space' offset.Y + center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockLeftIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2 - Root.DockIconSize.Width - space' offset.Y + center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockRightIcon.Offset = new Point(offset.X + center.X + Root.DockIconSize.Width / 2 + space' offset.Y + center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockRightIcon.Offset = new Point(offset.X + center.X + Root.DockIconSize.Width / 2 + space' offset.Y + center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockTopIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y - Root.DockIconSize.Height / 2 - Root.DockIconSize.Height - space);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockTopIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y - Root.DockIconSize.Height / 2 - Root.DockIconSize.Height - space);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockBottomIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y + Root.DockIconSize.Height / 2 + space);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockBottomIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y + Root.DockIconSize.Height / 2 + space);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockTabIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockTabIcon.Offset = new Point(offset.X + center.X - Root.DockIconSize.Width / 2' offset.Y + center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = Root.PointFromScreen(PointToScreen(new Point(space' space)));                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }                      Root.DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      Root.DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockPanel,The following statement contains a magic number: HeaderIconSize = new Size(16' 16);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockPanel,The following statement contains a magic number: HeaderIconSize = new Size(16' 16);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockPanel,The following statement contains a magic number: DockIconSize = new Size(32' 32);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockPanel,The following statement contains a magic number: DockIconSize = new Size(32' 32);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following statement contains a magic number: if (IsLoaded && (dockContent = content as DockContent) != null)              {                  if (!m_registeredContents.ContainsValue(dockContent))                  {                      throw new ArgumentOutOfRangeException("Given content is not registered!");                  }                  if (!((IDockLayout)this).HasDescendant(content))                  {                      ContentSettings contentSettings = dockContent.Settings;                      if (contentSettings.Size == new Size(0' 0))                      {                          double ratio = contentSettings.DefaultDock == DockTo.Center ? 0.8 : 0.2;                          contentSettings.Size = new Size(ActualWidth * ratio' ActualHeight * ratio);                      }                      switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }                  }                  Focus(content);              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following statement contains a magic number: if (IsLoaded && (dockContent = content as DockContent) != null)              {                  if (!m_registeredContents.ContainsValue(dockContent))                  {                      throw new ArgumentOutOfRangeException("Given content is not registered!");                  }                  if (!((IDockLayout)this).HasDescendant(content))                  {                      ContentSettings contentSettings = dockContent.Settings;                      if (contentSettings.Size == new Size(0' 0))                      {                          double ratio = contentSettings.DefaultDock == DockTo.Center ? 0.8 : 0.2;                          contentSettings.Size = new Size(ActualWidth * ratio' ActualHeight * ratio);                      }                      switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }                  }                  Focus(content);              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following statement contains a magic number: if (IsLoaded && (dockContent = content as DockContent) != null)              {                  if (!m_registeredContents.ContainsValue(dockContent))                  {                      throw new ArgumentOutOfRangeException("Given content is not registered!");                  }                  if (!((IDockLayout)this).HasDescendant(content))                  {                      ContentSettings contentSettings = dockContent.Settings;                      if (contentSettings.Size == new Size(0' 0))                      {                          double ratio = contentSettings.DefaultDock == DockTo.Center ? 0.8 : 0.2;                          contentSettings.Size = new Size(ActualWidth * ratio' ActualHeight * ratio);                      }                      switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }                  }                  Focus(content);              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following statement contains a magic number: if (IsLoaded && (dockContent = content as DockContent) != null)              {                  if (!m_registeredContents.ContainsValue(dockContent))                  {                      throw new ArgumentOutOfRangeException("Given content is not registered!");                  }                  if (!((IDockLayout)this).HasDescendant(content))                  {                      ContentSettings contentSettings = dockContent.Settings;                      if (contentSettings.Size == new Size(0' 0))                      {                          double ratio = contentSettings.DefaultDock == DockTo.Center ? 0.8 : 0.2;                          contentSettings.Size = new Size(ActualWidth * ratio' ActualHeight * ratio);                      }                      switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }                  }                  Focus(content);              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following statement contains a magic number: if (IsLoaded && (dockContent = content as DockContent) != null)              {                  if (!m_registeredContents.ContainsValue(dockContent))                  {                      throw new ArgumentOutOfRangeException("Given content is not registered!");                  }                  if (!((IDockLayout)this).HasDescendant(content))                  {                      ContentSettings contentSettings = dockContent.Settings;                      if (contentSettings.Size == new Size(0' 0))                      {                          double ratio = contentSettings.DefaultDock == DockTo.Center ? 0.8 : 0.2;                          contentSettings.Size = new Size(ActualWidth * ratio' ActualHeight * ratio);                      }                      switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }                  }                  Focus(content);              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following statement contains a magic number: if (IsLoaded && (dockContent = content as DockContent) != null)              {                  if (!m_registeredContents.ContainsValue(dockContent))                  {                      throw new ArgumentOutOfRangeException("Given content is not registered!");                  }                  if (!((IDockLayout)this).HasDescendant(content))                  {                      ContentSettings contentSettings = dockContent.Settings;                      if (contentSettings.Size == new Size(0' 0))                      {                          double ratio = contentSettings.DefaultDock == DockTo.Center ? 0.8 : 0.2;                          contentSettings.Size = new Size(ActualWidth * ratio' ActualHeight * ratio);                      }                      switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }                  }                  Focus(content);              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Drag,The following statement contains a magic number: Point offset = new Point(settings.Size.Width / 2' 3);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Drag,The following statement contains a magic number: Point offset = new Point(settings.Size.Width / 2' 3);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Drag,The following statement contains a magic number: offset.Y = offset.Y > 20 ? 10 : offset.Y;
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Drag,The following statement contains a magic number: offset.Y = offset.Y > 20 ? 10 : offset.Y;
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Collapse,The following statement contains a magic number: if (GridLayout != null && GridLayout.HasDescendant(content))              {                  FrameworkElement element = (FrameworkElement)content;                  parent = (FrameworkElement)element.Parent;                  if (parent != null)                  {                      rectFrom = new Rect(parent.PointToScreen(new Point(0' 0))' parent.RenderSize);                      // create visual image of the element that is being collapsed                      VisualBrush elementBrush = new VisualBrush(parent);                      DrawingVisual visual = new DrawingVisual();                      DrawingContext dc = visual.RenderOpen();                      dc.DrawRectangle(elementBrush' null' new Rect(0' 0' rectFrom.Width' rectFrom.Height));                      dc.Close();                      RenderTargetBitmap bitmap = new RenderTargetBitmap((int)rectFrom.Width' (int)rectFrom.Height' 96' 96' PixelFormats.Default);                      bitmap.Render(visual);                      image = new Image();                      image.Source = bitmap;                      // undock element                      if (GridLayout != null)                      {                          GridLayout.Undock(content);                      }                      m_lastFocusedContent = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Collapse,The following statement contains a magic number: if (GridLayout != null && GridLayout.HasDescendant(content))              {                  FrameworkElement element = (FrameworkElement)content;                  parent = (FrameworkElement)element.Parent;                  if (parent != null)                  {                      rectFrom = new Rect(parent.PointToScreen(new Point(0' 0))' parent.RenderSize);                      // create visual image of the element that is being collapsed                      VisualBrush elementBrush = new VisualBrush(parent);                      DrawingVisual visual = new DrawingVisual();                      DrawingContext dc = visual.RenderOpen();                      dc.DrawRectangle(elementBrush' null' new Rect(0' 0' rectFrom.Width' rectFrom.Height));                      dc.Close();                      RenderTargetBitmap bitmap = new RenderTargetBitmap((int)rectFrom.Width' (int)rectFrom.Height' 96' 96' PixelFormats.Default);                      bitmap.Render(visual);                      image = new Image();                      image.Source = bitmap;                      // undock element                      if (GridLayout != null)                      {                          GridLayout.Undock(content);                      }                      m_lastFocusedContent = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,AnimateCollapse,The following statement contains a magic number: Duration duration = new Duration(TimeSpan.FromSeconds(0.33));
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,Dock,The following statement contains a magic number: if (GridLayout == null)              {                  GridLayout = new GridLayout(this);                  GridLayout.Dock(null' newContent' DockTo.Center);                }              else              {                  if (nextTo == null)                  {                      if (GridLayout.Children.Count < 2)                      {                          GridLayout.Dock(null' newContent' dockTo);                      }                      else                      {                          if (dockTo == DockTo.Center)                          {                              dockTo = DockTo.Right;                          }                          GridLayout gridLayout = GridLayout;                          GridLayout = null;                          gridLayout = new GridLayout(this' gridLayout);                          GridLayout = gridLayout;                          gridLayout.Dock(null' newContent' dockTo);                      }                  }                  else                  {                      GridLayout.Dock(nextTo' newContent' dockTo);                  }                  CheckConsistency();              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: Point center = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: Point center = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: int space = (int)DockIconSize.Width / 4;
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: m_dockLeftIcon.Offset = new Point(space' center.Y - DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: m_dockRightIcon.Offset = new Point(ActualWidth - DockIconSize.Width - space' center.Y - DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: m_dockTopIcon.Offset = new Point(center.X - DockIconSize.Width / 2' space);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: m_dockBottomIcon.Offset = new Point(center.X - DockIconSize.Width / 2' ActualHeight - DockIconSize.Height - space);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: m_dockTabIcon.Offset = new Point(center.X - DockIconSize.Width / 2' center.Y - DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragEnter,The following statement contains a magic number: m_dockTabIcon.Offset = new Point(center.X - DockIconSize.Width / 2' center.Y - DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following statement contains a magic number: if (m_dockPreview != null)              {                  if (previousDockPreview != m_dockPreview)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                      Window owner = Window.GetWindow(this);                      Rectangle rect = new Rectangle();                      rect.Fill = Brushes.RoyalBlue;                      rect.Opacity = 0.3;                      FrameworkElement fe = rect;                      double space = 2;                      Point p = new Point(space' space);                      ContentSettings contentSettings = (e.Content is TabLayout) ? ((TabLayout)e.Content).Children[0].Settings : ((DockContent)e.Content).Settings;                      double width = Math.Max(Math.Min(contentSettings.Size.Width' ActualWidth / 2)' ActualWidth / 5);                      double height = Math.Max(Math.Min(contentSettings.Size.Height' ActualHeight / 2)' ActualHeight / 5);                      double ratioWidth = width / ActualWidth;                      double ratioHeight = height / ActualHeight;                      switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }                      DockIconsLayer.InsertChild(0' fe);                      m_dockPreviewShape = fe;                  }              }              else              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,FloatingWindow_MouseMove,The following statement contains a magic number: if (IsMouseCaptured && m_validPosition)              {                  Topmost = true;                  pos = e.GetPosition(Owner);                  if (!m_dragging)                  {                      if ((m_lastMousePos - pos).Length > 2)                      {                          m_dragging = true;                      }                  }                  if(m_dragging)                  {                      if (WindowState == WindowState.Maximized)                      {                          WindowState = WindowState.Normal;                          Left = 0.0;                          Top = 0.0;                      }                      else                      {                          Left = Left + pos.X - m_lastMousePos.X;                          Top = Top + pos.Y - m_lastMousePos.Y;                      }                      m_lastMousePos = pos;                      List<IDockable> dockOver = Root.FindElementsAt(e);                      DockDragDropEventArgs args = new DockDragDropEventArgs(DockedContent' e);                      foreach (IDockable dockable in m_dockOver)                      {                          if (!dockOver.Contains(dockable))                          {                              dockable.DockDragLeave(this' args);                          }                      }                      foreach (IDockable dockable in dockOver)                      {                          if (!m_dockOver.Contains(dockable))                          {                              dockable.DockDragEnter(this' args);                          }                      }                      foreach (IDockable dockable in dockOver)                      {                          dockable.DockDragOver(this' args);                      }                      m_dockOver = dockOver;                  }              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragEnter,The following statement contains a magic number: Point center = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragEnter,The following statement contains a magic number: Point center = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockTabIcon.Offset = new Point(center.X - Root.DockIconSize.Width / 2' center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragEnter,The following statement contains a magic number: m_dockTabIcon.Offset = new Point(center.X - Root.DockIconSize.Width / 2' center.Y - Root.DockIconSize.Height / 2);
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,FloatingWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\FloatingWindow.cs,DockDragOver,The following statement contains a magic number: if (b && !m_dockTabIcon.Highlight)              {                  m_dockTabIcon.Highlight = b;                  DockIconsLayer.RemoveChild(m_dockPreviewShape);                  m_dockPreviewShape = null;                  Window owner = Window.GetWindow(this);                  Rectangle rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  m_dockPreviewShape = rect;                  double space = 2;                  Point p = PointFromScreen(PointToScreen(new Point(space' space)));                  Canvas c = new Canvas();                  c.SnapsToDevicePixels = true;                  c.Width = DockedContent.ActualWidth;                  c.Height = DockedContent.ActualHeight;                  Canvas.SetLeft(c' p.X);                  Canvas.SetTop(c' p.Y);                  m_dockPreviewShape.Width = DockedContent.ActualWidth - space * 2;                  m_dockPreviewShape.Height = DockedContent.ActualHeight - 20 - space * 2;                  Canvas.SetLeft(m_dockPreviewShape' 0);                  Canvas.SetTop(m_dockPreviewShape' 0);                  c.Children.Add(m_dockPreviewShape);                    rect = new Rectangle();                  rect.Fill = Brushes.RoyalBlue;                  rect.Opacity = 0.3;                  rect.Width = Math.Min(DockedContent.ActualWidth / 4' 50);                  rect.Height = 20;                  Canvas.SetLeft(rect' 0);                  Canvas.SetTop(rect' DockedContent.ActualHeight - 20 - space * 2);                  c.Children.Add(rect);                  m_dockPreviewShape = c;                    DockIconsLayer.InsertChild(0' m_dockPreviewShape);              }              else if(!b)              {                  if (m_dockPreviewShape != null)                  {                      DockIconsLayer.RemoveChild(m_dockPreviewShape);                      m_dockPreviewShape = null;                  }                  m_dockTabIcon.Highlight = false;				              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,MergeWith,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  // get the column definition of child grid                  ColumnDefinition oldColumnDef = ColumnDefinitions[index * 2];                  // count the sum of columns widths of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      totalValue += layoutColumnDef.Width.Value;                  }                  // remove the child from our list' from view children adn from column definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  ColumnDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create column definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int columnIndex = Grid.GetColumn(element);                      ColumnDefinition layoutColumnDef = grid.ColumnDefinitions[columnIndex];                      double newValue = oldColumnDef.Width.Value * layoutColumnDef.Width.Value / totalValue;                      ColumnDefinition newColumnDef = NewColumnDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Width);                      grid.Children.Remove(element);                      ColumnDefinitions.Insert((index + indexOffset) * 2' newColumnDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          ColumnDefinitions.Insert((index + indexOffset) * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset) * 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of column indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetColumn(Children[i]' i);                  }              }              else              {                  // get the row definition of child grid                  RowDefinition oldRowDef = RowDefinitions[index * 2];                  // count the sum of row heights of childs children                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      totalValue += layoutRowDef.Height.Value;                  }                  // remove the child from our list' from view children adn from row definitions                  m_children.RemoveAt(index);                  Children.RemoveAt(index * 2);                  RowDefinitions.RemoveAt(index * 2);                  // move all childs children to this grid and create row definitions for each of them                  foreach (IDockLayout newLayout in grid.Layouts)                  {                      FrameworkElement element = (FrameworkElement)newLayout;                      int RowIndex = Grid.GetRow(element);                      RowDefinition layoutRowDef = grid.RowDefinitions[RowIndex];                      double newValue = oldRowDef.Height.Value * layoutRowDef.Height.Value / totalValue;                      RowDefinition newRowDef = NewRowDefinition(new GridLength(newValue' GridUnitType.Star)' m_minGridSize.Height);                      grid.Children.Remove(element);                      RowDefinitions.Insert((index + indexOffset) * 2' newRowDef);                      Children.Insert((index + indexOffset) * 2' element);                      m_children.Insert(index + indexOffset' newLayout);                      if (indexOffset < grid.Layouts.Count - 1)                      {                          // if we move more than one child' then we need to add new splitters too                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          RowDefinitions.Insert((index + indexOffset) * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                          Children.Insert((index + indexOffset)* 2 + 1' splitter);                      }                      indexOffset ++;                  }                  // set the association of row indexes                  for (int i = 0; i < Children.Count; i++)                  {                      Grid.SetRow(Children[i]' i);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Dock,The following statement contains a magic number: if (dockTo == DockTo.Center && m_children.Count == 1)              {                  m_children[0].Dock(null' newContent' dockTo);              }              else if (m_children.Count < 2)              {                  if (dockTo == DockTo.Center)                  {                      dockTo = DockTo.Right;                  }                  if (dockTo == DockTo.Top || dockTo == DockTo.Bottom)                  {                      m_orientation = Orientation.Vertical;                  }                  else                  {                      m_orientation = Orientation.Horizontal;                  }                  DockedWindow newChild = new DockedWindow(Root' newContent);                  if (Children.Count == 0)                  {                      AddFirstChild(newChild);                  }                  else                  {                      if (targetChild == null)                      {                          if (dockTo == DockTo.Top || dockTo == DockTo.Left)                          {                              targetChild = m_children[0];                          }                          else                          {                              targetChild = m_children[m_children.Count - 1];                          }                      }                      FrameworkElement control = (FrameworkElement)targetChild;                      int index = m_children.IndexOf(targetChild);                      if (dockTo == DockTo.Left || dockTo == DockTo.Right)                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Horizontal);                          int column = (int)control.GetValue(Grid.ColumnProperty);                          ColumnDefinition oldColumn = ColumnDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalWidth = ((FrameworkElement)targetChild).ActualWidth;                          double width = Math.Max(Math.Min(contentSettings.Size.Width' (totalWidth - splitter.Width) / 2)' (totalWidth - splitter.Width) / 5);                          double ratioNew = width / totalWidth;                          double ratioOld = (totalWidth - width - splitter.Width) / totalWidth;                            if (dockTo == DockTo.Left)                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                                                            Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              ColumnDefinition leftColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioOld' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinition rightColumn = NewColumnDefinition(new GridLength(oldColumn.Width.Value * ratioNew' oldColumn.Width.GridUnitType)' m_minGridSize.Width);                              ColumnDefinitions[index * 2] = leftColumn;                              ColumnDefinitions.Insert(index * 2 + 1' rightColumn);                              ColumnDefinitions.Insert(index * 2 + 1' NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetColumn(Children[i]' i);                          }                      }                      else                      {                          GridSplitter splitter = NewGridSplitter(Orientation.Vertical);                          int row = (int)control.GetValue(Grid.RowProperty);                          RowDefinition oldRow = RowDefinitions[index * 2];                            ContentSettings contentSettings = (newContent is TabLayout) ? ((TabLayout)newContent).Children[0].Settings : ((DockContent)newContent).Settings;                          double totalHeight = ((FrameworkElement)targetChild).ActualHeight;                          double height = Math.Max(Math.Min(contentSettings.Size.Height' (totalHeight - splitter.Height) / 2)' (totalHeight - splitter.Height) / 5);                          double ratioNew = height / totalHeight;                          double ratioOld = (totalHeight - height - splitter.Height) / totalHeight;                            if (dockTo == DockTo.Top)                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value *ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index' newChild);                              Children.Insert(index * 2' splitter);                              Children.Insert(index * 2' newChild);                          }                          else                          {                              RowDefinition topRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioOld' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinition bottomRow = NewRowDefinition(new GridLength(oldRow.Height.Value * ratioNew' oldRow.Height.GridUnitType)' m_minGridSize.Height);                              RowDefinitions[index * 2] = topRow;                              RowDefinitions.Insert(index * 2 + 1' bottomRow);                              RowDefinitions.Insert(index * 2 + 1' NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                              m_children.Insert(index + 1' newChild);                              Children.Insert(index * 2 + 1' newChild);                              Children.Insert(index * 2 + 1' splitter);                          }                          for (int i = index * 2; i < Children.Count; i++)                          {                              Grid.SetRow(Children[i]' i);                          }                      }                  }              }              else if (dockTo == DockTo.Left || dockTo == DockTo.Right || dockTo == DockTo.Top || dockTo == DockTo.Bottom)              {                  DockedWindow dockedWindow = (DockedWindow)targetChild;                  int index = m_children.IndexOf(targetChild);                  GridLayout gridLayout = new GridLayout(Root);                  gridLayout.SetValue(Grid.ColumnProperty' dockedWindow.GetValue(Grid.ColumnProperty));                  gridLayout.SetValue(Grid.RowProperty' dockedWindow.GetValue(Grid.RowProperty));                  Children.Remove(dockedWindow);                  IDockContent content = dockedWindow.DockedContent;                  dockedWindow.Undock(content);                  m_children[index] = gridLayout;                  Children.Insert(index * 2' gridLayout);                  gridLayout.Dock(null' content' DockTo.Center);                  UpdateLayout();                  gridLayout.Dock(content' newContent' dockTo);              }              else if (targetChild != null)              {                  targetChild.Dock(nextTo' newContent' dockTo);              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,Undock,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)              {                  ColumnDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      ColumnDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                        for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetColumn(Children[i]' i);                      }                  }              }              else              {                  RowDefinitions.RemoveAt(index * 2);                  Children.RemoveAt(index * 2);                  if (m_children.Count > 1)                  {                      RowDefinitions.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      Children.RemoveAt(index * 2 + (index == 0 ? 0 : -1));                      for (int i = 0; i < Children.Count; i++)                      {                          Grid.SetRow(Children[i]' i);                      }                  }              }
Magic Number,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Me = ((Sce.Atf.Wpf.Docking.ResizablePopup)(target));              return;              case 3:              this.TopResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 4:              this.BottomResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 5:              this.LeftResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 6:              this.RightResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Me = ((Sce.Atf.Wpf.Docking.ResizablePopup)(target));              return;              case 3:              this.TopResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 4:              this.BottomResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 5:              this.LeftResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 6:              this.RightResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Me = ((Sce.Atf.Wpf.Docking.ResizablePopup)(target));              return;              case 3:              this.TopResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 4:              this.BottomResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 5:              this.LeftResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 6:              this.RightResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.Me = ((Sce.Atf.Wpf.Docking.ResizablePopup)(target));              return;              case 3:              this.TopResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 4:              this.BottomResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 5:              this.LeftResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 6:              this.RightResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              }
Magic Number,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 2:              eventSetter = new System.Windows.EventSetter();              eventSetter.Event = System.Windows.Controls.Primitives.Thumb.DragStartedEvent;                            #line 31 "..\..\..\Docking\ResizablePopup.xaml"              eventSetter.Handler = new System.Windows.Controls.Primitives.DragStartedEventHandler(this.ThumbDragStarted);                            #line default              #line hidden              ((System.Windows.Style)(target)).Setters.Add(eventSetter);              eventSetter = new System.Windows.EventSetter();              eventSetter.Event = System.Windows.Controls.Primitives.Thumb.DragDeltaEvent;                            #line 32 "..\..\..\Docking\ResizablePopup.xaml"              eventSetter.Handler = new System.Windows.Controls.Primitives.DragDeltaEventHandler(this.ThumbDragDelta);                            #line default              #line hidden              ((System.Windows.Style)(target)).Setters.Add(eventSetter);              eventSetter = new System.Windows.EventSetter();              eventSetter.Event = System.Windows.Controls.Primitives.Thumb.DragCompletedEvent;                            #line 33 "..\..\..\Docking\ResizablePopup.xaml"              eventSetter.Handler = new System.Windows.Controls.Primitives.DragCompletedEventHandler(this.ThumbDragCompleted);                            #line default              #line hidden              ((System.Windows.Style)(target)).Setters.Add(eventSetter);              break;              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,SidePopup,The following statement contains a magic number: m_timer.Interval = 50;
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,Timer_Elapsed,The following statement contains a magic number: try              {                  Point curMousePos = m_lastItemOver != null ? Win32Calls.GetPosition(m_lastItemOver) : new Point(-1' -1);                  if (m_lastItemOver != null && new Rect(0' 0' m_lastItemOver.ActualWidth' m_lastItemOver.ActualHeight).Contains(curMousePos))                  {                      TimeSpan ts = DateTime.Now - m_timerTime;                      if (ts.TotalMilliseconds > 500 || Mouse.LeftButton == MouseButtonState.Pressed)                      {                          ShowPopup();                          m_lastItemOver.IsChecked = true;                          m_lastItemOver = null;                          m_timerTime = DateTime.Now;                      }                      m_timer.Start();                  }                  else                  {                      var app = Application.Current;                      if (app == null)                          return;                        var window = app.MainWindow;                      if (window == null || !window.IsActive)                          return;                        if (PART_Popup.IsOpen && !PART_Popup.Resizing)                      {                          var pt32 = new User32.POINT();                          Win32Calls.GetCursorPos(ref pt32);                          Point mousePos = new Point(pt32.X' pt32.Y);                          Point pos = PointToScreen(new Point(0' 0));                          Matrix m = PresentationSource.FromVisual(Window.GetWindow(this)).CompositionTarget.TransformToDevice;                          if (m != Matrix.Identity)                          {                              m.Invert();                              mousePos = m.Transform(mousePos);                              pos = m.Transform(pos);                          }                          switch (TabsPlacement)                          {                              case System.Windows.Controls.Dock.Top:                                  pos.Y += ActualHeight;                                  break;                              case System.Windows.Controls.Dock.Bottom:                                  pos.Y -= PART_Popup.Height;                                  break;                              case System.Windows.Controls.Dock.Left:                                  pos.X += ActualWidth;                                  break;                              case System.Windows.Controls.Dock.Right:                                  pos.X -= PART_Popup.Width;                                  break;                          }                          bool b2 = new Rect(pos.X' pos.Y' PART_Popup.Width' PART_Popup.Height).Contains(mousePos);                          Point posThis = Win32Calls.GetPosition(this);                          bool b3 = new Rect(0' 0' ActualWidth' ActualHeight).Contains(posThis);                          if (!b2 && !b3)                          {                              TimeSpan ts = DateTime.Now - m_timerTime;                              if(ts.TotalMilliseconds > 1000)                              {                                  // if mouse is outside for more than some time' then collapse this popup                                  ClosePopup();                              }                              else                              {                                  m_timer.Start();                              }                          }                          else                          {                              m_timerTime = DateTime.Now;                              m_timer.Start();                          }                      }                  }              }              catch (InvalidOperationException)              {                  // Can be thrown when closing the application and popup is still open...              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,Timer_Elapsed,The following statement contains a magic number: try              {                  Point curMousePos = m_lastItemOver != null ? Win32Calls.GetPosition(m_lastItemOver) : new Point(-1' -1);                  if (m_lastItemOver != null && new Rect(0' 0' m_lastItemOver.ActualWidth' m_lastItemOver.ActualHeight).Contains(curMousePos))                  {                      TimeSpan ts = DateTime.Now - m_timerTime;                      if (ts.TotalMilliseconds > 500 || Mouse.LeftButton == MouseButtonState.Pressed)                      {                          ShowPopup();                          m_lastItemOver.IsChecked = true;                          m_lastItemOver = null;                          m_timerTime = DateTime.Now;                      }                      m_timer.Start();                  }                  else                  {                      var app = Application.Current;                      if (app == null)                          return;                        var window = app.MainWindow;                      if (window == null || !window.IsActive)                          return;                        if (PART_Popup.IsOpen && !PART_Popup.Resizing)                      {                          var pt32 = new User32.POINT();                          Win32Calls.GetCursorPos(ref pt32);                          Point mousePos = new Point(pt32.X' pt32.Y);                          Point pos = PointToScreen(new Point(0' 0));                          Matrix m = PresentationSource.FromVisual(Window.GetWindow(this)).CompositionTarget.TransformToDevice;                          if (m != Matrix.Identity)                          {                              m.Invert();                              mousePos = m.Transform(mousePos);                              pos = m.Transform(pos);                          }                          switch (TabsPlacement)                          {                              case System.Windows.Controls.Dock.Top:                                  pos.Y += ActualHeight;                                  break;                              case System.Windows.Controls.Dock.Bottom:                                  pos.Y -= PART_Popup.Height;                                  break;                              case System.Windows.Controls.Dock.Left:                                  pos.X += ActualWidth;                                  break;                              case System.Windows.Controls.Dock.Right:                                  pos.X -= PART_Popup.Width;                                  break;                          }                          bool b2 = new Rect(pos.X' pos.Y' PART_Popup.Width' PART_Popup.Height).Contains(mousePos);                          Point posThis = Win32Calls.GetPosition(this);                          bool b3 = new Rect(0' 0' ActualWidth' ActualHeight).Contains(posThis);                          if (!b2 && !b3)                          {                              TimeSpan ts = DateTime.Now - m_timerTime;                              if(ts.TotalMilliseconds > 1000)                              {                                  // if mouse is outside for more than some time' then collapse this popup                                  ClosePopup();                              }                              else                              {                                  m_timer.Start();                              }                          }                          else                          {                              m_timerTime = DateTime.Now;                              m_timer.Start();                          }                      }                  }              }              catch (InvalidOperationException)              {                  // Can be thrown when closing the application and popup is still open...              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following statement contains a magic number: switch (Orientation)              {                  case Orientation.Horizontal:                      PART_Popup.MaxWidth = RenderSize.Width;                      PART_Popup.MaxHeight = 0.75 * Math.Min(Root.RenderSize.Height' System.Windows.SystemParameters.PrimaryScreenHeight);                      PART_Popup.Width = RenderSize.Width;                      PART_Popup.Height = Math.Min(settings.Size.Height + 25' PART_Popup.MaxHeight);                      break;                  case Orientation.Vertical:                      PART_Popup.MaxWidth = 0.75 * Math.Min(Root.RenderSize.Width' System.Windows.SystemParameters.PrimaryScreenWidth);                      PART_Popup.MaxHeight = RenderSize.Height;                      PART_Popup.Width = Math.Min(settings.Size.Width + 7' PART_Popup.MaxWidth);                      PART_Popup.Height = RenderSize.Height;                      break;              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following statement contains a magic number: switch (Orientation)              {                  case Orientation.Horizontal:                      PART_Popup.MaxWidth = RenderSize.Width;                      PART_Popup.MaxHeight = 0.75 * Math.Min(Root.RenderSize.Height' System.Windows.SystemParameters.PrimaryScreenHeight);                      PART_Popup.Width = RenderSize.Width;                      PART_Popup.Height = Math.Min(settings.Size.Height + 25' PART_Popup.MaxHeight);                      break;                  case Orientation.Vertical:                      PART_Popup.MaxWidth = 0.75 * Math.Min(Root.RenderSize.Width' System.Windows.SystemParameters.PrimaryScreenWidth);                      PART_Popup.MaxHeight = RenderSize.Height;                      PART_Popup.Width = Math.Min(settings.Size.Width + 7' PART_Popup.MaxWidth);                      PART_Popup.Height = RenderSize.Height;                      break;              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following statement contains a magic number: switch (Orientation)              {                  case Orientation.Horizontal:                      PART_Popup.MaxWidth = RenderSize.Width;                      PART_Popup.MaxHeight = 0.75 * Math.Min(Root.RenderSize.Height' System.Windows.SystemParameters.PrimaryScreenHeight);                      PART_Popup.Width = RenderSize.Width;                      PART_Popup.Height = Math.Min(settings.Size.Height + 25' PART_Popup.MaxHeight);                      break;                  case Orientation.Vertical:                      PART_Popup.MaxWidth = 0.75 * Math.Min(Root.RenderSize.Width' System.Windows.SystemParameters.PrimaryScreenWidth);                      PART_Popup.MaxHeight = RenderSize.Height;                      PART_Popup.Width = Math.Min(settings.Size.Width + 7' PART_Popup.MaxWidth);                      PART_Popup.Height = RenderSize.Height;                      break;              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following statement contains a magic number: switch (Orientation)              {                  case Orientation.Horizontal:                      PART_Popup.MaxWidth = RenderSize.Width;                      PART_Popup.MaxHeight = 0.75 * Math.Min(Root.RenderSize.Height' System.Windows.SystemParameters.PrimaryScreenHeight);                      PART_Popup.Width = RenderSize.Width;                      PART_Popup.Height = Math.Min(settings.Size.Height + 25' PART_Popup.MaxHeight);                      break;                  case Orientation.Vertical:                      PART_Popup.MaxWidth = 0.75 * Math.Min(Root.RenderSize.Width' System.Windows.SystemParameters.PrimaryScreenWidth);                      PART_Popup.MaxHeight = RenderSize.Height;                      PART_Popup.Width = Math.Min(settings.Size.Width + 7' PART_Popup.MaxWidth);                      PART_Popup.Height = RenderSize.Height;                      break;              }
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following statement contains a magic number: booleanAnimation.Duration = TimeSpan.FromSeconds(0.1);
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following statement contains a magic number: booleanAnimation.KeyFrames.Add(                  new DiscreteBooleanKeyFrame(                      true' // Target value (KeyValue)                      KeyTime.FromTimeSpan(TimeSpan.FromSeconds(0.1))) // KeyTime                  );
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,CreateHeader,The following statement contains a magic number: tb.RenderTransformOrigin = new Point(0.5' 0.5);
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,CreateHeader,The following statement contains a magic number: tb.RenderTransformOrigin = new Point(0.5' 0.5);
Magic Number,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,CreateHeader,The following statement contains a magic number: header.LayoutTransform = new RotateTransform(Orientation == Orientation.Horizontal ? 0 : 90);
Magic Number,Sce.Atf.Wpf.Docking,TabLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\TabLayout.cs,TabLayout,The following statement contains a magic number: m_timer.Interval = 500;
Magic Number,Sce.Atf.Wpf.Docking,TabLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\TabLayout.cs,TabLayout_SizeChanged,The following statement contains a magic number: foreach (DockContent content in Children)              {                  if (content.Settings.DockState == DockState.Docked || content.Settings.DockState == DockState.Collapsed)                  {                      Point p = Root.PointFromScreen(PointToScreen(new Point(ActualWidth / 2' ActualHeight / 2)));                      content.Settings.Location = new Point(p.X / Root.ActualWidth' p.Y / Root.ActualHeight);                      content.Settings.Size = new Size(ActualWidth' ActualHeight);                  }              }
Magic Number,Sce.Atf.Wpf.Docking,TabLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\TabLayout.cs,TabLayout_SizeChanged,The following statement contains a magic number: foreach (DockContent content in Children)              {                  if (content.Settings.DockState == DockState.Docked || content.Settings.DockState == DockState.Collapsed)                  {                      Point p = Root.PointFromScreen(PointToScreen(new Point(ActualWidth / 2' ActualHeight / 2)));                      content.Settings.Location = new Point(p.X / Root.ActualWidth' p.Y / Root.ActualHeight);                      content.Settings.Size = new Size(ActualWidth' ActualHeight);                  }              }
Magic Number,Sce.Atf.Wpf.Models,CommandItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\CommandItem.cs,ParseMenuPath,The following statement contains a magic number: if (!string.IsNullOrEmpty(menuText))              {                  string[] segments;                  if (menuText[0] == '@')                      segments = new[] { menuText.Substring(1' menuText.Length - 1) };                  else                      segments = menuText.Split(s_pathDelimiters' 8);                    if(segments.Length > 1)                  {                      string[] result = new string[segments.Length - 1];                      Array.Copy(segments' result' segments.Length - 1);                      return result;                  }              }
Magic Number,Sce.Atf.Wpf.Models,ProgressViewModel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Models\ProgressViewModel.cs,worker_RunWorkerCompleted,The following statement contains a magic number: Progress = 100;
Magic Number,Sce.Atf.Wpf.ValueConverters,ColorAndOpacityToBrushConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,Convert,The following statement contains a magic number: if (values[0] is Color && values[1] is double)              {                  var c = (Color)values[0];                  var d = (double)values[1];                  return new SolidColorBrush(Color.FromArgb((byte)(d * 255)' c.R' c.G' c.B));              }
Magic Number,Sce.Atf.Wpf.ValueConverters,ScaleDoubleConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,Convert,The following statement contains a magic number: double dScale = 0.75;
Magic Number,Sce.Atf.Wpf.ValueConverters,IndexerBindingConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\MiscValueConverters.cs,Convert,The following statement contains a magic number: if (values.Length < 2)                  return DependencyProperty.UnsetValue;
Magic Number,Sce.Atf.Wpf.ValueConverters,TimeSpanToVisibilityConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\ValueConverters\VisibilityValueConverters.cs,Convert,The following statement contains a magic number: if (value is double)              {                  var ts = (double)value;                  return Math.Abs(ts - 0.0) < 0.00001 ? Visibility.Collapsed : Visibility.Visible;              }
Missing Default,Sce.Atf.Wpf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\ControlHostService.cs,ControlGroupToDockTo,The following switch statement is missing a default case: switch (standardControlGroup)              {                  case Sce.Atf.Applications.StandardControlGroup.Bottom:                      dockTo = DockTo.Bottom;                      break;                  case Sce.Atf.Applications.StandardControlGroup.Center:                      dockTo = DockTo.Center;                      break;                  case Sce.Atf.Applications.StandardControlGroup.CenterPermanent:                      dockTo = DockTo.Center;                      break;                  case Sce.Atf.Applications.StandardControlGroup.Floating:                      dockTo = DockTo.Center;                      break;                  case Sce.Atf.Applications.StandardControlGroup.Left:                      dockTo = DockTo.Left;                      break;                  case Sce.Atf.Applications.StandardControlGroup.Right:                      dockTo = DockTo.Right;                      break;                  case Sce.Atf.Applications.StandardControlGroup.Top:                      dockTo = DockTo.Top;                      break;              }
Missing Default,Sce.Atf.Wpf.Applications,EditLabelCommand,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\EditLabelCommand.cs,DoCommand,The following switch statement is missing a default case: switch ((Commands)tag)              {                  case Commands.EditLabel:                      var target = m_contextRegistry.GetCommandTarget<object>();                      if (target != null)                      {                          var labelEditingContext = m_contextRegistry.GetActiveContext<ILabelEditingContext>();                          if (labelEditingContext != null)                              labelEditingContext.EditLabel(target);                      }                      break;              }
Missing Default,Sce.Atf.Wpf.Applications,HelpCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\HelpCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((Commands)tag)                  {                      case Commands.Help: return HelpFilePath != null;                      case Commands.HelpReleaseNotes: return ReleaseNotesFilePath != null;                      case Commands.HelpAbout: return true;                  }
Missing Default,Sce.Atf.Wpf.Applications,HelpCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\HelpCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((Commands)tag)                  {                      case Commands.Help:                          ShowHelp(System.Windows.Forms.HelpNavigator.TableOfContents);                          break;                      case Commands.HelpReleaseNotes:                          ShowReleaseNotes();                          break;                      case Commands.HelpAbout:                          ShowHelpAbout();                          break;                    }
Missing Default,Sce.Atf.Wpf.Applications,StandardEditCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\StandardEditCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)tag)              {                  case StandardCommand.EditCut:                      if (instancingContext == null)                          canDo = false;                      else                          canDo =                              instancingContext.CanCopy() &&                              instancingContext.CanDelete();                      break;                    case StandardCommand.EditDelete:                      canDo =                          instancingContext != null &&                          instancingContext.CanDelete();                      break;                    case StandardCommand.EditCopy:                      canDo =                          instancingContext != null &&                          instancingContext.CanCopy();                      break;                    case StandardCommand.EditPaste:                      canDo =                          instancingContext != null &&                          CanPaste();                      break;              }
Missing Default,Sce.Atf.Wpf.Applications,StandardEditCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\StandardEditCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)tag)              {                  case StandardCommand.EditCut:                      Cut();                      break;                    case StandardCommand.EditDelete:                      Delete();                      break;                    case StandardCommand.EditCopy:                      Copy();                      break;                    case StandardCommand.EditPaste:                      Paste();                      break;              }
Missing Default,Sce.Atf.Wpf.Applications,TargetService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Applications\TargetService.cs,DoCommand,The following switch statement is missing a default case: switch ((Command)tag)                  {                      case Command.EditTargets:                          ShowTargetDialog();                          break;                  }
Missing Default,Sce.Atf.Wpf.Behaviors,ListBoxScrollToEndBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\ListBoxScrollToEndBehavior.cs,ItemsSource_CollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                  case NotifyCollectionChangedAction.Move:                       selectedItem = e.NewItems[e.NewItems.Count - 1];                       break;                  case NotifyCollectionChangedAction.Remove:                       if (ic.Count < e.OldStartingIndex)                      {                          selectedItem = ic[e.OldStartingIndex - 1];                      }                       else if (ic.Count > 0)                      {                          selectedItem = ic[0];                       }                      break;                  case NotifyCollectionChangedAction.Reset:                       if (ic.Count > 0)                      {                          selectedItem = ic[0];                      }                      break;              }
Missing Default,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,ValidateValue,The following switch statement is missing a default case: switch (mask)              {                  case MaskType.Integer:                      try                      {                          Convert.ToInt64(value);                          return value;                      }                      catch                      {                      }                      return string.Empty;                    case MaskType.Decimal:                      try                      {                          Convert.ToDouble(value);                          return value;                      }                      catch                      {                      }                      return string.Empty;              }
Missing Default,Sce.Atf.Wpf.Behaviors,TextBoxNumericBehavior,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Behaviors\TextBoxNumericBehavior.cs,IsSymbolValid,The following switch statement is missing a default case: switch (mask)              {                  case MaskType.Any:                      return true;                    case MaskType.Integer:                      if (str == NumberFormatInfo.CurrentInfo.NegativeSign)                          return true;                      break;                    case MaskType.Decimal:                      if (str == NumberFormatInfo.CurrentInfo.NumberDecimalSeparator ||                          str == NumberFormatInfo.CurrentInfo.NegativeSign)                          return true;                      break;              }
Missing Default,Sce.Atf.Wpf,FindFileResolver,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\FindFileResolver.cs,QueryUser,The following switch statement is missing a default case: switch (s_lastAction)                  {                      case FindFileAction.AcceptSuggestion:                          newUri = suggestedUri;                          return true;                        case FindFileAction.AcceptAllSuggestions:                          newUri = suggestedUri;                          return true;                        case FindFileAction.SearchDirectory:                          if (SearchForFile(uri' out newUri' true))                              return true;                          continue;                        case FindFileAction.SearchDirectoryForAll:                          if (SearchForFile(uri' out newUri' false))                              return true;                          continue;                        case FindFileAction.UserSpecify:                          if (UserFindFile(uri' out newUri' options))                              return true;                          continue;                        case FindFileAction.Ignore:                          newUri = uri;                          return false;                        case FindFileAction.IgnoreAll:                          newUri = uri;                          return false;                                            case FindFileAction.Quit:                          newUri = uri;                          return null;                  }
Missing Default,Sce.Atf.Wpf.Controls,ConfirmationDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ConfirmationDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.yesButton = ((System.Windows.Controls.Button)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,BrowseForFolderDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\DirectoryPicker.cs,BrowseEventHandler,The following switch statement is missing a default case: switch (uMsg)              {                  case MessageFromBrowser.BFFM_INITIALIZED:                      {                          // The dialog box has finished initializing.                          // lParam   Not used' value is NULL.                          if (!string.IsNullOrEmpty(InitialExpandedFolder))                          {                              SendMessageW(hwnd' MessageToBrowser.BFFM_SETEXPANDED' new IntPtr(1)' InitialExpandedFolder);                          }                          else if (!string.IsNullOrEmpty(InitialFolder))                          {                              SendMessageW(hwnd' MessageToBrowser.BFFM_SETSELECTIONW' new IntPtr(1)' InitialFolder);                          }                            if (!string.IsNullOrEmpty(OKButtonText))                          {                              SendMessageW(hwnd' MessageToBrowser.BFFM_SETOKTEXT' new IntPtr(1)' OKButtonText);                          }                            break;                      }                    case MessageFromBrowser.BFFM_SELCHANGED:                      {                          // The selection has changed in the dialog box.                          // lParam   A pointer to an item identifier list (PIDL) identifying the newly selected item.                          var pathsb = new StringBuilder(260);                          if (SHGetPathFromIDList(lParam' pathsb))                          {                              SelectedFolder = pathsb.ToString();                          }                            break;                      }                    case MessageFromBrowser.BFFM_VALIDATEFAILEDA:                      {                          // ANSI                          // The user typed an invalid name into the dialog's edit box. A nonexistent folder is considered an invalid name.                          // lParam   A pointer to a string containing the invalid name. An application can use this data in an error dialog informing the user that the name was not valid.                          // Return zero to dismiss the dialog or nonzero to keep the dialog displayed                          break;                      }                    case MessageFromBrowser.BFFM_VALIDATEFAILEDW:                      {                          // Unicode                          // The user typed an invalid name into the dialog's edit box. A nonexistent folder is considered an invalid name.                          // lParam   A pointer to a string containing the invalid name. An application can use this data in an error dialog informing the user that the name was not valid.                          // Return zero to dismiss the dialog or nonzero to keep the dialog displayed                          break;                      }                    case MessageFromBrowser.BFFM_IUNKNOWN:                      {                          // An IUnknown interface is available to the dialog box.                          // lParam   A pointer to an IUnknown interface.                          break;                      }              }
Missing Default,Sce.Atf.Wpf.Controls,FindTargetsDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\FindTargetsDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.listView = ((System.Windows.Controls.ListView)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,SizeToContentDecorator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SizeToContentDecorator.cs,MeasureOverride,The following switch statement is missing a default case: switch (this.SizeToContent)              {                  case SizeToContent.Height:                      measureConstraint = new Size(constraint.Width' double.PositiveInfinity);                      break;                  case SizeToContent.Width:                      measureConstraint = new Size(double.PositiveInfinity' constraint.Height);                      break;                  case SizeToContent.WidthAndHeight:                      measureConstraint = new Size(double.PositiveInfinity' double.PositiveInfinity);                      break;              }
Missing Default,Sce.Atf.Wpf.Controls,SwitchToDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SwitchToDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.SwitchToLabel = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:              this.ControlList = ((System.Windows.Controls.ListBox)(target));              return;              case 3:              this.CurrentSelection = ((System.Windows.Controls.TextBlock)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,TargetDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TargetDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.listView = ((System.Windows.Controls.ListView)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,TcpIpTargetEditDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\TcpIpTargetEditDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.button_OK = ((System.Windows.Controls.Button)(target));              return;              case 2:              this.button_Cancel = ((System.Windows.Controls.Button)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,VirtualizingWrapPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\VirtualizingWrapPanel.cs,OnItemsChanged,The following switch statement is missing a default case: switch (args.Action)              {                  case NotifyCollectionChangedAction.Remove:                  case NotifyCollectionChangedAction.Replace:                      RemoveInternalChildRange(args.Position.Index' args.ItemUICount);                      break;                  case NotifyCollectionChangedAction.Move:                      RemoveInternalChildRange(args.OldPosition.Index' args.ItemUICount);                      break;              }
Missing Default,Sce.Atf.Wpf.Controls,WindowLayoutNewDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\WindowLayoutNameDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.textBox = ((System.Windows.Controls.TextBox)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\AboutDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:                            #line 44 "..\..\..\Controls\AboutDialog.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.Button_Click);                            #line default              #line hidden              return;              case 2:              this.hyperlink = ((System.Windows.Documents.Hyperlink)(target));                            #line 48 "..\..\..\Controls\AboutDialog.xaml"              this.hyperlink.RequestNavigate += new System.Windows.Navigation.RequestNavigateEventHandler(this.hyperlink_RequestNavigate);                            #line default              #line hidden              return;              }
Missing Default,Sce.Atf.Wpf.Controls,MainWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MainWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.me = ((Sce.Atf.Wpf.Controls.MainWindow)(target));              return;              case 2:              this.dockPanel = ((System.Windows.Controls.DockPanel)(target));              return;              case 3:              this.menuBar = ((System.Windows.Controls.Menu)(target));              return;              case 4:              this.toolBarTray = ((System.Windows.Controls.ToolBarTray)(target));              return;              case 5:              this.statusBar = ((System.Windows.Controls.Primitives.StatusBar)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls,MessageBoxDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\MessageBoxDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.Image = ((Sce.Atf.Wpf.Controls.Icon)(target));              return;              case 2:              this.MessageText = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.OkButton = ((System.Windows.Controls.Button)(target));                            #line 36 "..\..\..\Controls\MessageBoxDialog.xaml"              this.OkButton.Click += new System.Windows.RoutedEventHandler(this.OkButton_Click);                            #line default              #line hidden              return;              case 4:              this.YesButton = ((System.Windows.Controls.Button)(target));                            #line 37 "..\..\..\Controls\MessageBoxDialog.xaml"              this.YesButton.Click += new System.Windows.RoutedEventHandler(this.YesButton_Click);                            #line default              #line hidden              return;              case 5:              this.NoButton = ((System.Windows.Controls.Button)(target));                            #line 38 "..\..\..\Controls\MessageBoxDialog.xaml"              this.NoButton.Click += new System.Windows.RoutedEventHandler(this.NoButton_Click);                            #line default              #line hidden              return;              case 6:              this.CancelButton = ((System.Windows.Controls.Button)(target));                            #line 39 "..\..\..\Controls\MessageBoxDialog.xaml"              this.CancelButton.Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Missing Default,Sce.Atf.Wpf.Controls,ProgressDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\ProgressDialog.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.lblStatus = ((System.Windows.Controls.TextBlock)(target));              return;              case 2:                            #line 39 "..\..\..\Controls\ProgressDialog.xaml"              ((System.Windows.Controls.Button)(target)).Click += new System.Windows.RoutedEventHandler(this.CancelButton_Click);                            #line default              #line hidden              return;              }
Missing Default,Sce.Atf.Wpf.Controls,SliderBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\SliderBox.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.PositionSlider = ((System.Windows.Controls.Slider)(target));              return;              case 2:              this.TextBox = ((Sce.Atf.Wpf.Controls.FormattingTextBox)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Controls\PropertyEditing\PropertyGridView.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.m_propertyGrid = ((Sce.Atf.Wpf.Controls.PropertyEditing.PropertyGrid)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDragOver,The following switch statement is missing a default case: switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              Canvas c = new Canvas();                              c.SnapsToDevicePixels = true;                              c.Width = ActualWidth;                              c.Height = ActualHeight;                              Canvas.SetLeft(c' p.X);                              Canvas.SetTop(c' p.Y);                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - 20 - space * 2;                              Canvas.SetLeft(fe' 0);                              Canvas.SetTop(fe' 0);                              c.Children.Add(fe);                                rect = new Rectangle();                              rect.Fill = Brushes.RoyalBlue;                              rect.Opacity = 0.3;                              rect.Width = Math.Min(ActualWidth / 4' 50);                              rect.Height = 20;                              Canvas.SetLeft(rect' 0);                              Canvas.SetTop(rect' ActualHeight - 20 - space * 2);                              c.Children.Add(rect);                              fe = c;                              break;                      }
Missing Default,Sce.Atf.Wpf.Docking,DockedWindow,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockedWindow.cs,DockDrop,The following switch statement is missing a default case: switch (dockTo)              {                  case DockTo.Left:                  case DockTo.Right:                  case DockTo.Top:                  case DockTo.Bottom:                      ((IDockLayout)Parent).Dock(DockedContent' e.Content' dockTo);                      break;                  case DockTo.Center:                      Dock(null' e.Content' dockTo);                      break;              }
Missing Default,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following switch statement is missing a default case: switch (contentSettings.DockState)                      {                          case DockState.Docked:                              {                                  if (GridLayout == null)                                  {                                      ((IDockLayout)this).Dock(null' content' DockTo.Center);                                  }                                  else                                  {                                      Point position = new Point(ActualWidth / 2' ActualHeight / 2);                                      DockTo dockTo = contentSettings.DefaultDock;                                      switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }                                      position = PointToScreen(position);                                      DockContent target = ((IDockLayout)this).HitTest(position);                                      if (target != null)                                      {                                          DockTo targetDock = target.Settings.DefaultDock;                                          if (targetDock == dockTo)                                          {                                              ((IDockLayout)this).Dock(target' content' DockTo.Center);                                          }                                          else                                          {                                              if (dockTo == DockTo.Center && (targetDock == DockTo.Right) ||                                                  dockTo == DockTo.Left && (targetDock == DockTo.Center || targetDock == DockTo.Right))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Left);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Left) ||                                                      dockTo == DockTo.Right && (targetDock == DockTo.Center || targetDock == DockTo.Left))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Right);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Bottom) ||                                                      dockTo == DockTo.Top && (targetDock == DockTo.Center || targetDock == DockTo.Bottom))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Top);                                              }                                              else if (dockTo == DockTo.Center && (targetDock == DockTo.Top) ||                                                      dockTo == DockTo.Bottom && (targetDock == DockTo.Center || targetDock == DockTo.Top))                                              {                                                  ((IDockLayout)this).Dock(target' content' DockTo.Bottom);                                              }                                              else                                              {                                                  ((IDockLayout)this).Dock(null' content' dockTo);                                              }                                          }                                      }                                      else                                      {                                          ((IDockLayout)this).Dock(null' content' dockTo);                                      }                                  }                                  UpdateLayout();                              }                              break;                          case DockState.Floating:                              {                                  FloatingWindow wnd = new FloatingWindow(this' content' contentSettings.Location' contentSettings.Size);                                  wnd.Closing += ChildWindowClosing;                                  m_windows.Add(wnd);                                  wnd.Owner = Window.GetWindow(this);                                  wnd.Show();                              }                              break;                          case DockState.Collapsed:                              Collapse(content);                              break;                      }
Missing Default,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ShowContent,The following switch statement is missing a default case: switch (dockTo)                                      {                                          case DockTo.Left:                                              position.X = 1;                                              break;                                          case DockTo.Right:                                              position.X = ActualWidth - 2;                                              break;                                          case DockTo.Top:                                              position.Y = 1;                                              break;                                          case DockTo.Bottom:                                              position.Y = ActualHeight - 2;                                              break;                                          case DockTo.Center:                                              // no modification necessary                                              break;                                      }
Missing Default,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,ApplyLayout,The following switch statement is missing a default case: switch (dockSide)                                  {                                      case System.Windows.Controls.Dock.Left:                                          PART_LeftCollapsePanel.ReadXml(reader.ReadSubtree());                                          break;                                      case System.Windows.Controls.Dock.Top:                                          PART_TopCollapsePanel.ReadXml(reader.ReadSubtree());                                          break;                                      case System.Windows.Controls.Dock.Right:                                          PART_RightCollapsePanel.ReadXml(reader.ReadSubtree());                                          break;                                      case System.Windows.Controls.Dock.Bottom:                                          PART_BottomCollapsePanel.ReadXml(reader.ReadSubtree());                                          break;                                  }
Missing Default,Sce.Atf.Wpf.Docking,DockPanel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\DockPanel.cs,DockDragOver,The following switch statement is missing a default case: switch (m_dockPreview)                      {                          case DockTo.Left:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Right:                              fe.Width = ActualWidth * ratioWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X + ActualWidth * (1 - ratioWidth));                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Top:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                          case DockTo.Bottom:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight * ratioHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y + ActualHeight * (1 - ratioHeight));                              break;                          case DockTo.Center:                              fe.Width = ActualWidth - space * 2;                              fe.Height = ActualHeight - space * 2;                              Canvas.SetLeft(fe' p.X);                              Canvas.SetTop(fe' p.Y);                              break;                      }
Missing Default,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,ReadXml,The following switch statement is missing a default case: switch (m_orientation)                  {                      case Orientation.Horizontal:                          if (reader.ReadToDescendant("Column"))                          {                              RowDefinitions.Add(NewRowDefinition(new GridLength(1' GridUnitType.Star)' m_minGridSize.Height));                              do                              {                                  double width = double.Parse(reader.GetAttribute("Width"));                                  IDockLayout layout = null;                                  reader.ReadStartElement();                                  if (reader.LocalName == typeof(DockedWindow).Name)                                  {                                      DockedWindow dockedWindow = new DockedWindow(Root' reader.ReadSubtree());                                      layout = dockedWindow.DockedContent.Children.Count != 0 ? dockedWindow : null;                                      reader.ReadEndElement();                                  }                                  else if (reader.LocalName == typeof(GridLayout).Name)                                  {                                      GridLayout gridLayout = new GridLayout(Root' reader.ReadSubtree());                                      layout = gridLayout.Layouts.Count > 0 ? gridLayout : null;                                      reader.ReadEndElement();                                  }                                  if (layout != null)                                  {                                      if (Children.Count > 0)                                      {                                          ColumnDefinitions.Add(NewColumnDefinition(new GridLength(1' GridUnitType.Auto)' 0));                                          Children.Add(NewGridSplitter(Orientation));                                      }                                      ColumnDefinitions.Add(NewColumnDefinition(new GridLength(width' GridUnitType.Star)' m_minGridSize.Width));                                      m_children.Add(layout);                                      Children.Add((FrameworkElement)layout);                                  }                              } while (reader.ReadToNextSibling("Column"));                          }                          break;                      case Orientation.Vertical:                          if (reader.ReadToDescendant("Row"))                          {                              ColumnDefinitions.Add(NewColumnDefinition(new GridLength(1' GridUnitType.Star)' m_minGridSize.Width));                              do                              {                                  double height = double.Parse(reader.GetAttribute("Height"));                                  IDockLayout layout = null;                                  reader.ReadStartElement();                                  if (reader.LocalName == typeof(DockedWindow).Name)                                  {                                      DockedWindow dockedWindow = new DockedWindow(Root' reader.ReadSubtree());                                      layout = dockedWindow.DockedContent.Children.Count != 0 ? dockedWindow : null;                                      reader.ReadEndElement();                                  }                                  else if (reader.LocalName == typeof(GridLayout).Name)                                  {                                      GridLayout gridLayout = new GridLayout(Root' reader.ReadSubtree());                                      layout = gridLayout.Layouts.Count > 0 ? gridLayout : null;                                      reader.ReadEndElement();                                  }                                  if (layout != null)                                  {                                      if (Children.Count > 0)                                      {                                          RowDefinitions.Add(NewRowDefinition(new GridLength(1' GridUnitType.Auto)' 0));                                          Children.Add(NewGridSplitter(Orientation));                                      }                                      RowDefinitions.Add(NewRowDefinition(new GridLength(height' GridUnitType.Star)' m_minGridSize.Height));                                      m_children.Add(layout);                                      Children.Add((FrameworkElement)layout);                                  }                              } while (reader.ReadToNextSibling("Row"));                          }                          break;                  }
Missing Default,Sce.Atf.Wpf.Docking,GridLayout,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\GridLayout.cs,WriteXml,The following switch statement is missing a default case: switch (Orientation)              {                  case Orientation.Horizontal:                      foreach (IXmlSerializable layout in m_children)                      {                          writer.WriteStartElement("Column");                          writer.WriteAttributeString("Width"' ColumnDefinitions[Grid.GetColumn((FrameworkElement)layout)].Width.Value.ToString());                          layout.WriteXml(writer);                          writer.WriteEndElement();                      }                      break;                  case Orientation.Vertical:                      foreach (IXmlSerializable layout in m_children)                      {                          writer.WriteStartElement("Row");                          writer.WriteAttributeString("Height"' RowDefinitions[Grid.GetRow((FrameworkElement)layout)].Height.Value.ToString());                          layout.WriteXml(writer);                          writer.WriteEndElement();                      }                      break;              }
Missing Default,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,ThumbDragDelta,The following switch statement is missing a default case: switch (DockSide)              {                  case Dock.Top:                      Height += e.VerticalChange;                      break;                  case Dock.Bottom:					                      Height -= e.VerticalChange;                      break;                  case Dock.Left:                      Width += e.HorizontalChange;                      break;                  case Dock.Right:                      Width -= e.HorizontalChange;                      break;              }
Missing Default,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.Me = ((Sce.Atf.Wpf.Docking.ResizablePopup)(target));              return;              case 3:              this.TopResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 4:              this.BottomResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 5:              this.LeftResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              case 6:              this.RightResizeThumb = ((System.Windows.Controls.Primitives.Thumb)(target));              return;              }
Missing Default,Sce.Atf.Wpf.Docking,ResizablePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\ResizablePopup.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 2:              eventSetter = new System.Windows.EventSetter();              eventSetter.Event = System.Windows.Controls.Primitives.Thumb.DragStartedEvent;                            #line 31 "..\..\..\Docking\ResizablePopup.xaml"              eventSetter.Handler = new System.Windows.Controls.Primitives.DragStartedEventHandler(this.ThumbDragStarted);                            #line default              #line hidden              ((System.Windows.Style)(target)).Setters.Add(eventSetter);              eventSetter = new System.Windows.EventSetter();              eventSetter.Event = System.Windows.Controls.Primitives.Thumb.DragDeltaEvent;                            #line 32 "..\..\..\Docking\ResizablePopup.xaml"              eventSetter.Handler = new System.Windows.Controls.Primitives.DragDeltaEventHandler(this.ThumbDragDelta);                            #line default              #line hidden              ((System.Windows.Style)(target)).Setters.Add(eventSetter);              eventSetter = new System.Windows.EventSetter();              eventSetter.Event = System.Windows.Controls.Primitives.Thumb.DragCompletedEvent;                            #line 33 "..\..\..\Docking\ResizablePopup.xaml"              eventSetter.Handler = new System.Windows.Controls.Primitives.DragCompletedEventHandler(this.ThumbDragCompleted);                            #line default              #line hidden              ((System.Windows.Style)(target)).Setters.Add(eventSetter);              break;              }
Missing Default,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,TabsPlacementPropertyChanged,The following switch statement is missing a default case: switch ((Dock)args.NewValue)              {                  case System.Windows.Controls.Dock.Top:                  case System.Windows.Controls.Dock.Bottom:                      sidePopup.Orientation = Orientation.Horizontal;                      break;                  case System.Windows.Controls.Dock.Right:                  case System.Windows.Controls.Dock.Left:                      sidePopup.Orientation = Orientation.Vertical;                      break;              }
Missing Default,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,Timer_Elapsed,The following switch statement is missing a default case: switch (TabsPlacement)                          {                              case System.Windows.Controls.Dock.Top:                                  pos.Y += ActualHeight;                                  break;                              case System.Windows.Controls.Dock.Bottom:                                  pos.Y -= PART_Popup.Height;                                  break;                              case System.Windows.Controls.Dock.Left:                                  pos.X += ActualWidth;                                  break;                              case System.Windows.Controls.Dock.Right:                                  pos.X -= PART_Popup.Width;                                  break;                          }
Missing Default,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,ShowPopup,The following switch statement is missing a default case: switch (Orientation)              {                  case Orientation.Horizontal:                      PART_Popup.MaxWidth = RenderSize.Width;                      PART_Popup.MaxHeight = 0.75 * Math.Min(Root.RenderSize.Height' System.Windows.SystemParameters.PrimaryScreenHeight);                      PART_Popup.Width = RenderSize.Width;                      PART_Popup.Height = Math.Min(settings.Size.Height + 25' PART_Popup.MaxHeight);                      break;                  case Orientation.Vertical:                      PART_Popup.MaxWidth = 0.75 * Math.Min(Root.RenderSize.Width' System.Windows.SystemParameters.PrimaryScreenWidth);                      PART_Popup.MaxHeight = RenderSize.Height;                      PART_Popup.Width = Math.Min(settings.Size.Width + 7' PART_Popup.MaxWidth);                      PART_Popup.Height = RenderSize.Height;                      break;              }
Missing Default,Sce.Atf.Wpf.Docking,SidePopup,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.Wpf\Docking\SidePopup.cs,UpdatePopupProperties,The following switch statement is missing a default case: switch (TabsPlacement)                  {                      case System.Windows.Controls.Dock.Top:                          PART_Popup.Placement = PlacementMode.Bottom;                          break;                      case System.Windows.Controls.Dock.Bottom:                          PART_Popup.Placement = PlacementMode.Top;                          break;                      case System.Windows.Controls.Dock.Left:                          PART_Popup.Placement = PlacementMode.Right;                          break;                      case System.Windows.Controls.Dock.Right:                          PART_Popup.Placement = PlacementMode.Left;                          break;                  }
