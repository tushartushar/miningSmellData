Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The method has 142 lines of code.
Complex Method,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,Cyclomatic complexity of the method is 35
Long Statement,Sce.Atf.Obj,Node,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\Node.cs,OnNodeSet,The length of the statement  "            m_boundingBox = boxValue.IsEmpty ? new Cached<Box>(CalculateBoundingBox) : new Cached<Box>(CalculateBoundingBox' boxValue); " is 123.
Long Statement,Sce.Atf.Obj,Mesh,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\Mesh.cs,OnNodeSet,The length of the statement  "            m_boundingBox = boxValue.IsEmpty ? new Cached<Box>(CalculateBoundingBox) : new Cached<Box>(CalculateBoundingBox' boxValue); " is 123.
Complex Conditional,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The conditional expression  "isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r')"  is complex.
Magic Number,Sce.Atf.Obj,Shader,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\Shader.cs,ParseAttributesForTexture,The following statement contains a magic number: info.Components == 4
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following statement contains a magic number: switch (buf[0])                      {                          case 'n': // newmtl name                              if (split.Length >= 2)                              {                                  string newMtl = split[1];                                    // Check for duplicate material                                  if (!Materials.ContainsKey(newMtl))                                  {                                      // Create a new material                                      currentMtl = new MaterialDef(newMtl);                                      Materials.Add(newMtl' currentMtl);                                      isValid = true;                                  }                                  else                                      isValid = false;                              }                              break;                            case 'K': // k* r g b                              if (isValid && split.Length == 4)                                  switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }                              else                                  throw new Exception(string.Format("Error parsing k{0} in file: {1}"' buf[1]' filename));                              break;                            case 'N': // Ns shininess                              if (isValid && split.Length == 2 && buf[1] == 's')                                  currentMtl.Shininess = float.Parse(split[1]);                              break;                            case 'm': // map_Kd texture                              if (isValid && split.Length == 2 && split[0].Equals("map_Kd"))                                  currentMtl.TextureName = split[1];                              break;                            case 'd': // d alpha                          case 'T': // Tf r g b or Tr alpha                              if (isValid && split.Length <= 4 && (buf[0] == 'd' || buf[1] == 'f' || buf[1] == 'r'))                                  currentMtl.Alpha = float.Parse(split[1]);                              break;                            default:                              break;                      }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,The following statement contains a magic number: array.SetAttribute(Schema.vertexArray_array.countAttribute' obj.m_normals.Count / 3);
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,The following statement contains a magic number: array.SetAttribute(Schema.vertexArray_array.strideAttribute' 3);
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,The following statement contains a magic number: array.SetAttribute(Schema.vertexArray_array.countAttribute' obj.m_texcoords.Count / 2);
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,The following statement contains a magic number: array.SetAttribute(Schema.vertexArray_array.strideAttribute' 2);
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,The following statement contains a magic number: array.SetAttribute(Schema.vertexArray_array.countAttribute' obj.m_positions.Count / 3);
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,PopulateDomNode,The following statement contains a magic number: array.SetAttribute(Schema.vertexArray_array.strideAttribute' 3);
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Magic Number,Sce.Atf.Obj,ObjFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\ObjFile.cs,Parse,The following statement contains a magic number: switch (buf[0])                  {                      case 'v': // vertex                          switch (buf[1])                          {                              case ' ':                              case '\t':                                  if (split.Length != 4) // v + 3 floats                                      throw new ApplicationException("Parse: Vertex split.Length is invalid");                                  m_positions.Add(float.Parse(split[1]));                                  m_positions.Add(float.Parse(split[2]));                                  m_positions.Add(float.Parse(split[3]));                                  break;                              case 'n':                                  if (split.Length != 4) // vn + 3 floats                                      throw new ApplicationException("Parse: Normal split.Length is invalid");                                  m_normals.Add(float.Parse(split[1]));                                  m_normals.Add(float.Parse(split[2]));                                  m_normals.Add(float.Parse(split[3]));                                  break;                              case 't':                                  if (split.Length != 3) // vt + 2 floats                                      throw new ApplicationException("Parse: TexCoord split.Length is invalid");                                  m_texcoords.Add(float.Parse(split[1]));                                  m_texcoords.Add(float.Parse(split[2]));                                  break;                              default:                                  break;                          }                          break;                        case 'f': // face                           if (split.Length < 4) // f v/vt/vn v/vt/vn v/vt/vn ...                              throw new ApplicationException("Parse: Face split.Length is invalid");                          m_currentFaceSet.Sizes.Add(split.Length - 1);                          for (int vi = 1; vi < split.Length; vi++)                          {                              string[] ptn = split[vi].Split('/');                              if (ptn.Length == 3) // v/vt/vn or v//vn                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[2]) - 1);                                  m_currentFaceSet.HasNormals = true;                                    if (!string.IsNullOrEmpty(ptn[1]))                                  {                                      m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                      m_currentFaceSet.HasTexCoords = true;                                  }                              }                              else if (ptn.Length == 2) // v/vt/                              {                                  m_currentFaceSet.Indices.Add(int.Parse(ptn[1]) - 1);                                  m_currentFaceSet.HasTexCoords = true;                              }                              m_currentFaceSet.Indices.Add(int.Parse(ptn[0]) - 1); // v or v// or v/vt/vn                          }                          break;                        case 'm': // material                          if (split.Length == 2)                          {                              var uri = new Uri(m_resolvedUri' split[1]);                              string fullPath = Uri.UnescapeDataString(uri.AbsolutePath);                                m_mtl = new MtlFile { Name = Path.GetFileName(fullPath) };                              m_mtl.Read(fullPath);                          }                            break;                        case 'g': // group                      case 'o': // object                          if (split.Length >= 2) // g + groupName + ...                          {                              string curMatName = m_currentFaceSet.MaterialName;                                // Find group' otherwise create new group                              if (!m_groups.TryGetValue(split[1]' out m_currentGroup))                              {                                  m_currentGroup = new Group { Name = split[1] };                                  m_groups.Add(m_currentGroup.Name' m_currentGroup);                                  m_currentFaceSet = new FaceSet(curMatName);                                  m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                              }                              // Group exists                              else                              {                                  // Find faceset with current material' otherwise create new faceset with current material                                  if (!m_currentGroup.FaceSets.TryGetValue(curMatName' out m_currentFaceSet))                                  {                                      m_currentFaceSet = new FaceSet(curMatName);                                      m_currentGroup.FaceSets.Add(curMatName' m_currentFaceSet);                                  }                              }                          }                          break;                        case 'u':                          if (split.Length != 2) // usemtl + mat name                              throw new ApplicationException("Parse: Usemtl split.Length is invalid");                          string matName = split[1];                          // Find material by name                          if (m_mtl.Materials.ContainsKey(matName))                          {                              // Find faceset with current material' otherwise create new faceset with current material                              if (!m_currentGroup.FaceSets.TryGetValue(matName' out m_currentFaceSet))                              {                                  m_currentFaceSet = new FaceSet(matName);                                  m_currentGroup.FaceSets.Add(matName' m_currentFaceSet);                              }                          }                          else                              Outputs.WriteLine(OutputMessageType.Warning' "Material not found: {0}"' matName);                          break;                        default:                          break;                  }
Missing Default,Sce.Atf.Obj,MtlFile,D:\research\architectureSmells\repos1\SonyWWS_ATF\Framework\Atf.Obj\ObjReader\MtlFile.cs,Read,The following switch statement is missing a default case: switch (buf[1])                                  {                                      case 'a': // ambient                                          currentMtl.Ambient = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 'd': // diffuse                                          currentMtl.Diffuse = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                      case 's': // specular                                          currentMtl.Specular = new Vec4F(                                              float.Parse(split[1])'                                              float.Parse(split[2])'                                              float.Parse(split[3])'                                              1.0f);                                          break;                                  }
