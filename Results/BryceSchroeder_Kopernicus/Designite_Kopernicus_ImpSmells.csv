Implementation smell,Namespace,Class,File,Method,Description
Long Method,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The method has 116 lines of code.
Long Method,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The method has 124 lines of code.
Long Method,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The method has 104 lines of code.
Long Method,ModLoader,LandControl,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The method has 105 lines of code.
Complex Method,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,Cyclomatic complexity of the method is 26
Complex Method,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,Cyclomatic complexity of the method is 12
Complex Method,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,Cyclomatic complexity of the method is 19
Complex Method,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,PostSpawnFixups,Cyclomatic complexity of the method is 11
Complex Method,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,OverrideNode,Cyclomatic complexity of the method is 10
Complex Method,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,Cyclomatic complexity of the method is 10
Complex Method,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,Cyclomatic complexity of the method is 25
Complex Method,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,FindMapSO,Cyclomatic complexity of the method is 10
Complex Method,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,RemoveModsOfType,Cyclomatic complexity of the method is 14
Complex Method,Configuration,Loader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Loader.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Configuration,Body,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Body.cs,PostApply,Cyclomatic complexity of the method is 10
Complex Method,Configuration,TemplateLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\TemplateLoader.cs,PostApply,Cyclomatic complexity of the method is 21
Complex Method,Configuration,ScaledVersionLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ScaledVersionLoader.cs,Apply,Cyclomatic complexity of the method is 15
Complex Method,Configuration,ScaledVersionLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ScaledVersionLoader.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,Cyclomatic complexity of the method is 9
Complex Method,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,MeshScatter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\MeshScatter.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,LandControl,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,Cyclomatic complexity of the method is 24
Complex Method,ModLoader,HeightColorMapNoise,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,HeightColorMap2,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,HeightColorMap,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,Cyclomatic complexity of the method is 8
Long Parameter List,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,UpdateScaledMesh,The method has 7 parameters.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "	FieldInfo[] fields = Injector.ModTypes.Where (t => t.Name == "CompatibilityChecker").Select (t => t.GetField ("_version"' BindingFlags.Static | BindingFlags.NonPublic)).Where (f => f != null).Where (f => f.FieldType == typeof(int)).ToArray (); " is 243.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "	Debug.Log (String.Format ("[CompatibilityChecker] Running checker version {0} from '{1}'"' _version' Assembly.GetExecutingAssembly ().GetName ().Name)); " is 152.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "	String[] incompatible = fields.Select (f => f.DeclaringType.GetMethod ("IsCompatible"' Type.EmptyTypes)).Where (m => m.IsStatic).Where (m => m.ReturnType == typeof(bool)).Where (m => { " is 184.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "			Debug.LogWarning (String.Format ("[CompatibilityChecker] Exception while invoking IsCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName ().Name' e)); " is 164.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "	String[] incompatibleUnity = fields.Select (f => f.DeclaringType.GetMethod ("IsUnityCompatible"' Type.EmptyTypes)).Where (m => m != null)// Mods without IsUnityCompatible() are assumed to be compatible. " is 202.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "			Debug.LogWarning (String.Format ("[CompatibilityChecker] Exception while invoking IsUnityCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName ().Name' e)); " is 169.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "	//    message += "WARNING: You are using 64-bit KSP on Windows. This version of KSP is known to cause crashes. It's highly recommended that you use either 32-bit KSP on Windows or switch to Linux."; " is 198.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "		message += ((message == String.Empty) ? "Some" : "\n\nAdditionally' some") + " installed mods may be incompatible with this version of Kerbal Space Program. Features may be broken or disabled. Please check for updates to the listed mods."; " is 239.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "			message += String.Format ("\n\nThese mods are incompatible with KSP {0}.{1}.{2}:\n\n"' Versioning.version_major' Versioning.version_minor' Versioning.Revision); " is 160.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "			Debug.LogWarning ("[CompatibilityChecker] Incompatible mods (Unity) detected: " + String.Join ("' "' incompatibleUnity)); " is 121.
Long Statement,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "		PopupDialog.SpawnPopupDialog (new Vector2 (0.5f' 0.5f)' new Vector2 (0.5f' 0.5f)' "CompatibilityChecker"' "Incompatible Mods Detected"' message' "OK"' true' UISkinManager.defaultSkin); " is 184.
Long Statement,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "			PSystemBody body = PSystemManager.Instance.systemPrefab.GetComponentsInChildren<PSystemBody> (true).First (b => b.name == name); " is 128.
Long Statement,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "			PSystemBody oldParent = PSystemManager.Instance.systemPrefab.GetComponentsInChildren<PSystemBody> (true).First (b => b.children.Contains (body)); " is 145.
Long Statement,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "				newParent = PSystemManager.Instance.systemPrefab.GetComponentsInChildren<PSystemBody> (true).First (b => b.name == patch.GetValue ("referenceBody")); " is 149.
Long Statement,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "		CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.transform.name == planetItem.label_planetName.text); " is 122.
Long Statement,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "		if (FindObjectsOfType<NameChanger> ().Count (n => n.oldName == planetItem.label_planetName.text) != 0 && !planetItem.label_planetName.name.EndsWith ("NAMECHANGER")) { " is 166.
Long Statement,Kopernicus,RnDFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RnDFixer.cs,AddPlanets,The length of the statement  "	FieldInfo list = typeof(RDArchivesController).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Skip (7).First (); " is 123.
Long Statement,Kopernicus,AtmosphereFixer,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\AtmosphereFixer.cs,Update,The length of the statement  "			//    Debug.Log("[Kopernicus]: ERROR AtmosphereFixer => Couldn't patch AtmosphereFromGround for " + afg.planet.bodyName + "!"); " is 127.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "	PlanetariumCamera.fetch.targets.Where (m => m.celestialBody != null && (m.celestialBody.Has ("barycenter") || m.celestialBody.Has ("notSelectable"))).ToList ().ForEach (map => PlanetariumCamera.fetch.targets.Remove (map)); " is 222.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "	Dictionary<String' KeyValuePair<CelestialBody' CelestialBody>> fixes = new Dictionary<String' KeyValuePair<CelestialBody' CelestialBody>> (); " is 141.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "			body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody); " is 149.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "				body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333); " is 149.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "				double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod; " is 134.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "				double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter); " is 131.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "		fixes [b.transform.name].Key.orbitingBodies = fixes [b.transform.name].Key.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList (); " is 139.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "			FieldInfo mode_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType.Name.EndsWith ("MenuDrawMode")); " is 165.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "			FieldInfo context_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType == typeof(MapContextMenu)); " is 163.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "			FieldInfo cast_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType == typeof(OrbitRenderer.OrbitCastHit)); " is 172.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "		body.afg.lightDot = Mathf.Clamp01 (Vector3.Dot (planet2cam' body.afg.mainCamera.transform.position - star_.transform.position) * body.afg.dawnFactor); " is 150.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The length of the statement  "		PlanetariumCamera.fetch.SetTarget (PlanetariumCamera.fetch.targets [(PlanetariumCamera.fetch.targets.IndexOf (PlanetariumCamera.fetch.target) + 1) % PlanetariumCamera.fetch.targets.Count]); " is 189.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The length of the statement  "		PlanetariumCamera.fetch.SetTarget (PlanetariumCamera.fetch.targets [(PlanetariumCamera.fetch.targets.IndexOf (PlanetariumCamera.fetch.target) - 1) + (((PlanetariumCamera.fetch.targets.IndexOf (PlanetariumCamera.fetch.target) - 1) >= 0) ? 0 : PlanetariumCamera.fetch.targets.Count)]); " is 283.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The length of the statement  "		munRotato.speed = (refRotato.speed / 542.494239600754f) * (float)moonCB.GetOrbit ().getOrbitalSpeedAtDistance (moonCB.GetOrbit ().semiMajorAxis); " is 145.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The length of the statement  "		menuMoon.transform.localPosition = new Vector3 (-5000f * (float)(moonCB.GetOrbit ().semiMajorAxis / 12000000.0)' 0f' 0f); " is 121.
Long Statement,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The length of the statement  "			surfaceObj.SetValue (cam' SurfaceObject.Create (initialTransform.gameObject' FlightGlobals.currentMainBody' 3' KFSMUpdateMode.FIXEDUPDATE)); " is 140.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,Awake,The length of the statement  "		string supported = CompatibilityChecker.version_major + "." + CompatibilityChecker.version_minor + "." + CompatibilityChecker.Revision; " is 135.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,Awake,The length of the statement  "		Debug.LogWarning ("[Kopernicus] Detected incompatible install.\nCurrent version of KSP: " + current + ".\nSupported version of KSP: " + supported + ".\nPlease wait' until Kopernicus gets updated to match your version of KSP."); " is 227.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,Awake,The length of the statement  "	// THIS IS WHERE THE MAGIC HAPPENS - OVERWRITE THE SYSTEM PREFAB SO KSP ACCEPTS OUR CUSTOM SOLAR SYSTEM AS IF IT WERE FROM SQUAD " is 128.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,Awake,The length of the statement  "	PSystemManager.Instance.systemPrefab = Parser.CreateObjectFromConfigNode<Loader> (kopernicus' "Kopernicus").systemPrefab; " is 121.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "		Logger.Default.Log ("Found Body: " + body.bodyName + ":" + body.flightGlobalsIndex + " -> SOI = " + body.sphereOfInfluence + "' Hill Sphere = " + body.hillSphere); " is 163.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "	// Fix the maximum viewing distance of the map view camera (get the farthest away something can be from the root object) " is 120.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "	// rootBody.children.Max(b => (b.orbitDriver != null) ? b.orbitDriver.orbit.semiMajorAxis * (1 + b.orbitDriver.orbit.eccentricity) : 0); " is 136.
Long Statement,Kopernicus,Injector,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "					maximumDistance = Math.Max (maximumDistance' body.orbitDriver.orbit.semiMajorAxis * (1d + body.orbitDriver.orbit.eccentricity)); " is 128.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The length of the statement  "	List<Vessel> spaceObjects = FlightGlobals.Vessels.Where (v => !v.DiscoveryInfo.HaveKnowledgeAbout (DiscoveryLevels.StateVectors) && v.DiscoveryInfo.GetSignalLife (Planetarium.GetUniversalTime ()) == 0).ToList (); " is 212.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The length of the statement  "	} else if (GameVariables.Instance.UnlockedSpaceObjectDiscovery (ScenarioUpgradeableFacilities.GetFacilityLevel (SpaceCenterFacility.TrackingStation))) { " is 152.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The length of the statement  "		int untrackedCount = FlightGlobals.Vessels.Count (v => !v.DiscoveryInfo.HaveKnowledgeAbout (DiscoveryLevels.StateVectors)) - spaceObjects.Count; " is 144.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "		IEnumerable<Location.AroundLoader> arounds = GetProbabilityList (asteroid.location.around' asteroid.location.around.Select (a => a.probability.value)); " is 151.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "		IEnumerable<Location.NearbyLoader> nearbys = GetProbabilityList (asteroid.location.nearby' asteroid.location.nearby.Select (a => a.probability.value)); " is 151.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "		IEnumerable<Location.FlybyLoader> flybys = GetProbabilityList (asteroid.location.flyby' asteroid.location.flyby.Select (a => a.probability.value)); " is 147.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "	UntrackedObjectClass size = (UntrackedObjectClass)((int)(asteroid.size.curve.Evaluate (Random.Range (0f' 1f)) * Enum.GetNames (typeof(UntrackedObjectClass)).Length)); " is 166.
Long Statement,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "	}' new ConfigNode ("ACTIONGROUPS")' ProtoVessel.CreateDiscoveryNode (DiscoveryLevels.Presence' size' lifetime' maxLifetime)); " is 125.
Long Statement,Kopernicus,StarComponent,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,SetAsActive,The length of the statement  "                foreach (ModuleDeployableSolarPanel sp in FlightGlobals.ActiveVessel.FindPartModulesImplementing<ModuleDeployableSolarPanel>())" is 127.
Long Statement,Kopernicus,StarComponent,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,SetAsActive,The length of the statement  "		foreach (ModuleDeployableRadiator rad in FlightGlobals.ActiveVessel.FindPartModulesImplementing<ModuleDeployableRadiator> ()) { " is 127.
Long Statement,Kopernicus,StarLightSwitcher,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,Start,The length of the statement  "	stars = PSystemManager.Instance.localBodies.SelectMany (body => body.scaledBody.GetComponentsInChildren<StarComponent> (true)).ToList (); " is 137.
Long Statement,Kopernicus,StarLightSwitcher,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,Update,The length of the statement  "	if (HighLogic.LoadedScene == GameScenes.TRACKSTATION || HighLogic.LoadedScene == GameScenes.FLIGHT || HighLogic.LoadedScene == GameScenes.SPACECENTER) { " is 152.
Long Statement,Kopernicus,StarLightSwitcher,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,HomeStar,The length of the statement  "	return PSystemManager.Instance.localBodies.First (body => body.flightGlobalsIndex == 0).scaledBody.GetComponent<StarComponent> (); " is 130.
Long Statement,Kopernicus,Logger,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Logger.cs,LogException,The length of the statement  "	loggerStream.WriteLine ("[LOG " + DateTime.Now.ToString ("HH:mm:ss") + "]: Exception Was Recorded: " + e.Message + "\n" + e.StackTrace); " is 136.
Long Statement,Kopernicus,Logger,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Logger.cs,LogException,The length of the statement  "		loggerStream.WriteLine ("[LOG " + DateTime.Now.ToString ("HH:mm:ss") + "]: Inner Exception Was Recorded: " + e.InnerException.Message + "\n" + e.InnerException.StackTrace); " is 172.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,CopyObjectFields,The length of the statement  "				Logger.Active.Log ("Copying \"" + field.Name + "\": " + (field.GetValue (destination) ?? "<NULL>") + " => " + (field.GetValue (source) ?? "<NULL>")); " is 149.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "		foreach (PQSMod mod in pqsVersion.GetComponentsInChildren<PQSMod> (true).Where (m => blacklist.Contains (m.GetType ()))) { " is 122.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "		IEnumerable<PQSMod> mods = pqsVersion.GetComponentsInChildren<PQSMod> (true).Where (m => m.modEnabled).OrderBy (m => m.order); " is 126.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "			flatten.GetType ().GetFields (BindingFlags.NonPublic | BindingFlags.Instance).Where (f => f.FieldType == typeof(Boolean)).First ().SetValue (flatten' true); " is 156.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "					bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000; " is 143.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "					//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff; " is 145.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "					bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F; " is 143.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "					bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f; " is 189.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "					bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00; " is 189.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "							map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "							map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "							map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "							map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,FindMapSO,The length of the statement  "			Logger.Active.Log ("MapSO grabber: Tried to grab " + url + " but type not found. VertexHeight type for reference = " + typeof(PQSMod_VertexHeightMap).FullName + ". Exception: " + e); " is 182.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,FindMapSO,The length of the statement  "			Logger.Active.Log ("MapSO grabber: Tried to grab " + url + " but could not find PQSMod of that type of the given name"); " is 120.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,CBTCheck,The length of the statement  "			PQSMod_CelestialBodyTransform cbt = body.pqsVersion.GetComponentsInChildren (typeof(PQSMod_CelestialBodyTransform)' true).FirstOrDefault () as PQSMod_CelestialBodyTransform; " is 173.
Long Statement,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,CreateReadable,The length of the statement  "	RenderTexture rt = RenderTexture.GetTemporary (original.width' original.height' 0' RenderTextureFormat.ARGB32' RenderTextureReadWrite.sRGB' 1); " is 143.
Long Statement,Configuration,OceanLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "	PQSMod_CelestialBodyTransform transform = generatedBody.pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (mod => mod.transform.parent == generatedBody.pqsVersion.transform); " is 212.
Long Statement,Configuration,OceanLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "			Debug.LogError ("MOD NULL: Loadertype " + mod.name + " with mod type " + testName + " and null? " + (loaderType == null) + (modType == null)); " is 142.
Long Statement,Configuration,OceanLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "		IEnumerable<PQSMod> existingMods = ocean.GetComponentsInChildren<PQSMod> (true).Where (m => m.GetType () == modType && m.transform.parent == ocean.transform); " is 158.
Long Statement,Configuration,OceanLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "			PQSMod existingMod = existingMods.FirstOrDefault (m => !patchedMods.Contains (m) && (mod.HasValue ("name") ? m.name == mod.GetValue ("name") : true)); " is 150.
Long Statement,Configuration,Loader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Loader.cs,RecursivelySortBodies,The length of the statement  "	body.children = body.children.OrderBy (b => b.orbitDriver.orbit.semiMajorAxis * (1 + b.orbitDriver.orbit.eccentricity)).ToList (); " is 130.
Long Statement,Configuration,Body,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Body.cs,PostApply,The length of the statement  "	if (!scaledVersion.deferMesh && (((template != null) && (Math.Abs (template.radius - generatedBody.celestialBody.Radius) > 1.0 || template.type != scaledVersion.type.value)) || template == null || debug.update)) { " is 213.
Long Statement,Configuration,Body,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Body.cs,PostApply,The length of the statement  "		Utility.UpdateScaledMesh (generatedBody.scaledVersion' generatedBody.pqsVersion' generatedBody.celestialBody' ScaledSpaceCacheDirectory' cacheFile' debug.exportMesh' scaledVersion.sphericalModel); " is 196.
Long Statement,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The length of the statement  "	Logger.Active.Log ("Via surface G' set gravParam to " + celestialBody.gravParameter + "' mass to " + celestialBody.Mass); " is 121.
Long Statement,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The length of the statement  "	Logger.Active.Log ("Via mass' set gravParam to " + celestialBody.gravParameter + "' surface G to " + celestialBody.GeeASL); " is 123.
Long Statement,Configuration,TemplateLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "			PQSMod_CelestialBodyTransform cbt = body.pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).First (); " is 123.
Long Statement,Configuration,TemplateLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "					//modsPerName.Add(name' Type.GetType(modName + "' Assembly-CSharp' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null")); " is 124.
Long Statement,Configuration,TemplateLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "				PQSMod[] allMods = body.pqsVersion.GetComponentsInChildren (kvP.Value' true).Select (m => m as PQSMod).Where (m => m.name == name).ToArray (); " is 142.
Long Statement,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "				body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0); " is 143.
Long Statement,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "				body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude)); " is 214.
Long Statement,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "			body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass)); " is 166.
Long Statement,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "				body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly; " is 151.
Long Statement,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "			Debug.LogError ("MOD NULL: Loadertype " + mod.name + " with mod type " + modType.Name + " and null? " + (loaderType == null) + (modType == null)); " is 146.
Long Statement,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "		IEnumerable<PQSMod> existingMods = pqsVersion.GetComponentsInChildren<PQSMod> (true).Where (m => m.GetType () == modType && m.transform.parent == pqsVersion.transform); " is 168.
Long Statement,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "			PQSMod existingMod = existingMods.FirstOrDefault (m => !patchedMods.Contains (m) && (!mod.HasValue ("name") || (mod.HasValue ("index") ? existingMods.ToList ().IndexOf (m) == Int32.Parse (mod.GetValue ("index")) && m.name == mod.GetValue ("name") : m.name == mod.GetValue ("name")))); " is 284.
Long Statement,ModLoader,LandControl,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "				loader = landClasses.Where (m => !patchedClasses.Contains (m.landClass) && (lcNode.HasValue ("name") ? m.landClass.landClassName == lcNode.GetValue ("name") : false)).FirstOrDefault (); " is 185.
Long Statement,ModLoader,LandControl,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "				loader = scatters.Where (m => !patchedScatters.Contains (m.scatter) && (scatterNode.HasValue ("name") ? m.scatter.scatterName == scatterNode.GetValue ("name") : false)).FirstOrDefault (); " is 187.
Long Statement,ModLoader,VertexPlanet,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,The length of the statement  "			loader = landClasses.Where (m => !patchedClasses.Contains (m.landClass) && ((lcNode.HasValue ("name") ? m.landClass.name == lcNode.GetValue ("name") : true) || (lcNode.HasValue ("index") ? landClasses.IndexOf (m).ToString () == lcNode.GetValue ("index") : false))).FirstOrDefault (); " is 283.
Long Statement,ModLoader,VoronoiCraters,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\VoronoiCraters.cs,Create,The length of the statement  "	PQSMod_VoronoiCraters clone = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' "Mun").pqsVersion.GetComponentsInChildren<PQSMod_VoronoiCraters> (true) [0] as PQSMod_VoronoiCraters; " is 196.
Long Statement,ModLoader,HeightColorMapNoise,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,The length of the statement  "				loader = landClasses.Where (m => !patchedClasses.Contains (m.landClassNoise) && ((lcNode.HasValue ("name") ? m.landClassNoise.name == lcNode.GetValue ("name") : false) || (lcNode.HasValue ("index") ? landClasses.IndexOf (m).ToString () == lcNode.GetValue ("index") : false))).FirstOrDefault (); " is 294.
Long Statement,ModLoader,HeightColorMapNoise,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,PostApply,The length of the statement  "	PQSMod_HeightColorMapNoise.LandClass[] landClassesArray = landClasses.Select (loader => loader.landClassNoise).ToArray (); " is 122.
Long Statement,ModLoader,HeightColorMap2,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,The length of the statement  "				loader = landClasses.Where (m => !patchedClasses.Contains (m.landClass2) && ((lcNode.HasValue ("name") ? m.landClass2.name == lcNode.GetValue ("name") : false) || (lcNode.HasValue ("index") ? landClasses.IndexOf (m).ToString () == lcNode.GetValue ("index") : false))).FirstOrDefault (); " is 286.
Long Statement,ModLoader,HeightColorMap,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,The length of the statement  "				loader = landClasses.Where (m => !patchedClasses.Contains (m.landClass) && ((lcNode.HasValue ("name") ? m.landClass.name == lcNode.GetValue ("name") : true) || (lcNode.HasValue ("index") ? landClasses.IndexOf (m).ToString () == lcNode.GetValue ("index") : false))).FirstOrDefault (); " is 283.
Complex Conditional,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The conditional expression  "camPQS != null && transform1 != null && transform2 != null && surfaceObj != null"  is complex.
Complex Conditional,Configuration,Body,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Body.cs,PostApply,The conditional expression  "!scaledVersion.deferMesh && (((template != null) && (Math.Abs (template.radius - generatedBody.celestialBody.Radius) > 1.0 || template.type != scaledVersion.type.value)) || template == null || debug.update)"  is complex.
Magic Number,Kopernicus,CompatibilityChecker,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\CompatibilityChecker.cs,IsWin64,The following statement contains a magic number: return (IntPtr.Size == 8) && (Environment.OSVersion.Platform == PlatformID.Win32NT);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies) {  	// More stars  	if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController> (true).Length > 0) {  		GameObject starObj = Instantiate (Sun.Instance.gameObject);  		KopernicusStar star_ = starObj.GetComponent<KopernicusStar> ();  		star_.sun = body;  		starObj.transform.parent = Sun.Instance.transform.parent;  		starObj.name = body.name;  		starObj.transform.localPosition = Vector3.zero;  		starObj.transform.localRotation = Quaternion.identity;  		starObj.transform.localScale = Vector3.one;  		starObj.transform.position = body.position;  		starObj.transform.rotation = body.rotation;  	}  	// Post spawn patcher  	if (body.Has ("orbitPatches")) {  		ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  		OrbitLoader loader = new OrbitLoader (body);  		Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  		body.orbitDriver.orbit = loader.orbit;  		CelestialBody oldRef = body.referenceBody;  		body.referenceBody.orbitingBodies.Remove (body);  		body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  		fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  		body.referenceBody.orbitingBodies.Add (body);  		body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  		body.orbit.Init ();  		body.orbitDriver.UpdateOrbit ();  		// Calculations  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  		if (body.solarRotationPeriod) {  			double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  			double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  			body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  			;  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies) {  	// More stars  	if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController> (true).Length > 0) {  		GameObject starObj = Instantiate (Sun.Instance.gameObject);  		KopernicusStar star_ = starObj.GetComponent<KopernicusStar> ();  		star_.sun = body;  		starObj.transform.parent = Sun.Instance.transform.parent;  		starObj.name = body.name;  		starObj.transform.localPosition = Vector3.zero;  		starObj.transform.localRotation = Quaternion.identity;  		starObj.transform.localScale = Vector3.one;  		starObj.transform.position = body.position;  		starObj.transform.rotation = body.rotation;  	}  	// Post spawn patcher  	if (body.Has ("orbitPatches")) {  		ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  		OrbitLoader loader = new OrbitLoader (body);  		Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  		body.orbitDriver.orbit = loader.orbit;  		CelestialBody oldRef = body.referenceBody;  		body.referenceBody.orbitingBodies.Remove (body);  		body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  		fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  		body.referenceBody.orbitingBodies.Add (body);  		body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  		body.orbit.Init ();  		body.orbitDriver.UpdateOrbit ();  		// Calculations  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  		if (body.solarRotationPeriod) {  			double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  			double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  			body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  			;  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies) {  	// More stars  	if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController> (true).Length > 0) {  		GameObject starObj = Instantiate (Sun.Instance.gameObject);  		KopernicusStar star_ = starObj.GetComponent<KopernicusStar> ();  		star_.sun = body;  		starObj.transform.parent = Sun.Instance.transform.parent;  		starObj.name = body.name;  		starObj.transform.localPosition = Vector3.zero;  		starObj.transform.localRotation = Quaternion.identity;  		starObj.transform.localScale = Vector3.one;  		starObj.transform.position = body.position;  		starObj.transform.rotation = body.rotation;  	}  	// Post spawn patcher  	if (body.Has ("orbitPatches")) {  		ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  		OrbitLoader loader = new OrbitLoader (body);  		Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  		body.orbitDriver.orbit = loader.orbit;  		CelestialBody oldRef = body.referenceBody;  		body.referenceBody.orbitingBodies.Remove (body);  		body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  		fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  		body.referenceBody.orbitingBodies.Add (body);  		body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  		body.orbit.Init ();  		body.orbitDriver.UpdateOrbit ();  		// Calculations  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  		if (body.solarRotationPeriod) {  			double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  			double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  			body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  			;  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies) {  	// More stars  	if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController> (true).Length > 0) {  		GameObject starObj = Instantiate (Sun.Instance.gameObject);  		KopernicusStar star_ = starObj.GetComponent<KopernicusStar> ();  		star_.sun = body;  		starObj.transform.parent = Sun.Instance.transform.parent;  		starObj.name = body.name;  		starObj.transform.localPosition = Vector3.zero;  		starObj.transform.localRotation = Quaternion.identity;  		starObj.transform.localScale = Vector3.one;  		starObj.transform.position = body.position;  		starObj.transform.rotation = body.rotation;  	}  	// Post spawn patcher  	if (body.Has ("orbitPatches")) {  		ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  		OrbitLoader loader = new OrbitLoader (body);  		Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  		body.orbitDriver.orbit = loader.orbit;  		CelestialBody oldRef = body.referenceBody;  		body.referenceBody.orbitingBodies.Remove (body);  		body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  		fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  		body.referenceBody.orbitingBodies.Add (body);  		body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  		body.orbit.Init ();  		body.orbitDriver.UpdateOrbit ();  		// Calculations  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  		if (body.solarRotationPeriod) {  			double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  			double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  			body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  			;  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (body.Has ("orbitPatches")) {  	ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  	OrbitLoader loader = new OrbitLoader (body);  	Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  	body.orbitDriver.orbit = loader.orbit;  	CelestialBody oldRef = body.referenceBody;  	body.referenceBody.orbitingBodies.Remove (body);  	body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  	fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  	body.referenceBody.orbitingBodies.Add (body);  	body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  	body.orbit.Init ();  	body.orbitDriver.UpdateOrbit ();  	// Calculations  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  	if (body.solarRotationPeriod) {  		double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  		double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  		body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  		;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (body.Has ("orbitPatches")) {  	ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  	OrbitLoader loader = new OrbitLoader (body);  	Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  	body.orbitDriver.orbit = loader.orbit;  	CelestialBody oldRef = body.referenceBody;  	body.referenceBody.orbitingBodies.Remove (body);  	body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  	fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  	body.referenceBody.orbitingBodies.Add (body);  	body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  	body.orbit.Init ();  	body.orbitDriver.UpdateOrbit ();  	// Calculations  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  	if (body.solarRotationPeriod) {  		double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  		double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  		body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  		;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (body.Has ("orbitPatches")) {  	ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  	OrbitLoader loader = new OrbitLoader (body);  	Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  	body.orbitDriver.orbit = loader.orbit;  	CelestialBody oldRef = body.referenceBody;  	body.referenceBody.orbitingBodies.Remove (body);  	body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  	fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  	body.referenceBody.orbitingBodies.Add (body);  	body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  	body.orbit.Init ();  	body.orbitDriver.UpdateOrbit ();  	// Calculations  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  	if (body.solarRotationPeriod) {  		double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  		double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  		body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  		;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (body.Has ("orbitPatches")) {  	ConfigNode orbitNode = body.Get<ConfigNode> ("orbitPatches");  	OrbitLoader loader = new OrbitLoader (body);  	Parser.LoadObjectFromConfigurationNode (loader' orbitNode' "Kopernicus");  	body.orbitDriver.orbit = loader.orbit;  	CelestialBody oldRef = body.referenceBody;  	body.referenceBody.orbitingBodies.Remove (body);  	body.orbit.referenceBody = body.orbitDriver.referenceBody = PSystemManager.Instance.localBodies.Find (b => b.transform.name == loader.referenceBody);  	fixes.Add (body.transform.name' new KeyValuePair<CelestialBody' CelestialBody> (oldRef' body.referenceBody));  	body.referenceBody.orbitingBodies.Add (body);  	body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy (cb => cb.orbit.semiMajorAxis).ToList ();  	body.orbit.Init ();  	body.orbitDriver.UpdateOrbit ();  	// Calculations  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  	if (body.solarRotationPeriod) {  		double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  		double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  		body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  		;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (!body.Has ("sphereOfInfluence"))  	body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (!body.Has ("hillSphere"))  	body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (body.solarRotationPeriod) {  	double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  	double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  	body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  	;  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: if (body.solarRotationPeriod) {  	double rotPeriod = Utility.FindBody (PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;  	double num1 = Math.PI * 2 * Math.Sqrt (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);  	body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod);  	;  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (MapView.MapIsEnabled) {  	if (fields == null) {  		FieldInfo mode_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType.Name.EndsWith ("MenuDrawMode"));  		FieldInfo context_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType == typeof(MapContextMenu));  		FieldInfo cast_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType == typeof(OrbitRenderer.OrbitCastHit));  		fields = new FieldInfo[] {  			mode_f'  			context_f'  			cast_f  		};  	}  	if (FlightGlobals.ActiveVessel != null) {  		OrbitTargeter targeter = FlightGlobals.ActiveVessel.orbitTargeter;  		if (targeter == null)  			return;  		Int32 mode = (Int32)fields [0].GetValue (targeter);  		if (mode == 2) {  			OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields [2].GetValue (targeter);  			CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.name == cast.or.discoveryInfo.name.Value);  			if (body == null)  				return;  			if (body.Has ("barycenter") || body.Has ("notSelectable")) {  				if (cast.driver.Targetable == null)  					return;  				MapContextMenu context = MapContextMenu.Create (body.name' new Rect (0.5f' 0.5f' 300f' 50f)' cast' () => {  					fields [0].SetValue (targeter' 0);  					fields [1].SetValue (targeter' null);  				}' new SetAsTarget (cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));  				fields [1].SetValue (targeter' context);  			}  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (MapView.MapIsEnabled) {  	if (fields == null) {  		FieldInfo mode_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType.Name.EndsWith ("MenuDrawMode"));  		FieldInfo context_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType == typeof(MapContextMenu));  		FieldInfo cast_f = typeof(OrbitTargeter).GetFields (BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault (f => f.FieldType == typeof(OrbitRenderer.OrbitCastHit));  		fields = new FieldInfo[] {  			mode_f'  			context_f'  			cast_f  		};  	}  	if (FlightGlobals.ActiveVessel != null) {  		OrbitTargeter targeter = FlightGlobals.ActiveVessel.orbitTargeter;  		if (targeter == null)  			return;  		Int32 mode = (Int32)fields [0].GetValue (targeter);  		if (mode == 2) {  			OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields [2].GetValue (targeter);  			CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.name == cast.or.discoveryInfo.name.Value);  			if (body == null)  				return;  			if (body.Has ("barycenter") || body.Has ("notSelectable")) {  				if (cast.driver.Targetable == null)  					return;  				MapContextMenu context = MapContextMenu.Create (body.name' new Rect (0.5f' 0.5f' 300f' 50f)' cast' () => {  					fields [0].SetValue (targeter' 0);  					fields [1].SetValue (targeter' null);  				}' new SetAsTarget (cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));  				fields [1].SetValue (targeter' context);  			}  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (FlightGlobals.ActiveVessel != null) {  	OrbitTargeter targeter = FlightGlobals.ActiveVessel.orbitTargeter;  	if (targeter == null)  		return;  	Int32 mode = (Int32)fields [0].GetValue (targeter);  	if (mode == 2) {  		OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields [2].GetValue (targeter);  		CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.name == cast.or.discoveryInfo.name.Value);  		if (body == null)  			return;  		if (body.Has ("barycenter") || body.Has ("notSelectable")) {  			if (cast.driver.Targetable == null)  				return;  			MapContextMenu context = MapContextMenu.Create (body.name' new Rect (0.5f' 0.5f' 300f' 50f)' cast' () => {  				fields [0].SetValue (targeter' 0);  				fields [1].SetValue (targeter' null);  			}' new SetAsTarget (cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));  			fields [1].SetValue (targeter' context);  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (FlightGlobals.ActiveVessel != null) {  	OrbitTargeter targeter = FlightGlobals.ActiveVessel.orbitTargeter;  	if (targeter == null)  		return;  	Int32 mode = (Int32)fields [0].GetValue (targeter);  	if (mode == 2) {  		OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields [2].GetValue (targeter);  		CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.name == cast.or.discoveryInfo.name.Value);  		if (body == null)  			return;  		if (body.Has ("barycenter") || body.Has ("notSelectable")) {  			if (cast.driver.Targetable == null)  				return;  			MapContextMenu context = MapContextMenu.Create (body.name' new Rect (0.5f' 0.5f' 300f' 50f)' cast' () => {  				fields [0].SetValue (targeter' 0);  				fields [1].SetValue (targeter' null);  			}' new SetAsTarget (cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));  			fields [1].SetValue (targeter' context);  		}  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (mode == 2) {  	OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields [2].GetValue (targeter);  	CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.name == cast.or.discoveryInfo.name.Value);  	if (body == null)  		return;  	if (body.Has ("barycenter") || body.Has ("notSelectable")) {  		if (cast.driver.Targetable == null)  			return;  		MapContextMenu context = MapContextMenu.Create (body.name' new Rect (0.5f' 0.5f' 300f' 50f)' cast' () => {  			fields [0].SetValue (targeter' 0);  			fields [1].SetValue (targeter' null);  		}' new SetAsTarget (cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));  		fields [1].SetValue (targeter' context);  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (mode == 2) {  	OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields [2].GetValue (targeter);  	CelestialBody body = PSystemManager.Instance.localBodies.Find (b => b.name == cast.or.discoveryInfo.name.Value);  	if (body == null)  		return;  	if (body.Has ("barycenter") || body.Has ("notSelectable")) {  		if (cast.driver.Targetable == null)  			return;  		MapContextMenu context = MapContextMenu.Create (body.name' new Rect (0.5f' 0.5f' 300f' 50f)' cast' () => {  			fields [0].SetValue (targeter' 0);  			fields [1].SetValue (targeter' null);  		}' new SetAsTarget (cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));  		fields [1].SetValue (targeter' context);  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The following statement contains a magic number: if (HighLogic.LoadedScene == GameScenes.TRACKSTATION || MapView.MapIsEnabled) {  	MapObject target = PlanetariumCamera.fetch.target;  	if (target.celestialBody != null) {  		CelestialBody body = target.celestialBody;  		if (body.Has ("maxZoom"))  			PlanetariumCamera.fetch.minDistance = body.Get<float> ("maxZoom");  		else  			PlanetariumCamera.fetch.minDistance = 10;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The following statement contains a magic number: if (target.celestialBody != null) {  	CelestialBody body = target.celestialBody;  	if (body.Has ("maxZoom"))  		PlanetariumCamera.fetch.minDistance = body.Get<float> ("maxZoom");  	else  		PlanetariumCamera.fetch.minDistance = 10;  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The following statement contains a magic number: if (body.Has ("maxZoom"))  	PlanetariumCamera.fetch.minDistance = body.Get<float> ("maxZoom");  else  	PlanetariumCamera.fetch.minDistance = 10;  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The following statement contains a magic number: PlanetariumCamera.fetch.minDistance = 10;  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: if (logic.areas.Length < 2) {  	Debug.LogError ("[Kopernicus] Not enough bodies");  	return;  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: for (int i = 0; i < planetCB.scaledBody.transform.childCount; i++) {  	// Just clone everything  	Transform t = planetCB.scaledBody.transform.GetChild (i);  	if (t.gameObject.GetComponent<AtmosphereFromGround> ())  		continue;  	GameObject newT = Instantiate (t.gameObject) as GameObject;  	newT.transform.parent = menuPlanet.transform;  	newT.layer = 0;  	newT.transform.localPosition = Vector3.zero;  	newT.transform.localRotation = Quaternion.identity;  	newT.transform.localScale = (float)(1008 / planetCB.Radius) * Vector3.one;  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: newT.transform.localScale = (float)(1008 / planetCB.Radius) * Vector3.one;  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: foreach (PSystemBody moon in planet.children) {  	// Grab the CeletialBody of the moon  	CelestialBody moonCB = PSystemManager.Instance.localBodies.Find (b => b.GetTransform ().name == moon.name);  	// Create the Rotation-Transforms  	GameObject menuMoonPivot = new GameObject (moon.name + " Pivot");  	menuMoonPivot.gameObject.layer = 0;  	menuMoonPivot.transform.position = menuPlanet.transform.position;  	// Still funny...  	Rotato munRotato = menuMoonPivot.AddComponent<Rotato> ();  	Rotato refRotato = mun.GetComponent<Rotato> ();  	munRotato.speed = (refRotato.speed / 542.494239600754f) * (float)moonCB.GetOrbit ().getOrbitalSpeedAtDistance (moonCB.GetOrbit ().semiMajorAxis);  	// Clone the scaledVersion and attach it to the pivot  	GameObject menuMoon = Instantiate (moon.scaledVersion) as GameObject;  	menuMoon.transform.parent = menuMoonPivot.transform;  	// Move and scale the menuMoon correctly  	menuMoon.transform.localPosition = new Vector3 (-5000f * (float)(moonCB.GetOrbit ().semiMajorAxis / 12000000.0)' 0f' 0f);  	menuMoon.transform.localScale *= 7f;  	// Destroy stuff  	DestroyImmediate (menuMoon.GetComponent<ScaledSpaceFader> ());  	DestroyImmediate (menuMoon.GetComponent<SphereCollider> ());  	DestroyImmediate (menuMoon.GetComponentInChildren<AtmosphereFromGround> ());  	DestroyImmediate (menuMoon.GetComponent<MaterialSetDirection> ());  	// More Rotato  	Rotato moonRotato = menuMoon.AddComponent<Rotato> ();  	moonRotato.speed = -0.005f / (float)(moonCB.rotationPeriod / 400.0);  	// Apply orbital stuff  	menuMoon.transform.Rotate (0f' (float)moonCB.orbitDriver.orbit.LAN' 0f);  	menuMoon.transform.Rotate (0f' 0f' (float)moonCB.orbitDriver.orbit.inclination);  	menuMoon.transform.Rotate (0f' (float)moonCB.orbitDriver.orbit.argumentOfPeriapsis' 0f);  	// And set the layer to 0  	menuMoon.layer = 0;  	// Patch the material' because Mods like TextureReplacer run post spawn' and we'd overwrite their changes  	menuMoon.GetComponent<Renderer> ().sharedMaterial = moonCB.scaledBody.GetComponent<Renderer> ().sharedMaterial;  	// Copy EVE 7.4 clouds / Rings  	for (int i = 0; i < moonCB.scaledBody.transform.childCount; i++) {  		Transform t = moonCB.scaledBody.transform.GetChild (i);  		if (t.gameObject.GetComponent<AtmosphereFromGround> ())  			continue;  		GameObject newT = Instantiate (t.gameObject) as GameObject;  		newT.transform.parent = menuMoon.transform;  		newT.layer = 0;  		newT.transform.localPosition = Vector3.zero;  		newT.transform.localRotation = Quaternion.identity;  		newT.transform.localScale = (float)(1008 / moonCB.Radius) * Vector3.one;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: foreach (PSystemBody moon in planet.children) {  	// Grab the CeletialBody of the moon  	CelestialBody moonCB = PSystemManager.Instance.localBodies.Find (b => b.GetTransform ().name == moon.name);  	// Create the Rotation-Transforms  	GameObject menuMoonPivot = new GameObject (moon.name + " Pivot");  	menuMoonPivot.gameObject.layer = 0;  	menuMoonPivot.transform.position = menuPlanet.transform.position;  	// Still funny...  	Rotato munRotato = menuMoonPivot.AddComponent<Rotato> ();  	Rotato refRotato = mun.GetComponent<Rotato> ();  	munRotato.speed = (refRotato.speed / 542.494239600754f) * (float)moonCB.GetOrbit ().getOrbitalSpeedAtDistance (moonCB.GetOrbit ().semiMajorAxis);  	// Clone the scaledVersion and attach it to the pivot  	GameObject menuMoon = Instantiate (moon.scaledVersion) as GameObject;  	menuMoon.transform.parent = menuMoonPivot.transform;  	// Move and scale the menuMoon correctly  	menuMoon.transform.localPosition = new Vector3 (-5000f * (float)(moonCB.GetOrbit ().semiMajorAxis / 12000000.0)' 0f' 0f);  	menuMoon.transform.localScale *= 7f;  	// Destroy stuff  	DestroyImmediate (menuMoon.GetComponent<ScaledSpaceFader> ());  	DestroyImmediate (menuMoon.GetComponent<SphereCollider> ());  	DestroyImmediate (menuMoon.GetComponentInChildren<AtmosphereFromGround> ());  	DestroyImmediate (menuMoon.GetComponent<MaterialSetDirection> ());  	// More Rotato  	Rotato moonRotato = menuMoon.AddComponent<Rotato> ();  	moonRotato.speed = -0.005f / (float)(moonCB.rotationPeriod / 400.0);  	// Apply orbital stuff  	menuMoon.transform.Rotate (0f' (float)moonCB.orbitDriver.orbit.LAN' 0f);  	menuMoon.transform.Rotate (0f' 0f' (float)moonCB.orbitDriver.orbit.inclination);  	menuMoon.transform.Rotate (0f' (float)moonCB.orbitDriver.orbit.argumentOfPeriapsis' 0f);  	// And set the layer to 0  	menuMoon.layer = 0;  	// Patch the material' because Mods like TextureReplacer run post spawn' and we'd overwrite their changes  	menuMoon.GetComponent<Renderer> ().sharedMaterial = moonCB.scaledBody.GetComponent<Renderer> ().sharedMaterial;  	// Copy EVE 7.4 clouds / Rings  	for (int i = 0; i < moonCB.scaledBody.transform.childCount; i++) {  		Transform t = moonCB.scaledBody.transform.GetChild (i);  		if (t.gameObject.GetComponent<AtmosphereFromGround> ())  			continue;  		GameObject newT = Instantiate (t.gameObject) as GameObject;  		newT.transform.parent = menuMoon.transform;  		newT.layer = 0;  		newT.transform.localPosition = Vector3.zero;  		newT.transform.localRotation = Quaternion.identity;  		newT.transform.localScale = (float)(1008 / moonCB.Radius) * Vector3.one;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: foreach (PSystemBody moon in planet.children) {  	// Grab the CeletialBody of the moon  	CelestialBody moonCB = PSystemManager.Instance.localBodies.Find (b => b.GetTransform ().name == moon.name);  	// Create the Rotation-Transforms  	GameObject menuMoonPivot = new GameObject (moon.name + " Pivot");  	menuMoonPivot.gameObject.layer = 0;  	menuMoonPivot.transform.position = menuPlanet.transform.position;  	// Still funny...  	Rotato munRotato = menuMoonPivot.AddComponent<Rotato> ();  	Rotato refRotato = mun.GetComponent<Rotato> ();  	munRotato.speed = (refRotato.speed / 542.494239600754f) * (float)moonCB.GetOrbit ().getOrbitalSpeedAtDistance (moonCB.GetOrbit ().semiMajorAxis);  	// Clone the scaledVersion and attach it to the pivot  	GameObject menuMoon = Instantiate (moon.scaledVersion) as GameObject;  	menuMoon.transform.parent = menuMoonPivot.transform;  	// Move and scale the menuMoon correctly  	menuMoon.transform.localPosition = new Vector3 (-5000f * (float)(moonCB.GetOrbit ().semiMajorAxis / 12000000.0)' 0f' 0f);  	menuMoon.transform.localScale *= 7f;  	// Destroy stuff  	DestroyImmediate (menuMoon.GetComponent<ScaledSpaceFader> ());  	DestroyImmediate (menuMoon.GetComponent<SphereCollider> ());  	DestroyImmediate (menuMoon.GetComponentInChildren<AtmosphereFromGround> ());  	DestroyImmediate (menuMoon.GetComponent<MaterialSetDirection> ());  	// More Rotato  	Rotato moonRotato = menuMoon.AddComponent<Rotato> ();  	moonRotato.speed = -0.005f / (float)(moonCB.rotationPeriod / 400.0);  	// Apply orbital stuff  	menuMoon.transform.Rotate (0f' (float)moonCB.orbitDriver.orbit.LAN' 0f);  	menuMoon.transform.Rotate (0f' 0f' (float)moonCB.orbitDriver.orbit.inclination);  	menuMoon.transform.Rotate (0f' (float)moonCB.orbitDriver.orbit.argumentOfPeriapsis' 0f);  	// And set the layer to 0  	menuMoon.layer = 0;  	// Patch the material' because Mods like TextureReplacer run post spawn' and we'd overwrite their changes  	menuMoon.GetComponent<Renderer> ().sharedMaterial = moonCB.scaledBody.GetComponent<Renderer> ().sharedMaterial;  	// Copy EVE 7.4 clouds / Rings  	for (int i = 0; i < moonCB.scaledBody.transform.childCount; i++) {  		Transform t = moonCB.scaledBody.transform.GetChild (i);  		if (t.gameObject.GetComponent<AtmosphereFromGround> ())  			continue;  		GameObject newT = Instantiate (t.gameObject) as GameObject;  		newT.transform.parent = menuMoon.transform;  		newT.layer = 0;  		newT.transform.localPosition = Vector3.zero;  		newT.transform.localRotation = Quaternion.identity;  		newT.transform.localScale = (float)(1008 / moonCB.Radius) * Vector3.one;  	}  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: menuMoon.transform.localPosition = new Vector3 (-5000f * (float)(moonCB.GetOrbit ().semiMajorAxis / 12000000.0)' 0f' 0f);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: moonRotato.speed = -0.005f / (float)(moonCB.rotationPeriod / 400.0);  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: for (int i = 0; i < moonCB.scaledBody.transform.childCount; i++) {  	Transform t = moonCB.scaledBody.transform.GetChild (i);  	if (t.gameObject.GetComponent<AtmosphereFromGround> ())  		continue;  	GameObject newT = Instantiate (t.gameObject) as GameObject;  	newT.transform.parent = menuMoon.transform;  	newT.layer = 0;  	newT.transform.localPosition = Vector3.zero;  	newT.transform.localRotation = Quaternion.identity;  	newT.transform.localScale = (float)(1008 / moonCB.Radius) * Vector3.one;  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: newT.transform.localScale = (float)(1008 / moonCB.Radius) * Vector3.one;  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The following statement contains a magic number: foreach (SpaceCenterCamera2 cam in Resources.FindObjectsOfTypeAll<SpaceCenterCamera2> ()) {  	if (ksc.repositionToSphere || ksc.repositionToSphereSurface) {  		double normalHeight = body.pqsController.GetSurfaceHeight ((Vector3d)ksc.repositionRadial.normalized) - body.Radius;  		if (ksc.repositionToSphereSurface) {  			normalHeight += ksc.repositionRadiusOffset;  		}  		cam.altitudeInitial = 0f - (float)normalHeight;  	} else {  		cam.altitudeInitial = 0f - (float)ksc.repositionRadiusOffset;  	}  	// re-implement cam.Start()  	// fields  	Type camType = cam.GetType ();  	FieldInfo camPQS = null;  	FieldInfo transform1 = null;  	FieldInfo transform2 = null;  	FieldInfo surfaceObj = null;  	// get fields  	FieldInfo[] fields = camType.GetFields (BindingFlags.NonPublic | BindingFlags.Instance);  	for (int i = 0; i < fields.Length; ++i) {  		FieldInfo fi = fields [i];  		if (fi.FieldType == typeof(PQS))  			camPQS = fi;  		else if (fi.FieldType == typeof(Transform) && transform1 == null)  			transform1 = fi;  		else if (fi.FieldType == typeof(Transform) && transform2 == null)  			transform2 = fi;  		else if (fi.FieldType == typeof(SurfaceObject))  			surfaceObj = fi;  	}  	if (camPQS != null && transform1 != null && transform2 != null && surfaceObj != null) {  		camPQS.SetValue (cam' body.pqsController);  		Transform initialTransform = body.pqsController.transform.Find (cam.initialPositionTransformName);  		if (initialTransform != null) {  			transform1.SetValue (cam' initialTransform);  			cam.transform.NestToParent (initialTransform);  		} else {  			Debug.Log ("[Kopernicus] SSC2 can't find initial transform!");  			Transform initialTrfOrig = transform1.GetValue (cam) as Transform;  			if (initialTrfOrig != null)  				cam.transform.NestToParent (initialTrfOrig);  			else  				Debug.Log ("[Kopernicus] SSC2 own initial transform null!");  		}  		Transform camTransform = transform2.GetValue (cam) as Transform;  		if (camTransform != null) {  			camTransform.NestToParent (cam.transform);  			if (FlightCamera.fetch != null && FlightCamera.fetch.transform != null) {  				FlightCamera.fetch.transform.NestToParent (camTransform);  			}  			if (LocalSpace.fetch != null && LocalSpace.fetch.transform != null) {  				LocalSpace.fetch.transform.position = camTransform.position;  			}  		} else  			Debug.Log ("[Kopernicus] SSC2 cam transform null!");  		cam.ResetCamera ();  		SurfaceObject so = surfaceObj.GetValue (cam) as SurfaceObject;  		if (so != null) {  			so.ReturnToParent ();  			DestroyImmediate (so);  		} else  			Debug.Log ("[Kopernicus] SSC2 surfaceObject is null!");  		surfaceObj.SetValue (cam' SurfaceObject.Create (initialTransform.gameObject' FlightGlobals.currentMainBody' 3' KFSMUpdateMode.FIXEDUPDATE));  		Debug.Log ("[Kopernicus] Fixed SpaceCenterCamera");  	} else  		Debug.Log ("[Kopernicus] ERROR fixing space center camera' could not find some fields");  }  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The following statement contains a magic number: if (camPQS != null && transform1 != null && transform2 != null && surfaceObj != null) {  	camPQS.SetValue (cam' body.pqsController);  	Transform initialTransform = body.pqsController.transform.Find (cam.initialPositionTransformName);  	if (initialTransform != null) {  		transform1.SetValue (cam' initialTransform);  		cam.transform.NestToParent (initialTransform);  	} else {  		Debug.Log ("[Kopernicus] SSC2 can't find initial transform!");  		Transform initialTrfOrig = transform1.GetValue (cam) as Transform;  		if (initialTrfOrig != null)  			cam.transform.NestToParent (initialTrfOrig);  		else  			Debug.Log ("[Kopernicus] SSC2 own initial transform null!");  	}  	Transform camTransform = transform2.GetValue (cam) as Transform;  	if (camTransform != null) {  		camTransform.NestToParent (cam.transform);  		if (FlightCamera.fetch != null && FlightCamera.fetch.transform != null) {  			FlightCamera.fetch.transform.NestToParent (camTransform);  		}  		if (LocalSpace.fetch != null && LocalSpace.fetch.transform != null) {  			LocalSpace.fetch.transform.position = camTransform.position;  		}  	} else  		Debug.Log ("[Kopernicus] SSC2 cam transform null!");  	cam.ResetCamera ();  	SurfaceObject so = surfaceObj.GetValue (cam) as SurfaceObject;  	if (so != null) {  		so.ReturnToParent ();  		DestroyImmediate (so);  	} else  		Debug.Log ("[Kopernicus] SSC2 surfaceObject is null!");  	surfaceObj.SetValue (cam' SurfaceObject.Create (initialTransform.gameObject' FlightGlobals.currentMainBody' 3' KFSMUpdateMode.FIXEDUPDATE));  	Debug.Log ("[Kopernicus] Fixed SpaceCenterCamera");  } else  	Debug.Log ("[Kopernicus] ERROR fixing space center camera' could not find some fields");  
Magic Number,Kopernicus,RuntimeUtility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The following statement contains a magic number: surfaceObj.SetValue (cam' SurfaceObject.Create (initialTransform.gameObject' FlightGlobals.currentMainBody' 3' KFSMUpdateMode.FIXEDUPDATE));  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The following statement contains a magic number: if (spaceObjects.Any ()) {  	Vessel vessel = spaceObjects.First ();  	Debug.Log ("[Kopernicus] " + vessel.vesselName + " has been untracked for too long and is now lost.");  	vessel.Die ();  } else if (GameVariables.Instance.UnlockedSpaceObjectDiscovery (ScenarioUpgradeableFacilities.GetFacilityLevel (SpaceCenterFacility.TrackingStation))) {  	int untrackedCount = FlightGlobals.Vessels.Count (v => !v.DiscoveryInfo.HaveKnowledgeAbout (DiscoveryLevels.StateVectors)) - spaceObjects.Count;  	int max = Mathf.Max (untrackedCount' limit);  	if (max > untrackedCount) {  		if (Random.Range (0' 100) < asteroid.probability) {  			uint seed = (uint)Random.Range (0' Int32.MaxValue);  			Random.InitState ((int)seed);  			SpawnAsteroid (asteroid' seed);  		} else {  			Debug.Log ("[Kopernicus] No new objects this time. (Probablility is " + asteroid.probability.value + "%)");  		}  	}  }  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The following statement contains a magic number: if (GameVariables.Instance.UnlockedSpaceObjectDiscovery (ScenarioUpgradeableFacilities.GetFacilityLevel (SpaceCenterFacility.TrackingStation))) {  	int untrackedCount = FlightGlobals.Vessels.Count (v => !v.DiscoveryInfo.HaveKnowledgeAbout (DiscoveryLevels.StateVectors)) - spaceObjects.Count;  	int max = Mathf.Max (untrackedCount' limit);  	if (max > untrackedCount) {  		if (Random.Range (0' 100) < asteroid.probability) {  			uint seed = (uint)Random.Range (0' Int32.MaxValue);  			Random.InitState ((int)seed);  			SpawnAsteroid (asteroid' seed);  		} else {  			Debug.Log ("[Kopernicus] No new objects this time. (Probablility is " + asteroid.probability.value + "%)");  		}  	}  }  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The following statement contains a magic number: if (max > untrackedCount) {  	if (Random.Range (0' 100) < asteroid.probability) {  		uint seed = (uint)Random.Range (0' Int32.MaxValue);  		Random.InitState ((int)seed);  		SpawnAsteroid (asteroid' seed);  	} else {  		Debug.Log ("[Kopernicus] No new objects this time. (Probablility is " + asteroid.probability.value + "%)");  	}  }  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The following statement contains a magic number: if (Random.Range (0' 100) < asteroid.probability) {  	uint seed = (uint)Random.Range (0' Int32.MaxValue);  	Random.InitState ((int)seed);  	SpawnAsteroid (asteroid' seed);  } else {  	Debug.Log ("[Kopernicus] No new objects this time. (Probablility is " + asteroid.probability.value + "%)");  }  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The following statement contains a magic number: if (type == 0 && asteroid.location.around.Count != 0) {  	// Around  	IEnumerable<Location.AroundLoader> arounds = GetProbabilityList (asteroid.location.around' asteroid.location.around.Select (a => a.probability.value));  	Location.AroundLoader around = arounds.ElementAt (Random.Range (0' arounds.Count ()));  	body = PSystemManager.Instance.localBodies.Find (b => b.name == around.body);  	if (!body)  		return;  	if (around.reached && !ReachedBody (body))  		return;  	orbit = new Orbit ();  	orbit.referenceBody = body;  	orbit.eccentricity = around.eccentricity;  	orbit.semiMajorAxis = around.semiMajorAxis;  	orbit.inclination = around.inclination;  	orbit.LAN = around.longitudeOfAscendingNode;  	orbit.argumentOfPeriapsis = around.argumentOfPeriapsis;  	orbit.meanAnomalyAtEpoch = around.meanAnomalyAtEpoch;  	orbit.epoch = around.epoch;  	orbit.Init ();  } else if (type == 1 && asteroid.location.nearby.Count != 0) {  	// Nearby  	IEnumerable<Location.NearbyLoader> nearbys = GetProbabilityList (asteroid.location.nearby' asteroid.location.nearby.Select (a => a.probability.value));  	Location.NearbyLoader nearby = nearbys.ElementAt (Random.Range (0' nearbys.Count ()));  	body = PSystemManager.Instance.localBodies.Find (b => b.name == nearby.body);  	if (!body)  		return;  	if (nearby.reached && !ReachedBody (body))  		return;  	orbit = new Orbit ();  	orbit.eccentricity = body.orbit.eccentricity + nearby.eccentricity;  	orbit.semiMajorAxis = body.orbit.semiMajorAxis * nearby.semiMajorAxis;  	orbit.inclination = body.orbit.inclination + nearby.inclination;  	orbit.LAN = body.orbit.LAN * nearby.longitudeOfAscendingNode;  	orbit.argumentOfPeriapsis = body.orbit.argumentOfPeriapsis * nearby.argumentOfPeriapsis;  	orbit.meanAnomalyAtEpoch = body.orbit.meanAnomalyAtEpoch * nearby.meanAnomalyAtEpoch;  	orbit.epoch = body.orbit.epoch;  	orbit.referenceBody = body.orbit.referenceBody;  	orbit.Init ();  } else if (type == 2 && asteroid.location.flyby.Count != 0) {  	// Flyby  	IEnumerable<Location.FlybyLoader> flybys = GetProbabilityList (asteroid.location.flyby' asteroid.location.flyby.Select (a => a.probability.value));  	Location.FlybyLoader flyby = flybys.ElementAt (Random.Range (0' flybys.Count ()));  	body = PSystemManager.Instance.localBodies.Find (b => b.name == flyby.body);  	if (!body)  		return;  	if (flyby.reached && !ReachedBody (body))  		return;  	orbit = Orbit.CreateRandomOrbitFlyBy (body' Random.Range (flyby.minDuration' flyby.maxDuration));  }  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The following statement contains a magic number: if (type == 1 && asteroid.location.nearby.Count != 0) {  	// Nearby  	IEnumerable<Location.NearbyLoader> nearbys = GetProbabilityList (asteroid.location.nearby' asteroid.location.nearby.Select (a => a.probability.value));  	Location.NearbyLoader nearby = nearbys.ElementAt (Random.Range (0' nearbys.Count ()));  	body = PSystemManager.Instance.localBodies.Find (b => b.name == nearby.body);  	if (!body)  		return;  	if (nearby.reached && !ReachedBody (body))  		return;  	orbit = new Orbit ();  	orbit.eccentricity = body.orbit.eccentricity + nearby.eccentricity;  	orbit.semiMajorAxis = body.orbit.semiMajorAxis * nearby.semiMajorAxis;  	orbit.inclination = body.orbit.inclination + nearby.inclination;  	orbit.LAN = body.orbit.LAN * nearby.longitudeOfAscendingNode;  	orbit.argumentOfPeriapsis = body.orbit.argumentOfPeriapsis * nearby.argumentOfPeriapsis;  	orbit.meanAnomalyAtEpoch = body.orbit.meanAnomalyAtEpoch * nearby.meanAnomalyAtEpoch;  	orbit.epoch = body.orbit.epoch;  	orbit.referenceBody = body.orbit.referenceBody;  	orbit.Init ();  } else if (type == 2 && asteroid.location.flyby.Count != 0) {  	// Flyby  	IEnumerable<Location.FlybyLoader> flybys = GetProbabilityList (asteroid.location.flyby' asteroid.location.flyby.Select (a => a.probability.value));  	Location.FlybyLoader flyby = flybys.ElementAt (Random.Range (0' flybys.Count ()));  	body = PSystemManager.Instance.localBodies.Find (b => b.name == flyby.body);  	if (!body)  		return;  	if (flyby.reached && !ReachedBody (body))  		return;  	orbit = Orbit.CreateRandomOrbitFlyBy (body' Random.Range (flyby.minDuration' flyby.maxDuration));  }  
Magic Number,Kopernicus,DiscoverableObjects,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The following statement contains a magic number: if (type == 2 && asteroid.location.flyby.Count != 0) {  	// Flyby  	IEnumerable<Location.FlybyLoader> flybys = GetProbabilityList (asteroid.location.flyby' asteroid.location.flyby.Select (a => a.probability.value));  	Location.FlybyLoader flyby = flybys.ElementAt (Random.Range (0' flybys.Count ()));  	body = PSystemManager.Instance.localBodies.Find (b => b.name == flyby.body);  	if (!body)  		return;  	if (flyby.reached && !ReachedBody (body))  		return;  	orbit = Orbit.CreateRandomOrbitFlyBy (body' Random.Range (flyby.minDuration' flyby.maxDuration));  }  
Magic Number,Kopernicus,Logger,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Logger.cs,Logger,The following statement contains a magic number: try {  	// Open the log file (overwrite existing logs)  	LogFileName = LogFileName.Replace ("/"' "").Replace ("\\"' "");  	string LogFile = Logger.LogDirectory + LogFileName + ".log";  	loggerStream = new StreamWriter (LogFile);  	// Write an opening message  	string logVersion = "//=====  " + version + "  =====//";  	// Create the header this way' because I'm maybe too stupid to find the "fill" function  	string logHeader = "";  	for (int i = 0; i < (logVersion.Length - 4); i++) {  		logHeader += "=";  	}  	logHeader = "//" + logHeader + "//";  	loggerStream.WriteLine (logHeader + "\n" + logVersion + "\n" + logHeader);  	// Don't use Log() because we don't want a date time in front of the Versioning.  	Log ("Logger \"" + LogFileName + "\" was created");  } catch (Exception e) {  	Debug.LogException (e);  }  
Magic Number,Kopernicus,Logger,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Logger.cs,Logger,The following statement contains a magic number: for (int i = 0; i < (logVersion.Length - 4); i++) {  	logHeader += "=";  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,RecalculateTangents,The following statement contains a magic number: for (int i = 0; i < (triangleCount); i++) {  	int i1 = triangles [tri];  	int i2 = triangles [tri + 1];  	int i3 = triangles [tri + 2];  	Vector3 v1 = vertices [i1];  	Vector3 v2 = vertices [i2];  	Vector3 v3 = vertices [i3];  	Vector2 w1 = texcoords [i1];  	Vector2 w2 = texcoords [i2];  	Vector2 w3 = texcoords [i3];  	float x1 = v2.x - v1.x;  	float x2 = v3.x - v1.x;  	float y1 = v2.y - v1.y;  	float y2 = v3.y - v1.y;  	float z1 = v2.z - v1.z;  	float z2 = v3.z - v1.z;  	float s1 = w2.x - w1.x;  	float s2 = w3.x - w1.x;  	float t1 = w2.y - w1.y;  	float t2 = w3.y - w1.y;  	float r = 1.0f / (s1 * t2 - s2 * t1);  	var sdir = new Vector3 ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	var tdir = new Vector3 ((s1 * x2 - s2 * x1) * r' (s1 * y2 - s2 * y1) * r' (s1 * z2 - s2 * z1) * r);  	tan1 [i1] += sdir;  	tan1 [i2] += sdir;  	tan1 [i3] += sdir;  	tan2 [i1] += tdir;  	tan2 [i2] += tdir;  	tan2 [i3] += tdir;  	tri += 3;  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,RecalculateTangents,The following statement contains a magic number: for (int i = 0; i < (triangleCount); i++) {  	int i1 = triangles [tri];  	int i2 = triangles [tri + 1];  	int i3 = triangles [tri + 2];  	Vector3 v1 = vertices [i1];  	Vector3 v2 = vertices [i2];  	Vector3 v3 = vertices [i3];  	Vector2 w1 = texcoords [i1];  	Vector2 w2 = texcoords [i2];  	Vector2 w3 = texcoords [i3];  	float x1 = v2.x - v1.x;  	float x2 = v3.x - v1.x;  	float y1 = v2.y - v1.y;  	float y2 = v3.y - v1.y;  	float z1 = v2.z - v1.z;  	float z2 = v3.z - v1.z;  	float s1 = w2.x - w1.x;  	float s2 = w3.x - w1.x;  	float t1 = w2.y - w1.y;  	float t2 = w3.y - w1.y;  	float r = 1.0f / (s1 * t2 - s2 * t1);  	var sdir = new Vector3 ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	var tdir = new Vector3 ((s1 * x2 - s2 * x1) * r' (s1 * y2 - s2 * y1) * r' (s1 * z2 - s2 * z1) * r);  	tan1 [i1] += sdir;  	tan1 [i2] += sdir;  	tan1 [i3] += sdir;  	tan2 [i1] += tdir;  	tan2 [i2] += tdir;  	tan2 [i3] += tdir;  	tri += 3;  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,RecalculateTangents,The following statement contains a magic number: tri += 3;  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LLAtoECEF,The following statement contains a magic number: lat = (lat - 90) * degreesToRadians;  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (System.IO.File.Exists (path)) {  	bool uncaught = true;  	try {  		if (path.ToLower ().EndsWith (".dds")) {  			// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  			// Also borrowed the extra bits from Sarbian.  			byte[] buffer = System.IO.File.ReadAllBytes (path);  			System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  			uint num = binaryReader.ReadUInt32 ();  			if (num == DDSHeaders.DDSValues.uintMagic) {  				DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					new DDSHeaders.DDSHeaderDX10 (binaryReader);  				}  				bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  				bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  				bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  				bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  				bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  				bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  				//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  				bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  				bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  				bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  				bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  				bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  				if (fourcc) {  					if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  						Debug.Log ("[Kopernicus] DXT2 not supported" + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  						Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  						Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  					} else  						fourcc = false;  				}  				if (!fourcc) {  					TextureFormat textureFormat = TextureFormat.ARGB32;  					bool ok = true;  					if (rgb && (rgb888/*|| bgr888*/)) {  						// RGB or RGBA format  						textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  					} else if (rgb && rgb565) {  						// Nvidia texconv B5G6R5_UNORM  						textureFormat = TextureFormat.RGB565;  					} else if (rgb && alphapixel && argb4444) {  						// Nvidia texconv B4G4R4A4_UNORM  						textureFormat = TextureFormat.ARGB4444;  					} else if (rgb && alphapixel && rbga4444) {  						textureFormat = TextureFormat.RGBA4444;  					} else if (!rgb && alpha != luminance) {  						// A8 format or Luminance 8  						textureFormat = TextureFormat.Alpha8;  					} else {  						ok = false;  						Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  					}  					if (ok) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					}  				}  				if (map != null)  					if (upload)  						map.Apply (false' unreadable);  			} else  				Debug.Log ("[Kopernicus] Bad DDS header.");  		} else {  			map = new Texture2D (2' 2);  			map.LoadImage (System.IO.File.ReadAllBytes (path));  			if (compress)  				map.Compress (true);  			if (upload)  				map.Apply (false' unreadable);  		}  	} catch (Exception e) {  		uncaught = false;  		Debug.Log ("[Kopernicus] failed to load " + path + " with exception " + e.Message);  	}  	if (map == null && uncaught) {  		Debug.Log ("[Kopernicus] failed to load " + path);  	}  	map.name = path.Remove (0' (KSPUtil.ApplicationRootPath + "GameData/").Length);  } else  	Debug.Log ("[Kopernicus] texture does not exist! " + path);  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (System.IO.File.Exists (path)) {  	bool uncaught = true;  	try {  		if (path.ToLower ().EndsWith (".dds")) {  			// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  			// Also borrowed the extra bits from Sarbian.  			byte[] buffer = System.IO.File.ReadAllBytes (path);  			System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  			uint num = binaryReader.ReadUInt32 ();  			if (num == DDSHeaders.DDSValues.uintMagic) {  				DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					new DDSHeaders.DDSHeaderDX10 (binaryReader);  				}  				bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  				bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  				bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  				bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  				bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  				bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  				//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  				bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  				bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  				bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  				bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  				bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  				if (fourcc) {  					if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  						Debug.Log ("[Kopernicus] DXT2 not supported" + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  						Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  						Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  					} else  						fourcc = false;  				}  				if (!fourcc) {  					TextureFormat textureFormat = TextureFormat.ARGB32;  					bool ok = true;  					if (rgb && (rgb888/*|| bgr888*/)) {  						// RGB or RGBA format  						textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  					} else if (rgb && rgb565) {  						// Nvidia texconv B5G6R5_UNORM  						textureFormat = TextureFormat.RGB565;  					} else if (rgb && alphapixel && argb4444) {  						// Nvidia texconv B4G4R4A4_UNORM  						textureFormat = TextureFormat.ARGB4444;  					} else if (rgb && alphapixel && rbga4444) {  						textureFormat = TextureFormat.RGBA4444;  					} else if (!rgb && alpha != luminance) {  						// A8 format or Luminance 8  						textureFormat = TextureFormat.Alpha8;  					} else {  						ok = false;  						Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  					}  					if (ok) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					}  				}  				if (map != null)  					if (upload)  						map.Apply (false' unreadable);  			} else  				Debug.Log ("[Kopernicus] Bad DDS header.");  		} else {  			map = new Texture2D (2' 2);  			map.LoadImage (System.IO.File.ReadAllBytes (path));  			if (compress)  				map.Compress (true);  			if (upload)  				map.Apply (false' unreadable);  		}  	} catch (Exception e) {  		uncaught = false;  		Debug.Log ("[Kopernicus] failed to load " + path + " with exception " + e.Message);  	}  	if (map == null && uncaught) {  		Debug.Log ("[Kopernicus] failed to load " + path);  	}  	map.name = path.Remove (0' (KSPUtil.ApplicationRootPath + "GameData/").Length);  } else  	Debug.Log ("[Kopernicus] texture does not exist! " + path);  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (System.IO.File.Exists (path)) {  	bool uncaught = true;  	try {  		if (path.ToLower ().EndsWith (".dds")) {  			// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  			// Also borrowed the extra bits from Sarbian.  			byte[] buffer = System.IO.File.ReadAllBytes (path);  			System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  			uint num = binaryReader.ReadUInt32 ();  			if (num == DDSHeaders.DDSValues.uintMagic) {  				DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					new DDSHeaders.DDSHeaderDX10 (binaryReader);  				}  				bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  				bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  				bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  				bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  				bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  				bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  				//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  				bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  				bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  				bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  				bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  				bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  				if (fourcc) {  					if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  						Debug.Log ("[Kopernicus] DXT2 not supported" + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  						Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  						Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  					} else  						fourcc = false;  				}  				if (!fourcc) {  					TextureFormat textureFormat = TextureFormat.ARGB32;  					bool ok = true;  					if (rgb && (rgb888/*|| bgr888*/)) {  						// RGB or RGBA format  						textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  					} else if (rgb && rgb565) {  						// Nvidia texconv B5G6R5_UNORM  						textureFormat = TextureFormat.RGB565;  					} else if (rgb && alphapixel && argb4444) {  						// Nvidia texconv B4G4R4A4_UNORM  						textureFormat = TextureFormat.ARGB4444;  					} else if (rgb && alphapixel && rbga4444) {  						textureFormat = TextureFormat.RGBA4444;  					} else if (!rgb && alpha != luminance) {  						// A8 format or Luminance 8  						textureFormat = TextureFormat.Alpha8;  					} else {  						ok = false;  						Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  					}  					if (ok) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  						map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  					}  				}  				if (map != null)  					if (upload)  						map.Apply (false' unreadable);  			} else  				Debug.Log ("[Kopernicus] Bad DDS header.");  		} else {  			map = new Texture2D (2' 2);  			map.LoadImage (System.IO.File.ReadAllBytes (path));  			if (compress)  				map.Compress (true);  			if (upload)  				map.Apply (false' unreadable);  		}  	} catch (Exception e) {  		uncaught = false;  		Debug.Log ("[Kopernicus] failed to load " + path + " with exception " + e.Message);  	}  	if (map == null && uncaught) {  		Debug.Log ("[Kopernicus] failed to load " + path);  	}  	map.name = path.Remove (0' (KSPUtil.ApplicationRootPath + "GameData/").Length);  } else  	Debug.Log ("[Kopernicus] texture does not exist! " + path);  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: try {  	if (path.ToLower ().EndsWith (".dds")) {  		// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  		// Also borrowed the extra bits from Sarbian.  		byte[] buffer = System.IO.File.ReadAllBytes (path);  		System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  		uint num = binaryReader.ReadUInt32 ();  		if (num == DDSHeaders.DDSValues.uintMagic) {  			DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				new DDSHeaders.DDSHeaderDX10 (binaryReader);  			}  			bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  			bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  			bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  			bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  			bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  			bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  			//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  			bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  			bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  			bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  			bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  			bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  			if (fourcc) {  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  					Debug.Log ("[Kopernicus] DXT2 not supported" + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  					Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  				} else  					fourcc = false;  			}  			if (!fourcc) {  				TextureFormat textureFormat = TextureFormat.ARGB32;  				bool ok = true;  				if (rgb && (rgb888/*|| bgr888*/)) {  					// RGB or RGBA format  					textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  				} else if (rgb && rgb565) {  					// Nvidia texconv B5G6R5_UNORM  					textureFormat = TextureFormat.RGB565;  				} else if (rgb && alphapixel && argb4444) {  					// Nvidia texconv B4G4R4A4_UNORM  					textureFormat = TextureFormat.ARGB4444;  				} else if (rgb && alphapixel && rbga4444) {  					textureFormat = TextureFormat.RGBA4444;  				} else if (!rgb && alpha != luminance) {  					// A8 format or Luminance 8  					textureFormat = TextureFormat.Alpha8;  				} else {  					ok = false;  					Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  				}  				if (ok) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				}  			}  			if (map != null)  				if (upload)  					map.Apply (false' unreadable);  		} else  			Debug.Log ("[Kopernicus] Bad DDS header.");  	} else {  		map = new Texture2D (2' 2);  		map.LoadImage (System.IO.File.ReadAllBytes (path));  		if (compress)  			map.Compress (true);  		if (upload)  			map.Apply (false' unreadable);  	}  } catch (Exception e) {  	uncaught = false;  	Debug.Log ("[Kopernicus] failed to load " + path + " with exception " + e.Message);  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: try {  	if (path.ToLower ().EndsWith (".dds")) {  		// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  		// Also borrowed the extra bits from Sarbian.  		byte[] buffer = System.IO.File.ReadAllBytes (path);  		System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  		uint num = binaryReader.ReadUInt32 ();  		if (num == DDSHeaders.DDSValues.uintMagic) {  			DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				new DDSHeaders.DDSHeaderDX10 (binaryReader);  			}  			bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  			bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  			bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  			bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  			bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  			bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  			//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  			bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  			bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  			bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  			bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  			bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  			if (fourcc) {  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  					Debug.Log ("[Kopernicus] DXT2 not supported" + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  					Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  				} else  					fourcc = false;  			}  			if (!fourcc) {  				TextureFormat textureFormat = TextureFormat.ARGB32;  				bool ok = true;  				if (rgb && (rgb888/*|| bgr888*/)) {  					// RGB or RGBA format  					textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  				} else if (rgb && rgb565) {  					// Nvidia texconv B5G6R5_UNORM  					textureFormat = TextureFormat.RGB565;  				} else if (rgb && alphapixel && argb4444) {  					// Nvidia texconv B4G4R4A4_UNORM  					textureFormat = TextureFormat.ARGB4444;  				} else if (rgb && alphapixel && rbga4444) {  					textureFormat = TextureFormat.RGBA4444;  				} else if (!rgb && alpha != luminance) {  					// A8 format or Luminance 8  					textureFormat = TextureFormat.Alpha8;  				} else {  					ok = false;  					Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  				}  				if (ok) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				}  			}  			if (map != null)  				if (upload)  					map.Apply (false' unreadable);  		} else  			Debug.Log ("[Kopernicus] Bad DDS header.");  	} else {  		map = new Texture2D (2' 2);  		map.LoadImage (System.IO.File.ReadAllBytes (path));  		if (compress)  			map.Compress (true);  		if (upload)  			map.Apply (false' unreadable);  	}  } catch (Exception e) {  	uncaught = false;  	Debug.Log ("[Kopernicus] failed to load " + path + " with exception " + e.Message);  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: try {  	if (path.ToLower ().EndsWith (".dds")) {  		// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  		// Also borrowed the extra bits from Sarbian.  		byte[] buffer = System.IO.File.ReadAllBytes (path);  		System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  		uint num = binaryReader.ReadUInt32 ();  		if (num == DDSHeaders.DDSValues.uintMagic) {  			DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				new DDSHeaders.DDSHeaderDX10 (binaryReader);  			}  			bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  			bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  			bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  			bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  			bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  			bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  			//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  			bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  			bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  			bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  			bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  			bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  			if (fourcc) {  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  					Debug.Log ("[Kopernicus] DXT2 not supported" + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  					Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  				} else  					fourcc = false;  			}  			if (!fourcc) {  				TextureFormat textureFormat = TextureFormat.ARGB32;  				bool ok = true;  				if (rgb && (rgb888/*|| bgr888*/)) {  					// RGB or RGBA format  					textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  				} else if (rgb && rgb565) {  					// Nvidia texconv B5G6R5_UNORM  					textureFormat = TextureFormat.RGB565;  				} else if (rgb && alphapixel && argb4444) {  					// Nvidia texconv B4G4R4A4_UNORM  					textureFormat = TextureFormat.ARGB4444;  				} else if (rgb && alphapixel && rbga4444) {  					textureFormat = TextureFormat.RGBA4444;  				} else if (!rgb && alpha != luminance) {  					// A8 format or Luminance 8  					textureFormat = TextureFormat.Alpha8;  				} else {  					ok = false;  					Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  				}  				if (ok) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  					map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  				}  			}  			if (map != null)  				if (upload)  					map.Apply (false' unreadable);  		} else  			Debug.Log ("[Kopernicus] Bad DDS header.");  	} else {  		map = new Texture2D (2' 2);  		map.LoadImage (System.IO.File.ReadAllBytes (path));  		if (compress)  			map.Compress (true);  		if (upload)  			map.Apply (false' unreadable);  	}  } catch (Exception e) {  	uncaught = false;  	Debug.Log ("[Kopernicus] failed to load " + path + " with exception " + e.Message);  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (path.ToLower ().EndsWith (".dds")) {  	// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  	// Also borrowed the extra bits from Sarbian.  	byte[] buffer = System.IO.File.ReadAllBytes (path);  	System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  	uint num = binaryReader.ReadUInt32 ();  	if (num == DDSHeaders.DDSValues.uintMagic) {  		DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			new DDSHeaders.DDSHeaderDX10 (binaryReader);  		}  		bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  		bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  		bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  		bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  		bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  		bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  		//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  		bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  		bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  		bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  		bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  		bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  		if (fourcc) {  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  				Debug.Log ("[Kopernicus] DXT2 not supported" + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  				Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  			} else  				fourcc = false;  		}  		if (!fourcc) {  			TextureFormat textureFormat = TextureFormat.ARGB32;  			bool ok = true;  			if (rgb && (rgb888/*|| bgr888*/)) {  				// RGB or RGBA format  				textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  			} else if (rgb && rgb565) {  				// Nvidia texconv B5G6R5_UNORM  				textureFormat = TextureFormat.RGB565;  			} else if (rgb && alphapixel && argb4444) {  				// Nvidia texconv B4G4R4A4_UNORM  				textureFormat = TextureFormat.ARGB4444;  			} else if (rgb && alphapixel && rbga4444) {  				textureFormat = TextureFormat.RGBA4444;  			} else if (!rgb && alpha != luminance) {  				// A8 format or Luminance 8  				textureFormat = TextureFormat.Alpha8;  			} else {  				ok = false;  				Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  			}  			if (ok) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			}  		}  		if (map != null)  			if (upload)  				map.Apply (false' unreadable);  	} else  		Debug.Log ("[Kopernicus] Bad DDS header.");  } else {  	map = new Texture2D (2' 2);  	map.LoadImage (System.IO.File.ReadAllBytes (path));  	if (compress)  		map.Compress (true);  	if (upload)  		map.Apply (false' unreadable);  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (path.ToLower ().EndsWith (".dds")) {  	// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  	// Also borrowed the extra bits from Sarbian.  	byte[] buffer = System.IO.File.ReadAllBytes (path);  	System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  	uint num = binaryReader.ReadUInt32 ();  	if (num == DDSHeaders.DDSValues.uintMagic) {  		DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			new DDSHeaders.DDSHeaderDX10 (binaryReader);  		}  		bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  		bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  		bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  		bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  		bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  		bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  		//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  		bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  		bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  		bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  		bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  		bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  		if (fourcc) {  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  				Debug.Log ("[Kopernicus] DXT2 not supported" + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  				Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  			} else  				fourcc = false;  		}  		if (!fourcc) {  			TextureFormat textureFormat = TextureFormat.ARGB32;  			bool ok = true;  			if (rgb && (rgb888/*|| bgr888*/)) {  				// RGB or RGBA format  				textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  			} else if (rgb && rgb565) {  				// Nvidia texconv B5G6R5_UNORM  				textureFormat = TextureFormat.RGB565;  			} else if (rgb && alphapixel && argb4444) {  				// Nvidia texconv B4G4R4A4_UNORM  				textureFormat = TextureFormat.ARGB4444;  			} else if (rgb && alphapixel && rbga4444) {  				textureFormat = TextureFormat.RGBA4444;  			} else if (!rgb && alpha != luminance) {  				// A8 format or Luminance 8  				textureFormat = TextureFormat.Alpha8;  			} else {  				ok = false;  				Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  			}  			if (ok) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			}  		}  		if (map != null)  			if (upload)  				map.Apply (false' unreadable);  	} else  		Debug.Log ("[Kopernicus] Bad DDS header.");  } else {  	map = new Texture2D (2' 2);  	map.LoadImage (System.IO.File.ReadAllBytes (path));  	if (compress)  		map.Compress (true);  	if (upload)  		map.Apply (false' unreadable);  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (path.ToLower ().EndsWith (".dds")) {  	// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  	// Also borrowed the extra bits from Sarbian.  	byte[] buffer = System.IO.File.ReadAllBytes (path);  	System.IO.BinaryReader binaryReader = new System.IO.BinaryReader (new System.IO.MemoryStream (buffer));  	uint num = binaryReader.ReadUInt32 ();  	if (num == DDSHeaders.DDSValues.uintMagic) {  		DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			new DDSHeaders.DDSHeaderDX10 (binaryReader);  		}  		bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  		bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  		bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  		bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  		bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  		bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  		//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  		bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  		bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  		bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  		bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  		bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  		if (fourcc) {  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  				Debug.Log ("[Kopernicus] DXT2 not supported" + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  				Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  			} else  				fourcc = false;  		}  		if (!fourcc) {  			TextureFormat textureFormat = TextureFormat.ARGB32;  			bool ok = true;  			if (rgb && (rgb888/*|| bgr888*/)) {  				// RGB or RGBA format  				textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  			} else if (rgb && rgb565) {  				// Nvidia texconv B5G6R5_UNORM  				textureFormat = TextureFormat.RGB565;  			} else if (rgb && alphapixel && argb4444) {  				// Nvidia texconv B4G4R4A4_UNORM  				textureFormat = TextureFormat.ARGB4444;  			} else if (rgb && alphapixel && rbga4444) {  				textureFormat = TextureFormat.RGBA4444;  			} else if (!rgb && alpha != luminance) {  				// A8 format or Luminance 8  				textureFormat = TextureFormat.Alpha8;  			} else {  				ok = false;  				Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  			}  			if (ok) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  				map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  			}  		}  		if (map != null)  			if (upload)  				map.Apply (false' unreadable);  	} else  		Debug.Log ("[Kopernicus] Bad DDS header.");  } else {  	map = new Texture2D (2' 2);  	map.LoadImage (System.IO.File.ReadAllBytes (path));  	if (compress)  		map.Compress (true);  	if (upload)  		map.Apply (false' unreadable);  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (num == DDSHeaders.DDSValues.uintMagic) {  	DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  	if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  		new DDSHeaders.DDSHeaderDX10 (binaryReader);  	}  	bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  	bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  	bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  	bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  	bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  	bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  	//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  	bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  	bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  	bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  	bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  	bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  	if (fourcc) {  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  			map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  			map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  			map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  			Debug.Log ("[Kopernicus] DXT2 not supported" + path);  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  			Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  		} else  			fourcc = false;  	}  	if (!fourcc) {  		TextureFormat textureFormat = TextureFormat.ARGB32;  		bool ok = true;  		if (rgb && (rgb888/*|| bgr888*/)) {  			// RGB or RGBA format  			textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  		} else if (rgb && rgb565) {  			// Nvidia texconv B5G6R5_UNORM  			textureFormat = TextureFormat.RGB565;  		} else if (rgb && alphapixel && argb4444) {  			// Nvidia texconv B4G4R4A4_UNORM  			textureFormat = TextureFormat.ARGB4444;  		} else if (rgb && alphapixel && rbga4444) {  			textureFormat = TextureFormat.RGBA4444;  		} else if (!rgb && alpha != luminance) {  			// A8 format or Luminance 8  			textureFormat = TextureFormat.Alpha8;  		} else {  			ok = false;  			Debug.Log ("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  		}  		if (ok) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  			map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  		}  	}  	if (map != null)  		if (upload)  			map.Apply (false' unreadable);  } else  	Debug.Log ("[Kopernicus] Bad DDS header.");  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (fourcc) {  	if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  		map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  		map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  		map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  		map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  		map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  		map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  		Debug.Log ("[Kopernicus] DXT2 not supported" + path);  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  		Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  		Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  	} else  		fourcc = false;  }  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  	map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  	map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  	map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  	Debug.Log ("[Kopernicus] DXT2 not supported" + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  	Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  	Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  } else  	fourcc = false;  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  	map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  	map.LoadRawTextureData (binaryReader.ReadBytes ((int)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  	Debug.Log ("[Kopernicus] DXT2 not supported" + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  	Debug.Log ("[Kopernicus] DXT4 not supported: " + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  	Debug.Log ("[Kopernicus] DX10 dds not supported: " + path);  } else  	fourcc = false;  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: map = new Texture2D (2' 2);  
Magic Number,Kopernicus,Utility,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: map = new Texture2D (2' 2);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,AtmosphereFromGroundLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,AtmosphereFromGroundLoader,The following statement contains a magic number: afg.invWaveLength = new Color ((float)(1d / Math.Pow (afg.waveLength [0]' 4))' (float)(1d / Math.Pow (afg.waveLength [1]' 4))' (float)(1d / Math.Pow (afg.waveLength [2]' 4))' 0.5f);  
Magic Number,Configuration,OceanLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OceanLoader.cs,OceanLoader,The following statement contains a magic number: uvs.order = 999999;  
Magic Number,Configuration,Loader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\Loader.cs,Apply,The following statement contains a magic number: systemPrefab.mainToolbarSelected = 2;  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The following statement contains a magic number: celestialBody.gMagnitudeAtCenter = celestialBody.GeeASL * 9.80665 * rsq;  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The following statement contains a magic number: celestialBody.Mass = celestialBody.gravParameter * (1 / 6.67408E-11);  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.Mass * (6.67408E-11 / 9.80665) / rsq;  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.Mass * (6.67408E-11 / 9.80665) / rsq;  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.gMagnitudeAtCenter = celestialBody.GeeASL * 9.80665 * rsq;  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,GravParamToOthers,The following statement contains a magic number: celestialBody.Mass = celestialBody.gravParameter * (1 / 6.67408E-11);  
Magic Number,Configuration,PropertiesLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PropertiesLoader.cs,GravParamToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.gravParameter / 9.80665 / rsq;  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null) {  	if (body.referenceBody != null) {  		// Only recalculate the SOI' if it's not forced  		if (!body.Has ("hillSphere"))  			body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  		if (!body.Has ("sphereOfInfluence"))  			body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  		// this is unlike stock KSP' where only the reference body's mass is used.  		body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  		body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  		// in theory this should work but I haven't tested it  		if (body.orbit.eccentricity <= 1.0) {  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  			body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  		} else {  			// ignores this body's own mass for this one...  			body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  			body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  			body.orbit.ObTAtEpoch = body.orbit.ObT;  		}  	} else {  		body.sphereOfInfluence = Double.PositiveInfinity;  		body.hillSphere = Double.PositiveInfinity;  	}  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.referenceBody != null) {  	// Only recalculate the SOI' if it's not forced  	if (!body.Has ("hillSphere"))  		body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  	if (!body.Has ("sphereOfInfluence"))  		body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  	// this is unlike stock KSP' where only the reference body's mass is used.  	body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  	body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  	// in theory this should work but I haven't tested it  	if (body.orbit.eccentricity <= 1.0) {  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  		body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  	} else {  		// ignores this body's own mass for this one...  		body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  		body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  		body.orbit.ObTAtEpoch = body.orbit.ObT;  	}  } else {  	body.sphereOfInfluence = Double.PositiveInfinity;  	body.hillSphere = Double.PositiveInfinity;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (!body.Has ("hillSphere"))  	body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (!body.Has ("sphereOfInfluence"))  	body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.sphereOfInfluence = Math.Max (body.orbit.semiMajorAxis * Math.Pow (body.Mass / body.orbit.referenceBody.Mass' 0.4)' Math.Max (body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.period = 2 * Math.PI * Math.Sqrt (Math.Pow (body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbit.eccentricity <= 1.0) {  	body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  	body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  	body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  } else {  	// ignores this body's own mass for this one...  	body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  	body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  	body.orbit.ObTAtEpoch = body.orbit.ObT;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbit.eccentricity <= 1.0) {  	body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  	body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  	body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  } else {  	// ignores this body's own mass for this one...  	body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  	body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  	body.orbit.ObTAtEpoch = body.orbit.ObT;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbit.eccentricity <= 1.0) {  	body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  	body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  	body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;  } else {  	// ignores this body's own mass for this one...  	body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;  	body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  	body.orbit.ObTAtEpoch = body.orbit.ObT;  }  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  
Magic Number,Configuration,OrbitLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: body.orbit.ObT = Math.Pow (Math.Pow (Math.Abs (body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null) {  	// Save the PQSVersion  	pqsVersion = generatedBody.pqsVersion;  	// Get the required PQS information  	transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	// Create physics material editor  	physicsMaterial = new PhysicsMaterialParser (collider.physicsMaterial);  	// Clone the surface material of the PQS  	if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  		if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  	}  	surfaceMaterial = pqsVersion.surfaceMaterial;  	surfaceMaterial.name = Guid.NewGuid ().ToString ();  	// Clone the fallback material of the PQS  	fallbackMaterial = new PQSProjectionFallbackLoader (pqsVersion.fallbackMaterial);  	pqsVersion.fallbackMaterial = fallbackMaterial;  	fallbackMaterial.name = Guid.NewGuid ().ToString ();  	return;  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null) {  	// Save the PQSVersion  	pqsVersion = generatedBody.pqsVersion;  	// Get the required PQS information  	transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	// Create physics material editor  	physicsMaterial = new PhysicsMaterialParser (collider.physicsMaterial);  	// Clone the surface material of the PQS  	if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  		if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  	}  	surfaceMaterial = pqsVersion.surfaceMaterial;  	surfaceMaterial.name = Guid.NewGuid ().ToString ();  	// Clone the fallback material of the PQS  	fallbackMaterial = new PQSProjectionFallbackLoader (pqsVersion.fallbackMaterial);  	pqsVersion.fallbackMaterial = fallbackMaterial;  	fallbackMaterial.name = Guid.NewGuid ().ToString ();  	return;  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null) {  	// Save the PQSVersion  	pqsVersion = generatedBody.pqsVersion;  	// Get the required PQS information  	transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	// Create physics material editor  	physicsMaterial = new PhysicsMaterialParser (collider.physicsMaterial);  	// Clone the surface material of the PQS  	if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  		if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  	}  	surfaceMaterial = pqsVersion.surfaceMaterial;  	surfaceMaterial.name = Guid.NewGuid ().ToString ();  	// Clone the fallback material of the PQS  	fallbackMaterial = new PQSProjectionFallbackLoader (pqsVersion.fallbackMaterial);  	pqsVersion.fallbackMaterial = fallbackMaterial;  	fallbackMaterial.name = Guid.NewGuid ().ToString ();  	return;  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null) {  	// Save the PQSVersion  	pqsVersion = generatedBody.pqsVersion;  	// Get the required PQS information  	transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	// Create physics material editor  	physicsMaterial = new PhysicsMaterialParser (collider.physicsMaterial);  	// Clone the surface material of the PQS  	if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  		if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  	}  	surfaceMaterial = pqsVersion.surfaceMaterial;  	surfaceMaterial.name = Guid.NewGuid ().ToString ();  	// Clone the fallback material of the PQS  	fallbackMaterial = new PQSProjectionFallbackLoader (pqsVersion.fallbackMaterial);  	pqsVersion.fallbackMaterial = fallbackMaterial;  	fallbackMaterial.name = Guid.NewGuid ().ToString ();  	return;  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null) {  	// Save the PQSVersion  	pqsVersion = generatedBody.pqsVersion;  	// Get the required PQS information  	transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	// Create physics material editor  	physicsMaterial = new PhysicsMaterialParser (collider.physicsMaterial);  	// Clone the surface material of the PQS  	if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  		if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  	}  	surfaceMaterial = pqsVersion.surfaceMaterial;  	surfaceMaterial.name = Guid.NewGuid ().ToString ();  	// Clone the fallback material of the PQS  	fallbackMaterial = new PQSProjectionFallbackLoader (pqsVersion.fallbackMaterial);  	pqsVersion.fallbackMaterial = fallbackMaterial;  	fallbackMaterial.name = Guid.NewGuid ().ToString ();  	return;  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null) {  	// Save the PQSVersion  	pqsVersion = generatedBody.pqsVersion;  	// Get the required PQS information  	transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders> (true).FirstOrDefault (Mod => Mod.transform.parent == pqsVersion.transform);  	// Create physics material editor  	physicsMaterial = new PhysicsMaterialParser (collider.physicsMaterial);  	// Clone the surface material of the PQS  	if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  		if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  		if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  			((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  	} else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  		pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  	}  	surfaceMaterial = pqsVersion.surfaceMaterial;  	surfaceMaterial.name = Guid.NewGuid ().ToString ();  	// Clone the fallback material of the PQS  	fallbackMaterial = new PQSProjectionFallbackLoader (pqsVersion.fallbackMaterial);  	pqsVersion.fallbackMaterial = fallbackMaterial;  	fallbackMaterial.name = Guid.NewGuid ().ToString ();  	return;  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: ((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: ((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: ((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = (float)-8E-06;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: transform.deactivateAltitude = 115000;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: transform.order = 10;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: lightDirection.order = 100;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: uvs.order = 999999;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: collider.order = 100;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainOptimisedLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSMainOptimisedLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainShader.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSMainShaderLoader (pqsVersion.surfaceMaterial);  	if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSMainShaderLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSProjectionAerialQuadRelative.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionAerialQuadRelativeLoader (pqsVersion.surfaceMaterial);  	if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  		((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  } else if (PQSProjectionSurfaceQuad.UsesSameShader (pqsVersion.surfaceMaterial)) {  	pqsVersion.surfaceMaterial = new PQSProjectionSurfaceQuadLoader (pqsVersion.surfaceMaterial);  }  
Magic Number,Configuration,PQSLoader,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity < 2)  	((PQSProjectionAerialQuadRelativeLoader)pqsVersion.surfaceMaterial).globalDensity = -8E-06f;  
Magic Number,Constants,Version,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: try {  	s = new FileStream (filePath' FileMode.Open' FileAccess.Read);  	s.Read (b' 0' 2048);  } finally {  	if (s != null) {  		s.Close ();  	}  }  
Magic Number,Constants,Version,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: s.Read (b' 0' 2048);  
