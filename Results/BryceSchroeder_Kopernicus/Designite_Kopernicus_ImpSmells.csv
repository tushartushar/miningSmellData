Implementation smell,Namespace,Class,File,Method,Description
Long Method,Configuration,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The method has 116 lines of code.
Long Method,Configuration,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,PostApply,The method has 120 lines of code.
Long Method,Configuration,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The method has 112 lines of code.
Long Method,Configuration,ScaledVersionLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ScaledVersionLoader.cs,Apply,The method has 103 lines of code.
Long Method,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The method has 100 lines of code.
Long Method,Kopernicus,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The method has 116 lines of code.
Long Method,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The method has 198 lines of code.
Long Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The method has 105 lines of code.
Long Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The method has 135 lines of code.
Long Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The method has 109 lines of code.
Long Method,Kopernicus,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,PostApply,The method has 120 lines of code.
Long Method,Kopernicus,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The method has 112 lines of code.
Long Method,Kopernicus,ScaledVersionLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ScaledVersionLoader.cs,Apply,The method has 103 lines of code.
Long Method,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The method has 100 lines of code.
Long Method,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The method has 101 lines of code.
Long Method,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The method has 139 lines of code.
Long Method,ModLoader,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The method has 116 lines of code.
Complex Method,Configuration,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,Cyclomatic complexity of the method is 24
Complex Method,Configuration,VertexPlanet,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,Cyclomatic complexity of the method is 8
Complex Method,Configuration,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Configuration,HeightColorMap2,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Configuration,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,Cyclomatic complexity of the method is 8
Complex Method,Configuration,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,PostApply,Cyclomatic complexity of the method is 13
Complex Method,Configuration,Body,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Body.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Configuration,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,Cyclomatic complexity of the method is 18
Complex Method,Configuration,ScaledVersionLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ScaledVersionLoader.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Configuration,ScaledVersionLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ScaledVersionLoader.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Configuration,HeightColorMap,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,Cyclomatic complexity of the method is 24
Complex Method,Kopernicus,VertexPlanet,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,HeightColorMap2,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,Cyclomatic complexity of the method is 29
Complex Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,Cyclomatic complexity of the method is 11
Complex Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,Cyclomatic complexity of the method is 12
Complex Method,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,Cyclomatic complexity of the method is 16
Complex Method,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,PostSpawnFixups,Cyclomatic complexity of the method is 11
Complex Method,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,OverrideNode,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,PostApply,Cyclomatic complexity of the method is 13
Complex Method,Kopernicus,Body,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Body.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,Cyclomatic complexity of the method is 18
Complex Method,Kopernicus,ScaledVersionLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ScaledVersionLoader.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,ScaledVersionLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ScaledVersionLoader.cs,PostApply,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,HeightColorMap,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,Cyclomatic complexity of the method is 12
Complex Method,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,Cyclomatic complexity of the method is 13
Complex Method,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,FindMapSO,Cyclomatic complexity of the method is 9
Complex Method,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,RemoveModsOfType,Cyclomatic complexity of the method is 26
Complex Method,ModLoader,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,Cyclomatic complexity of the method is 24
Complex Method,ModLoader,VertexPlanet,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,HeightColorMap2,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,ModLoader,HeightColorMap,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,Cyclomatic complexity of the method is 8
Long Parameter List,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,UpdateScaledMesh,The method has 7 parameters. Parameters: scaledVersion' pqs' body' path' cacheFile' exportBin' useSpherical
Long Statement,Configuration,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The length of the statement  "                    Logger.Active.Log("AtmosphereFromGroundLoader.Apply(ConfigNode): No AtmosphereFromGround was found on \"" + celestialBody.name + "\". Adding one."); " is 148.
Long Statement,Configuration,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The length of the statement  "                atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f); " is 245.
Long Statement,Configuration,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && (lcNode.HasValue("name") ? m.landClass.landClassName == lcNode.GetValue("name") : false)) " is 162.
Long Statement,Configuration,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "                                loader = scatters.Where(m => !patchedScatters.Contains(m.scatter) && (scatterNode.HasValue("name") ? m.scatter.scatterName == scatterNode.GetValue("name") : false)) " is 164.
Long Statement,Configuration,VertexPlanet,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,The length of the statement  "                            loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && ((lcNode.HasValue("name") ? m.landClass.name == lcNode.GetValue("name") : true) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 256.
Long Statement,Configuration,VoronoiCraters,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VoronoiCraters.cs,Create,The length of the statement  "                    PQSMod_VoronoiCraters clone = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' "Mun").pqsVersion.GetComponentsInChildren<PQSMod_VoronoiCraters>(true)[0] as PQSMod_VoronoiCraters; " is 193.
Long Statement,Configuration,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClassNoise) && ((lcNode.HasValue("name") ? m.landClassNoise.name == lcNode.GetValue("name") : false) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 267.
Long Statement,Configuration,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,PostApply,The length of the statement  "                    PQSMod_HeightColorMapNoise.LandClass[] landClassesArray = landClasses.Select(loader => loader.landClassNoise).ToArray(); " is 120.
Long Statement,Configuration,HeightColorMap2,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass2) && ((lcNode.HasValue("name") ? m.landClass2.name == lcNode.GetValue("name") : false) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 259.
Long Statement,Configuration,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "                PQSMod_CelestialBodyTransform transform = generatedBody.pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(mod => mod.transform.parent == generatedBody.pqsVersion.transform); " is 210.
Long Statement,Configuration,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "                        Debug.LogError("MOD NULL: Loadertype " + mod.name + " with mod type " + testName + " and null? " + (loaderType == null) + (modType == null)); " is 141.
Long Statement,Configuration,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "                        PQSMod existingMod = existingMods.FirstOrDefault(m => !patchedMods.Contains(m) && (mod.HasValue("name") ? m.name == mod.GetValue("name") : true)); " is 146.
Long Statement,Configuration,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,PostApply,The length of the statement  "                            throw new Exception("Reference body for \"" + body.Key + "\" could not be found. Missing body name is \"" + body.Value.orbit.referenceBody + "\"."); " is 148.
Long Statement,Configuration,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,RecursivelySortBodies,The length of the statement  "                body.children = body.children.OrderBy(b => b.orbitDriver.orbit.semiMajorAxis * (1 + b.orbitDriver.orbit.eccentricity)).ToList(); " is 128.
Long Statement,Configuration,Body,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Body.cs,PostApply,The length of the statement  "                    (((template != null) && (Math.Abs(template.radius - generatedBody.celestialBody.Radius) > 1.0 || template.type != scaledVersion.type.value)) " is 140.
Long Statement,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The length of the statement  "                Logger.Active.Log("Via surface G' set gravParam to " + celestialBody.gravParameter + "' mass to " + celestialBody.Mass); " is 120.
Long Statement,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The length of the statement  "                Logger.Active.Log("Via mass' set gravParam to " + celestialBody.gravParameter + "' surface G to " + celestialBody.GeeASL); " is 122.
Long Statement,Configuration,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "                        PQSMod_CelestialBodyTransform cbt = body.pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).First(); " is 121.
Long Statement,Configuration,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "                                //modsPerName.Add(name' Type.GetType(modName + "' Assembly-CSharp' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null")); " is 124.
Long Statement,Configuration,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "                            PQSMod[] allMods = body.pqsVersion.GetComponentsInChildren(kvP.Value' true).Select(m => m as PQSMod).Where(m => m.name == name).ToArray(); " is 138.
Long Statement,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "                            body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0); " is 142.
Long Statement,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "                        body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass)); " is 164.
Long Statement,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "                            body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly; " is 148.
Long Statement,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "                            Debug.LogError("MOD NULL: Loadertype " + mod.name + " with mod type " + modType.Name + " and null? " + (loaderType == null) + (modType == null)); " is 145.
Long Statement,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "                        IEnumerable<PQSMod> existingMods = pqsVersion.GetComponentsInChildren<PQSMod>(true).Where(m => m.GetType() == modType && " is 120.
Long Statement,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "                            PQSMod existingMod = existingMods.FirstOrDefault(m => !patchedMods.Contains(m) && (!mod.HasValue("name") || (mod.HasValue("index") ? existingMods.ToList().IndexOf(m) == Int32.Parse(mod.GetValue("index")) && m.name == mod.GetValue("name") : m.name == mod.GetValue("name")))); " is 274.
Long Statement,Configuration,HeightColorMap,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && ((lcNode.HasValue("name") ? m.landClass.name == lcNode.GetValue("name") : true) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 256.
Long Statement,Kopernicus,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The length of the statement  "                    Logger.Active.Log("AtmosphereFromGroundLoader.Apply(ConfigNode): No AtmosphereFromGround was found on \"" + celestialBody.name + "\". Adding one."); " is 148.
Long Statement,Kopernicus,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The length of the statement  "                atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f); " is 245.
Long Statement,Kopernicus,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && (lcNode.HasValue("name") ? m.landClass.landClassName == lcNode.GetValue("name") : false)) " is 162.
Long Statement,Kopernicus,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "                                loader = scatters.Where(m => !patchedScatters.Contains(m.scatter) && (scatterNode.HasValue("name") ? m.scatter.scatterName == scatterNode.GetValue("name") : false)) " is 164.
Long Statement,Kopernicus,VertexPlanet,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,The length of the statement  "                            loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && ((lcNode.HasValue("name") ? m.landClass.name == lcNode.GetValue("name") : true) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 256.
Long Statement,Kopernicus,VoronoiCraters,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VoronoiCraters.cs,Create,The length of the statement  "                    PQSMod_VoronoiCraters clone = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' "Mun").pqsVersion.GetComponentsInChildren<PQSMod_VoronoiCraters>(true)[0] as PQSMod_VoronoiCraters; " is 193.
Long Statement,Kopernicus,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClassNoise) && ((lcNode.HasValue("name") ? m.landClassNoise.name == lcNode.GetValue("name") : false) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 267.
Long Statement,Kopernicus,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,PostApply,The length of the statement  "                    PQSMod_HeightColorMapNoise.LandClass[] landClassesArray = landClasses.Select(loader => loader.landClassNoise).ToArray(); " is 120.
Long Statement,Kopernicus,HeightColorMap2,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass2) && ((lcNode.HasValue("name") ? m.landClass2.name == lcNode.GetValue("name") : false) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 259.
Long Statement,Kopernicus,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "                PQSMod_CelestialBodyTransform transform = generatedBody.pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(mod => mod.transform.parent == generatedBody.pqsVersion.transform); " is 210.
Long Statement,Kopernicus,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "                        Debug.LogError("MOD NULL: Loadertype " + mod.name + " with mod type " + testName + " and null? " + (loaderType == null) + (modType == null)); " is 141.
Long Statement,Kopernicus,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,PostApply,The length of the statement  "                        PQSMod existingMod = existingMods.FirstOrDefault(m => !patchedMods.Contains(m) && (mod.HasValue("name") ? m.name == mod.GetValue("name") : true)); " is 146.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "            Debug.Log(String.Format("[CompatibilityChecker] Running checker version {0} from '{1}'"' _version' Assembly.GetExecutingAssembly().GetName().Name)); " is 148.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "                        Debug.LogWarning(String.Format("[CompatibilityChecker] Exception while invoking IsCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName().Name' e)); " is 161.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "                        Debug.LogWarning(String.Format("[CompatibilityChecker] Exception while invoking IsUnityCompatible() from '{0}':\n\n{1}"' m.DeclaringType.Assembly.GetName().Name' e)); " is 166.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "            //    message += "WARNING: You are using 64-bit KSP on Windows. This version of KSP is known to cause crashes. It's highly recommended that you use either 32-bit KSP on Windows or switch to Linux."; " is 198.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "                message += ((message == String.Empty) ? "Some" : "\n\nAdditionally' some") + " installed mods may be incompatible with this version of Kerbal Space Program. Features may be broken or disabled. Please check for updates to the listed mods."; " is 239.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "                    message += String.Format("\n\nThese mods are incompatible with KSP {0}.{1}.{2}:\n\n"' Versioning.version_major' Versioning.version_minor' Versioning.Revision); " is 159.
Long Statement,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,Start,The length of the statement  "                PopupDialog.SpawnPopupDialog(new Vector2(0.5f' 0.5f)' new Vector2(0.5f' 0.5f)' "CompatibilityChecker"' "Incompatible Mods Detected"' message' "OK"' true' UISkinManager.defaultSkin); " is 181.
Long Statement,Kopernicus,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Events.cs,Awake,The length of the statement  "            PropertyInfo[] events = typeof(Events).GetProperties(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 121.
Long Statement,Kopernicus,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Events.cs,Awake,The length of the statement  "                DescriptionAttribute description = (info.GetCustomAttributes(typeof(DescriptionAttribute)' false) as DescriptionAttribute[])[0]; " is 128.
Long Statement,Kopernicus,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Events.cs,Awake,The length of the statement  "                events[i].SetValue(null' Activator.CreateInstance(events[i].PropertyType' new[] { "Kopernicus." + description.Description })' null); " is 132.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "                    PSystemBody body = PSystemManager.Instance?.systemPrefab?.GetComponentsInChildren<PSystemBody>(true)?.FirstOrDefault(b => b.name == cb.transform.name); " is 151.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "                    PSystemBody oldParent = PSystemManager.Instance?.systemPrefab?.GetComponentsInChildren<PSystemBody>(true)?.FirstOrDefault(b => b.children.Contains(body)); " is 154.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "                        newParent = PSystemManager.Instance?.systemPrefab?.GetComponentsInChildren<PSystemBody>(true).FirstOrDefault(b => b.name == patch.GetValue("referenceBody")); " is 157.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "            List<KeyValuePair<PSystemBody' KeyValuePair<PSystemBody' Int32>>> hideList = new List<KeyValuePair<PSystemBody' KeyValuePair<PSystemBody' int>>>(); " is 147.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "                            hideList.Add(new KeyValuePair<PSystemBody' KeyValuePair<PSystemBody' Int32>>(hidden' new KeyValuePair<PSystemBody' int>(parent' 0))); " is 133.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "                hideList[i] = new KeyValuePair<PSystemBody' KeyValuePair<PSystemBody' Int32>>(hidden' new KeyValuePair<PSystemBody' int>(parent' index)); " is 137.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "            RDPlanetListItemContainer[] containers = Resources.FindObjectsOfTypeAll<RDPlanetListItemContainer>().Where(i => i.label_planetName.text != "Planet name").ToArray(); " is 164.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,Start,The length of the statement  "                if (body.Has("RnDRotation") ? !body.Get<Boolean>("RnDRotation") : body?.scaledBody?.GetComponentInChildren<SunCoronas>(true) != null) " is 133.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,AddPlanets,The length of the statement  "            RDPlanetListItemContainer[] planetItems = Resources.FindObjectsOfTypeAll<RDPlanetListItemContainer>().Where(i => i.label_planetName.text != "Planet name").ToArray(); " is 165.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,AddPlanets,The length of the statement  "            FieldInfo list = typeof(RDArchivesController).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Skip(7).FirstOrDefault(); " is 129.
Long Statement,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,AddPlanets,The length of the statement  "            MethodInfo add = typeof(RDArchivesController).GetMethods(BindingFlags.Instance | BindingFlags.NonPublic)?.Skip(26)?.FirstOrDefault(); " is 133.
Long Statement,Kopernicus,AtmosphereFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\AtmosphereFixer.cs,Update,The length of the statement  "                    //    Debug.Log("[Kopernicus]: ERROR AtmosphereFixer => Couldn't patch AtmosphereFromGround for " + afg.planet.bodyName + "!"); " is 127.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "            Dictionary<String' KeyValuePair<CelestialBody' CelestialBody>> fixes = new Dictionary<String' KeyValuePair<CelestialBody' CelestialBody>>(); " is 140.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "                    CelestialBody newRef = PSystemManager.Instance.localBodies.FirstOrDefault(b => b.transform.name == loader.referenceBody); " is 121.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "                        Debug.Log("Exception: PostSpawnOrbit reference body for \"" + body.name + "\" could not be found. Missing body name is \"" + loader.referenceBody + "\"."); " is 155.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "                        body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333); " is 148.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "                        Double rotPeriod = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod; " is 133.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "                        Double num1 = Math.PI * 2 * Math.Sqrt(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter); " is 128.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "            Resources.FindObjectsOfTypeAll<PlanetariumCamera>().FirstOrDefault().initialTarget = Resources.FindObjectsOfTypeAll<ScaledMovement>().FirstOrDefault(o => o.celestialBody.isHomeWorld); " is 183.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The length of the statement  "                fixes[b.transform.name].Key.orbitingBodies = fixes[b.transform.name].Key.orbitingBodies.OrderBy(cb => cb.orbit.semiMajorAxis).ToList(); " is 135.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "                    FieldInfo mode_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType.IsEnum && f.FieldType.IsNested); " is 163.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "                    FieldInfo context_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType == typeof(MapContextMenu)); " is 161.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "                    FieldInfo cast_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType == typeof(OrbitRenderer.OrbitCastHit)); " is 170.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The length of the statement  "                body.afg.lightDot = Mathf.Clamp01(Vector3.Dot(planet2cam' body.afg.mainCamera.transform.position - star_.transform.position) * body.afg.dawnFactor); " is 148.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The length of the statement  "                PlanetariumCamera.fetch.SetTarget(PlanetariumCamera.fetch.targets[(PlanetariumCamera.fetch.targets.IndexOf(PlanetariumCamera.fetch.target) + 1) % PlanetariumCamera.fetch.targets.Count]); " is 186.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The length of the statement  "                PlanetariumCamera.fetch.SetTarget(PlanetariumCamera.fetch.targets[(PlanetariumCamera.fetch.targets.IndexOf(PlanetariumCamera.fetch.target) - 1) + (((PlanetariumCamera.fetch.targets.IndexOf(PlanetariumCamera.fetch.target) - 1) >= 0) ? 0 : PlanetariumCamera.fetch.targets.Count)]); " is 279.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The length of the statement  "            planetRotato.speed = (planetRefRotato.speed / 9284.50070356553f) * (Single)planetCB.orbitDriver.orbit.orbitalSpeed; // calc.exe for the win " is 139.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The length of the statement  "                munRotato.speed = (refRotato.speed / 542.494239600754f) * (Single)moonCB.GetOrbit().getOrbitalSpeedAtDistance(moonCB.GetOrbit().semiMajorAxis); " is 143.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The length of the statement  "                menuMoon.transform.localPosition = new Vector3(-5000f * (Single)(moonCB.GetOrbit().semiMajorAxis / 12000000.0)' 0f' 0f); " is 120.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The length of the statement  "                    surfaceObj.SetValue(cam' SurfaceObject.Create(initialTransform.gameObject' FlightGlobals.currentMainBody' 3' KFSMUpdateMode.FIXEDUPDATE)); " is 138.
Long Statement,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,TransformBodyReferencesOnSave,The length of the statement  "            CelestialBody body = PSystemManager.Instance.localBodies.FirstOrDefault(b => b.flightGlobalsIndex == data.from.orbitSnapShot.ReferenceBodyIndex); " is 145.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,Awake,The length of the statement  "                String supported = CompatibilityChecker.version_major + "." + CompatibilityChecker.version_minor + "." + CompatibilityChecker.Revision; " is 135.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,Awake,The length of the statement  "                Debug.LogWarning("[Kopernicus] Detected incompatible install.\nCurrent version of KSP: " + current + ".\nSupported version of KSP: " + supported + ".\nPlease wait' until Kopernicus gets updated to match your version of KSP."); " is 226.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,Awake,The length of the statement  "                String kopernicusVersion = CompatibilityChecker.version_major + "." + CompatibilityChecker.version_minor + "." + CompatibilityChecker.Revision + "-" + CompatibilityChecker.Kopernicus; " is 183.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,Awake,The length of the statement  "                ParserOptions.Register("Kopernicus"' new ParserOptions.Data { errorCallback = e => Logger.Active.LogException(e)' logCallback = s => Logger.Active.Log(s) }); " is 157.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,Awake,The length of the statement  "                // THIS IS WHERE THE MAGIC HAPPENS - OVERWRITE THE SYSTEM PREFAB SO KSP ACCEPTS OUR CUSTOM SOLAR SYSTEM AS IF IT WERE FROM SQUAD " is 128.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,Awake,The length of the statement  "                PSystemManager.Instance.systemPrefab = Parser.CreateObjectFromConfigNode<Loader>(kopernicus' "Kopernicus").systemPrefab; " is 120.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "                SpaceCenter.Instance = PSystemManager.Instance.localBodies.First(cb => cb.isHomeWorld).GetComponentsInChildren<SpaceCenter>(true).FirstOrDefault(); " is 147.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "                    Logger.Default.Log("Found Body: " + body.bodyName + ":" + body.flightGlobalsIndex + " -> SOI = " + body.sphereOfInfluence + "' Hill Sphere = " + body.hillSphere); " is 162.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "                // Fix the maximum viewing distance of the map view camera (get the farthest away something can be from the root object) " is 120.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "                Double maximumDistance = 1000d; // rootBody.children.Max(b => (b.orbitDriver != null) ? b.orbitDriver.orbit.semiMajorAxis * (1 + b.orbitDriver.orbit.eccentricity) : 0); " is 168.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,PostSpawnFixups,The length of the statement  "                                maximumDistance = Math.Max(maximumDistance' body.orbitDriver.orbit.semiMajorAxis * (1d + body.orbitDriver.orbit.eccentricity)); " is 127.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,DisplayWarning,The length of the statement  "            PopupDialog.SpawnPopupDialog(new Vector2(0.5f' 0.5f)' new Vector2(0.5f' 0.5f)' "KopernicusFail"' "Warning"' "Kopernicus was not able to load the custom planetary system due to an exception in the loading process.\n" + " is 217.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,DisplayWarning,The length of the statement  "                "Loading your savegame is NOT recommended' because the missing planets could corrupt it and delete your progress.\n\n" + " is 120.
Long Statement,Kopernicus,Injector,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Injector.cs,DisplayWarning,The length of the statement  "                "Please contact the planet pack author or the Kopernicus team about the issue and send them a valid bugreport' including your KSP.log' your ModuleManager.ConfigCache file and the folder Logs/Kopernicus/ from your KSP root directory.\n\n"' "OK"' true' UISkinManager.GetSkin("MainMenuSkin")); " is 290.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The length of the statement  "            List<Vessel> spaceObjects = FlightGlobals.Vessels.Where(v => !v.DiscoveryInfo.HaveKnowledgeAbout(DiscoveryLevels.StateVectors) && v.DiscoveryInfo.GetSignalLife(Planetarium.GetUniversalTime()) == 0).ToList(); " is 207.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The length of the statement  "            else if (GameVariables.Instance.UnlockedSpaceObjectDiscovery(ScenarioUpgradeableFacilities.GetFacilityLevel(SpaceCenterFacility.TrackingStation))) " is 146.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The length of the statement  "                Int32 untrackedCount = FlightGlobals.Vessels.Count(v => !v.DiscoveryInfo.HaveKnowledgeAbout(DiscoveryLevels.StateVectors)) - spaceObjects.Count; " is 144.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "                IEnumerable<Location.AroundLoader> arounds = GetProbabilityList(asteroid.location.around' asteroid.location.around.Select(a => a.probability.value)); " is 149.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "                IEnumerable<Location.NearbyLoader> nearbys = GetProbabilityList(asteroid.location.nearby' asteroid.location.nearby.Select(a => a.probability.value)); " is 149.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "                IEnumerable<Location.FlybyLoader> flybys = GetProbabilityList(asteroid.location.flyby' asteroid.location.flyby.Select(a => a.probability.value)); " is 145.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The length of the statement  "            UntrackedObjectClass size = (UntrackedObjectClass)((Int32)(asteroid.size.curve.Evaluate(Random.Range(0f' 1f)) * Enum.GetNames(typeof(UntrackedObjectClass)).Length)); " is 165.
Long Statement,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,OverrideNode,The length of the statement  "                String[] names = original.GetValue("removeNodes").Split(new char[] { '''' ' '' ';' }' StringSplitOptions.RemoveEmptyEntries); " is 125.
Long Statement,Kopernicus,StarComponent,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,SetAsActive,The length of the statement  "                foreach (ModuleDeployableSolarPanel sp in FlightGlobals.ActiveVessel.FindPartModulesImplementing<ModuleDeployableSolarPanel>()) " is 127.
Long Statement,Kopernicus,StarComponent,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,SetAsActive,The length of the statement  "                foreach (ModuleDeployableRadiator rad in FlightGlobals.ActiveVessel.FindPartModulesImplementing<ModuleDeployableRadiator>()) " is 124.
Long Statement,Kopernicus,StarLightSwitcher,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,Start,The length of the statement  "            stars = PSystemManager.Instance.localBodies.SelectMany (body => body.scaledBody.GetComponentsInChildren<StarComponent>(true)).ToList(); " is 135.
Long Statement,Kopernicus,StarLightSwitcher,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,Update,The length of the statement  "            if (HighLogic.LoadedScene == GameScenes.TRACKSTATION || HighLogic.LoadedScene == GameScenes.FLIGHT || HighLogic.LoadedScene == GameScenes.SPACECENTER) " is 150.
Long Statement,Kopernicus,StarLightSwitcher,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\StarLightSwitcher.cs,HomeStar,The length of the statement  "            return PSystemManager.Instance.localBodies.First (body => body.flightGlobalsIndex == 0).scaledBody.GetComponent<StarComponent> (); " is 130.
Long Statement,Kopernicus,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,PostApply,The length of the statement  "                            throw new Exception("Reference body for \"" + body.Key + "\" could not be found. Missing body name is \"" + body.Value.orbit.referenceBody + "\"."); " is 148.
Long Statement,Kopernicus,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,RecursivelySortBodies,The length of the statement  "                body.children = body.children.OrderBy(b => b.orbitDriver.orbit.semiMajorAxis * (1 + b.orbitDriver.orbit.eccentricity)).ToList(); " is 128.
Long Statement,Kopernicus,Body,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Body.cs,PostApply,The length of the statement  "                    (((template != null) && (Math.Abs(template.radius - generatedBody.celestialBody.Radius) > 1.0 || template.type != scaledVersion.type.value)) " is 140.
Long Statement,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The length of the statement  "                Logger.Active.Log("Via surface G' set gravParam to " + celestialBody.gravParameter + "' mass to " + celestialBody.Mass); " is 120.
Long Statement,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The length of the statement  "                Logger.Active.Log("Via mass' set gravParam to " + celestialBody.gravParameter + "' surface G to " + celestialBody.GeeASL); " is 122.
Long Statement,Kopernicus,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "                        PQSMod_CelestialBodyTransform cbt = body.pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).First(); " is 121.
Long Statement,Kopernicus,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "                                //modsPerName.Add(name' Type.GetType(modName + "' Assembly-CSharp' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null")); " is 124.
Long Statement,Kopernicus,TemplateLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\TemplateLoader.cs,PostApply,The length of the statement  "                            PQSMod[] allMods = body.pqsVersion.GetComponentsInChildren(kvP.Value' true).Select(m => m as PQSMod).Where(m => m.name == name).ToArray(); " is 138.
Long Statement,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "                            body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0); " is 142.
Long Statement,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "                        body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass)); " is 164.
Long Statement,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The length of the statement  "                            body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly; " is 148.
Long Statement,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "                            Debug.LogError("MOD NULL: Loadertype " + mod.name + " with mod type " + modType.Name + " and null? " + (loaderType == null) + (modType == null)); " is 145.
Long Statement,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "                        IEnumerable<PQSMod> existingMods = pqsVersion.GetComponentsInChildren<PQSMod>(true).Where(m => m.GetType() == modType && " is 120.
Long Statement,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PostApply,The length of the statement  "                            PQSMod existingMod = existingMods.FirstOrDefault(m => !patchedMods.Contains(m) && (!mod.HasValue("name") || (mod.HasValue("index") ? existingMods.ToList().IndexOf(m) == Int32.Parse(mod.GetValue("index")) && m.name == mod.GetValue("name") : m.name == mod.GetValue("name")))); " is 274.
Long Statement,Kopernicus,HeightColorMap,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && ((lcNode.HasValue("name") ? m.landClass.name == lcNode.GetValue("name") : true) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 256.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,CopyObjectFields,The length of the statement  "                        Logger.Active.Log("Copying \"" + field.Name + "\": " + (field.GetValue(destination) ?? "<NULL>") + " => " + (field.GetValue(source) ?? "<NULL>")); " is 146.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "                foreach (PQSMod mod in pqsVersion.GetComponentsInChildren<PQSMod>(true).Where(m => m.enabled && blacklist.Contains(m.GetType()))) " is 129.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "                IEnumerable<PQSMod> mods = pqsVersion.GetComponentsInChildren<PQSMod>(true).Where(m => m.modEnabled).OrderBy(m => m.order); " is 123.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "                    flatten.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance).Where(f => f.FieldType == typeof(Boolean)).First().SetValue(flatten' true); " is 151.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,ComputeScaledSpaceMesh,The length of the statement  "                        flatten.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance).Where(f => f.FieldType == typeof(Boolean)).First().SetValue(flatten' true); " is 151.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                            Boolean rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000; " is 146.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                            //Boolean bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff; " is 148.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                            Boolean rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F; " is 146.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                            Boolean argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f; " is 192.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                            Boolean rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00; " is 192.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                                    map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                                    map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                                    map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The length of the statement  "                                    map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position))); " is 123.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,FindMapSO,The length of the statement  "                    Logger.Active.Log("MapSO grabber: Tried to grab " + url + " but type not found. VertexHeight type for reference = " + typeof(PQSMod_VertexHeightMap).FullName + ". Exception: " + e); " is 181.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,CBTCheck,The length of the statement  "                    PQSMod_CelestialBodyTransform cbt = body.pqsVersion.GetComponentsInChildren(typeof(PQSMod_CelestialBodyTransform)' true).FirstOrDefault() as PQSMod_CelestialBodyTransform; " is 171.
Long Statement,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,CreateReadable,The length of the statement  "            RenderTexture rt = RenderTexture.GetTemporary(original.width' original.height' 0' RenderTextureFormat.ARGB32' RenderTextureReadWrite.sRGB' 1); " is 142.
Long Statement,ModLoader,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && (lcNode.HasValue("name") ? m.landClass.landClassName == lcNode.GetValue("name") : false)) " is 162.
Long Statement,ModLoader,LandControl,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,PostApply,The length of the statement  "                                loader = scatters.Where(m => !patchedScatters.Contains(m.scatter) && (scatterNode.HasValue("name") ? m.scatter.scatterName == scatterNode.GetValue("name") : false)) " is 164.
Long Statement,ModLoader,VertexPlanet,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VertexPlanet.cs,PostApply,The length of the statement  "                            loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && ((lcNode.HasValue("name") ? m.landClass.name == lcNode.GetValue("name") : true) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 256.
Long Statement,ModLoader,VoronoiCraters,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\VoronoiCraters.cs,Create,The length of the statement  "                    PQSMod_VoronoiCraters clone = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' "Mun").pqsVersion.GetComponentsInChildren<PQSMod_VoronoiCraters>(true)[0] as PQSMod_VoronoiCraters; " is 193.
Long Statement,ModLoader,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClassNoise) && ((lcNode.HasValue("name") ? m.landClassNoise.name == lcNode.GetValue("name") : false) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 267.
Long Statement,ModLoader,HeightColorMapNoise,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMapNoise.cs,PostApply,The length of the statement  "                    PQSMod_HeightColorMapNoise.LandClass[] landClassesArray = landClasses.Select(loader => loader.landClassNoise).ToArray(); " is 120.
Long Statement,ModLoader,HeightColorMap2,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap2.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass2) && ((lcNode.HasValue("name") ? m.landClass2.name == lcNode.GetValue("name") : false) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 259.
Long Statement,ModLoader,HeightColorMap,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\HeightColorMap.cs,Apply,The length of the statement  "                                loader = landClasses.Where(m => !patchedClasses.Contains(m.landClass) && ((lcNode.HasValue("name") ? m.landClass.name == lcNode.GetValue("name") : true) || (lcNode.HasValue("index") ? landClasses.IndexOf(m).ToString() == lcNode.GetValue("index") : false))) " is 256.
Complex Conditional,Configuration,Body,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Body.cs,PostApply,The conditional expression  "!scaledVersion.deferMesh &&                      (((template != null) && (Math.Abs(template.radius - generatedBody.celestialBody.Radius) > 1.0 || template.type != scaledVersion.type.value))                      || template == null || debug.update)"  is complex.
Complex Conditional,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The conditional expression  "camPQS != null && transform1 != null && transform2 != null && surfaceObj != null"  is complex.
Complex Conditional,Kopernicus,Body,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Body.cs,PostApply,The conditional expression  "!scaledVersion.deferMesh &&                      (((template != null) && (Math.Abs(template.radius - generatedBody.celestialBody.Radius) > 1.0 || template.type != scaledVersion.type.value))                      || template == null || debug.update)"  is complex.
Magic Number,Configuration,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Configuration,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Configuration,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Configuration,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Configuration,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxCache = 512;
Magic Number,Configuration,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxCacheDelta = 32;
Magic Number,Configuration,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxSpeed = 1000;
Magic Number,Configuration,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,Configuration,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,Configuration,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,Configuration,LandClassLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassLoader,The following statement contains a magic number: range.lerpRange.endEnd = 2;
Magic Number,Configuration,LandClassLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassLoader,The following statement contains a magic number: range.lerpRange.endStart = 2;
Magic Number,Configuration,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,OceanLoader,The following statement contains a magic number: uvs.order = 999999;
Magic Number,Configuration,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,Apply,The following statement contains a magic number: systemPrefab.mainToolbarSelected = 2;
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The following statement contains a magic number: celestialBody.gMagnitudeAtCenter = celestialBody.GeeASL * 9.80665 * rsq;
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The following statement contains a magic number: celestialBody.Mass = celestialBody.gravParameter * (1 / 6.67408E-11);
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.Mass * (6.67408E-11 / 9.80665) / rsq;
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.Mass * (6.67408E-11 / 9.80665) / rsq;
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.gMagnitudeAtCenter = celestialBody.GeeASL * 9.80665 * rsq;
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GravParamToOthers,The following statement contains a magic number: celestialBody.Mass = celestialBody.gravParameter * (1 / 6.67408E-11);
Magic Number,Configuration,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GravParamToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.gravParameter / 9.80665 / rsq;
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Configuration,MapSOParser_GreyScale<T>,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Parser\BuiltinTypeParsers.cs,SetFromString,The following statement contains a magic number: if (s.StartsWith("BUILTIN/"))                  {                      s = s.Substring(8);                      value = Utility.FindMapSO<T>(s);                  }                  else                  {                      // are we on-demand? Don't load now.                      if (useOnDemand)                      {                          if (Utility.TextureExists(s))                          {                              String mapName = s;                              mapName = mapName.Substring(s.LastIndexOf('/') + 1);                              Int32 lastDot = mapName.LastIndexOf('.');                              if (lastDot > 0)                                  mapName = mapName.Substring(0' lastDot);                              if (typeof(T) == typeof(CBAttributeMapSO))                              {                                  CBAttributeMapSODemand valCB = ScriptableObject.CreateInstance<CBAttributeMapSODemand>();                                  valCB.Path = s;                                  valCB.Depth = MapSO.MapDepth.Greyscale;                                  valCB.name = mapName + " (CBG) for " + generatedBody.name;                                  valCB.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valCB);                                  value = valCB as T;                              }                              else                              {                                  MapSODemand valMap = ScriptableObject.CreateInstance<MapSODemand>();                                  valMap.Path = s;                                  valMap.Depth = MapSO.MapDepth.Greyscale;                                  valMap.name = mapName + " (G) for " + generatedBody.name;                                  valMap.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valMap);                                  value = valMap as T;                              }                          }                      }                      else // Load the texture                      {                          Texture2D map = Utility.LoadTexture(s' false' false' false);                          if (map != null)                          {                              // Create a new map script object                              value = ScriptableObject.CreateInstance<T>();                              value.CreateMap(MapSO.MapDepth.Greyscale' map);                              UnityEngine.Object.DestroyImmediate(map);                          }                      }                  }
Magic Number,Configuration,MapSOParser_RGB<T>,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Parser\BuiltinTypeParsers.cs,SetFromString,The following statement contains a magic number: if (s.StartsWith("BUILTIN/"))                  {                      s = s.Substring(8);                      value = Utility.FindMapSO<T>(s);                  }                  else                  {                      // check if OnDemand.                      if (useOnDemand)                      {                          if (Utility.TextureExists(s))                          {                              String mapName = s;                              mapName = mapName.Substring(s.LastIndexOf('/') + 1);                              Int32 lastDot = mapName.LastIndexOf('.');                              if (lastDot > 0)                                  mapName = mapName.Substring(0' lastDot);                              if (typeof(T) == typeof(CBAttributeMapSO))                              {                                  CBAttributeMapSODemand valCB = ScriptableObject.CreateInstance<CBAttributeMapSODemand>();                                  valCB.Path = s;                                  valCB.Depth = MapSO.MapDepth.RGB;                                  valCB.name = mapName + " (CBRGB) for " + generatedBody.name;                                  valCB.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valCB);                                  value = valCB as T;                              }                              else                              {                                  OnDemand.MapSODemand valMap = ScriptableObject.CreateInstance<MapSODemand>();                                  valMap.Path = s;                                  valMap.Depth = MapSO.MapDepth.RGB;                                  valMap.name = mapName + " (RGB) for " + generatedBody.name;                                  valMap.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valMap);                                  value = valMap as T;                              }                          }                      }                      else                      {                          // Load the texture                          Texture2D map = Utility.LoadTexture(s' false' false' false);                          if (map != null)                          {                              // Create a new map script object                              value = ScriptableObject.CreateInstance<T>();                              value.CreateMap(MapSO.MapDepth.RGB' map);                              UnityEngine.Object.DestroyImmediate(map);                          }                      }                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: transform.deactivateAltitude = 115000;
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: transform.order = 10;
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: lightDirection.order = 100;
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: uvs.order = 999999;
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: collider.order = 100;
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Configuration,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Kopernicus,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Kopernicus,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Kopernicus,AtmosphereFromGroundLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\AtmosphereFromGroundLoader.cs,Apply,The following statement contains a magic number: atmosphereFromGround.invWaveLength = new Color((Single)(1d / Math.Pow(atmosphereFromGround.waveLength[0]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[1]' 4))' (Single)(1d / Math.Pow(atmosphereFromGround.waveLength[2]' 4))' 0.5f);
Magic Number,Kopernicus,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxCache = 512;
Magic Number,Kopernicus,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxCacheDelta = 32;
Magic Number,Kopernicus,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxSpeed = 1000;
Magic Number,Kopernicus,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,Kopernicus,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,Kopernicus,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,Kopernicus,LandClassLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassLoader,The following statement contains a magic number: range.lerpRange.endEnd = 2;
Magic Number,Kopernicus,LandClassLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassLoader,The following statement contains a magic number: range.lerpRange.endStart = 2;
Magic Number,Kopernicus,OceanLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OceanLoader.cs,OceanLoader,The following statement contains a magic number: uvs.order = 999999;
Magic Number,Kopernicus,CompatibilityChecker,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\CompatibilityChecker.cs,IsWin64,The following statement contains a magic number: return (IntPtr.Size == 8) && (Environment.OSVersion.Platform == PlatformID.Win32NT);
Magic Number,Kopernicus,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: const Int32 c_PeHeaderOffset = 60;
Magic Number,Kopernicus,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: const Int32 c_LinkerTimestampOffset = 8;
Magic Number,Kopernicus,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: byte[] b = new byte[2048];
Magic Number,Kopernicus,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: try                  {                      s = new FileStream(filePath' FileMode.Open' FileAccess.Read);                      s.Read(b' 0' 2048);                  }                  finally                  {                      if (s != null)                      {                          s.Close();                      }                  }
Magic Number,Kopernicus,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: DateTime dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,AddPlanets,The following statement contains a magic number: FieldInfo list = typeof(RDArchivesController).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Skip(7).FirstOrDefault();
Magic Number,Kopernicus,RnDFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RnDFixer.cs,AddPlanets,The following statement contains a magic number: MethodInfo add = typeof(RDArchivesController).GetMethods(BindingFlags.Instance | BindingFlags.NonPublic)?.Skip(26)?.FirstOrDefault();
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies)              {                  // More stars                  if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController>(true).Length > 0)                  {                      GameObject starObj = Instantiate(Sun.Instance.gameObject);                      KopernicusStar star_ = starObj.GetComponent<KopernicusStar>();                      star_.sun = body;                      starObj.transform.parent = Sun.Instance.transform.parent;                      starObj.name = body.name;                      starObj.transform.localPosition = Vector3.zero;                      starObj.transform.localRotation = Quaternion.identity;                      starObj.transform.localScale = Vector3.one;                      starObj.transform.position = body.position;                      starObj.transform.rotation = body.rotation;                        GameObject flareObj = Instantiate(SunFlare.Instance.gameObject);                      KopernicusSunFlare flare_ = flareObj.GetComponent<KopernicusSunFlare>();                      star_.lensFlare = flare_;                      flareObj.transform.parent = SunFlare.Instance.transform.parent;                      flareObj.name = body.name;                      flareObj.transform.localPosition = Vector3.zero;                      flareObj.transform.localRotation = Quaternion.identity;                      flareObj.transform.localScale = Vector3.one;                      flareObj.transform.position = body.position;                      flareObj.transform.rotation = body.rotation;                  }                    // Post spawn patcher                  if (body.Has("orbitPatches"))                  {                      ConfigNode orbitNode = body.Get<ConfigNode>("orbitPatches");                      OrbitLoader loader = new OrbitLoader(body);                      Parser.LoadObjectFromConfigurationNode(loader' orbitNode' "Kopernicus");                      body.orbitDriver.orbit = loader.orbit;                      CelestialBody oldRef = body.referenceBody;                      body.referenceBody.orbitingBodies.Remove(body);                        CelestialBody newRef = PSystemManager.Instance.localBodies.FirstOrDefault(b => b.transform.name == loader.referenceBody);                      if (newRef != null)                      {                          body.orbit.referenceBody = body.orbitDriver.referenceBody = newRef;                      }                      else                      {                          // Log the exception                          Debug.Log("Exception: PostSpawnOrbit reference body for \"" + body.name + "\" could not be found. Missing body name is \"" + loader.referenceBody + "\".");                            // Open the Warning popup                          Injector.DisplayWarning();                      }                        fixes.Add(body.transform.name' new KeyValuePair<CelestialBody' CelestialBody>(oldRef' body.referenceBody));                      body.referenceBody.orbitingBodies.Add(body);                      body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy(cb => cb.orbit.semiMajorAxis).ToList();                      body.orbit.Init();                      body.orbitDriver.UpdateOrbit();                        // Calculations                      if (!body.Has("sphereOfInfluence"))                          body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                      if (!body.Has("hillSphere"))                          body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);                      if (body.solarRotationPeriod)                      {                          Double rotPeriod = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;                          Double num1 = Math.PI * 2 * Math.Sqrt(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);                          body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod); ;                      }                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies)              {                  // More stars                  if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController>(true).Length > 0)                  {                      GameObject starObj = Instantiate(Sun.Instance.gameObject);                      KopernicusStar star_ = starObj.GetComponent<KopernicusStar>();                      star_.sun = body;                      starObj.transform.parent = Sun.Instance.transform.parent;                      starObj.name = body.name;                      starObj.transform.localPosition = Vector3.zero;                      starObj.transform.localRotation = Quaternion.identity;                      starObj.transform.localScale = Vector3.one;                      starObj.transform.position = body.position;                      starObj.transform.rotation = body.rotation;                        GameObject flareObj = Instantiate(SunFlare.Instance.gameObject);                      KopernicusSunFlare flare_ = flareObj.GetComponent<KopernicusSunFlare>();                      star_.lensFlare = flare_;                      flareObj.transform.parent = SunFlare.Instance.transform.parent;                      flareObj.name = body.name;                      flareObj.transform.localPosition = Vector3.zero;                      flareObj.transform.localRotation = Quaternion.identity;                      flareObj.transform.localScale = Vector3.one;                      flareObj.transform.position = body.position;                      flareObj.transform.rotation = body.rotation;                  }                    // Post spawn patcher                  if (body.Has("orbitPatches"))                  {                      ConfigNode orbitNode = body.Get<ConfigNode>("orbitPatches");                      OrbitLoader loader = new OrbitLoader(body);                      Parser.LoadObjectFromConfigurationNode(loader' orbitNode' "Kopernicus");                      body.orbitDriver.orbit = loader.orbit;                      CelestialBody oldRef = body.referenceBody;                      body.referenceBody.orbitingBodies.Remove(body);                        CelestialBody newRef = PSystemManager.Instance.localBodies.FirstOrDefault(b => b.transform.name == loader.referenceBody);                      if (newRef != null)                      {                          body.orbit.referenceBody = body.orbitDriver.referenceBody = newRef;                      }                      else                      {                          // Log the exception                          Debug.Log("Exception: PostSpawnOrbit reference body for \"" + body.name + "\" could not be found. Missing body name is \"" + loader.referenceBody + "\".");                            // Open the Warning popup                          Injector.DisplayWarning();                      }                        fixes.Add(body.transform.name' new KeyValuePair<CelestialBody' CelestialBody>(oldRef' body.referenceBody));                      body.referenceBody.orbitingBodies.Add(body);                      body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy(cb => cb.orbit.semiMajorAxis).ToList();                      body.orbit.Init();                      body.orbitDriver.UpdateOrbit();                        // Calculations                      if (!body.Has("sphereOfInfluence"))                          body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                      if (!body.Has("hillSphere"))                          body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);                      if (body.solarRotationPeriod)                      {                          Double rotPeriod = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;                          Double num1 = Math.PI * 2 * Math.Sqrt(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);                          body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod); ;                      }                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies)              {                  // More stars                  if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController>(true).Length > 0)                  {                      GameObject starObj = Instantiate(Sun.Instance.gameObject);                      KopernicusStar star_ = starObj.GetComponent<KopernicusStar>();                      star_.sun = body;                      starObj.transform.parent = Sun.Instance.transform.parent;                      starObj.name = body.name;                      starObj.transform.localPosition = Vector3.zero;                      starObj.transform.localRotation = Quaternion.identity;                      starObj.transform.localScale = Vector3.one;                      starObj.transform.position = body.position;                      starObj.transform.rotation = body.rotation;                        GameObject flareObj = Instantiate(SunFlare.Instance.gameObject);                      KopernicusSunFlare flare_ = flareObj.GetComponent<KopernicusSunFlare>();                      star_.lensFlare = flare_;                      flareObj.transform.parent = SunFlare.Instance.transform.parent;                      flareObj.name = body.name;                      flareObj.transform.localPosition = Vector3.zero;                      flareObj.transform.localRotation = Quaternion.identity;                      flareObj.transform.localScale = Vector3.one;                      flareObj.transform.position = body.position;                      flareObj.transform.rotation = body.rotation;                  }                    // Post spawn patcher                  if (body.Has("orbitPatches"))                  {                      ConfigNode orbitNode = body.Get<ConfigNode>("orbitPatches");                      OrbitLoader loader = new OrbitLoader(body);                      Parser.LoadObjectFromConfigurationNode(loader' orbitNode' "Kopernicus");                      body.orbitDriver.orbit = loader.orbit;                      CelestialBody oldRef = body.referenceBody;                      body.referenceBody.orbitingBodies.Remove(body);                        CelestialBody newRef = PSystemManager.Instance.localBodies.FirstOrDefault(b => b.transform.name == loader.referenceBody);                      if (newRef != null)                      {                          body.orbit.referenceBody = body.orbitDriver.referenceBody = newRef;                      }                      else                      {                          // Log the exception                          Debug.Log("Exception: PostSpawnOrbit reference body for \"" + body.name + "\" could not be found. Missing body name is \"" + loader.referenceBody + "\".");                            // Open the Warning popup                          Injector.DisplayWarning();                      }                        fixes.Add(body.transform.name' new KeyValuePair<CelestialBody' CelestialBody>(oldRef' body.referenceBody));                      body.referenceBody.orbitingBodies.Add(body);                      body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy(cb => cb.orbit.semiMajorAxis).ToList();                      body.orbit.Init();                      body.orbitDriver.UpdateOrbit();                        // Calculations                      if (!body.Has("sphereOfInfluence"))                          body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                      if (!body.Has("hillSphere"))                          body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);                      if (body.solarRotationPeriod)                      {                          Double rotPeriod = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;                          Double num1 = Math.PI * 2 * Math.Sqrt(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);                          body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod); ;                      }                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,Start,The following statement contains a magic number: foreach (CelestialBody body in PSystemManager.Instance.localBodies)              {                  // More stars                  if (body.flightGlobalsIndex != 0 && body.scaledBody.GetComponentsInChildren<SunShaderController>(true).Length > 0)                  {                      GameObject starObj = Instantiate(Sun.Instance.gameObject);                      KopernicusStar star_ = starObj.GetComponent<KopernicusStar>();                      star_.sun = body;                      starObj.transform.parent = Sun.Instance.transform.parent;                      starObj.name = body.name;                      starObj.transform.localPosition = Vector3.zero;                      starObj.transform.localRotation = Quaternion.identity;                      starObj.transform.localScale = Vector3.one;                      starObj.transform.position = body.position;                      starObj.transform.rotation = body.rotation;                        GameObject flareObj = Instantiate(SunFlare.Instance.gameObject);                      KopernicusSunFlare flare_ = flareObj.GetComponent<KopernicusSunFlare>();                      star_.lensFlare = flare_;                      flareObj.transform.parent = SunFlare.Instance.transform.parent;                      flareObj.name = body.name;                      flareObj.transform.localPosition = Vector3.zero;                      flareObj.transform.localRotation = Quaternion.identity;                      flareObj.transform.localScale = Vector3.one;                      flareObj.transform.position = body.position;                      flareObj.transform.rotation = body.rotation;                  }                    // Post spawn patcher                  if (body.Has("orbitPatches"))                  {                      ConfigNode orbitNode = body.Get<ConfigNode>("orbitPatches");                      OrbitLoader loader = new OrbitLoader(body);                      Parser.LoadObjectFromConfigurationNode(loader' orbitNode' "Kopernicus");                      body.orbitDriver.orbit = loader.orbit;                      CelestialBody oldRef = body.referenceBody;                      body.referenceBody.orbitingBodies.Remove(body);                        CelestialBody newRef = PSystemManager.Instance.localBodies.FirstOrDefault(b => b.transform.name == loader.referenceBody);                      if (newRef != null)                      {                          body.orbit.referenceBody = body.orbitDriver.referenceBody = newRef;                      }                      else                      {                          // Log the exception                          Debug.Log("Exception: PostSpawnOrbit reference body for \"" + body.name + "\" could not be found. Missing body name is \"" + loader.referenceBody + "\".");                            // Open the Warning popup                          Injector.DisplayWarning();                      }                        fixes.Add(body.transform.name' new KeyValuePair<CelestialBody' CelestialBody>(oldRef' body.referenceBody));                      body.referenceBody.orbitingBodies.Add(body);                      body.referenceBody.orbitingBodies = body.referenceBody.orbitingBodies.OrderBy(cb => cb.orbit.semiMajorAxis).ToList();                      body.orbit.Init();                      body.orbitDriver.UpdateOrbit();                        // Calculations                      if (!body.Has("sphereOfInfluence"))                          body.sphereOfInfluence = body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4);                      if (!body.Has("hillSphere"))                          body.hillSphere = body.orbit.semiMajorAxis * (1 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.333333333333333);                      if (body.solarRotationPeriod)                      {                          Double rotPeriod = Utility.FindBody(PSystemManager.Instance.systemPrefab.rootBody' body.transform.name).celestialBody.rotationPeriod;                          Double num1 = Math.PI * 2 * Math.Sqrt(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3) / body.orbit.referenceBody.gravParameter);                          body.rotationPeriod = rotPeriod * num1 / (num1 + rotPeriod); ;                      }                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (MapView.MapIsEnabled)              {                  if (fields == null)                  {                      FieldInfo mode_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType.IsEnum && f.FieldType.IsNested);                      FieldInfo context_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType == typeof(MapContextMenu));                      FieldInfo cast_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType == typeof(OrbitRenderer.OrbitCastHit));                      fields = new FieldInfo[] { mode_f' context_f' cast_f };                  }                  if (FlightGlobals.ActiveVessel != null)                  {                      OrbitTargeter targeter = FlightGlobals.ActiveVessel.orbitTargeter;                      if (targeter == null)                          return;                      Int32 mode = (Int32)fields[0].GetValue(targeter);                      if (mode == 2)                      {                          OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields[2].GetValue(targeter);                          CelestialBody body = PSystemManager.Instance.localBodies.Find(b => b.name == cast.or?.discoveryInfo?.name?.Value);                          if (body == null) return;                          if (body.Has("barycenter") || body.Has("notSelectable"))                          {                              if (cast.driver?.Targetable == null) return;                              MapContextMenu context = MapContextMenu.Create(body.name' new Rect(0.5f' 0.5f' 300f' 50f)' cast' () =>                              {                                  fields[0].SetValue(targeter' 0);                                  fields[1].SetValue(targeter' null);                              }' new SetAsTarget(cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));                              fields[1].SetValue(targeter' context);                          }                      }                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,LateUpdate,The following statement contains a magic number: if (MapView.MapIsEnabled)              {                  if (fields == null)                  {                      FieldInfo mode_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType.IsEnum && f.FieldType.IsNested);                      FieldInfo context_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType == typeof(MapContextMenu));                      FieldInfo cast_f = typeof(OrbitTargeter).GetFields(BindingFlags.NonPublic | BindingFlags.Instance).FirstOrDefault(f => f.FieldType == typeof(OrbitRenderer.OrbitCastHit));                      fields = new FieldInfo[] { mode_f' context_f' cast_f };                  }                  if (FlightGlobals.ActiveVessel != null)                  {                      OrbitTargeter targeter = FlightGlobals.ActiveVessel.orbitTargeter;                      if (targeter == null)                          return;                      Int32 mode = (Int32)fields[0].GetValue(targeter);                      if (mode == 2)                      {                          OrbitRenderer.OrbitCastHit cast = (OrbitRenderer.OrbitCastHit)fields[2].GetValue(targeter);                          CelestialBody body = PSystemManager.Instance.localBodies.Find(b => b.name == cast.or?.discoveryInfo?.name?.Value);                          if (body == null) return;                          if (body.Has("barycenter") || body.Has("notSelectable"))                          {                              if (cast.driver?.Targetable == null) return;                              MapContextMenu context = MapContextMenu.Create(body.name' new Rect(0.5f' 0.5f' 300f' 50f)' cast' () =>                              {                                  fields[0].SetValue(targeter' 0);                                  fields[1].SetValue(targeter' null);                              }' new SetAsTarget(cast.driver.Targetable' () => FlightGlobals.fetch.VesselTarget));                              fields[1].SetValue(targeter' context);                          }                      }                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixZooming,The following statement contains a magic number: if (HighLogic.LoadedScene == GameScenes.TRACKSTATION || MapView.MapIsEnabled)              {                  MapObject target = PlanetariumCamera.fetch.target;                  if (target?.celestialBody != null)                  {                      CelestialBody body = target.celestialBody;                      if (body.Has("maxZoom"))                          PlanetariumCamera.fetch.minDistance = body.Get<Single>("maxZoom");                      else                          PlanetariumCamera.fetch.minDistance = 10;                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: if (logic.areas.Length < 2)              {                  Debug.LogError("[Kopernicus] Not enough bodies");                  return;              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: for (Int32 i = 0; i < planetCB.scaledBody.transform.childCount; i++)              {                  // Just clone everything                  Transform t = planetCB.scaledBody.transform.GetChild(i);                  if (t.gameObject.GetComponent<AtmosphereFromGround>())                      continue;                  GameObject newT = Instantiate(t.gameObject) as GameObject;                  newT.transform.parent = menuPlanet.transform;                  newT.layer = 0;                  newT.transform.localPosition = Vector3.zero;                  newT.transform.localRotation = Quaternion.identity;                  newT.transform.localScale = (Single)(1008 / planetCB.Radius) * Vector3.one;              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: foreach (PSystemBody moon in planet.children)              {                  // Grab the CeletialBody of the moon                  CelestialBody moonCB = PSystemManager.Instance.localBodies.Find(b => b.GetTransform().name == moon.name);                    // Create the Rotation-Transforms                  GameObject menuMoonPivot = new GameObject(moon.name + " Pivot");                  menuMoonPivot.gameObject.layer = 0;                  menuMoonPivot.transform.position = menuPlanet.transform.position;                    // Still funny...                  Rotato munRotato = menuMoonPivot.AddComponent<Rotato>();                  Rotato refRotato = mun.GetComponent<Rotato>();                  munRotato.speed = (refRotato.speed / 542.494239600754f) * (Single)moonCB.GetOrbit().getOrbitalSpeedAtDistance(moonCB.GetOrbit().semiMajorAxis);                    // Clone the scaledVersion and attach it to the pivot                  GameObject menuMoon = Instantiate(moon.scaledVersion) as GameObject;                  menuMoon.transform.parent = menuMoonPivot.transform;                    // Move and scale the menuMoon correctly                  menuMoon.transform.localPosition = new Vector3(-5000f * (Single)(moonCB.GetOrbit().semiMajorAxis / 12000000.0)' 0f' 0f);                  menuMoon.transform.localScale *= 7f;                    // Destroy stuff                  DestroyImmediate(menuMoon.GetComponent<ScaledSpaceFader>());                  DestroyImmediate(menuMoon.GetComponent<SphereCollider>());                  DestroyImmediate(menuMoon.GetComponentInChildren<AtmosphereFromGround>());                  DestroyImmediate(menuMoon.GetComponent<MaterialSetDirection>());                    // More Rotato                  Rotato moonRotato = menuMoon.AddComponent<Rotato>();                  moonRotato.speed = -0.005f / (Single)(moonCB.rotationPeriod / 400.0);                    // Apply orbital stuff                  menuMoon.transform.Rotate(0f' (Single)moonCB.orbitDriver.orbit.LAN' 0f);                  menuMoon.transform.Rotate(0f' 0f' (Single)moonCB.orbitDriver.orbit.inclination);                  menuMoon.transform.Rotate(0f' (Single)moonCB.orbitDriver.orbit.argumentOfPeriapsis' 0f);                    // And set the layer to 0                  menuMoon.layer = 0;                    // Patch the material' because Mods like TextureReplacer run post spawn' and we'd overwrite their changes                  menuMoon.GetComponent<Renderer>().sharedMaterial = moonCB.scaledBody.GetComponent<Renderer>().sharedMaterial;                    // Copy EVE 7.4 clouds / Rings                  for (Int32 i = 0; i < moonCB.scaledBody.transform.childCount; i++)                  {                      Transform t = moonCB.scaledBody.transform.GetChild(i);                      if (t.gameObject.GetComponent<AtmosphereFromGround>())                          continue;                      GameObject newT = Instantiate(t.gameObject) as GameObject;                      newT.transform.parent = menuMoon.transform;                      newT.layer = 0;                      newT.transform.localPosition = Vector3.zero;                      newT.transform.localRotation = Quaternion.identity;                      newT.transform.localScale = (Single)(1008 / moonCB.Radius) * Vector3.one;                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: foreach (PSystemBody moon in planet.children)              {                  // Grab the CeletialBody of the moon                  CelestialBody moonCB = PSystemManager.Instance.localBodies.Find(b => b.GetTransform().name == moon.name);                    // Create the Rotation-Transforms                  GameObject menuMoonPivot = new GameObject(moon.name + " Pivot");                  menuMoonPivot.gameObject.layer = 0;                  menuMoonPivot.transform.position = menuPlanet.transform.position;                    // Still funny...                  Rotato munRotato = menuMoonPivot.AddComponent<Rotato>();                  Rotato refRotato = mun.GetComponent<Rotato>();                  munRotato.speed = (refRotato.speed / 542.494239600754f) * (Single)moonCB.GetOrbit().getOrbitalSpeedAtDistance(moonCB.GetOrbit().semiMajorAxis);                    // Clone the scaledVersion and attach it to the pivot                  GameObject menuMoon = Instantiate(moon.scaledVersion) as GameObject;                  menuMoon.transform.parent = menuMoonPivot.transform;                    // Move and scale the menuMoon correctly                  menuMoon.transform.localPosition = new Vector3(-5000f * (Single)(moonCB.GetOrbit().semiMajorAxis / 12000000.0)' 0f' 0f);                  menuMoon.transform.localScale *= 7f;                    // Destroy stuff                  DestroyImmediate(menuMoon.GetComponent<ScaledSpaceFader>());                  DestroyImmediate(menuMoon.GetComponent<SphereCollider>());                  DestroyImmediate(menuMoon.GetComponentInChildren<AtmosphereFromGround>());                  DestroyImmediate(menuMoon.GetComponent<MaterialSetDirection>());                    // More Rotato                  Rotato moonRotato = menuMoon.AddComponent<Rotato>();                  moonRotato.speed = -0.005f / (Single)(moonCB.rotationPeriod / 400.0);                    // Apply orbital stuff                  menuMoon.transform.Rotate(0f' (Single)moonCB.orbitDriver.orbit.LAN' 0f);                  menuMoon.transform.Rotate(0f' 0f' (Single)moonCB.orbitDriver.orbit.inclination);                  menuMoon.transform.Rotate(0f' (Single)moonCB.orbitDriver.orbit.argumentOfPeriapsis' 0f);                    // And set the layer to 0                  menuMoon.layer = 0;                    // Patch the material' because Mods like TextureReplacer run post spawn' and we'd overwrite their changes                  menuMoon.GetComponent<Renderer>().sharedMaterial = moonCB.scaledBody.GetComponent<Renderer>().sharedMaterial;                    // Copy EVE 7.4 clouds / Rings                  for (Int32 i = 0; i < moonCB.scaledBody.transform.childCount; i++)                  {                      Transform t = moonCB.scaledBody.transform.GetChild(i);                      if (t.gameObject.GetComponent<AtmosphereFromGround>())                          continue;                      GameObject newT = Instantiate(t.gameObject) as GameObject;                      newT.transform.parent = menuMoon.transform;                      newT.layer = 0;                      newT.transform.localPosition = Vector3.zero;                      newT.transform.localRotation = Quaternion.identity;                      newT.transform.localScale = (Single)(1008 / moonCB.Radius) * Vector3.one;                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,UpdateMenu,The following statement contains a magic number: foreach (PSystemBody moon in planet.children)              {                  // Grab the CeletialBody of the moon                  CelestialBody moonCB = PSystemManager.Instance.localBodies.Find(b => b.GetTransform().name == moon.name);                    // Create the Rotation-Transforms                  GameObject menuMoonPivot = new GameObject(moon.name + " Pivot");                  menuMoonPivot.gameObject.layer = 0;                  menuMoonPivot.transform.position = menuPlanet.transform.position;                    // Still funny...                  Rotato munRotato = menuMoonPivot.AddComponent<Rotato>();                  Rotato refRotato = mun.GetComponent<Rotato>();                  munRotato.speed = (refRotato.speed / 542.494239600754f) * (Single)moonCB.GetOrbit().getOrbitalSpeedAtDistance(moonCB.GetOrbit().semiMajorAxis);                    // Clone the scaledVersion and attach it to the pivot                  GameObject menuMoon = Instantiate(moon.scaledVersion) as GameObject;                  menuMoon.transform.parent = menuMoonPivot.transform;                    // Move and scale the menuMoon correctly                  menuMoon.transform.localPosition = new Vector3(-5000f * (Single)(moonCB.GetOrbit().semiMajorAxis / 12000000.0)' 0f' 0f);                  menuMoon.transform.localScale *= 7f;                    // Destroy stuff                  DestroyImmediate(menuMoon.GetComponent<ScaledSpaceFader>());                  DestroyImmediate(menuMoon.GetComponent<SphereCollider>());                  DestroyImmediate(menuMoon.GetComponentInChildren<AtmosphereFromGround>());                  DestroyImmediate(menuMoon.GetComponent<MaterialSetDirection>());                    // More Rotato                  Rotato moonRotato = menuMoon.AddComponent<Rotato>();                  moonRotato.speed = -0.005f / (Single)(moonCB.rotationPeriod / 400.0);                    // Apply orbital stuff                  menuMoon.transform.Rotate(0f' (Single)moonCB.orbitDriver.orbit.LAN' 0f);                  menuMoon.transform.Rotate(0f' 0f' (Single)moonCB.orbitDriver.orbit.inclination);                  menuMoon.transform.Rotate(0f' (Single)moonCB.orbitDriver.orbit.argumentOfPeriapsis' 0f);                    // And set the layer to 0                  menuMoon.layer = 0;                    // Patch the material' because Mods like TextureReplacer run post spawn' and we'd overwrite their changes                  menuMoon.GetComponent<Renderer>().sharedMaterial = moonCB.scaledBody.GetComponent<Renderer>().sharedMaterial;                    // Copy EVE 7.4 clouds / Rings                  for (Int32 i = 0; i < moonCB.scaledBody.transform.childCount; i++)                  {                      Transform t = moonCB.scaledBody.transform.GetChild(i);                      if (t.gameObject.GetComponent<AtmosphereFromGround>())                          continue;                      GameObject newT = Instantiate(t.gameObject) as GameObject;                      newT.transform.parent = menuMoon.transform;                      newT.layer = 0;                      newT.transform.localPosition = Vector3.zero;                      newT.transform.localRotation = Quaternion.identity;                      newT.transform.localScale = (Single)(1008 / moonCB.Radius) * Vector3.one;                  }              }
Magic Number,Kopernicus,RuntimeUtility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\RuntimeUtility.cs,FixCameras,The following statement contains a magic number: foreach (SpaceCenterCamera2 cam in Resources.FindObjectsOfTypeAll<SpaceCenterCamera2>())              {                  if (ksc.repositionToSphere || ksc.repositionToSphereSurface)                  {                      Double normalHeight = body.pqsController.GetSurfaceHeight((Vector3d)ksc.repositionRadial.normalized) - body.Radius;                      if (ksc.repositionToSphereSurface)                      {                          normalHeight += ksc.repositionRadiusOffset;                      }                      cam.altitudeInitial = 0f - (Single)normalHeight;                  }                  else                  {                      cam.altitudeInitial = 0f - (Single)ksc.repositionRadiusOffset;                  }                    // re-implement cam.Start()                  // fields                  Type camType = cam.GetType();                  FieldInfo camPQS = null;                  FieldInfo transform1 = null;                  FieldInfo transform2 = null;                  FieldInfo surfaceObj = null;                    // get fields                  FieldInfo[] fields = camType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);                  for (Int32 i = 0; i < fields.Length; ++i)                  {                      FieldInfo fi = fields[i];                      if (fi.FieldType == typeof(PQS))                          camPQS = fi;                      else if (fi.FieldType == typeof(Transform) && transform1 == null)                          transform1 = fi;                      else if (fi.FieldType == typeof(Transform) && transform2 == null)                          transform2 = fi;                      else if (fi.FieldType == typeof(SurfaceObject))                          surfaceObj = fi;                  }                  if (camPQS != null && transform1 != null && transform2 != null && surfaceObj != null)                  {                      camPQS.SetValue(cam' body.pqsController);                        Transform initialTransform = body.pqsController.transform.Find(cam.initialPositionTransformName);                      if (initialTransform != null)                      {                          transform1.SetValue(cam' initialTransform);                          cam.transform.NestToParent(initialTransform);                      }                      else                      {                          Debug.Log("[Kopernicus] SSC2 can't find initial transform!");                          Transform initialTrfOrig = transform1.GetValue(cam) as Transform;                          if (initialTrfOrig != null)                              cam.transform.NestToParent(initialTrfOrig);                          else                              Debug.Log("[Kopernicus] SSC2 own initial transform null!");                      }                      Transform camTransform = transform2.GetValue(cam) as Transform;                      if (camTransform != null)                      {                          camTransform.NestToParent(cam.transform);                          if (FlightCamera.fetch != null && FlightCamera.fetch.transform != null)                          {                              FlightCamera.fetch.transform.NestToParent(camTransform);                          }                          if (LocalSpace.fetch != null && LocalSpace.fetch.transform != null)                          {                              LocalSpace.fetch.transform.position = camTransform.position;                          }                      }                      else                          Debug.Log("[Kopernicus] SSC2 cam transform null!");                        cam.ResetCamera();                        SurfaceObject so = surfaceObj.GetValue(cam) as SurfaceObject;                      if (so != null)                      {                          so.ReturnToParent();                          DestroyImmediate(so);                      }                      else                          Debug.Log("[Kopernicus] SSC2 surfaceObject is null!");                        surfaceObj.SetValue(cam' SurfaceObject.Create(initialTransform.gameObject' FlightGlobals.currentMainBody' 3' KFSMUpdateMode.FIXEDUPDATE));                        Debug.Log("[Kopernicus] Fixed SpaceCenterCamera");                  }                  else                      Debug.Log("[Kopernicus] ERROR fixing space center camera' could not find some fields");              }
Magic Number,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,UpdateAsteroid,The following statement contains a magic number: if (spaceObjects.Any())              {                  Vessel vessel = spaceObjects.First();                  Debug.Log("[Kopernicus] " + vessel.vesselName + " has been untracked for too long and is now lost.");                  vessel.Die();              }              else if (GameVariables.Instance.UnlockedSpaceObjectDiscovery(ScenarioUpgradeableFacilities.GetFacilityLevel(SpaceCenterFacility.TrackingStation)))              {                  Int32 untrackedCount = FlightGlobals.Vessels.Count(v => !v.DiscoveryInfo.HaveKnowledgeAbout(DiscoveryLevels.StateVectors)) - spaceObjects.Count;                  Int32 max = Mathf.Max(untrackedCount' limit);                  if (max > untrackedCount)                  {                      if (Random.Range(0' 100) < asteroid.probability)                      {                          uint seed = (uint)Random.Range(0' Int32.MaxValue);                          Random.InitState((Int32)seed);                          SpawnAsteroid(asteroid' seed);                      }                      else                      {                          Debug.Log("[Kopernicus] No new objects this time. (Probablility is " + asteroid.probability.value + "%)");                      }                  }              }
Magic Number,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The following statement contains a magic number: Int32 type = Random.Range(0' 3);
Magic Number,Kopernicus,DiscoverableObjects,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\RuntimeUtility\DiscoverableObjects.cs,SpawnAsteroid,The following statement contains a magic number: if (type == 0 && asteroid.location.around.Count != 0)              {                  // Around                  IEnumerable<Location.AroundLoader> arounds = GetProbabilityList(asteroid.location.around' asteroid.location.around.Select(a => a.probability.value));                  Location.AroundLoader around = arounds.ElementAt(Random.Range(0' arounds.Count()));                  body = PSystemManager.Instance.localBodies.Find(b => b.name == around.body);                  if (!body) return;                  if (around.reached && !ReachedBody(body)) return;                  orbit = new Orbit();                  orbit.referenceBody = body;                  orbit.eccentricity = around.eccentricity;                  orbit.semiMajorAxis = around.semiMajorAxis;                  orbit.inclination = around.inclination;                  orbit.LAN = around.longitudeOfAscendingNode;                  orbit.argumentOfPeriapsis = around.argumentOfPeriapsis;                  orbit.meanAnomalyAtEpoch = around.meanAnomalyAtEpoch;                  orbit.epoch = around.epoch;                  orbit.Init();              }              else if (type == 1 && asteroid.location.nearby.Count != 0)              {                  // Nearby                  IEnumerable<Location.NearbyLoader> nearbys = GetProbabilityList(asteroid.location.nearby' asteroid.location.nearby.Select(a => a.probability.value));                  Location.NearbyLoader nearby = nearbys.ElementAt(Random.Range(0' nearbys.Count()));                  body = PSystemManager.Instance.localBodies.Find(b => b.name == nearby.body);                  if (!body) return;                  if (nearby.reached && !ReachedBody(body)) return;                  orbit = new Orbit();                  orbit.eccentricity = body.orbit.eccentricity + nearby.eccentricity;                  orbit.semiMajorAxis = body.orbit.semiMajorAxis * nearby.semiMajorAxis;                  orbit.inclination = body.orbit.inclination + nearby.inclination;                  orbit.LAN = body.orbit.LAN * nearby.longitudeOfAscendingNode;                  orbit.argumentOfPeriapsis = body.orbit.argumentOfPeriapsis * nearby.argumentOfPeriapsis;                  orbit.meanAnomalyAtEpoch = body.orbit.meanAnomalyAtEpoch * nearby.meanAnomalyAtEpoch;                  orbit.epoch = body.orbit.epoch;                  orbit.referenceBody = body.orbit.referenceBody;                  orbit.Init();              }              else if (type == 2 && asteroid.location.flyby.Count != 0)              {                  // Flyby                  IEnumerable<Location.FlybyLoader> flybys = GetProbabilityList(asteroid.location.flyby' asteroid.location.flyby.Select(a => a.probability.value));                  Location.FlybyLoader flyby = flybys.ElementAt(Random.Range(0' flybys.Count()));                  body = PSystemManager.Instance.localBodies.Find(b => b.name == flyby.body);                  if (!body) return;                  if (flyby.reached && !ReachedBody(body)) return;                  orbit = Orbit.CreateRandomOrbitFlyBy(body' Random.Range(flyby.minDuration' flyby.maxDuration));              }
Magic Number,Kopernicus,Loader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Loader.cs,Apply,The following statement contains a magic number: systemPrefab.mainToolbarSelected = 2;
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The following statement contains a magic number: celestialBody.gMagnitudeAtCenter = celestialBody.GeeASL * 9.80665 * rsq;
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GeeASLToOthers,The following statement contains a magic number: celestialBody.Mass = celestialBody.gravParameter * (1 / 6.67408E-11);
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.Mass * (6.67408E-11 / 9.80665) / rsq;
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.Mass * (6.67408E-11 / 9.80665) / rsq;
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,MassToOthers,The following statement contains a magic number: celestialBody.gMagnitudeAtCenter = celestialBody.GeeASL * 9.80665 * rsq;
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GravParamToOthers,The following statement contains a magic number: celestialBody.Mass = celestialBody.gravParameter * (1 / 6.67408E-11);
Magic Number,Kopernicus,PropertiesLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PropertiesLoader.cs,GravParamToOthers,The following statement contains a magic number: celestialBody.GeeASL = celestialBody.gravParameter / 9.80665 / rsq;
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,OrbitLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\OrbitLoader.cs,FinalizeOrbit,The following statement contains a magic number: if (body.orbitDriver != null)                  {                      if (body.referenceBody != null)                      {                          // Only recalculate the SOI' if it's not forced                          if (!body.Has("hillSphere"))                              body.hillSphere = body.orbit.semiMajorAxis * (1.0 - body.orbit.eccentricity) * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 1.0 / 3.0);                            if (!body.Has("sphereOfInfluence"))                              body.sphereOfInfluence = Math.Max(                                  body.orbit.semiMajorAxis * Math.Pow(body.Mass / body.orbit.referenceBody.Mass' 0.4)'                                  Math.Max(body.Radius * Templates.SOIMinRadiusMult' body.Radius + Templates.SOIMinAltitude));                            // this is unlike stock KSP' where only the reference body's mass is used.                          body.orbit.period = 2 * Math.PI * Math.Sqrt(Math.Pow(body.orbit.semiMajorAxis' 2) / 6.67408e-11 * body.orbit.semiMajorAxis / (body.referenceBody.Mass + body.Mass));                          body.orbit.meanMotion = 2 * Math.PI / body.orbit.period;    // in theory this should work but I haven't tested it                            if (body.orbit.eccentricity <= 1.0)                          {                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.orbitPercent = body.orbit.meanAnomalyAtEpoch / (Math.PI * 2);                              body.orbit.ObTAtEpoch = body.orbit.orbitPercent * body.orbit.period;                          }                          else                          {                              // ignores this body's own mass for this one...                              body.orbit.meanAnomaly = body.orbit.meanAnomalyAtEpoch;                              body.orbit.ObT = Math.Pow(Math.Pow(Math.Abs(body.orbit.semiMajorAxis)' 3.0) / body.orbit.referenceBody.gravParameter' 0.5) * body.orbit.meanAnomaly;                              body.orbit.ObTAtEpoch = body.orbit.ObT;                          }                      }                      else                      {                          body.sphereOfInfluence = Double.PositiveInfinity;                          body.hillSphere = Double.PositiveInfinity;                      }                  }
Magic Number,Kopernicus,MapSOParser_GreyScale<T>,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Parser\BuiltinTypeParsers.cs,SetFromString,The following statement contains a magic number: if (s.StartsWith("BUILTIN/"))                  {                      s = s.Substring(8);                      value = Utility.FindMapSO<T>(s);                  }                  else                  {                      // are we on-demand? Don't load now.                      if (useOnDemand)                      {                          if (Utility.TextureExists(s))                          {                              String mapName = s;                              mapName = mapName.Substring(s.LastIndexOf('/') + 1);                              Int32 lastDot = mapName.LastIndexOf('.');                              if (lastDot > 0)                                  mapName = mapName.Substring(0' lastDot);                              if (typeof(T) == typeof(CBAttributeMapSO))                              {                                  CBAttributeMapSODemand valCB = ScriptableObject.CreateInstance<CBAttributeMapSODemand>();                                  valCB.Path = s;                                  valCB.Depth = MapSO.MapDepth.Greyscale;                                  valCB.name = mapName + " (CBG) for " + generatedBody.name;                                  valCB.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valCB);                                  value = valCB as T;                              }                              else                              {                                  MapSODemand valMap = ScriptableObject.CreateInstance<MapSODemand>();                                  valMap.Path = s;                                  valMap.Depth = MapSO.MapDepth.Greyscale;                                  valMap.name = mapName + " (G) for " + generatedBody.name;                                  valMap.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valMap);                                  value = valMap as T;                              }                          }                      }                      else // Load the texture                      {                          Texture2D map = Utility.LoadTexture(s' false' false' false);                          if (map != null)                          {                              // Create a new map script object                              value = ScriptableObject.CreateInstance<T>();                              value.CreateMap(MapSO.MapDepth.Greyscale' map);                              UnityEngine.Object.DestroyImmediate(map);                          }                      }                  }
Magic Number,Kopernicus,MapSOParser_RGB<T>,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\Parser\BuiltinTypeParsers.cs,SetFromString,The following statement contains a magic number: if (s.StartsWith("BUILTIN/"))                  {                      s = s.Substring(8);                      value = Utility.FindMapSO<T>(s);                  }                  else                  {                      // check if OnDemand.                      if (useOnDemand)                      {                          if (Utility.TextureExists(s))                          {                              String mapName = s;                              mapName = mapName.Substring(s.LastIndexOf('/') + 1);                              Int32 lastDot = mapName.LastIndexOf('.');                              if (lastDot > 0)                                  mapName = mapName.Substring(0' lastDot);                              if (typeof(T) == typeof(CBAttributeMapSO))                              {                                  CBAttributeMapSODemand valCB = ScriptableObject.CreateInstance<CBAttributeMapSODemand>();                                  valCB.Path = s;                                  valCB.Depth = MapSO.MapDepth.RGB;                                  valCB.name = mapName + " (CBRGB) for " + generatedBody.name;                                  valCB.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valCB);                                  value = valCB as T;                              }                              else                              {                                  OnDemand.MapSODemand valMap = ScriptableObject.CreateInstance<MapSODemand>();                                  valMap.Path = s;                                  valMap.Depth = MapSO.MapDepth.RGB;                                  valMap.name = mapName + " (RGB) for " + generatedBody.name;                                  valMap.AutoLoad = OnDemandStorage.onDemandLoadOnMissing;                                  OnDemandStorage.AddMap(generatedBody.name' valMap);                                  value = valMap as T;                              }                          }                      }                      else                      {                          // Load the texture                          Texture2D map = Utility.LoadTexture(s' false' false' false);                          if (map != null)                          {                              // Create a new map script object                              value = ScriptableObject.CreateInstance<T>();                              value.CreateMap(MapSO.MapDepth.RGB' map);                              UnityEngine.Object.DestroyImmediate(map);                          }                      }                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (generatedBody.pqsVersion != null)                  {                      // Save the PQSVersion                      pqsVersion = generatedBody.pqsVersion;                        // Get the required PQS information                      transform = pqsVersion.GetComponentsInChildren<PQSMod_CelestialBodyTransform>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      lightDirection = pqsVersion.GetComponentsInChildren<PQSMod_MaterialSetDirection>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      uvs = pqsVersion.GetComponentsInChildren<PQSMod_UVPlanetRelativePosition>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                      collider = pqsVersion.GetComponentsInChildren<PQSMod_QuadMeshColliders>(true).FirstOrDefault(Mod => Mod.transform.parent == pqsVersion.transform);                        // Clone the surface material of the PQS                      if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                      {                          PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSMainShader.UsesSameShader(surfaceMaterial))                      {                          PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                      {                          PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                          loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                          surfaceMaterial = loader;                      }                      else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                      {                          surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                      }                      surfaceMaterial.name = Guid.NewGuid().ToString();                        // Clone the fallback material of the PQS                      fallbackMaterial = new PQSProjectionFallbackLoader(fallbackMaterial);                      fallbackMaterial.name = Guid.NewGuid().ToString();                      return;                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: transform.deactivateAltitude = 115000;
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: transform.order = 10;
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: lightDirection.order = 100;
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: uvs.order = 999999;
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: collider.order = 100;
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,PQSLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\PQSLoader.cs,PQSLoader,The following statement contains a magic number: if (PQSMainOptimised.UsesSameShader(surfaceMaterial))                  {                      PQSMainOptimisedLoader loader = new PQSMainOptimisedLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSMainShader.UsesSameShader(surfaceMaterial))                  {                      PQSMainShaderLoader loader = new PQSMainShaderLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionAerialQuadRelative.UsesSameShader(surfaceMaterial))                  {                      PQSProjectionAerialQuadRelativeLoader loader = new PQSProjectionAerialQuadRelativeLoader(surfaceMaterial);                      loader.globalDensity = loader.globalDensity < 2 ? (Single)(-8E-06) : loader.globalDensity;                      surfaceMaterial = loader;                  }                  else if (PQSProjectionSurfaceQuad.UsesSameShader(surfaceMaterial))                  {                      surfaceMaterial = new PQSProjectionSurfaceQuadLoader(surfaceMaterial);                  }
Magic Number,Kopernicus,Logger,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Logger.cs,Logger,The following statement contains a magic number: try              {                  // Open the log file (overwrite existing logs)                  LogFileName = LogFileName.Replace("/"' "").Replace("\\"' "");                  String LogFile = Logger.LogDirectory + LogFileName + ".log";                  loggerStream = new StreamWriter(LogFile);                    // Write an opening message                  String logVersion = "//=====  " + version + "  =====//";                    // Create the header this way' because I'm maybe too stupid to find the "fill" function                  String logHeader = "";                  for (Int32 i = 0; i < (logVersion.Length - 4); i++)                  {                      logHeader += "=";                  }                  logHeader = "//" + logHeader + "//";                    loggerStream.WriteLine(logHeader + "\n" + logVersion + "\n" + logHeader); // Don't use Log() because we don't want a date time in front of the Versioning.                  Log ("Logger \"" + LogFileName + "\" was created");              }              catch (Exception e)               {                  Debug.LogException (e);              }
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,UpdateScaledMesh,The following statement contains a magic number: const Double rJool = 6000000.0;
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,RecalculateTangents,The following statement contains a magic number: Int32 triangleCount = triangles.Length / 3;
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,RecalculateTangents,The following statement contains a magic number: for (Int32 i = 0; i < (triangleCount); i++)              {                  Int32 i1 = triangles[tri];                  Int32 i2 = triangles[tri + 1];                  Int32 i3 = triangles[tri + 2];                    Vector3 v1 = vertices[i1];                  Vector3 v2 = vertices[i2];                  Vector3 v3 = vertices[i3];                    Vector2 w1 = texcoords[i1];                  Vector2 w2 = texcoords[i2];                  Vector2 w3 = texcoords[i3];                    Single x1 = v2.x - v1.x;                  Single x2 = v3.x - v1.x;                  Single y1 = v2.y - v1.y;                  Single y2 = v3.y - v1.y;                  Single z1 = v2.z - v1.z;                  Single z2 = v3.z - v1.z;                    Single s1 = w2.x - w1.x;                  Single s2 = w3.x - w1.x;                  Single t1 = w2.y - w1.y;                  Single t2 = w3.y - w1.y;                    Single r = 1.0f / (s1 * t2 - s2 * t1);                  var sdir = new Vector3((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  var tdir = new Vector3((s1 * x2 - s2 * x1) * r' (s1 * y2 - s2 * y1) * r' (s1 * z2 - s2 * z1) * r);                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;                    tri += 3;              }
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,RecalculateTangents,The following statement contains a magic number: for (Int32 i = 0; i < (triangleCount); i++)              {                  Int32 i1 = triangles[tri];                  Int32 i2 = triangles[tri + 1];                  Int32 i3 = triangles[tri + 2];                    Vector3 v1 = vertices[i1];                  Vector3 v2 = vertices[i2];                  Vector3 v3 = vertices[i3];                    Vector2 w1 = texcoords[i1];                  Vector2 w2 = texcoords[i2];                  Vector2 w3 = texcoords[i3];                    Single x1 = v2.x - v1.x;                  Single x2 = v3.x - v1.x;                  Single y1 = v2.y - v1.y;                  Single y2 = v3.y - v1.y;                  Single z1 = v2.z - v1.z;                  Single z2 = v3.z - v1.z;                    Single s1 = w2.x - w1.x;                  Single s2 = w3.x - w1.x;                  Single t1 = w2.y - w1.y;                  Single t2 = w3.y - w1.y;                    Single r = 1.0f / (s1 * t2 - s2 * t1);                  var sdir = new Vector3((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  var tdir = new Vector3((s1 * x2 - s2 * x1) * r' (s1 * y2 - s2 * y1) * r' (s1 * z2 - s2 * z1) * r);                    tan1[i1] += sdir;                  tan1[i2] += sdir;                  tan1[i3] += sdir;                    tan2[i1] += tdir;                  tan2[i2] += tdir;                  tan2[i3] += tdir;                    tri += 3;              }
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LLAtoECEF,The following statement contains a magic number: const Double degreesToRadians = Math.PI / 180.0;
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LLAtoECEF,The following statement contains a magic number: lat = (lat - 90) * degreesToRadians;
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (System.IO.File.Exists(path))              {                  Boolean uncaught = true;                  try                  {                      if (path.ToLower().EndsWith(".dds"))                      {                          // Borrowed from stock KSP 1.0 DDS loader (hi Mike!)                          // Also borrowed the extra bits from Sarbian.                          byte[] buffer = System.IO.File.ReadAllBytes(path);                          System.IO.BinaryReader binaryReader = new System.IO.BinaryReader(new System.IO.MemoryStream(buffer));                          uint num = binaryReader.ReadUInt32();                          if (num == DDSHeaders.DDSValues.uintMagic)                          {                                DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader(binaryReader);                                if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10)                              {                                  new DDSHeaders.DDSHeaderDX10(binaryReader);                              }                                Boolean alpha = (dDSHeader.dwFlags & 0x00000002) != 0;                              Boolean fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;                              Boolean rgb = (dDSHeader.dwFlags & 0x00000040) != 0;                              Boolean alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;                              Boolean luminance = (dDSHeader.dwFlags & 0x00020000) != 0;                              Boolean rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;                              //Boolean bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;                              Boolean rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;                              Boolean argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;                              Boolean rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;                                Boolean mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;                              Boolean isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);                              if (fourcc)                              {                                  if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' (TextureFormat)11' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2)                                  {                                      Debug.Log("[Kopernicus] DXT2 not supported" + path);                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4)                                  {                                      Debug.Log("[Kopernicus] DXT4 not supported: " + path);                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10)                                  {                                      Debug.Log("[Kopernicus] DX10 dds not supported: " + path);                                  }                                  else                                      fourcc = false;                              }                              if (!fourcc)                              {                                  TextureFormat textureFormat = TextureFormat.ARGB32;                                  Boolean ok = true;                                  if (rgb && (rgb888 /*|| bgr888*/))                                  {                                      // RGB or RGBA format                                      textureFormat = alphapixel                                      ? TextureFormat.RGBA32                                      : TextureFormat.RGB24;                                  }                                  else if (rgb && rgb565)                                  {                                      // Nvidia texconv B5G6R5_UNORM                                      textureFormat = TextureFormat.RGB565;                                  }                                  else if (rgb && alphapixel && argb4444)                                  {                                      // Nvidia texconv B4G4R4A4_UNORM                                      textureFormat = TextureFormat.ARGB4444;                                  }                                  else if (rgb && alphapixel && rbga4444)                                  {                                      textureFormat = TextureFormat.RGBA4444;                                  }                                  else if (!rgb && alpha != luminance)                                  {                                      // A8 format or Luminance 8                                      textureFormat = TextureFormat.Alpha8;                                  }                                  else                                  {                                      ok = false;                                      Debug.Log("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");                                  }                                  if (ok)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' textureFormat' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                }                              if (map != null)                                  if (upload)                                      map.Apply(false' unreadable);                          }                          else                              Debug.Log("[Kopernicus] Bad DDS header.");                      }                      else                      {                          map = new Texture2D(2' 2);                          map.LoadImage(System.IO.File.ReadAllBytes(path));                          if (compress)                              map.Compress(true);                          if (upload)                              map.Apply(false' unreadable);                      }                  }                  catch (Exception e)                  {                      uncaught = false;                      Debug.Log("[Kopernicus] failed to load " + path + " with exception " + e.Message);                  }                  if (map == null && uncaught)                  {                      Debug.Log("[Kopernicus] failed to load " + path);                  }                  map.name = path.Remove(0' (KSPUtil.ApplicationRootPath + "GameData/").Length);              }              else                  Debug.Log("[Kopernicus] texture does not exist! " + path);
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (System.IO.File.Exists(path))              {                  Boolean uncaught = true;                  try                  {                      if (path.ToLower().EndsWith(".dds"))                      {                          // Borrowed from stock KSP 1.0 DDS loader (hi Mike!)                          // Also borrowed the extra bits from Sarbian.                          byte[] buffer = System.IO.File.ReadAllBytes(path);                          System.IO.BinaryReader binaryReader = new System.IO.BinaryReader(new System.IO.MemoryStream(buffer));                          uint num = binaryReader.ReadUInt32();                          if (num == DDSHeaders.DDSValues.uintMagic)                          {                                DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader(binaryReader);                                if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10)                              {                                  new DDSHeaders.DDSHeaderDX10(binaryReader);                              }                                Boolean alpha = (dDSHeader.dwFlags & 0x00000002) != 0;                              Boolean fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;                              Boolean rgb = (dDSHeader.dwFlags & 0x00000040) != 0;                              Boolean alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;                              Boolean luminance = (dDSHeader.dwFlags & 0x00020000) != 0;                              Boolean rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;                              //Boolean bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;                              Boolean rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;                              Boolean argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;                              Boolean rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;                                Boolean mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;                              Boolean isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);                              if (fourcc)                              {                                  if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' (TextureFormat)11' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2)                                  {                                      Debug.Log("[Kopernicus] DXT2 not supported" + path);                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4)                                  {                                      Debug.Log("[Kopernicus] DXT4 not supported: " + path);                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10)                                  {                                      Debug.Log("[Kopernicus] DX10 dds not supported: " + path);                                  }                                  else                                      fourcc = false;                              }                              if (!fourcc)                              {                                  TextureFormat textureFormat = TextureFormat.ARGB32;                                  Boolean ok = true;                                  if (rgb && (rgb888 /*|| bgr888*/))                                  {                                      // RGB or RGBA format                                      textureFormat = alphapixel                                      ? TextureFormat.RGBA32                                      : TextureFormat.RGB24;                                  }                                  else if (rgb && rgb565)                                  {                                      // Nvidia texconv B5G6R5_UNORM                                      textureFormat = TextureFormat.RGB565;                                  }                                  else if (rgb && alphapixel && argb4444)                                  {                                      // Nvidia texconv B4G4R4A4_UNORM                                      textureFormat = TextureFormat.ARGB4444;                                  }                                  else if (rgb && alphapixel && rbga4444)                                  {                                      textureFormat = TextureFormat.RGBA4444;                                  }                                  else if (!rgb && alpha != luminance)                                  {                                      // A8 format or Luminance 8                                      textureFormat = TextureFormat.Alpha8;                                  }                                  else                                  {                                      ok = false;                                      Debug.Log("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");                                  }                                  if (ok)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' textureFormat' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                }                              if (map != null)                                  if (upload)                                      map.Apply(false' unreadable);                          }                          else                              Debug.Log("[Kopernicus] Bad DDS header.");                      }                      else                      {                          map = new Texture2D(2' 2);                          map.LoadImage(System.IO.File.ReadAllBytes(path));                          if (compress)                              map.Compress(true);                          if (upload)                              map.Apply(false' unreadable);                      }                  }                  catch (Exception e)                  {                      uncaught = false;                      Debug.Log("[Kopernicus] failed to load " + path + " with exception " + e.Message);                  }                  if (map == null && uncaught)                  {                      Debug.Log("[Kopernicus] failed to load " + path);                  }                  map.name = path.Remove(0' (KSPUtil.ApplicationRootPath + "GameData/").Length);              }              else                  Debug.Log("[Kopernicus] texture does not exist! " + path);
Magic Number,Kopernicus,Utility,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Utility.cs,LoadTexture,The following statement contains a magic number: if (System.IO.File.Exists(path))              {                  Boolean uncaught = true;                  try                  {                      if (path.ToLower().EndsWith(".dds"))                      {                          // Borrowed from stock KSP 1.0 DDS loader (hi Mike!)                          // Also borrowed the extra bits from Sarbian.                          byte[] buffer = System.IO.File.ReadAllBytes(path);                          System.IO.BinaryReader binaryReader = new System.IO.BinaryReader(new System.IO.MemoryStream(buffer));                          uint num = binaryReader.ReadUInt32();                          if (num == DDSHeaders.DDSValues.uintMagic)                          {                                DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader(binaryReader);                                if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10)                              {                                  new DDSHeaders.DDSHeaderDX10(binaryReader);                              }                                Boolean alpha = (dDSHeader.dwFlags & 0x00000002) != 0;                              Boolean fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;                              Boolean rgb = (dDSHeader.dwFlags & 0x00000040) != 0;                              Boolean alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;                              Boolean luminance = (dDSHeader.dwFlags & 0x00020000) != 0;                              Boolean rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;                              //Boolean bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;                              Boolean rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;                              Boolean argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;                              Boolean rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;                                Boolean mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;                              Boolean isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);                              if (fourcc)                              {                                  if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' (TextureFormat)11' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2)                                  {                                      Debug.Log("[Kopernicus] DXT2 not supported" + path);                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4)                                  {                                      Debug.Log("[Kopernicus] DXT4 not supported: " + path);                                  }                                  else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10)                                  {                                      Debug.Log("[Kopernicus] DX10 dds not supported: " + path);                                  }                                  else                                      fourcc = false;                              }                              if (!fourcc)                              {                                  TextureFormat textureFormat = TextureFormat.ARGB32;                                  Boolean ok = true;                                  if (rgb && (rgb888 /*|| bgr888*/))                                  {                                      // RGB or RGBA format                                      textureFormat = alphapixel                                      ? TextureFormat.RGBA32                                      : TextureFormat.RGB24;                                  }                                  else if (rgb && rgb565)                                  {                                      // Nvidia texconv B5G6R5_UNORM                                      textureFormat = TextureFormat.RGB565;                                  }                                  else if (rgb && alphapixel && argb4444)                                  {                                      // Nvidia texconv B4G4R4A4_UNORM                                      textureFormat = TextureFormat.ARGB4444;                                  }                                  else if (rgb && alphapixel && rbga4444)                                  {                                      textureFormat = TextureFormat.RGBA4444;                                  }                                  else if (!rgb && alpha != luminance)                                  {                                      // A8 format or Luminance 8                                      textureFormat = TextureFormat.Alpha8;                                  }                                  else                                  {                                      ok = false;                                      Debug.Log("[Kopernicus] Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");                                  }                                  if (ok)                                  {                                      map = new Texture2D((Int32)dDSHeader.dwWidth' (Int32)dDSHeader.dwHeight' textureFormat' mipmap);                                      map.LoadRawTextureData(binaryReader.ReadBytes((Int32)(binaryReader.BaseStream.Length - binaryReader.BaseStream.Position)));                                  }                                }                              if (map != null)                                  if (upload)                                      map.Apply(false' unreadable);                          }                          else                              Debug.Log("[Kopernicus] Bad DDS header.");                      }                      else                      {                          map = new Texture2D(2' 2);                          map.LoadImage(System.IO.File.ReadAllBytes(path));                          if (compress)                              map.Compress(true);                          if (upload)                              map.Apply(false' unreadable);                      }                  }                  catch (Exception e)                  {                      uncaught = false;                      Debug.Log("[Kopernicus] failed to load " + path + " with exception " + e.Message);                  }                  if (map == null && uncaught)                  {                      Debug.Log("[Kopernicus] failed to load " + path);                  }                  map.name = path.Remove(0' (KSPUtil.ApplicationRootPath + "GameData/").Length);              }              else                  Debug.Log("[Kopernicus] texture does not exist! " + path);
Magic Number,ModLoader,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxCache = 512;
Magic Number,ModLoader,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxCacheDelta = 32;
Magic Number,ModLoader,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: scatter.maxSpeed = 1000;
Magic Number,ModLoader,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,ModLoader,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,ModLoader,LandClassScatterLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassScatterLoader,The following statement contains a magic number: if (scatter != null)                              this.scatter = scatter;                          else                          {                              this.scatter = new PQSLandControl.LandClassScatter();                                // Initialize default parameters                              scatter.maxCache = 512;                              scatter.maxCacheDelta = 32;                              scatter.maxSpeed = 1000;                          }
Magic Number,ModLoader,LandClassLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassLoader,The following statement contains a magic number: range.lerpRange.endEnd = 2;
Magic Number,ModLoader,LandClassLoader,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Configuration\ModLoader\LandControl.cs,LandClassLoader,The following statement contains a magic number: range.lerpRange.endStart = 2;
Magic Number,Constants,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: const Int32 c_PeHeaderOffset = 60;
Magic Number,Constants,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: const Int32 c_LinkerTimestampOffset = 8;
Magic Number,Constants,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: byte[] b = new byte[2048];
Magic Number,Constants,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: try                  {                      s = new FileStream(filePath' FileMode.Open' FileAccess.Read);                      s.Read(b' 0' 2048);                  }                  finally                  {                      if (s != null)                      {                          s.Close();                      }                  }
Magic Number,Constants,Version,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus\Constants\Version.cs,BuiltTime,The following statement contains a magic number: DateTime dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
