Implementation smell,Namespace,Class,File,Method,Description
Long Method,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The method has 101 lines of code.
Complex Method,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelFloat,Cyclomatic complexity of the method is 8
Complex Method,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,Cyclomatic complexity of the method is 26
Long Statement,OnDemand,CBAttributeMapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\CBAttributeMapSODemand.cs,GetAtt,The length of the statement  "			Debug.Log ("[OD] ERROR: getting attribute with unloaded CBmap " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,CBAttributeMapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\CBAttributeMapSODemand.cs,GetPixelColor,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelColF with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,CBAttributeMapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\CBAttributeMapSODemand.cs,GetPixelColor,The length of the statement  "	return Color.Lerp (Color.Lerp (GetPixelColor (coords.xFloor' coords.yFloor)' GetPixelColor (coords.xCeiling' coords.yFloor)' coords.u)' Color.Lerp (GetPixelColor (coords.xFloor' coords.yCeiling)' GetPixelColor (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 267.
Long Statement,OnDemand,CBAttributeMapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\CBAttributeMapSODemand.cs,GetPixelColor,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelColI with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelByte,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelbyte with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelColD with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor,The length of the statement  "	return Color.Lerp (Color.Lerp (this.GetPixelColor (coords.xFloor' coords.yFloor)' this.GetPixelColor (coords.xCeiling' coords.yFloor)' coords.u)' Color.Lerp (this.GetPixelColor (coords.xFloor' coords.yCeiling)' this.GetPixelColor (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 287.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelColF with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor,The length of the statement  "	return Color.Lerp (Color.Lerp (this.GetPixelColor (coords.xFloor' coords.yFloor)' this.GetPixelColor (coords.xCeiling' coords.yFloor)' coords.u)' Color.Lerp (this.GetPixelColor (coords.xFloor' coords.yCeiling)' this.GetPixelColor (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 287.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelColI with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor32,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelCol32D with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor32,The length of the statement  "	return Color32.Lerp (Color32.Lerp (this.GetPixelColor32 (coords.xFloor' coords.yFloor)' this.GetPixelColor32 (coords.xCeiling' coords.yFloor)' coords.u)' Color32.Lerp (this.GetPixelColor32 (coords.xFloor' coords.yCeiling)' this.GetPixelColor32 (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 301.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor32,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelCol32F with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor32,The length of the statement  "	return Color32.Lerp (Color32.Lerp (this.GetPixelColor32 (coords.xFloor' coords.yFloor)' this.GetPixelColor32 (coords.xCeiling' coords.yFloor)' coords.u)' Color32.Lerp (this.GetPixelColor32 (coords.xFloor' coords.yCeiling)' this.GetPixelColor32 (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 301.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelColor32,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelCol32I with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelFloat,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelFloatD with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelFloat,The length of the statement  "	return Mathf.Lerp (Mathf.Lerp (GetPixelFloat (coords.xFloor' coords.yFloor)' GetPixelFloat (coords.xCeiling' coords.yFloor)' coords.u)' Mathf.Lerp (GetPixelFloat (coords.xFloor' coords.yCeiling)' GetPixelFloat (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 267.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelFloat,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelFloatF with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelFloat,The length of the statement  "	return Mathf.Lerp (Mathf.Lerp (GetPixelFloat (coords.xFloor' coords.yFloor)' GetPixelFloat (coords.xCeiling' coords.yFloor)' coords.u)' Mathf.Lerp (GetPixelFloat (coords.xFloor' coords.yCeiling)' GetPixelFloat (coords.xCeiling' coords.yCeiling)' coords.u)' coords.v); " is 267.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelFloat,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelFloatI with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 122.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelHeightAlpha,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelHeightAlphaD with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 128.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelHeightAlpha,The length of the statement  "	return HeightAlpha.Lerp (HeightAlpha.Lerp (GetPixelHeightAlpha (coords.xFloor' coords.yFloor)' GetPixelHeightAlpha (coords.xCeiling' coords.yFloor)' coords.u)' HeightAlpha.Lerp (GetPixelHeightAlpha (coords.xFloor' coords.yCeiling)' GetPixelHeightAlpha (coords.xFloor' coords.yCeiling)' coords.u)' coords.v); " is 307.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelHeightAlpha,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelHeightAlphaF with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 128.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelHeightAlpha,The length of the statement  "	return HeightAlpha.Lerp (HeightAlpha.Lerp (GetPixelHeightAlpha (coords.xFloor' coords.yFloor)' GetPixelHeightAlpha (coords.xCeiling' coords.yFloor)' coords.u)' HeightAlpha.Lerp (GetPixelHeightAlpha (coords.xFloor' coords.yCeiling)' GetPixelHeightAlpha (coords.xFloor' coords.yCeiling)' coords.u)' coords.v); " is 307.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GetPixelHeightAlpha,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelHeightAlphaI with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 128.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GreyByte,The length of the statement  "			Debug.Log ("[OD] ERROR: getting GreyByteI with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,GreyFloat,The length of the statement  "			Debug.Log ("[OD] ERROR: getting GreyFloat with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,MapSODemand,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\MapSODemand.cs,PixelByte,The length of the statement  "			Debug.Log ("[OD] ERROR: getting pixelByte with unloaded map " + name + " of path " + Path + "' autoload = " + AutoLoad); " is 120.
Long Statement,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,AddMap,The length of the statement  "		Debug.Log ("[OD] WARNING: trying to add a map but is already tracked! Current body is " + body + " and map name is " + map.name + " and path is " + map.Path); " is 158.
Long Statement,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The length of the statement  "					bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000; " is 143.
Long Statement,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The length of the statement  "					//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff; " is 145.
Long Statement,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The length of the statement  "					bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F; " is 143.
Long Statement,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The length of the statement  "					bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f; " is 189.
Long Statement,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The length of the statement  "					bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00; " is 189.
Long Statement,OnDemand,PQSMod_OnDemandHandler,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\PQSMod_OnDemandHandler.cs,OnSphereInactive,The length of the statement  "	unloadTime = System.Diagnostics.Stopwatch.GetTimestamp () + System.Diagnostics.Stopwatch.Frequency * OnDemandStorage.onDemandUnloadDelay; " is 137.
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: fixed (int* ptr = &temp [0]) {  	int* p = ptr - 1;  	while (*p != 3 && offset > -44) {  		offset -= 4;  		p--;  	}  	arrayLengthOffset = (*p == 3) ? offset : 1;  	Debug.Log ("[OD] CalculateArrayLengthOffset using offset of " + arrayLengthOffset);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: fixed (int* ptr = &temp [0]) {  	int* p = ptr - 1;  	while (*p != 3 && offset > -44) {  		offset -= 4;  		p--;  	}  	arrayLengthOffset = (*p == 3) ? offset : 1;  	Debug.Log ("[OD] CalculateArrayLengthOffset using offset of " + arrayLengthOffset);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: fixed (int* ptr = &temp [0]) {  	int* p = ptr - 1;  	while (*p != 3 && offset > -44) {  		offset -= 4;  		p--;  	}  	arrayLengthOffset = (*p == 3) ? offset : 1;  	Debug.Log ("[OD] CalculateArrayLengthOffset using offset of " + arrayLengthOffset);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: fixed (int* ptr = &temp [0]) {  	int* p = ptr - 1;  	while (*p != 3 && offset > -44) {  		offset -= 4;  		p--;  	}  	arrayLengthOffset = (*p == 3) ? offset : 1;  	Debug.Log ("[OD] CalculateArrayLengthOffset using offset of " + arrayLengthOffset);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: while (*p != 3 && offset > -44) {  	offset -= 4;  	p--;  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: while (*p != 3 && offset > -44) {  	offset -= 4;  	p--;  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: while (*p != 3 && offset > -44) {  	offset -= 4;  	p--;  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: offset -= 4;  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,CalculateArrayLengthOffset,The following statement contains a magic number: arrayLengthOffset = (*p == 3) ? offset : 1;  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (File.Exists (path)) {  	bool uncaught = true;  	try {  		if (path.ToLower ().EndsWith (".dds")) {  			// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  			// Also borrowed the extra bits from Sarbian.  			BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  			uint num = binaryReader.ReadUInt32 ();  			if (num == DDSHeaders.DDSValues.uintMagic) {  				DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					new DDSHeaders.DDSHeaderDX10 (binaryReader);  				}  				bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  				bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  				bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  				bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  				bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  				bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  				//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  				bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  				bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  				bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  				bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  				bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  				if (fourcc) {  					if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  						Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  						Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  						Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  					} else  						fourcc = false;  				}  				if (!fourcc) {  					TextureFormat textureFormat = TextureFormat.ARGB32;  					bool ok = true;  					if (rgb && (rgb888/*|| bgr888*/)) {  						// RGB or RGBA format  						textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  					} else if (rgb && rgb565) {  						// Nvidia texconv B5G6R5_UNORM  						textureFormat = TextureFormat.RGB565;  					} else if (rgb && alphapixel && argb4444) {  						// Nvidia texconv B4G4R4A4_UNORM  						textureFormat = TextureFormat.ARGB4444;  					} else if (rgb && alphapixel && rbga4444) {  						textureFormat = TextureFormat.RGBA4444;  					} else if (!rgb && alpha != luminance) {  						// A8 format or Luminance 8  						textureFormat = TextureFormat.Alpha8;  					} else {  						ok = false;  						Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  					}  					if (ok) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					}  				}  				if (map != null)  					if (upload)  						map.Apply (false' unreadable);  			} else  				Debug.Log ("[Kopernicus]: Bad DDS header.");  		} else {  			map = new Texture2D (2' 2);  			byte[] data = LoadWholeFile (path);  			if (data == null)  				throw new Exception ("LoadWholeFile failed");  			map.LoadImage (data);  			if (compress)  				map.Compress (true);  			if (upload)  				map.Apply (false' unreadable);  		}  	} catch (Exception ex) {  		uncaught = false;  		Debug.Log ("[Kopernicus]: failed to load " + path + " with exception " + ex.Message);  	}  	if (map == null && uncaught) {  		Debug.Log ("[Kopernicus]: failed to load " + path);  	}  	map.name = path.Remove (0' (KSPUtil.ApplicationRootPath + "GameData/").Length);  } else  	Debug.Log ("[Kopernicus]: texture does not exist! " + path);  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (File.Exists (path)) {  	bool uncaught = true;  	try {  		if (path.ToLower ().EndsWith (".dds")) {  			// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  			// Also borrowed the extra bits from Sarbian.  			BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  			uint num = binaryReader.ReadUInt32 ();  			if (num == DDSHeaders.DDSValues.uintMagic) {  				DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					new DDSHeaders.DDSHeaderDX10 (binaryReader);  				}  				bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  				bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  				bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  				bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  				bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  				bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  				//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  				bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  				bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  				bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  				bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  				bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  				if (fourcc) {  					if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  						Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  						Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  						Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  					} else  						fourcc = false;  				}  				if (!fourcc) {  					TextureFormat textureFormat = TextureFormat.ARGB32;  					bool ok = true;  					if (rgb && (rgb888/*|| bgr888*/)) {  						// RGB or RGBA format  						textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  					} else if (rgb && rgb565) {  						// Nvidia texconv B5G6R5_UNORM  						textureFormat = TextureFormat.RGB565;  					} else if (rgb && alphapixel && argb4444) {  						// Nvidia texconv B4G4R4A4_UNORM  						textureFormat = TextureFormat.ARGB4444;  					} else if (rgb && alphapixel && rbga4444) {  						textureFormat = TextureFormat.RGBA4444;  					} else if (!rgb && alpha != luminance) {  						// A8 format or Luminance 8  						textureFormat = TextureFormat.Alpha8;  					} else {  						ok = false;  						Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  					}  					if (ok) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					}  				}  				if (map != null)  					if (upload)  						map.Apply (false' unreadable);  			} else  				Debug.Log ("[Kopernicus]: Bad DDS header.");  		} else {  			map = new Texture2D (2' 2);  			byte[] data = LoadWholeFile (path);  			if (data == null)  				throw new Exception ("LoadWholeFile failed");  			map.LoadImage (data);  			if (compress)  				map.Compress (true);  			if (upload)  				map.Apply (false' unreadable);  		}  	} catch (Exception ex) {  		uncaught = false;  		Debug.Log ("[Kopernicus]: failed to load " + path + " with exception " + ex.Message);  	}  	if (map == null && uncaught) {  		Debug.Log ("[Kopernicus]: failed to load " + path);  	}  	map.name = path.Remove (0' (KSPUtil.ApplicationRootPath + "GameData/").Length);  } else  	Debug.Log ("[Kopernicus]: texture does not exist! " + path);  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (File.Exists (path)) {  	bool uncaught = true;  	try {  		if (path.ToLower ().EndsWith (".dds")) {  			// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  			// Also borrowed the extra bits from Sarbian.  			BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  			uint num = binaryReader.ReadUInt32 ();  			if (num == DDSHeaders.DDSValues.uintMagic) {  				DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					new DDSHeaders.DDSHeaderDX10 (binaryReader);  				}  				bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  				bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  				bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  				bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  				bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  				bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  				//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  				bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  				bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  				bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  				bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  				bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  				if (fourcc) {  					if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  						Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  						Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  					} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  						Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  					} else  						fourcc = false;  				}  				if (!fourcc) {  					TextureFormat textureFormat = TextureFormat.ARGB32;  					bool ok = true;  					if (rgb && (rgb888/*|| bgr888*/)) {  						// RGB or RGBA format  						textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  					} else if (rgb && rgb565) {  						// Nvidia texconv B5G6R5_UNORM  						textureFormat = TextureFormat.RGB565;  					} else if (rgb && alphapixel && argb4444) {  						// Nvidia texconv B4G4R4A4_UNORM  						textureFormat = TextureFormat.ARGB4444;  					} else if (rgb && alphapixel && rbga4444) {  						textureFormat = TextureFormat.RGBA4444;  					} else if (!rgb && alpha != luminance) {  						// A8 format or Luminance 8  						textureFormat = TextureFormat.Alpha8;  					} else {  						ok = false;  						Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  					}  					if (ok) {  						map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  						map.LoadRawTextureData (LoadRestOfReader (binaryReader));  					}  				}  				if (map != null)  					if (upload)  						map.Apply (false' unreadable);  			} else  				Debug.Log ("[Kopernicus]: Bad DDS header.");  		} else {  			map = new Texture2D (2' 2);  			byte[] data = LoadWholeFile (path);  			if (data == null)  				throw new Exception ("LoadWholeFile failed");  			map.LoadImage (data);  			if (compress)  				map.Compress (true);  			if (upload)  				map.Apply (false' unreadable);  		}  	} catch (Exception ex) {  		uncaught = false;  		Debug.Log ("[Kopernicus]: failed to load " + path + " with exception " + ex.Message);  	}  	if (map == null && uncaught) {  		Debug.Log ("[Kopernicus]: failed to load " + path);  	}  	map.name = path.Remove (0' (KSPUtil.ApplicationRootPath + "GameData/").Length);  } else  	Debug.Log ("[Kopernicus]: texture does not exist! " + path);  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: try {  	if (path.ToLower ().EndsWith (".dds")) {  		// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  		// Also borrowed the extra bits from Sarbian.  		BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  		uint num = binaryReader.ReadUInt32 ();  		if (num == DDSHeaders.DDSValues.uintMagic) {  			DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				new DDSHeaders.DDSHeaderDX10 (binaryReader);  			}  			bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  			bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  			bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  			bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  			bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  			bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  			//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  			bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  			bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  			bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  			bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  			bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  			if (fourcc) {  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  					Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  					Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  				} else  					fourcc = false;  			}  			if (!fourcc) {  				TextureFormat textureFormat = TextureFormat.ARGB32;  				bool ok = true;  				if (rgb && (rgb888/*|| bgr888*/)) {  					// RGB or RGBA format  					textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  				} else if (rgb && rgb565) {  					// Nvidia texconv B5G6R5_UNORM  					textureFormat = TextureFormat.RGB565;  				} else if (rgb && alphapixel && argb4444) {  					// Nvidia texconv B4G4R4A4_UNORM  					textureFormat = TextureFormat.ARGB4444;  				} else if (rgb && alphapixel && rbga4444) {  					textureFormat = TextureFormat.RGBA4444;  				} else if (!rgb && alpha != luminance) {  					// A8 format or Luminance 8  					textureFormat = TextureFormat.Alpha8;  				} else {  					ok = false;  					Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  				}  				if (ok) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				}  			}  			if (map != null)  				if (upload)  					map.Apply (false' unreadable);  		} else  			Debug.Log ("[Kopernicus]: Bad DDS header.");  	} else {  		map = new Texture2D (2' 2);  		byte[] data = LoadWholeFile (path);  		if (data == null)  			throw new Exception ("LoadWholeFile failed");  		map.LoadImage (data);  		if (compress)  			map.Compress (true);  		if (upload)  			map.Apply (false' unreadable);  	}  } catch (Exception ex) {  	uncaught = false;  	Debug.Log ("[Kopernicus]: failed to load " + path + " with exception " + ex.Message);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: try {  	if (path.ToLower ().EndsWith (".dds")) {  		// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  		// Also borrowed the extra bits from Sarbian.  		BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  		uint num = binaryReader.ReadUInt32 ();  		if (num == DDSHeaders.DDSValues.uintMagic) {  			DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				new DDSHeaders.DDSHeaderDX10 (binaryReader);  			}  			bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  			bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  			bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  			bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  			bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  			bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  			//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  			bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  			bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  			bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  			bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  			bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  			if (fourcc) {  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  					Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  					Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  				} else  					fourcc = false;  			}  			if (!fourcc) {  				TextureFormat textureFormat = TextureFormat.ARGB32;  				bool ok = true;  				if (rgb && (rgb888/*|| bgr888*/)) {  					// RGB or RGBA format  					textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  				} else if (rgb && rgb565) {  					// Nvidia texconv B5G6R5_UNORM  					textureFormat = TextureFormat.RGB565;  				} else if (rgb && alphapixel && argb4444) {  					// Nvidia texconv B4G4R4A4_UNORM  					textureFormat = TextureFormat.ARGB4444;  				} else if (rgb && alphapixel && rbga4444) {  					textureFormat = TextureFormat.RGBA4444;  				} else if (!rgb && alpha != luminance) {  					// A8 format or Luminance 8  					textureFormat = TextureFormat.Alpha8;  				} else {  					ok = false;  					Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  				}  				if (ok) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				}  			}  			if (map != null)  				if (upload)  					map.Apply (false' unreadable);  		} else  			Debug.Log ("[Kopernicus]: Bad DDS header.");  	} else {  		map = new Texture2D (2' 2);  		byte[] data = LoadWholeFile (path);  		if (data == null)  			throw new Exception ("LoadWholeFile failed");  		map.LoadImage (data);  		if (compress)  			map.Compress (true);  		if (upload)  			map.Apply (false' unreadable);  	}  } catch (Exception ex) {  	uncaught = false;  	Debug.Log ("[Kopernicus]: failed to load " + path + " with exception " + ex.Message);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: try {  	if (path.ToLower ().EndsWith (".dds")) {  		// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  		// Also borrowed the extra bits from Sarbian.  		BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  		uint num = binaryReader.ReadUInt32 ();  		if (num == DDSHeaders.DDSValues.uintMagic) {  			DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				new DDSHeaders.DDSHeaderDX10 (binaryReader);  			}  			bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  			bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  			bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  			bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  			bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  			bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  			//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  			bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  			bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  			bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  			bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  			bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  			if (fourcc) {  				if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  					Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  					Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  				} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  					Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  				} else  					fourcc = false;  			}  			if (!fourcc) {  				TextureFormat textureFormat = TextureFormat.ARGB32;  				bool ok = true;  				if (rgb && (rgb888/*|| bgr888*/)) {  					// RGB or RGBA format  					textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  				} else if (rgb && rgb565) {  					// Nvidia texconv B5G6R5_UNORM  					textureFormat = TextureFormat.RGB565;  				} else if (rgb && alphapixel && argb4444) {  					// Nvidia texconv B4G4R4A4_UNORM  					textureFormat = TextureFormat.ARGB4444;  				} else if (rgb && alphapixel && rbga4444) {  					textureFormat = TextureFormat.RGBA4444;  				} else if (!rgb && alpha != luminance) {  					// A8 format or Luminance 8  					textureFormat = TextureFormat.Alpha8;  				} else {  					ok = false;  					Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  				}  				if (ok) {  					map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  					map.LoadRawTextureData (LoadRestOfReader (binaryReader));  				}  			}  			if (map != null)  				if (upload)  					map.Apply (false' unreadable);  		} else  			Debug.Log ("[Kopernicus]: Bad DDS header.");  	} else {  		map = new Texture2D (2' 2);  		byte[] data = LoadWholeFile (path);  		if (data == null)  			throw new Exception ("LoadWholeFile failed");  		map.LoadImage (data);  		if (compress)  			map.Compress (true);  		if (upload)  			map.Apply (false' unreadable);  	}  } catch (Exception ex) {  	uncaught = false;  	Debug.Log ("[Kopernicus]: failed to load " + path + " with exception " + ex.Message);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (path.ToLower ().EndsWith (".dds")) {  	// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  	// Also borrowed the extra bits from Sarbian.  	BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  	uint num = binaryReader.ReadUInt32 ();  	if (num == DDSHeaders.DDSValues.uintMagic) {  		DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			new DDSHeaders.DDSHeaderDX10 (binaryReader);  		}  		bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  		bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  		bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  		bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  		bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  		bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  		//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  		bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  		bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  		bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  		bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  		bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  		if (fourcc) {  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  				Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  				Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  			} else  				fourcc = false;  		}  		if (!fourcc) {  			TextureFormat textureFormat = TextureFormat.ARGB32;  			bool ok = true;  			if (rgb && (rgb888/*|| bgr888*/)) {  				// RGB or RGBA format  				textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  			} else if (rgb && rgb565) {  				// Nvidia texconv B5G6R5_UNORM  				textureFormat = TextureFormat.RGB565;  			} else if (rgb && alphapixel && argb4444) {  				// Nvidia texconv B4G4R4A4_UNORM  				textureFormat = TextureFormat.ARGB4444;  			} else if (rgb && alphapixel && rbga4444) {  				textureFormat = TextureFormat.RGBA4444;  			} else if (!rgb && alpha != luminance) {  				// A8 format or Luminance 8  				textureFormat = TextureFormat.Alpha8;  			} else {  				ok = false;  				Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  			}  			if (ok) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			}  		}  		if (map != null)  			if (upload)  				map.Apply (false' unreadable);  	} else  		Debug.Log ("[Kopernicus]: Bad DDS header.");  } else {  	map = new Texture2D (2' 2);  	byte[] data = LoadWholeFile (path);  	if (data == null)  		throw new Exception ("LoadWholeFile failed");  	map.LoadImage (data);  	if (compress)  		map.Compress (true);  	if (upload)  		map.Apply (false' unreadable);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (path.ToLower ().EndsWith (".dds")) {  	// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  	// Also borrowed the extra bits from Sarbian.  	BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  	uint num = binaryReader.ReadUInt32 ();  	if (num == DDSHeaders.DDSValues.uintMagic) {  		DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			new DDSHeaders.DDSHeaderDX10 (binaryReader);  		}  		bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  		bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  		bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  		bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  		bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  		bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  		//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  		bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  		bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  		bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  		bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  		bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  		if (fourcc) {  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  				Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  				Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  			} else  				fourcc = false;  		}  		if (!fourcc) {  			TextureFormat textureFormat = TextureFormat.ARGB32;  			bool ok = true;  			if (rgb && (rgb888/*|| bgr888*/)) {  				// RGB or RGBA format  				textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  			} else if (rgb && rgb565) {  				// Nvidia texconv B5G6R5_UNORM  				textureFormat = TextureFormat.RGB565;  			} else if (rgb && alphapixel && argb4444) {  				// Nvidia texconv B4G4R4A4_UNORM  				textureFormat = TextureFormat.ARGB4444;  			} else if (rgb && alphapixel && rbga4444) {  				textureFormat = TextureFormat.RGBA4444;  			} else if (!rgb && alpha != luminance) {  				// A8 format or Luminance 8  				textureFormat = TextureFormat.Alpha8;  			} else {  				ok = false;  				Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  			}  			if (ok) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			}  		}  		if (map != null)  			if (upload)  				map.Apply (false' unreadable);  	} else  		Debug.Log ("[Kopernicus]: Bad DDS header.");  } else {  	map = new Texture2D (2' 2);  	byte[] data = LoadWholeFile (path);  	if (data == null)  		throw new Exception ("LoadWholeFile failed");  	map.LoadImage (data);  	if (compress)  		map.Compress (true);  	if (upload)  		map.Apply (false' unreadable);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (path.ToLower ().EndsWith (".dds")) {  	// Borrowed from stock KSP 1.0 DDS loader (hi Mike!)  	// Also borrowed the extra bits from Sarbian.  	BinaryReader binaryReader = new BinaryReader (File.OpenRead (path));  	uint num = binaryReader.ReadUInt32 ();  	if (num == DDSHeaders.DDSValues.uintMagic) {  		DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			new DDSHeaders.DDSHeaderDX10 (binaryReader);  		}  		bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  		bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  		bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  		bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  		bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  		bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  		//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  		bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  		bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  		bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  		bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  		bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  		if (fourcc) {  			if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  				Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  				Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  			} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  				Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  			} else  				fourcc = false;  		}  		if (!fourcc) {  			TextureFormat textureFormat = TextureFormat.ARGB32;  			bool ok = true;  			if (rgb && (rgb888/*|| bgr888*/)) {  				// RGB or RGBA format  				textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  			} else if (rgb && rgb565) {  				// Nvidia texconv B5G6R5_UNORM  				textureFormat = TextureFormat.RGB565;  			} else if (rgb && alphapixel && argb4444) {  				// Nvidia texconv B4G4R4A4_UNORM  				textureFormat = TextureFormat.ARGB4444;  			} else if (rgb && alphapixel && rbga4444) {  				textureFormat = TextureFormat.RGBA4444;  			} else if (!rgb && alpha != luminance) {  				// A8 format or Luminance 8  				textureFormat = TextureFormat.Alpha8;  			} else {  				ok = false;  				Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  			}  			if (ok) {  				map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  				map.LoadRawTextureData (LoadRestOfReader (binaryReader));  			}  		}  		if (map != null)  			if (upload)  				map.Apply (false' unreadable);  	} else  		Debug.Log ("[Kopernicus]: Bad DDS header.");  } else {  	map = new Texture2D (2' 2);  	byte[] data = LoadWholeFile (path);  	if (data == null)  		throw new Exception ("LoadWholeFile failed");  	map.LoadImage (data);  	if (compress)  		map.Compress (true);  	if (upload)  		map.Apply (false' unreadable);  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (num == DDSHeaders.DDSValues.uintMagic) {  	DDSHeaders.DDSHeader dDSHeader = new DDSHeaders.DDSHeader (binaryReader);  	if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  		new DDSHeaders.DDSHeaderDX10 (binaryReader);  	}  	bool alpha = (dDSHeader.dwFlags & 0x00000002) != 0;  	bool fourcc = (dDSHeader.dwFlags & 0x00000004) != 0;  	bool rgb = (dDSHeader.dwFlags & 0x00000040) != 0;  	bool alphapixel = (dDSHeader.dwFlags & 0x00000001) != 0;  	bool luminance = (dDSHeader.dwFlags & 0x00020000) != 0;  	bool rgb888 = dDSHeader.ddspf.dwRBitMask == 0x000000ff && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x00ff0000;  	//bool bgr888 = dDSHeader.ddspf.dwRBitMask == 0x00ff0000 && dDSHeader.ddspf.dwGBitMask == 0x0000ff00 && dDSHeader.ddspf.dwBBitMask == 0x000000ff;  	bool rgb565 = dDSHeader.ddspf.dwRBitMask == 0x0000F800 && dDSHeader.ddspf.dwGBitMask == 0x000007E0 && dDSHeader.ddspf.dwBBitMask == 0x0000001F;  	bool argb4444 = dDSHeader.ddspf.dwABitMask == 0x0000f000 && dDSHeader.ddspf.dwRBitMask == 0x00000f00 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x0000000f;  	bool rbga4444 = dDSHeader.ddspf.dwABitMask == 0x0000000f && dDSHeader.ddspf.dwRBitMask == 0x0000f000 && dDSHeader.ddspf.dwGBitMask == 0x000000f0 && dDSHeader.ddspf.dwBBitMask == 0x00000f00;  	bool mipmap = (dDSHeader.dwCaps & DDSHeaders.DDSPixelFormatCaps.MIPMAP) != (DDSHeaders.DDSPixelFormatCaps)0u;  	bool isNormalMap = ((dDSHeader.ddspf.dwFlags & 524288u) != 0u || (dDSHeader.ddspf.dwFlags & 2147483648u) != 0u);  	if (fourcc) {  		if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  			map.LoadRawTextureData (LoadRestOfReader (binaryReader));  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  			map.LoadRawTextureData (LoadRestOfReader (binaryReader));  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  			map.LoadRawTextureData (LoadRestOfReader (binaryReader));  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  			Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  			Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  		} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  			Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  		} else  			fourcc = false;  	}  	if (!fourcc) {  		TextureFormat textureFormat = TextureFormat.ARGB32;  		bool ok = true;  		if (rgb && (rgb888/*|| bgr888*/)) {  			// RGB or RGBA format  			textureFormat = alphapixel ? TextureFormat.RGBA32 : TextureFormat.RGB24;  		} else if (rgb && rgb565) {  			// Nvidia texconv B5G6R5_UNORM  			textureFormat = TextureFormat.RGB565;  		} else if (rgb && alphapixel && argb4444) {  			// Nvidia texconv B4G4R4A4_UNORM  			textureFormat = TextureFormat.ARGB4444;  		} else if (rgb && alphapixel && rbga4444) {  			textureFormat = TextureFormat.RGBA4444;  		} else if (!rgb && alpha != luminance) {  			// A8 format or Luminance 8  			textureFormat = TextureFormat.Alpha8;  		} else {  			ok = false;  			Debug.Log ("[Kopernicus]: Only DXT1' DXT5' A8' RGB24' RGBA32' RGB565' ARGB4444 and RGBA4444 are supported");  		}  		if (ok) {  			map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' textureFormat' mipmap);  			map.LoadRawTextureData (LoadRestOfReader (binaryReader));  		}  	}  	if (map != null)  		if (upload)  			map.Apply (false' unreadable);  } else  	Debug.Log ("[Kopernicus]: Bad DDS header.");  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (fourcc) {  	if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  		map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  		map.LoadRawTextureData (LoadRestOfReader (binaryReader));  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  		map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  		map.LoadRawTextureData (LoadRestOfReader (binaryReader));  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  		map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  		map.LoadRawTextureData (LoadRestOfReader (binaryReader));  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  		Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  		Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  	} else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  		Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  	} else  		fourcc = false;  }  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT1) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT1' mipmap);  	map.LoadRawTextureData (LoadRestOfReader (binaryReader));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  	map.LoadRawTextureData (LoadRestOfReader (binaryReader));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  	map.LoadRawTextureData (LoadRestOfReader (binaryReader));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  	Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  	Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  	Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  } else  	fourcc = false;  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT3) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  	map.LoadRawTextureData (LoadRestOfReader (binaryReader));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT5) {  	map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' TextureFormat.DXT5' mipmap);  	map.LoadRawTextureData (LoadRestOfReader (binaryReader));  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT2) {  	Debug.Log ("[Kopernicus]: DXT2 not supported" + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDXT4) {  	Debug.Log ("[Kopernicus]: DXT4 not supported: " + path);  } else if (dDSHeader.ddspf.dwFourCC == DDSHeaders.DDSValues.uintDX10) {  	Debug.Log ("[Kopernicus]: DX10 dds not supported: " + path);  } else  	fourcc = false;  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: map = new Texture2D ((int)dDSHeader.dwWidth' (int)dDSHeader.dwHeight' (TextureFormat)11' mipmap);  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: map = new Texture2D (2' 2);  
Magic Number,OnDemand,OnDemandStorage,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.OnDemand\OnDemandStorage.cs,LoadTexture,The following statement contains a magic number: map = new Texture2D (2' 2);  
