Implementation smell,Namespace,Class,File,Method,Description
Long Method,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The method has 117 lines of code.
Long Method,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The method has 125 lines of code.
Long Method,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The method has 117 lines of code.
Long Method,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The method has 125 lines of code.
Complex Method,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,Cyclomatic complexity of the method is 11
Complex Method,Components,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,Start,Cyclomatic complexity of the method is 20
Complex Method,Components,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,Cyclomatic complexity of the method is 10
Complex Method,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,Cyclomatic complexity of the method is 11
Complex Method,Kopernicus,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,Start,Cyclomatic complexity of the method is 20
Complex Method,Kopernicus,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,Cyclomatic complexity of the method is 10
Long Parameter List,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 8 parameters. Parameters: inc' e' sma' lan' w' mEp' t' body
Long Parameter List,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 9 parameters. Parameters: inc' e' sma' lan' w' mEp' t' body' color
Long Parameter List,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 10 parameters. Parameters: inc' e' sma' lan' w' mEp' t' body' color' style
Long Parameter List,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The method has 6 parameters. Parameters: vertices' Uvs' Tris' degreeStep' innerScale' outerScale
Long Parameter List,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The method has 7 parameters. Parameters: vertices' Uvs' Tris' degreeStep' innerScale' outerScale' thicknessOffset
Long Parameter List,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 8 parameters. Parameters: inc' e' sma' lan' w' mEp' t' body
Long Parameter List,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 9 parameters. Parameters: inc' e' sma' lan' w' mEp' t' body' color
Long Parameter List,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 10 parameters. Parameters: inc' e' sma' lan' w' mEp' t' body' color' style
Long Parameter List,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The method has 6 parameters. Parameters: vertices' Uvs' Tris' degreeStep' innerScale' outerScale
Long Parameter List,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The method has 7 parameters. Parameters: vertices' Uvs' Tris' degreeStep' innerScale' outerScale' thicknessOffset
Long Identifier,Components,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,,The length of the parameter repositionToSphereSurfaceAddHeight is 34.
Long Identifier,Kopernicus,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,,The length of the parameter repositionToSphereSurfaceAddHeight is 34.
Long Statement,Components,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Events.cs,Awake,The length of the statement  "                PropertyInfo[] events = typeof(Events).GetProperties(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 121.
Long Statement,Components,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Events.cs,Awake,The length of the statement  "                    DescriptionAttribute description = (info.GetCustomAttributes(typeof(DescriptionAttribute)' false) as DescriptionAttribute[])[0]; " is 128.
Long Statement,Components,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Events.cs,Awake,The length of the statement  "                    events[i].SetValue(null' Activator.CreateInstance(events[i].PropertyType' new[] { "Kopernicus." + description.Description })' null); " is 132.
Long Statement,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawPath,The length of the statement  "                    if (Physics.Raycast(cameraPos' (points[i] - cameraPos).normalized) || Physics.Raycast(cameraPos' (points[i + 1] - cameraPos).normalized)) " is 137.
Long Statement,Components,HazardousOcean,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\HazardousOcean.cs,Update,The length of the statement  "                    Double distanceToPlanet = Math.Abs(Vector3d.Distance(vessel.transform.position' body.transform.position)) - ocean.GetSurfaceHeight(ocean.GetRelativePosition(vessel.transform.position)); " is 185.
Long Statement,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The length of the statement  "                _efficMult = (temperatureEfficCurve.Evaluate((Single)part.skinTemperature) * timeEfficCurve.Evaluate((Single)((Planetarium.GetUniversalTime() - launchUT) * 1.15740740740741E-05)) * efficiencyMult); " is 197.
Long Statement,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,ManualTracking,The length of the statement  "                    options[i + 1] = new DialogGUIButton(body.bodyDisplayName.Replace("^N"' "")' () => { manualTracking = true; trackingBody = body; GetTrackingBodyTransforms(); }' true); " is 167.
Long Statement,Components,MaterialFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,Update,The length of the statement  "                        foreach (Material material in Resources.FindObjectsOfTypeAll<Material>().Where(m => m.color.ToString() == new Color(0.640f' 0.728f' 0.171f' 0.729f).ToString())) " is 160.
Long Statement,Components,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Start,The length of the statement  "                scatter.GetType().GetField("scatterParent"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue(scatter' gameObject); " is 122.
Long Statement,Components,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Start,The length of the statement  "                PSystemBody body = PSystemManager.Instance.systemPrefab.GetComponentsInChildren<PSystemBody>(true).First(b => b.name == transform.parent.name); " is 143.
Long Statement,Components,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Update,The length of the statement  "                if (FlightGlobals.ActiveVessel.evaController.part.FindModulesImplementing<ModuleScienceExperiment>().All(e => e.experimentID != experimentNode.GetValue("experimentID")) && " is 171.
Long Statement,Components,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Update,The length of the statement  "                ToggleExperiment(Physics.OverlapSphere(FlightGlobals.ship_position' 10f).Any(c => c.gameObject.transform.parent.name == name)); " is 127.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The length of the statement  "                typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome); " is 278.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,Awake,The length of the statement  "                typeof(Sun).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Last(f => f.FieldType == typeof(Light)).SetValue(this' light); " is 132.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                    scaledSunLight.intensity = shifter.scaledIntensityCurve.Evaluate((Single)Vector3d.Distance(ScaledSpace.LocalToScaledSpace(sun.position)' target.position)); " is 155.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                    iva.GetComponent<Light>().intensity = shifter.ivaIntensityCurve.Evaluate((Single)Vector3d.Distance(sun.position' target.position)); " is 131.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                Boolean lightsOn = (HighLogic.LoadedSceneIsFlight || HighLogic.LoadedSceneHasPlanetarium || HighLogic.LoadedScene == GameScenes.SPACECENTER); " is 141.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                    Double horizonAngle = Math.Acos(FlightGlobals.currentMainBody.Radius / (FlightGlobals.currentMainBody.Radius + targetAltitude)); " is 128.
Long Statement,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The length of the statement  "                Double angle = (Vector3d.Dot(Vector3d.Cross(pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween(pos1' pos2) / 6.28318530717959 + 0.5; " is 152.
Long Statement,Components,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "                GLTools.DrawOrbit(0' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 126.
Long Statement,Components,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "                GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 127.
Long Statement,Components,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "                GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 128.
Long Statement,Components,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,Update,The length of the statement  "                    if (targetTransform == null) targetTransform = PSystemManager.Instance.localBodies.Find(b => b.transform.name == target).scaledBody.transform; " is 142.
Long Statement,Components,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,OnParticleCollision,The length of the statement  "                other.GetComponent<Rigidbody>().AddForceAtPosition(partice.velocity.normalized * partice.energy' partice.position' ForceMode.Impulse); " is 134.
Long Statement,Components,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,GetWorldParticleCollider,The length of the statement  "                Stream stream = typeof(PlanetParticleEmitter).Assembly.GetManifestResourceStream("Kopernicus.Components.Assets.WorldParticleCollider.unity3d"); " is 143.
Long Statement,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The length of the statement  "                        Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod); " is 135.
Long Statement,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The length of the statement  "                        Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod); " is 135.
Long Statement,Kopernicus,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Events.cs,Awake,The length of the statement  "                PropertyInfo[] events = typeof(Events).GetProperties(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 121.
Long Statement,Kopernicus,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Events.cs,Awake,The length of the statement  "                    DescriptionAttribute description = (info.GetCustomAttributes(typeof(DescriptionAttribute)' false) as DescriptionAttribute[])[0]; " is 128.
Long Statement,Kopernicus,Events,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Events.cs,Awake,The length of the statement  "                    events[i].SetValue(null' Activator.CreateInstance(events[i].PropertyType' new[] { "Kopernicus." + description.Description })' null); " is 132.
Long Statement,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawPath,The length of the statement  "                    if (Physics.Raycast(cameraPos' (points[i] - cameraPos).normalized) || Physics.Raycast(cameraPos' (points[i + 1] - cameraPos).normalized)) " is 137.
Long Statement,Kopernicus,HazardousOcean,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\HazardousOcean.cs,Update,The length of the statement  "                    Double distanceToPlanet = Math.Abs(Vector3d.Distance(vessel.transform.position' body.transform.position)) - ocean.GetSurfaceHeight(ocean.GetRelativePosition(vessel.transform.position)); " is 185.
Long Statement,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The length of the statement  "                _efficMult = (temperatureEfficCurve.Evaluate((Single)part.skinTemperature) * timeEfficCurve.Evaluate((Single)((Planetarium.GetUniversalTime() - launchUT) * 1.15740740740741E-05)) * efficiencyMult); " is 197.
Long Statement,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,ManualTracking,The length of the statement  "                    options[i + 1] = new DialogGUIButton(body.bodyDisplayName.Replace("^N"' "")' () => { manualTracking = true; trackingBody = body; GetTrackingBodyTransforms(); }' true); " is 167.
Long Statement,Kopernicus,MaterialFixer,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,Update,The length of the statement  "                        foreach (Material material in Resources.FindObjectsOfTypeAll<Material>().Where(m => m.color.ToString() == new Color(0.640f' 0.728f' 0.171f' 0.729f).ToString())) " is 160.
Long Statement,Kopernicus,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Start,The length of the statement  "                scatter.GetType().GetField("scatterParent"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue(scatter' gameObject); " is 122.
Long Statement,Kopernicus,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Start,The length of the statement  "                PSystemBody body = PSystemManager.Instance.systemPrefab.GetComponentsInChildren<PSystemBody>(true).First(b => b.name == transform.parent.name); " is 143.
Long Statement,Kopernicus,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Update,The length of the statement  "                if (FlightGlobals.ActiveVessel.evaController.part.FindModulesImplementing<ModuleScienceExperiment>().All(e => e.experimentID != experimentNode.GetValue("experimentID")) && " is 171.
Long Statement,Kopernicus,Scatter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Scatter.cs,Update,The length of the statement  "                ToggleExperiment(Physics.OverlapSphere(FlightGlobals.ship_position' 10f).Any(c => c.gameObject.transform.parent.name == name)); " is 127.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The length of the statement  "                typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome); " is 278.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,Awake,The length of the statement  "                typeof(Sun).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Last(f => f.FieldType == typeof(Light)).SetValue(this' light); " is 132.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                    scaledSunLight.intensity = shifter.scaledIntensityCurve.Evaluate((Single)Vector3d.Distance(ScaledSpace.LocalToScaledSpace(sun.position)' target.position)); " is 155.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                    iva.GetComponent<Light>().intensity = shifter.ivaIntensityCurve.Evaluate((Single)Vector3d.Distance(sun.position' target.position)); " is 131.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                Boolean lightsOn = (HighLogic.LoadedSceneIsFlight || HighLogic.LoadedSceneHasPlanetarium || HighLogic.LoadedScene == GameScenes.SPACECENTER); " is 141.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "                    Double horizonAngle = Math.Acos(FlightGlobals.currentMainBody.Radius / (FlightGlobals.currentMainBody.Radius + targetAltitude)); " is 128.
Long Statement,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The length of the statement  "                Double angle = (Vector3d.Dot(Vector3d.Cross(pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween(pos1' pos2) / 6.28318530717959 + 0.5; " is 152.
Long Statement,Kopernicus,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "                GLTools.DrawOrbit(0' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 126.
Long Statement,Kopernicus,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "                GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 127.
Long Statement,Kopernicus,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "                GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 128.
Long Statement,Kopernicus,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,Update,The length of the statement  "                    if (targetTransform == null) targetTransform = PSystemManager.Instance.localBodies.Find(b => b.transform.name == target).scaledBody.transform; " is 142.
Long Statement,Kopernicus,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,OnParticleCollision,The length of the statement  "                other.GetComponent<Rigidbody>().AddForceAtPosition(partice.velocity.normalized * partice.energy' partice.position' ForceMode.Impulse); " is 134.
Long Statement,Kopernicus,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,GetWorldParticleCollider,The length of the statement  "                Stream stream = typeof(PlanetParticleEmitter).Assembly.GetManifestResourceStream("Kopernicus.Components.Assets.WorldParticleCollider.unity3d"); " is 143.
Long Statement,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The length of the statement  "                        Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod); " is 135.
Long Statement,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The length of the statement  "                        Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod); " is 135.
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,IsOccluded,The following statement contains a magic number: Vector3d VC = (byBody.position - camPos) / (byBody.Radius - 100);
Magic Number,Components,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,IsOccluded,The following statement contains a magic number: Vector3d VT = (worldPosition - camPos) / (byBody.Radius - 100);
Magic Number,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: _efficMult = (temperatureEfficCurve.Evaluate((Single)part.skinTemperature) * timeEfficCurve.Evaluate((Single)((Planetarium.GetUniversalTime() - launchUT) * 1.15740740740741E-05)) * efficiencyMult);
Magic Number,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Components,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Components,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,LLAtoECEF,The following statement contains a magic number: const Double degreesToRadians = Math.PI / 180.0;
Magic Number,Components,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,LLAtoECEF,The following statement contains a magic number: lat = (lat - 90) * degreesToRadians;
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,Flux,The following statement contains a magic number: if (directSunlight)                  {                      return PhysicsGlobals.SolarLuminosity / (12.5663706143592 * realDistanceToSun * realDistanceToSun);                  }
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,Start,The following statement contains a magic number: scaledSunLight.cullingMask = 1 << 10;
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: Double angle = (Vector3d.Dot(Vector3d.Cross(pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween(pos1' pos2) / 6.28318530717959 + 0.5;
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: Double angle = (Vector3d.Dot(Vector3d.Cross(pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween(pos1' pos2) / 6.28318530717959 + 0.5;
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: if (angle > Math.PI * 2)                      angle -= Math.PI * 2;
Magic Number,Components,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: if (angle > Math.PI * 2)                      angle -= Math.PI * 2;
Magic Number,Components,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);
Magic Number,Components,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);
Magic Number,Components,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);
Magic Number,Components,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,Create,The following statement contains a magic number: emitter.SetLayerRecursive(10);
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: Int32 Wrapping = steps * 2;
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: Int32 Wrapping = steps * 2;
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The following statement contains a magic number: if (lockRotation && referenceBody != null) {                      // Setting transform.rotation does NOT give us a consistent                      // absolute orientation as you would expect from the documentation.                      // "World" coordinates seem to be set differently each time the                      // game is loaded. Instead' we use localRotation to orient the ring                      // relative to its parent body' subtract off the parent body's                      // rotation at the current moment in time' then add the LAN.                      // Note that eastward (prograde) rotation is negative in trigonometry.                      if (rotationPeriod != 0f) {                          Single degreesPerSecond = -360f / rotationPeriod;                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation                              * Quaternion.Euler(0' (Single)Planetarium.GetUniversalTime() * degreesPerSecond' 0);                      } else {                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation;                      }                  }
Magic Number,Components,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The following statement contains a magic number: if (lockRotation && referenceBody != null) {                      // Setting transform.rotation does NOT give us a consistent                      // absolute orientation as you would expect from the documentation.                      // "World" coordinates seem to be set differently each time the                      // game is loaded. Instead' we use localRotation to orient the ring                      // relative to its parent body' subtract off the parent body's                      // rotation at the current moment in time' then add the LAN.                      // Note that eastward (prograde) rotation is negative in trigonometry.                      if (rotationPeriod != 0f) {                          Single degreesPerSecond = -360f / rotationPeriod;                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation                              * Quaternion.Euler(0' (Single)Planetarium.GetUniversalTime() * degreesPerSecond' 0);                      } else {                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation;                      }                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1)                  {                      for (Int32 i = 0; i < Math.Floor(360.0 / resolution); i++)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                      points.Add(points[0]); // close the loop                  }                  // Calculations for hyperbolic orbits                  else                  {                      for (Int32 i = -1000; i <= 1000; i += 5)                          points.Add(ScaledSpace.LocalToScaledSpace(orbit.getPositionFromEccAnomaly(i * resolution * Math.PI / 180)));                  }
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,IsOccluded,The following statement contains a magic number: Vector3d VC = (byBody.position - camPos) / (byBody.Radius - 100);
Magic Number,Kopernicus,GLTools,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\GLTools.cs,IsOccluded,The following statement contains a magic number: Vector3d VT = (worldPosition - camPos) / (byBody.Radius - 100);
Magic Number,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: _efficMult = (temperatureEfficCurve.Evaluate((Single)part.skinTemperature) * timeEfficCurve.Evaluate((Single)((Planetarium.GetUniversalTime() - launchUT) * 1.15740740740741E-05)) * efficiencyMult);
Magic Number,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Kopernicus,KopernicusSolarPanel,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars)                  {                      // Calculate stuff                      Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;                      CelestialBody old = trackingBody;                      trackingTransformLocal = star.sun.transform;                      trackingTransformScaled = star.sun.scaledBody.transform;                      trackingLOS = CalculateTrackingLOS(trackDir' ref blockingObject);                      trackingTransformLocal = old.transform;                      trackingTransformScaled = old.scaledBody.transform;                        // Calculate sun AOA                      Single _sunAOA = 0f;                      if (!trackingLOS)                      {                          _sunAOA = 0f;                          status = "Blocked by " + blockingObject;                      }                      else                      {                          status = "Direct Sunlight";                          if (panelType == PanelType.FLAT)                          {                              _sunAOA = Mathf.Clamp(Vector3.Dot(trackingDotTransform.forward' trackDir)' 0f' 1f);                          }                          else if (panelType != PanelType.CYLINDRICAL)                          {                              _sunAOA = 0.25f;                          }                          else                          {                              Vector3 direction;                              if (alignType == PanelAlignType.PIVOT)                              {                                  direction = trackingDotTransform.forward;                              }                              else if (alignType != PanelAlignType.X)                              {                                  direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;                              }                              else                              {                                  direction = part.partTransform.right;                              }                              _sunAOA = (1f - Mathf.Abs(Vector3.Dot(direction' trackDir))) * 0.318309873f;                          }                      }                        // Calculate distance multiplier                      Double __distMult = 1;                      if (!useCurve)                      {                          if (!KopernicusStar.SolarFlux.ContainsKey(star.name))                              continue;                          __distMult = (Single)(KopernicusStar.SolarFlux[star.name] / stockLuminosity);                      }                      else                      {                          __distMult = powerCurve.Evaluate((star.sun.transform.position - panelRotationTransform.position).magnitude);                      }                        // Calculate flow rate                      Double __flowRate = _sunAOA * _efficMult * __distMult;                      if (part.submergedPortion > 0)                      {                          Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos((Vector3d) secondaryTransform.position' vessel.mainBody);                          altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;                          if (altitudeAtPos < 0.5)                          {                              altitudeAtPos = 0.5;                          }                          Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);                          if (part.submergedPortion >= 1)                          {                              __flowRate = __flowRate * num;                          }                          else                          {                              __flowRate = __flowRate * UtilMath.LerpUnclamped(1' num' part.submergedPortion);                          }                          status += "' Underwater";                      }                      sunAOA += _sunAOA;                      Double energy = __distMult * _efficMult;                      if (energy > maxEnergy)                      {                          maxFlowRate = __flowRate;                          maxEnergy = energy;                          maxStar = star;                      }                        // Apply the flow rate                      _flowRate += __flowRate;                  }
Magic Number,Kopernicus,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,LLAtoECEF,The following statement contains a magic number: const Double degreesToRadians = Math.PI / 180.0;
Magic Number,Kopernicus,KSC,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KSC.cs,LLAtoECEF,The following statement contains a magic number: lat = (lat - 90) * degreesToRadians;
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields(BindingFlags.Instance | BindingFlags.NonPublic).Where(f => f.FieldType == typeof(Double)).Skip(2).First().SetValue(PhysicsGlobals.Instance' Math.Pow(homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,Flux,The following statement contains a magic number: if (directSunlight)                  {                      return PhysicsGlobals.SolarLuminosity / (12.5663706143592 * realDistanceToSun * realDistanceToSun);                  }
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,Start,The following statement contains a magic number: scaledSunLight.cullingMask = 1 << 10;
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: Double angle = (Vector3d.Dot(Vector3d.Cross(pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween(pos1' pos2) / 6.28318530717959 + 0.5;
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: Double angle = (Vector3d.Dot(Vector3d.Cross(pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween(pos1' pos2) / 6.28318530717959 + 0.5;
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: if (angle > Math.PI * 2)                      angle -= Math.PI * 2;
Magic Number,Kopernicus,KopernicusStar,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: if (angle > Math.PI * 2)                      angle -= Math.PI * 2;
Magic Number,Kopernicus,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);
Magic Number,Kopernicus,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);
Magic Number,Kopernicus,Wiresphere,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit(90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);
Magic Number,Kopernicus,PlanetParticleEmitter,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\PlanetaryParticle.cs,Create,The following statement contains a magic number: emitter.SetLayerRecursive(10);
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: Int32 Wrapping = steps * 2;
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add((i    ) % Wrapping);                      Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                        Tris.Add((i + 1) % Wrapping);                      Tris.Add((i + 3) % Wrapping);                      Tris.Add((i + 2) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeLinearMesh,The following statement contains a magic number: for (Int32 i = 0; i < Wrapping; i += 2)                  {                      Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                      Tris.Add(Wrapping + (i    ) % Wrapping);                        Tris.Add(Wrapping + (i + 2) % Wrapping);                      Tris.Add(Wrapping + (i + 3) % Wrapping);                      Tris.Add(Wrapping + (i + 1) % Wrapping);                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: Int32 Wrapping = steps * 2;
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (innerRadius < outerRadius)                  {                      // Top faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Bottom faces                      for (Single i = 0f; i < 360f; i += degreeStep)                      {                          // Rotation                          Vector3 eVert = Quaternion.Euler(0' i' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' i);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(sideInnerU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(sideOuterU + texV);                      }                      // Tri Wrapping                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          Tris.Add(i);                          Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add((i + 1) % Wrapping);                          Tris.Add((i + 3) % Wrapping);                          Tris.Add((i + 2) % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                          Tris.Add(Wrapping + i % Wrapping);                            Tris.Add(Wrapping + (i + 2) % Wrapping);                          Tris.Add(Wrapping + (i + 3) % Wrapping);                          Tris.Add(Wrapping + (i + 1) % Wrapping);                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,MakeTiledMesh,The following statement contains a magic number: if (thickness > 0)                  {                      Int32 firstTop = vertices.Count;                      // Mesh wrapping - top faces                      // We need to generate one extra pair of vertices                      // so the last triangles' texture coordinates don't                      // go from a high value back to zero.                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale + thicknessOffset);                          Uvs.Add(innerTopU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale + thicknessOffset);                          Uvs.Add(outerTopU + texV);                      }                      // Mesh wrapping - bottom faces                      for (Int32 i = 0; i <= steps; ++i)                      {                          Single f = i * degreeStep;                            // Rotation                          Vector3 eVert = Quaternion.Euler(0' f' 0) * Vector3.right;                          Vector2 texV  = textureV(tiles' f);                            // Inner Radius                          vertices.Add(eVert * innerScale - thicknessOffset);                          Uvs.Add(innerBottomU + texV);                            // Outer Radius                          vertices.Add(eVert * outerScale - thicknessOffset);                          Uvs.Add(outerBottomU + texV);                      }                      // Tri Wrapping                      // No modulus this time because we want to use those                      // extra vertices instead of having the                      // texture coordinates loop back around.                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Inner faces                          Tris.Add(firstTop + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + i);                            Tris.Add(firstTop + Wrapping + 2 + i);                          Tris.Add(firstTop + (i + 2));                          Tris.Add(firstTop + Wrapping + 2 + (i + 2));                      }                      // Outer faces should always draw after inner to                      // make the overlaps render correctly                      for (Int32 i = 0; i < Wrapping; i += 2)                      {                          // Outer faces                          Tris.Add(firstTop + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + (i + 3));                            Tris.Add(firstTop + Wrapping + 2 + (i + 1));                          Tris.Add(firstTop + Wrapping + 2 + (i + 3));                          Tris.Add(firstTop + (i + 3));                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The following statement contains a magic number: if (lockRotation && referenceBody != null) {                      // Setting transform.rotation does NOT give us a consistent                      // absolute orientation as you would expect from the documentation.                      // "World" coordinates seem to be set differently each time the                      // game is loaded. Instead' we use localRotation to orient the ring                      // relative to its parent body' subtract off the parent body's                      // rotation at the current moment in time' then add the LAN.                      // Note that eastward (prograde) rotation is negative in trigonometry.                      if (rotationPeriod != 0f) {                          Single degreesPerSecond = -360f / rotationPeriod;                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation                              * Quaternion.Euler(0' (Single)Planetarium.GetUniversalTime() * degreesPerSecond' 0);                      } else {                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation;                      }                  }
Magic Number,Kopernicus,Ring,C:\repos\BryceSchroeder_Kopernicus\src\Kopernicus.Components\Ring.cs,SetRotation,The following statement contains a magic number: if (lockRotation && referenceBody != null) {                      // Setting transform.rotation does NOT give us a consistent                      // absolute orientation as you would expect from the documentation.                      // "World" coordinates seem to be set differently each time the                      // game is loaded. Instead' we use localRotation to orient the ring                      // relative to its parent body' subtract off the parent body's                      // rotation at the current moment in time' then add the LAN.                      // Note that eastward (prograde) rotation is negative in trigonometry.                      if (rotationPeriod != 0f) {                          Single degreesPerSecond = -360f / rotationPeriod;                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation                              * Quaternion.Euler(0' (Single)Planetarium.GetUniversalTime() * degreesPerSecond' 0);                      } else {                          Single parentRotation = (Single) (referenceBody.initialRotation + 360 * Planetarium.GetUniversalTime() / referenceBody.rotationPeriod);                          transform.localRotation =                              Quaternion.Euler(0' parentRotation - longitudeOfAscendingNode' 0)                              * rotation;                      }                  }
