Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,Cyclomatic complexity of the method is 15
Complex Method,Components,KSC,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KSC.cs,Start,Cyclomatic complexity of the method is 27
Complex Method,Components,Scatter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Scatter.cs,Update,Cyclomatic complexity of the method is 15
Complex Method,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,Cyclomatic complexity of the method is 8
Long Parameter List,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 8 parameters.
Long Parameter List,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 9 parameters.
Long Parameter List,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The method has 10 parameters.
Long Statement,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawPath,The length of the statement  "		if (Physics.Raycast (cameraPos' (points [i] - cameraPos).normalized) || Physics.Raycast (cameraPos' (points [i + 1] - cameraPos).normalized)) " is 141.
Long Statement,Components,HazardousOcean,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\HazardousOcean.cs,Update,The length of the statement  "		double distanceToPlanet = Math.Abs (Vector3d.Distance (vessel.transform.position' body.transform.position)) - ocean.GetSurfaceHeight (ocean.GetRelativePosition (vessel.transform.position)); " is 189.
Long Statement,Components,KopernicusBuoyancy,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusBuoyancy.cs,GetOcean,The length of the statement  "		_ocean = mainBody.GetComponentsInChildren<PQS> (true).FirstOrDefault (p => p.name == mainBody.transform.name + "Ocean"); " is 120.
Long Statement,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The length of the statement  "	_efficMult = (temperatureEfficCurve.Evaluate ((Single)part.skinTemperature) * timeEfficCurve.Evaluate ((Single)((Planetarium.GetUniversalTime () - launchUT) * 1.15740740740741E-05)) * efficiencyMult); " is 200.
Long Statement,Components,Scatter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Scatter.cs,Start,The length of the statement  "	scatter.GetType ().GetField ("scatterParent"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue (scatter' gameObject); " is 125.
Long Statement,Components,Scatter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Scatter.cs,Start,The length of the statement  "	PSystemBody body = PSystemManager.Instance.systemPrefab.GetComponentsInChildren<PSystemBody> (true).First (b => b.name == transform.parent.name); " is 145.
Long Statement,Components,Scatter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Scatter.cs,Update,The length of the statement  "	if (FlightGlobals.ActiveVessel.evaController.part.FindModulesImplementing<ModuleScienceExperiment> ().All (e => e.experimentID != experimentNode.GetValue ("experimentID")) && !vesselID.Contains (FlightGlobals.ActiveVessel.id) && !FlightGlobals.ActiveVessel.packed) " is 264.
Long Statement,Components,Scatter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Scatter.cs,Update,The length of the statement  "	ToggleExperiment (Physics.OverlapSphere (FlightGlobals.ship_position' 10f).Any (c => c.gameObject.transform.parent.name == name)); " is 130.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The length of the statement  "	typeof(PhysicsGlobals).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Where (f => f.FieldType == typeof(double)).Skip (2).First ().SetValue (PhysicsGlobals.Instance' Math.Pow (homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome); " is 284.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,Awake,The length of the statement  "	typeof(Sun).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Last (f => f.FieldType == typeof(Light)).SetValue (this' light); " is 135.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "	sunFlare.brightness = brightnessMultiplier * brightnessCurve.Evaluate ((float)(1 / (Vector3d.Distance (target.position' ScaledSpace.LocalToScaledSpace (sun.position)) / (AU * ScaledSpace.InverseScaleFactor)))); " is 210.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "	bool lightsOn = (HighLogic.LoadedSceneIsFlight || HighLogic.LoadedSceneHasPlanetarium || HighLogic.LoadedScene == GameScenes.SPACECENTER); " is 138.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "		double horizonAngle = Math.Acos (FlightGlobals.currentMainBody.Radius / (FlightGlobals.currentMainBody.Radius + targetAltitude)); " is 129.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,LateUpdate,The length of the statement  "		light.intensity = Mathf.Lerp (0f' scaledSunLight.intensity' Mathf.InverseLerp (fadeEndAtAlt' fadeStartAtAlt' localTime)); " is 121.
Long Statement,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The length of the statement  "	double angle = (Vector3d.Dot (Vector3d.Cross (pos2' pos1)' cb.angularVelocity) < 0 ? -1 : 1) * Vector3d.AngleBetween (pos1' pos2) / 6.28318530717959 + 0.5; " is 155.
Long Statement,Components,Wiresphere,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "	GLTools.DrawOrbit (0' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 127.
Long Statement,Components,Wiresphere,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "	GLTools.DrawOrbit (90' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 128.
Long Statement,Components,Wiresphere,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Wiresphere.cs,OnGUI,The length of the statement  "	GLTools.DrawOrbit (90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED); " is 129.
Long Statement,Components,PlanetParticleEmitter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\PlanetaryParticle.cs,OnParticleCollision,The length of the statement  "	other.GetComponent<Rigidbody> ().AddForceAtPosition (partice.velocity.normalized * partice.energy' partice.position' ForceMode.Impulse); " is 136.
Long Statement,Components,PlanetParticleEmitter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\PlanetaryParticle.cs,GetWorldParticleCollider,The length of the statement  "	Stream stream = typeof(PlanetParticleEmitter).Assembly.GetManifestResourceStream ("Kopernicus.Components.Assets.WorldParticleCollider.unity3d"); " is 144.
Long Statement,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,Update,The length of the statement  "		Vector3 sunPosRelativeToPlanet = KopernicusStar.Current.sun.transform.position - ScaledSpace.ScaledToLocalSpace (transform.position); " is 133.
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1) {  	for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  	points.Add (points [0]);  	// close the loop  } // Calculations for hyperbolic orbits  else {  	for (int i = -1000; i <= 1000; i += 5)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  }  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1) {  	for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  	points.Add (points [0]);  	// close the loop  } // Calculations for hyperbolic orbits  else {  	for (int i = -1000; i <= 1000; i += 5)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  }  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1) {  	for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  	points.Add (points [0]);  	// close the loop  } // Calculations for hyperbolic orbits  else {  	for (int i = -1000; i <= 1000; i += 5)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  }  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1) {  	for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  	points.Add (points [0]);  	// close the loop  } // Calculations for hyperbolic orbits  else {  	for (int i = -1000; i <= 1000; i += 5)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  }  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1) {  	for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  	points.Add (points [0]);  	// close the loop  } // Calculations for hyperbolic orbits  else {  	for (int i = -1000; i <= 1000; i += 5)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  }  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: if (orbit.eccentricity < 1) {  	for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  	points.Add (points [0]);  	// close the loop  } // Calculations for hyperbolic orbits  else {  	for (int i = -1000; i <= 1000; i += 5)  		points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  }  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  	points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: for (int i = 0; i < Math.Floor (360.0 / resolution); i++)  	points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: for (int i = -1000; i <= 1000; i += 5)  	points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: for (int i = -1000; i <= 1000; i += 5)  	points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: for (int i = -1000; i <= 1000; i += 5)  	points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: for (int i = -1000; i <= 1000; i += 5)  	points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: i += 5
Magic Number,Components,GLTools,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\GLTools.cs,DrawOrbit,The following statement contains a magic number: points.Add (ScaledSpace.LocalToScaledSpace (orbit.getPositionFromEccAnomaly (i * resolution * Math.PI / 180)));  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: _efficMult = (temperatureEfficCurve.Evaluate ((Single)part.skinTemperature) * timeEfficCurve.Evaluate ((Single)((Planetarium.GetUniversalTime () - launchUT) * 1.15740740740741E-05)) * efficiencyMult);  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars) {  	// Calculate stuff  	Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;  	CelestialBody old = trackingBody;  	trackingTransformLocal = star.sun.transform;  	trackingTransformScaled = star.sun.scaledBody.transform;  	trackingLOS = CalculateTrackingLOS (trackDir' ref blockingObject);  	trackingTransformLocal = old.transform;  	trackingTransformScaled = old.scaledBody.transform;  	// Calculate sun AOA  	Single _sunAOA = 0f;  	if (!trackingLOS) {  		_sunAOA = 0f;  		status = "Blocked by " + blockingObject;  	} else {  		status = "Direct Sunlight";  		if (panelType == PanelType.FLAT) {  			_sunAOA = Mathf.Clamp (Vector3.Dot (trackingDotTransform.forward' trackDir)' 0f' 1f);  		} else if (panelType != PanelType.CYLINDRICAL) {  			_sunAOA = 0.25f;  		} else {  			Vector3 direction;  			if (alignType == PanelAlignType.PIVOT) {  				direction = trackingDotTransform.forward;  			} else if (alignType != PanelAlignType.X) {  				direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;  			} else {  				direction = part.partTransform.right;  			}  			_sunAOA = (1f - Mathf.Abs (Vector3.Dot (direction' trackDir))) * 0.318309873f;  		}  	}  	// Calculate distance multiplier  	Double __distMult = 1;  	if (!useCurve) {  		if (!KopernicusStar.SolarFlux.ContainsKey (star.name))  			continue;  		__distMult = (Single)(KopernicusStar.SolarFlux [star.name] / stockLuminosity);  	} else {  		__distMult = powerCurve.Evaluate ((star.sun.transform.position - panelRotationTransform.position).magnitude);  	}  	// Calculate flow rate  	Double __flowRate = _sunAOA * _efficMult * __distMult;  	if (part.submergedPortion > 0) {  		Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  		altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  		if (altitudeAtPos < 0.5) {  			altitudeAtPos = 0.5;  		}  		Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  		if (part.submergedPortion >= 1) {  			__flowRate = __flowRate * num;  		} else {  			__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  		}  		status += "' Underwater";  	}  	sunAOA += (Single)__flowRate * _sunAOA;  	if (__flowRate > maxFlowRate) {  		maxFlowRate = __flowRate;  	}  	// Apply the flow rate  	_flowRate += __flowRate;  	// Check if we have a new maximum  	if (_sunAOA > maxAOA) {  		maxAOA = _sunAOA;  		maxStar = star;  	}  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars) {  	// Calculate stuff  	Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;  	CelestialBody old = trackingBody;  	trackingTransformLocal = star.sun.transform;  	trackingTransformScaled = star.sun.scaledBody.transform;  	trackingLOS = CalculateTrackingLOS (trackDir' ref blockingObject);  	trackingTransformLocal = old.transform;  	trackingTransformScaled = old.scaledBody.transform;  	// Calculate sun AOA  	Single _sunAOA = 0f;  	if (!trackingLOS) {  		_sunAOA = 0f;  		status = "Blocked by " + blockingObject;  	} else {  		status = "Direct Sunlight";  		if (panelType == PanelType.FLAT) {  			_sunAOA = Mathf.Clamp (Vector3.Dot (trackingDotTransform.forward' trackDir)' 0f' 1f);  		} else if (panelType != PanelType.CYLINDRICAL) {  			_sunAOA = 0.25f;  		} else {  			Vector3 direction;  			if (alignType == PanelAlignType.PIVOT) {  				direction = trackingDotTransform.forward;  			} else if (alignType != PanelAlignType.X) {  				direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;  			} else {  				direction = part.partTransform.right;  			}  			_sunAOA = (1f - Mathf.Abs (Vector3.Dot (direction' trackDir))) * 0.318309873f;  		}  	}  	// Calculate distance multiplier  	Double __distMult = 1;  	if (!useCurve) {  		if (!KopernicusStar.SolarFlux.ContainsKey (star.name))  			continue;  		__distMult = (Single)(KopernicusStar.SolarFlux [star.name] / stockLuminosity);  	} else {  		__distMult = powerCurve.Evaluate ((star.sun.transform.position - panelRotationTransform.position).magnitude);  	}  	// Calculate flow rate  	Double __flowRate = _sunAOA * _efficMult * __distMult;  	if (part.submergedPortion > 0) {  		Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  		altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  		if (altitudeAtPos < 0.5) {  			altitudeAtPos = 0.5;  		}  		Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  		if (part.submergedPortion >= 1) {  			__flowRate = __flowRate * num;  		} else {  			__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  		}  		status += "' Underwater";  	}  	sunAOA += (Single)__flowRate * _sunAOA;  	if (__flowRate > maxFlowRate) {  		maxFlowRate = __flowRate;  	}  	// Apply the flow rate  	_flowRate += __flowRate;  	// Check if we have a new maximum  	if (_sunAOA > maxAOA) {  		maxAOA = _sunAOA;  		maxStar = star;  	}  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars) {  	// Calculate stuff  	Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;  	CelestialBody old = trackingBody;  	trackingTransformLocal = star.sun.transform;  	trackingTransformScaled = star.sun.scaledBody.transform;  	trackingLOS = CalculateTrackingLOS (trackDir' ref blockingObject);  	trackingTransformLocal = old.transform;  	trackingTransformScaled = old.scaledBody.transform;  	// Calculate sun AOA  	Single _sunAOA = 0f;  	if (!trackingLOS) {  		_sunAOA = 0f;  		status = "Blocked by " + blockingObject;  	} else {  		status = "Direct Sunlight";  		if (panelType == PanelType.FLAT) {  			_sunAOA = Mathf.Clamp (Vector3.Dot (trackingDotTransform.forward' trackDir)' 0f' 1f);  		} else if (panelType != PanelType.CYLINDRICAL) {  			_sunAOA = 0.25f;  		} else {  			Vector3 direction;  			if (alignType == PanelAlignType.PIVOT) {  				direction = trackingDotTransform.forward;  			} else if (alignType != PanelAlignType.X) {  				direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;  			} else {  				direction = part.partTransform.right;  			}  			_sunAOA = (1f - Mathf.Abs (Vector3.Dot (direction' trackDir))) * 0.318309873f;  		}  	}  	// Calculate distance multiplier  	Double __distMult = 1;  	if (!useCurve) {  		if (!KopernicusStar.SolarFlux.ContainsKey (star.name))  			continue;  		__distMult = (Single)(KopernicusStar.SolarFlux [star.name] / stockLuminosity);  	} else {  		__distMult = powerCurve.Evaluate ((star.sun.transform.position - panelRotationTransform.position).magnitude);  	}  	// Calculate flow rate  	Double __flowRate = _sunAOA * _efficMult * __distMult;  	if (part.submergedPortion > 0) {  		Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  		altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  		if (altitudeAtPos < 0.5) {  			altitudeAtPos = 0.5;  		}  		Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  		if (part.submergedPortion >= 1) {  			__flowRate = __flowRate * num;  		} else {  			__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  		}  		status += "' Underwater";  	}  	sunAOA += (Single)__flowRate * _sunAOA;  	if (__flowRate > maxFlowRate) {  		maxFlowRate = __flowRate;  	}  	// Apply the flow rate  	_flowRate += __flowRate;  	// Check if we have a new maximum  	if (_sunAOA > maxAOA) {  		maxAOA = _sunAOA;  		maxStar = star;  	}  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: foreach (KopernicusStar star in KopernicusStar.Stars) {  	// Calculate stuff  	Vector3 trackDir = (star.sun.transform.position - panelRotationTransform.position).normalized;  	CelestialBody old = trackingBody;  	trackingTransformLocal = star.sun.transform;  	trackingTransformScaled = star.sun.scaledBody.transform;  	trackingLOS = CalculateTrackingLOS (trackDir' ref blockingObject);  	trackingTransformLocal = old.transform;  	trackingTransformScaled = old.scaledBody.transform;  	// Calculate sun AOA  	Single _sunAOA = 0f;  	if (!trackingLOS) {  		_sunAOA = 0f;  		status = "Blocked by " + blockingObject;  	} else {  		status = "Direct Sunlight";  		if (panelType == PanelType.FLAT) {  			_sunAOA = Mathf.Clamp (Vector3.Dot (trackingDotTransform.forward' trackDir)' 0f' 1f);  		} else if (panelType != PanelType.CYLINDRICAL) {  			_sunAOA = 0.25f;  		} else {  			Vector3 direction;  			if (alignType == PanelAlignType.PIVOT) {  				direction = trackingDotTransform.forward;  			} else if (alignType != PanelAlignType.X) {  				direction = alignType != PanelAlignType.Y ? part.partTransform.forward : part.partTransform.up;  			} else {  				direction = part.partTransform.right;  			}  			_sunAOA = (1f - Mathf.Abs (Vector3.Dot (direction' trackDir))) * 0.318309873f;  		}  	}  	// Calculate distance multiplier  	Double __distMult = 1;  	if (!useCurve) {  		if (!KopernicusStar.SolarFlux.ContainsKey (star.name))  			continue;  		__distMult = (Single)(KopernicusStar.SolarFlux [star.name] / stockLuminosity);  	} else {  		__distMult = powerCurve.Evaluate ((star.sun.transform.position - panelRotationTransform.position).magnitude);  	}  	// Calculate flow rate  	Double __flowRate = _sunAOA * _efficMult * __distMult;  	if (part.submergedPortion > 0) {  		Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  		altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  		if (altitudeAtPos < 0.5) {  			altitudeAtPos = 0.5;  		}  		Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  		if (part.submergedPortion >= 1) {  			__flowRate = __flowRate * num;  		} else {  			__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  		}  		status += "' Underwater";  	}  	sunAOA += (Single)__flowRate * _sunAOA;  	if (__flowRate > maxFlowRate) {  		maxFlowRate = __flowRate;  	}  	// Apply the flow rate  	_flowRate += __flowRate;  	// Check if we have a new maximum  	if (_sunAOA > maxAOA) {  		maxAOA = _sunAOA;  		maxStar = star;  	}  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: if (part.submergedPortion > 0) {  	Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  	altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  	if (altitudeAtPos < 0.5) {  		altitudeAtPos = 0.5;  	}  	Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  	if (part.submergedPortion >= 1) {  		__flowRate = __flowRate * num;  	} else {  		__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  	}  	status += "' Underwater";  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: if (part.submergedPortion > 0) {  	Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  	altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  	if (altitudeAtPos < 0.5) {  		altitudeAtPos = 0.5;  	}  	Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  	if (part.submergedPortion >= 1) {  		__flowRate = __flowRate * num;  	} else {  		__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  	}  	status += "' Underwater";  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: if (part.submergedPortion > 0) {  	Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  	altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  	if (altitudeAtPos < 0.5) {  		altitudeAtPos = 0.5;  	}  	Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  	if (part.submergedPortion >= 1) {  		__flowRate = __flowRate * num;  	} else {  		__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  	}  	status += "' Underwater";  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: if (part.submergedPortion > 0) {  	Double altitudeAtPos = -FlightGlobals.getAltitudeAtPos ((Vector3d)secondaryTransform.position' vessel.mainBody);  	altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  	if (altitudeAtPos < 0.5) {  		altitudeAtPos = 0.5;  	}  	Double num = 1 / (1 + altitudeAtPos * part.vessel.mainBody.oceanDensity);  	if (part.submergedPortion >= 1) {  		__flowRate = __flowRate * num;  	} else {  		__flowRate = __flowRate * UtilMath.LerpUnclamped (1' num' part.submergedPortion);  	}  	status += "' Underwater";  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: altitudeAtPos = (altitudeAtPos * 3 + part.maxDepth) * 0.25;  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: if (altitudeAtPos < 0.5) {  	altitudeAtPos = 0.5;  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: if (altitudeAtPos < 0.5) {  	altitudeAtPos = 0.5;  }  
Magic Number,Components,KopernicusSolarPanel,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusSolarPanel.cs,PostCalculateTracking,The following statement contains a magic number: altitudeAtPos = 0.5;  
Magic Number,Components,KSC,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KSC.cs,LLAtoECEF,The following statement contains a magic number: lat = (lat - 90) * degreesToRadians;  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Where (f => f.FieldType == typeof(double)).Skip (2).First ().SetValue (PhysicsGlobals.Instance' Math.Pow (homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Where (f => f.FieldType == typeof(double)).Skip (2).First ().SetValue (PhysicsGlobals.Instance' Math.Pow (homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Where (f => f.FieldType == typeof(double)).Skip (2).First ().SetValue (PhysicsGlobals.Instance' Math.Pow (homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,CalculatePhysics,The following statement contains a magic number: typeof(PhysicsGlobals).GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Where (f => f.FieldType == typeof(double)).Skip (2).First ().SetValue (PhysicsGlobals.Instance' Math.Pow (homeBody.orbit.semiMajorAxis' 2) * 4 * 3.14159265358979 * PhysicsGlobals.SolarLuminosityAtHome);  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,Flux,The following statement contains a magic number: if (directSunlight) {  	return PhysicsGlobals.SolarLuminosity / (12.5663706143592 * realDistanceToSun * realDistanceToSun);  }  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,Flux,The following statement contains a magic number: return PhysicsGlobals.SolarLuminosity / (12.5663706143592 * realDistanceToSun * realDistanceToSun);  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,Start,The following statement contains a magic number: scaledSunLight.cullingMask = 1 << 10;  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: if (angle > Math.PI * 2)  	angle -= Math.PI * 2;  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: if (angle > Math.PI * 2)  	angle -= Math.PI * 2;  
Magic Number,Components,KopernicusStar,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\KopernicusStar.cs,GetLocalTimeAtPosition,The following statement contains a magic number: angle -= Math.PI * 2;  
Magic Number,Components,Wiresphere,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit (90' 0' body.sphereOfInfluence' 0' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);  
Magic Number,Components,Wiresphere,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit (90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);  
Magic Number,Components,Wiresphere,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Wiresphere.cs,OnGUI,The following statement contains a magic number: GLTools.DrawOrbit (90' 0' body.sphereOfInfluence' 90' 0' 0' 0' body' body.orbitDriver.Renderer.orbitColor' GLTools.Style.DASHED);  
Magic Number,Components,PlanetParticleEmitter,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\PlanetaryParticle.cs,Create,The following statement contains a magic number: emitter.SetLayerRecursive (10);  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add ((i) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 3) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add ((i) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 3) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add ((i) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 3) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add ((i) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  	Tris.Add ((i + 1) % Wrapping);  	Tris.Add ((i + 3) % Wrapping);  	Tris.Add ((i + 2) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: i += 2
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: Tris.Add ((i + 2) % Wrapping);  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: Tris.Add ((i + 3) % Wrapping);  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: Tris.Add ((i + 2) % Wrapping);  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  	Tris.Add (Wrapping + (i) % Wrapping);  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 3) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  	Tris.Add (Wrapping + (i) % Wrapping);  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 3) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  	Tris.Add (Wrapping + (i) % Wrapping);  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 3) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: for (int i = 0; i < Wrapping; i += 2) {  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  	Tris.Add (Wrapping + (i) % Wrapping);  	Tris.Add (Wrapping + (i + 2) % Wrapping);  	Tris.Add (Wrapping + (i + 3) % Wrapping);  	Tris.Add (Wrapping + (i + 1) % Wrapping);  }  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: i += 2
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: Tris.Add (Wrapping + (i + 2) % Wrapping);  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: Tris.Add (Wrapping + (i + 2) % Wrapping);  
Magic Number,Components,Ring,F:\newReposMay17\BryceSchroeder_Kopernicus\Kopernicus\Kopernicus.Components\Ring.cs,BuildRing,The following statement contains a magic number: Tris.Add (Wrapping + (i + 3) % Wrapping);  
