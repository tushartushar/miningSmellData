Implementation smell,Namespace,Class,File,Method,Description
Long Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The method has 132 lines of code.
Long Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The method has 167 lines of code.
Long Method,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The method has 106 lines of code.
Long Method,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,DeleteItemFromRange,The method has 178 lines of code.
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,RemoveDuplicatesInPlace,Cyclomatic complexity of the method is 13
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,TryFindLastWhere,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,RandomSubset,Cyclomatic complexity of the method is 9
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,GeneratePermutations,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,GenerateSortedPermutations,Cyclomatic complexity of the method is 11
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,Cyclomatic complexity of the method is 19
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,Cyclomatic complexity of the method is 21
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,MergeSorted,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,RemoveWhere,Cyclomatic complexity of the method is 19
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Partition,Cyclomatic complexity of the method is 11
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StablePartition,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,EqualCollections,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,EqualCollections,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,Cyclomatic complexity of the method is 13
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Rotate,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,RotateInPlace,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,Insert,Cyclomatic complexity of the method is 16
Complex Method,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,InsertRange,Cyclomatic complexity of the method is 21
Complex Method,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,RemoveAt,Cyclomatic complexity of the method is 14
Complex Method,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,RemoveRange,Cyclomatic complexity of the method is 22
Complex Method,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Insert,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,CloneContents,Cyclomatic complexity of the method is 9
Complex Method,Wintellect.PowerCollections,MultiDictionaryBase,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionaryBase.cs,DebuggerDisplayString,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,OrderedMultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedMultiDictionary.cs,CloneContents,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,GetEnumerator,Cyclomatic complexity of the method is 14
Complex Method,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,AddBalancedNodeToRebalanceArray,Cyclomatic complexity of the method is 10
Complex Method,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,InsertRange,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,InsertRange,Cyclomatic complexity of the method is 9
Complex Method,Wintellect.PowerCollections,ReadOnlyMultiDictionaryBase,C:\repos\xmj112288_Study\OpenSources\PowerCollection\ReadOnlyMultiDictionaryBase.cs,DebuggerDisplayString,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,Cyclomatic complexity of the method is 19
Complex Method,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,DeleteItemFromRange,Cyclomatic complexity of the method is 24
Complex Method,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,ValidateSubTree,Cyclomatic complexity of the method is 8
Complex Method,Wintellect.PowerCollections,OrderedDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedDictionary.cs,CloneContents,Cyclomatic complexity of the method is 8
Long Parameter List,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,ToString,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Copy,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,MultiDictionary,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,OrderedMultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedMultiDictionary.cs,DoubleBoundedKeyRangeTester,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,OrderedMultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedMultiDictionary.cs,OrderedMultiDictionary,The method has 6 parameters.
Long Parameter List,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,InsertSplit,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,BoundedRangeTester,The method has 5 parameters.
Long Parameter List,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,DoubleBoundedRangeTester,The method has 5 parameters.
Long Statement,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,ToString,The length of the statement  "			builder.Append (Algorithms.ToString (Algorithms.TypedAs<object> ((IEnumerable)item)' recursive' start' separator' end)); " is 120.
Long Statement,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,PrintStats,The length of the statement  "	Console.WriteLine ("loadFactor={0}  thresholdGrow={1}  thresholdShrink={2}"' loadFactor' thresholdGrow' thresholdShrink); " is 121.
Long Statement,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Print,The length of the statement  "		Console.WriteLine ("Slot {0'4:X}: {1} {2'8:X} {3}"' i' table [i].Collision ? "C" : " "' table [i].HashValue' table [i].Empty ? "<empty>" : table [i].item.ToString ()); " is 167.
Long Statement,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,Add,The length of the statement  "				if (Util.GetHashCode (existing.Values [i]' valueEqualityComparer) == valueHash && valueEqualityComparer.Equals (existing.Values [i]' value)) { " is 142.
Long Statement,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,Remove,The length of the statement  "			if (Util.GetHashCode (existing.Values [i]' valueEqualityComparer) == valueHash && valueEqualityComparer.Equals (existing.Values [i]' value)) { " is 142.
Long Statement,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,Contains,The length of the statement  "			if (Util.GetHashCode (item.Values [i]' valueEqualityComparer) == valueHash && valueEqualityComparer.Equals (item.Values [i]' value)) { " is 134.
Long Statement,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,Clone,The length of the statement  "	return new MultiDictionary<TKey' TValue> (allowDuplicateValues' keyEqualityComparer' valueEqualityComparer' equalityComparer' hash.Clone (KeyAndValues.Copy)); " is 158.
Long Statement,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,CloneContents,The length of the statement  "	MultiDictionary<TKey' TValue> newDict = new MultiDictionary<TKey' TValue> (allowDuplicateValues' keyEqualityComparer' valueEqualityComparer); " is 141.
Long Statement,Wintellect.PowerCollections,OrderedMultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedMultiDictionary.cs,Clone,The length of the statement  "	OrderedMultiDictionary<TKey' TValue> newDict = new OrderedMultiDictionary<TKey' TValue> (allowDuplicateValues' keyCount' keyComparer' valueComparer' comparer' tree.Clone ()); " is 174.
Long Statement,Wintellect.PowerCollections,OrderedMultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedMultiDictionary.cs,CloneContents,The length of the statement  "	OrderedMultiDictionary<TKey' TValue> newDict = new OrderedMultiDictionary<TKey' TValue> (allowDuplicateValues' keyComparer' valueComparer); " is 139.
Long Statement,Wintellect.PowerCollections,Pair,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Pair.cs,CompareTo,The length of the statement  "		if (!typeof(IComparable<TFirst>).IsAssignableFrom (typeof(TFirst)) && !typeof(System.IComparable).IsAssignableFrom (typeof(TFirst))) { " is 134.
Long Statement,Wintellect.PowerCollections,Pair,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Pair.cs,CompareTo,The length of the statement  "		else if (!typeof(IComparable<TSecond>).IsAssignableFrom (typeof(TSecond)) && !typeof(System.IComparable).IsAssignableFrom (typeof(TSecond))) { " is 142.
Long Statement,Wintellect.PowerCollections,Pair,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Pair.cs,ToString,The length of the statement  "	return string.Format ("First: {0}' Second: {1}"' (First == null) ? "null" : First.ToString ()' (Second == null) ? "null" : Second.ToString ()); " is 143.
Long Statement,Wintellect.PowerCollections,ReadOnlyCollectionBase,C:\repos\xmj112288_Study\OpenSources\PowerCollection\ReadOnlyCollectionBase.cs,MethodModifiesCollection,The length of the statement  "	throw new NotSupportedException (string.Format (Strings.CannotModifyCollection' Util.SimpleClassName (this.GetType ()))); " is 121.
Long Statement,Wintellect.PowerCollections,ReadOnlyDictionaryBase,C:\repos\xmj112288_Study\OpenSources\PowerCollection\ReadOnlyDictionaryBase.cs,MethodModifiesCollection,The length of the statement  "	throw new NotSupportedException (string.Format (Strings.CannotModifyCollection' Util.SimpleClassName (this.GetType ()))); " is 121.
Long Statement,Wintellect.PowerCollections,ReadOnlyListBase,C:\repos\xmj112288_Study\OpenSources\PowerCollection\ReadOnlyListBase.cs,MethodModifiesCollection,The length of the statement  "	throw new NotSupportedException (string.Format (Strings.CannotModifyCollection' Util.SimpleClassName (this.GetType ()))); " is 121.
Long Statement,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,CheckBalance,The length of the statement  "	if (root != null && (root.Depth > BALANCEFACTOR && !(root.Depth - BALANCEFACTOR <= MAXFIB && Count >= FIBONACCI [root.Depth - BALANCEFACTOR]))) { " is 145.
Long Statement,Wintellect.PowerCollections,ReadOnlyMultiDictionaryBase,C:\repos\xmj112288_Study\OpenSources\PowerCollection\ReadOnlyMultiDictionaryBase.cs,MethodModifiesCollection,The length of the statement  "	throw new NotSupportedException (string.Format (Strings.CannotModifyCollection' Util.SimpleClassName (this.GetType ()))); " is 121.
Long Statement,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The length of the statement  "		if (duplicateFound != null && (dupPolicy == DuplicatePolicy.ReplaceFirst || dupPolicy == DuplicatePolicy.ReplaceLast)) { " is 120.
Long Statement,Wintellect.PowerCollections,OrderedDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedDictionary.cs,Clone,The length of the statement  "	OrderedDictionary<TKey' TValue> newDict = new OrderedDictionary<TKey' TValue> (keyComparer' pairComparer' tree.Clone ()); " is 121.
Long Statement,Wintellect.PowerCollections,OrderedDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\OrderedDictionary.cs,Range,The length of the statement  "	return new View (this' tree.DoubleBoundedRangeTester (NewPair (from)' fromInclusive' NewPair (to)' toInclusive)' false' false); " is 127.
Long Statement,Wintellect.PowerCollections,Triple,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Triple.cs,Equals,The length of the statement  "	return firstEqualityComparer.Equals (First' other.First) && secondEqualityComparer.Equals (Second' other.Second) && thirdEqualityComparer.Equals (Third' other.Third); " is 166.
Long Statement,Wintellect.PowerCollections,Triple,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Triple.cs,CompareTo,The length of the statement  "		if (!typeof(IComparable<TFirst>).IsAssignableFrom (typeof(TFirst)) && !typeof(System.IComparable).IsAssignableFrom (typeof(TFirst))) { " is 134.
Long Statement,Wintellect.PowerCollections,Triple,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Triple.cs,CompareTo,The length of the statement  "		else if (!typeof(IComparable<TSecond>).IsAssignableFrom (typeof(TSecond)) && !typeof(System.IComparable).IsAssignableFrom (typeof(TSecond))) { " is 142.
Long Statement,Wintellect.PowerCollections,Triple,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Triple.cs,CompareTo,The length of the statement  "		else if (!typeof(IComparable<TThird>).IsAssignableFrom (typeof(TThird)) && !typeof(System.IComparable).IsAssignableFrom (typeof(TThird))) { " is 139.
Long Statement,Wintellect.PowerCollections,Triple,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Triple.cs,ToString,The length of the statement  "	return string.Format ("First: {0}' Second: {1}' Third: {2}"' (First == null) ? "null" : First.ToString ()' (Second == null) ? "null" : Second.ToString ()' (Third == null) ? "null" : Third.ToString ()); " is 201.
Complex Conditional,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Range,The conditional expression  "start < 0 || start > list.Count || (start == list.Count && count != 0)"  is complex.
Complex Conditional,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,Range,The conditional expression  "start < 0 || start > array.Length || (start == array.Length && count != 0)"  is complex.
Complex Conditional,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,CheckBalance,The conditional expression  "root != null && (root.Depth > BALANCEFACTOR && !(root.Depth - BALANCEFACTOR <= MAXFIB && Count >= FIBONACCI [root.Depth - BALANCEFACTOR]))"  is complex.
Complex Conditional,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,Range,The conditional expression  "index < 0 || index > this.Count || (index == this.Count && count != 0)"  is complex.
Complex Conditional,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The conditional expression  "node.left != null && node.left.IsRed && node.right != null && node.right.IsRed"  is complex.
Complex Conditional,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,DeleteItemFromRange,The conditional expression  "(node.left == null || !node.left.IsRed) && (node.right == null || !node.right.IsRed)"  is complex.
Complex Conditional,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,DeleteItemFromRange,The conditional expression  "(sib.left == null || !sib.left.IsRed) && (sib.right == null || !sib.right.IsRed)"  is complex.
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,GenerateSortedPermutations,The following statement contains a magic number: for (; ;) {  	// Find the key point -- where array[key]<array[key+1]. Everything after the  	// key is the tail.  	key = length - 2;  	while (comparer.Compare (array [key]' array [key + 1]) >= 0) {  		--key;  		if (key < 0)  			yield break;  	}  	// Find the last item in the tail less than key.  	swap = length - 1;  	while (comparer.Compare (array [swap]' array [key]) <= 0)  		--swap;  	// Swap it with the key.  	temp = array [key];  	array [key] = array [swap];  	array [swap] = temp;  	// Reverse the tail.  	i = key + 1;  	j = length - 1;  	while (i < j) {  		temp = array [i];  		array [i] = array [j];  		array [j] = temp;  		++i;  		--j;  	}  	yield return array;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,GenerateSortedPermutations,The following statement contains a magic number: key = length - 2;  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: for (; ;) {  	if (l == r - 1) {  		// We have exactly 2 elements to sort. Compare them and swap if needed.  		T e1' e2;  		e1 = list [l];  		e2 = list [r];  		if (comparer.Compare (e1' e2) > 0) {  			list [r] = e1;  			list [l] = e2;  		}  		l = r;  		// sort complete' find other work from the stack.  	}  	else if (l < r) {  		// Sort the items in the inclusive range l .. r  		// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  		int m = l + (r - l) / 2;  		T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  		if (comparer.Compare (e1' e2) > 0) {  			temp = e1;  			e1 = e2;  			e2 = temp;  		}  		if (comparer.Compare (e1' e3) > 0) {  			temp = e3;  			e3 = e2;  			e2 = e1;  			e1 = temp;  		}  		else if (comparer.Compare (e2' e3) > 0) {  			temp = e2;  			e2 = e3;  			e3 = temp;  		}  		if (l == r - 2) {  			// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  			list [l] = e1;  			list [m] = e2;  			list [r] = e3;  			l = r;  			// sort complete' find other work from the stack.  		}  		else {  			// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  			list [l] = e1;  			list [m] = e3;  			list [r] = partition = e2;  			// Partition into three parts' items <= partition' items == partition' and items >= partition  			int i = l' j = r;  			T item_i' item_j;  			for (; ;) {  				do {  					++i;  					item_i = list [i];  				}  				while (comparer.Compare (item_i' partition) < 0);  				do {  					--j;  					item_j = list [j];  				}  				while (comparer.Compare (item_j' partition) > 0);  				if (j < i)  					break;  				list [i] = item_j;  				list [j] = item_i;  				// swap items to continue the partition.  			}  			// Move the partition value into place.  			list [r] = item_i;  			list [i] = partition;  			++i;  			// We have partitioned the list.   			//    Items in the inclusive range l .. j are <= partition.  			//    Items in the inclusive range i .. r are >= partition.  			//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  			// We now need to sort l .. j and i .. r.  			// To do this' we stack one of the lists for later processing' and change l and r to the other list.  			// If we always stack the larger of the two sub-parts' the stack cannot get greater  			// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  			if ((j - l) > (r - i)) {  				// The right partition is smaller. Stack the left' and get ready to sort the right.  				leftStack [stackPtr] = l;  				rightStack [stackPtr] = j;  				l = i;  			}  			else {  				// The left partition is smaller. Stack the right' and get ready to sort the left.  				leftStack [stackPtr] = i;  				rightStack [stackPtr] = r;  				r = j;  			}  			++stackPtr;  		}  	}  	else if (stackPtr > 0) {  		// We have a stacked sub-list to sort. Pop it off and sort it.  		--stackPtr;  		l = leftStack [stackPtr];  		r = rightStack [stackPtr];  	}  	else {  		// We have nothing left to sort.  		break;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: for (; ;) {  	if (l == r - 1) {  		// We have exactly 2 elements to sort. Compare them and swap if needed.  		T e1' e2;  		e1 = list [l];  		e2 = list [r];  		if (comparer.Compare (e1' e2) > 0) {  			list [r] = e1;  			list [l] = e2;  		}  		l = r;  		// sort complete' find other work from the stack.  	}  	else if (l < r) {  		// Sort the items in the inclusive range l .. r  		// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  		int m = l + (r - l) / 2;  		T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  		if (comparer.Compare (e1' e2) > 0) {  			temp = e1;  			e1 = e2;  			e2 = temp;  		}  		if (comparer.Compare (e1' e3) > 0) {  			temp = e3;  			e3 = e2;  			e2 = e1;  			e1 = temp;  		}  		else if (comparer.Compare (e2' e3) > 0) {  			temp = e2;  			e2 = e3;  			e3 = temp;  		}  		if (l == r - 2) {  			// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  			list [l] = e1;  			list [m] = e2;  			list [r] = e3;  			l = r;  			// sort complete' find other work from the stack.  		}  		else {  			// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  			list [l] = e1;  			list [m] = e3;  			list [r] = partition = e2;  			// Partition into three parts' items <= partition' items == partition' and items >= partition  			int i = l' j = r;  			T item_i' item_j;  			for (; ;) {  				do {  					++i;  					item_i = list [i];  				}  				while (comparer.Compare (item_i' partition) < 0);  				do {  					--j;  					item_j = list [j];  				}  				while (comparer.Compare (item_j' partition) > 0);  				if (j < i)  					break;  				list [i] = item_j;  				list [j] = item_i;  				// swap items to continue the partition.  			}  			// Move the partition value into place.  			list [r] = item_i;  			list [i] = partition;  			++i;  			// We have partitioned the list.   			//    Items in the inclusive range l .. j are <= partition.  			//    Items in the inclusive range i .. r are >= partition.  			//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  			// We now need to sort l .. j and i .. r.  			// To do this' we stack one of the lists for later processing' and change l and r to the other list.  			// If we always stack the larger of the two sub-parts' the stack cannot get greater  			// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  			if ((j - l) > (r - i)) {  				// The right partition is smaller. Stack the left' and get ready to sort the right.  				leftStack [stackPtr] = l;  				rightStack [stackPtr] = j;  				l = i;  			}  			else {  				// The left partition is smaller. Stack the right' and get ready to sort the left.  				leftStack [stackPtr] = i;  				rightStack [stackPtr] = r;  				r = j;  			}  			++stackPtr;  		}  	}  	else if (stackPtr > 0) {  		// We have a stacked sub-list to sort. Pop it off and sort it.  		--stackPtr;  		l = leftStack [stackPtr];  		r = rightStack [stackPtr];  	}  	else {  		// We have nothing left to sort.  		break;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: if (l == r - 1) {  	// We have exactly 2 elements to sort. Compare them and swap if needed.  	T e1' e2;  	e1 = list [l];  	e2 = list [r];  	if (comparer.Compare (e1' e2) > 0) {  		list [r] = e1;  		list [l] = e2;  	}  	l = r;  	// sort complete' find other work from the stack.  }  else if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	if (comparer.Compare (e1' e2) > 0) {  		temp = e1;  		e1 = e2;  		e2 = temp;  	}  	if (comparer.Compare (e1' e3) > 0) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  	}  	else if (comparer.Compare (e2' e3) > 0) {  		temp = e2;  		e2 = e3;  		e3 = temp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		list [m] = e3;  		list [r] = partition = e2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  			}  			while (comparer.Compare (item_i' partition) < 0);  			do {  				--j;  				item_j = list [j];  			}  			while (comparer.Compare (item_j' partition) > 0);  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  		}  		// Move the partition value into place.  		list [r] = item_i;  		list [i] = partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: if (l == r - 1) {  	// We have exactly 2 elements to sort. Compare them and swap if needed.  	T e1' e2;  	e1 = list [l];  	e2 = list [r];  	if (comparer.Compare (e1' e2) > 0) {  		list [r] = e1;  		list [l] = e2;  	}  	l = r;  	// sort complete' find other work from the stack.  }  else if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	if (comparer.Compare (e1' e2) > 0) {  		temp = e1;  		e1 = e2;  		e2 = temp;  	}  	if (comparer.Compare (e1' e3) > 0) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  	}  	else if (comparer.Compare (e2' e3) > 0) {  		temp = e2;  		e2 = e3;  		e3 = temp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		list [m] = e3;  		list [r] = partition = e2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  			}  			while (comparer.Compare (item_i' partition) < 0);  			do {  				--j;  				item_j = list [j];  			}  			while (comparer.Compare (item_j' partition) > 0);  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  		}  		// Move the partition value into place.  		list [r] = item_i;  		list [i] = partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	if (comparer.Compare (e1' e2) > 0) {  		temp = e1;  		e1 = e2;  		e2 = temp;  	}  	if (comparer.Compare (e1' e3) > 0) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  	}  	else if (comparer.Compare (e2' e3) > 0) {  		temp = e2;  		e2 = e3;  		e3 = temp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		list [m] = e3;  		list [r] = partition = e2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  			}  			while (comparer.Compare (item_i' partition) < 0);  			do {  				--j;  				item_j = list [j];  			}  			while (comparer.Compare (item_j' partition) > 0);  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  		}  		// Move the partition value into place.  		list [r] = item_i;  		list [i] = partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	if (comparer.Compare (e1' e2) > 0) {  		temp = e1;  		e1 = e2;  		e2 = temp;  	}  	if (comparer.Compare (e1' e3) > 0) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  	}  	else if (comparer.Compare (e2' e3) > 0) {  		temp = e2;  		e2 = e3;  		e3 = temp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		list [m] = e3;  		list [r] = partition = e2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  			}  			while (comparer.Compare (item_i' partition) < 0);  			do {  				--j;  				item_j = list [j];  			}  			while (comparer.Compare (item_j' partition) > 0);  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  		}  		// Move the partition value into place.  		list [r] = item_i;  		list [i] = partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,SortInPlace,The following statement contains a magic number: if (l == r - 2) {  	// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  	list [l] = e1;  	list [m] = e2;  	list [r] = e3;  	l = r;  	// sort complete' find other work from the stack.  }  else {  	// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  	list [l] = e1;  	list [m] = e3;  	list [r] = partition = e2;  	// Partition into three parts' items <= partition' items == partition' and items >= partition  	int i = l' j = r;  	T item_i' item_j;  	for (; ;) {  		do {  			++i;  			item_i = list [i];  		}  		while (comparer.Compare (item_i' partition) < 0);  		do {  			--j;  			item_j = list [j];  		}  		while (comparer.Compare (item_j' partition) > 0);  		if (j < i)  			break;  		list [i] = item_j;  		list [j] = item_i;  		// swap items to continue the partition.  	}  	// Move the partition value into place.  	list [r] = item_i;  	list [i] = partition;  	++i;  	// We have partitioned the list.   	//    Items in the inclusive range l .. j are <= partition.  	//    Items in the inclusive range i .. r are >= partition.  	//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  	// We now need to sort l .. j and i .. r.  	// To do this' we stack one of the lists for later processing' and change l and r to the other list.  	// If we always stack the larger of the two sub-parts' the stack cannot get greater  	// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  	if ((j - l) > (r - i)) {  		// The right partition is smaller. Stack the left' and get ready to sort the right.  		leftStack [stackPtr] = l;  		rightStack [stackPtr] = j;  		l = i;  	}  	else {  		// The left partition is smaller. Stack the right' and get ready to sort the left.  		leftStack [stackPtr] = i;  		rightStack [stackPtr] = r;  		r = j;  	}  	++stackPtr;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: for (; ;) {  	if (l == r - 1) {  		// We have exactly 2 elements to sort. Compare them and swap if needed.  		T e1' e2;  		int o1' o2;  		e1 = list [l];  		o1 = order [l];  		e2 = list [r];  		o2 = order [r];  		if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  			list [r] = e1;  			order [r] = o1;  			list [l] = e2;  			order [l] = o2;  		}  		l = r;  		// sort complete' find other work from the stack.  	}  	else if (l < r) {  		// Sort the items in the inclusive range l .. r  		// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  		int m = l + (r - l) / 2;  		T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  		int o1 = order [l]' o2 = order [m]' o3 = order [r]' otemp;  		if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  			temp = e1;  			e1 = e2;  			e2 = temp;  			otemp = o1;  			o1 = o2;  			o2 = otemp;  		}  		if ((c = comparer.Compare (e1' e3)) > 0 || (c == 0 && o1 > o3)) {  			temp = e3;  			e3 = e2;  			e2 = e1;  			e1 = temp;  			otemp = o3;  			o3 = o2;  			o2 = o1;  			o1 = otemp;  		}  		else if ((c = comparer.Compare (e2' e3)) > 0 || (c == 0 && o2 > o3)) {  			temp = e2;  			e2 = e3;  			e3 = temp;  			otemp = o2;  			o2 = o3;  			o3 = otemp;  		}  		if (l == r - 2) {  			// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  			list [l] = e1;  			list [m] = e2;  			list [r] = e3;  			order [l] = o1;  			order [m] = o2;  			order [r] = o3;  			l = r;  			// sort complete' find other work from the stack.  		}  		else {  			// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  			list [l] = e1;  			order [l] = o1;  			list [m] = e3;  			order [m] = o3;  			list [r] = partition = e2;  			order [r] = order_partition = o2;  			// Partition into three parts' items <= partition' items == partition' and items >= partition  			int i = l' j = r;  			T item_i' item_j;  			int order_i' order_j;  			for (; ;) {  				do {  					++i;  					item_i = list [i];  					order_i = order [i];  				}  				while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  				do {  					--j;  					item_j = list [j];  					order_j = order [j];  				}  				while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  				if (j < i)  					break;  				list [i] = item_j;  				list [j] = item_i;  				// swap items to continue the partition.  				order [i] = order_j;  				order [j] = order_i;  			}  			// Move the partition value into place.  			list [r] = item_i;  			order [r] = order_i;  			list [i] = partition;  			order [i] = order_partition;  			++i;  			// We have partitioned the list.   			//    Items in the inclusive range l .. j are <= partition.  			//    Items in the inclusive range i .. r are >= partition.  			//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  			// We now need to sort l .. j and i .. r.  			// To do this' we stack one of the lists for later processing' and change l and r to the other list.  			// If we always stack the larger of the two sub-parts' the stack cannot get greater  			// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  			if ((j - l) > (r - i)) {  				// The right partition is smaller. Stack the left' and get ready to sort the right.  				leftStack [stackPtr] = l;  				rightStack [stackPtr] = j;  				l = i;  			}  			else {  				// The left partition is smaller. Stack the right' and get ready to sort the left.  				leftStack [stackPtr] = i;  				rightStack [stackPtr] = r;  				r = j;  			}  			++stackPtr;  		}  	}  	else if (stackPtr > 0) {  		// We have a stacked sub-list to sort. Pop it off and sort it.  		--stackPtr;  		l = leftStack [stackPtr];  		r = rightStack [stackPtr];  	}  	else {  		// We have nothing left to sort.  		break;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: for (; ;) {  	if (l == r - 1) {  		// We have exactly 2 elements to sort. Compare them and swap if needed.  		T e1' e2;  		int o1' o2;  		e1 = list [l];  		o1 = order [l];  		e2 = list [r];  		o2 = order [r];  		if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  			list [r] = e1;  			order [r] = o1;  			list [l] = e2;  			order [l] = o2;  		}  		l = r;  		// sort complete' find other work from the stack.  	}  	else if (l < r) {  		// Sort the items in the inclusive range l .. r  		// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  		int m = l + (r - l) / 2;  		T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  		int o1 = order [l]' o2 = order [m]' o3 = order [r]' otemp;  		if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  			temp = e1;  			e1 = e2;  			e2 = temp;  			otemp = o1;  			o1 = o2;  			o2 = otemp;  		}  		if ((c = comparer.Compare (e1' e3)) > 0 || (c == 0 && o1 > o3)) {  			temp = e3;  			e3 = e2;  			e2 = e1;  			e1 = temp;  			otemp = o3;  			o3 = o2;  			o2 = o1;  			o1 = otemp;  		}  		else if ((c = comparer.Compare (e2' e3)) > 0 || (c == 0 && o2 > o3)) {  			temp = e2;  			e2 = e3;  			e3 = temp;  			otemp = o2;  			o2 = o3;  			o3 = otemp;  		}  		if (l == r - 2) {  			// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  			list [l] = e1;  			list [m] = e2;  			list [r] = e3;  			order [l] = o1;  			order [m] = o2;  			order [r] = o3;  			l = r;  			// sort complete' find other work from the stack.  		}  		else {  			// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  			list [l] = e1;  			order [l] = o1;  			list [m] = e3;  			order [m] = o3;  			list [r] = partition = e2;  			order [r] = order_partition = o2;  			// Partition into three parts' items <= partition' items == partition' and items >= partition  			int i = l' j = r;  			T item_i' item_j;  			int order_i' order_j;  			for (; ;) {  				do {  					++i;  					item_i = list [i];  					order_i = order [i];  				}  				while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  				do {  					--j;  					item_j = list [j];  					order_j = order [j];  				}  				while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  				if (j < i)  					break;  				list [i] = item_j;  				list [j] = item_i;  				// swap items to continue the partition.  				order [i] = order_j;  				order [j] = order_i;  			}  			// Move the partition value into place.  			list [r] = item_i;  			order [r] = order_i;  			list [i] = partition;  			order [i] = order_partition;  			++i;  			// We have partitioned the list.   			//    Items in the inclusive range l .. j are <= partition.  			//    Items in the inclusive range i .. r are >= partition.  			//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  			// We now need to sort l .. j and i .. r.  			// To do this' we stack one of the lists for later processing' and change l and r to the other list.  			// If we always stack the larger of the two sub-parts' the stack cannot get greater  			// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  			if ((j - l) > (r - i)) {  				// The right partition is smaller. Stack the left' and get ready to sort the right.  				leftStack [stackPtr] = l;  				rightStack [stackPtr] = j;  				l = i;  			}  			else {  				// The left partition is smaller. Stack the right' and get ready to sort the left.  				leftStack [stackPtr] = i;  				rightStack [stackPtr] = r;  				r = j;  			}  			++stackPtr;  		}  	}  	else if (stackPtr > 0) {  		// We have a stacked sub-list to sort. Pop it off and sort it.  		--stackPtr;  		l = leftStack [stackPtr];  		r = rightStack [stackPtr];  	}  	else {  		// We have nothing left to sort.  		break;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: if (l == r - 1) {  	// We have exactly 2 elements to sort. Compare them and swap if needed.  	T e1' e2;  	int o1' o2;  	e1 = list [l];  	o1 = order [l];  	e2 = list [r];  	o2 = order [r];  	if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  		list [r] = e1;  		order [r] = o1;  		list [l] = e2;  		order [l] = o2;  	}  	l = r;  	// sort complete' find other work from the stack.  }  else if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	int o1 = order [l]' o2 = order [m]' o3 = order [r]' otemp;  	if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  		temp = e1;  		e1 = e2;  		e2 = temp;  		otemp = o1;  		o1 = o2;  		o2 = otemp;  	}  	if ((c = comparer.Compare (e1' e3)) > 0 || (c == 0 && o1 > o3)) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  		otemp = o3;  		o3 = o2;  		o2 = o1;  		o1 = otemp;  	}  	else if ((c = comparer.Compare (e2' e3)) > 0 || (c == 0 && o2 > o3)) {  		temp = e2;  		e2 = e3;  		e3 = temp;  		otemp = o2;  		o2 = o3;  		o3 = otemp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		order [l] = o1;  		order [m] = o2;  		order [r] = o3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		order [l] = o1;  		list [m] = e3;  		order [m] = o3;  		list [r] = partition = e2;  		order [r] = order_partition = o2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		int order_i' order_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  				order_i = order [i];  			}  			while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  			do {  				--j;  				item_j = list [j];  				order_j = order [j];  			}  			while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  			order [i] = order_j;  			order [j] = order_i;  		}  		// Move the partition value into place.  		list [r] = item_i;  		order [r] = order_i;  		list [i] = partition;  		order [i] = order_partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: if (l == r - 1) {  	// We have exactly 2 elements to sort. Compare them and swap if needed.  	T e1' e2;  	int o1' o2;  	e1 = list [l];  	o1 = order [l];  	e2 = list [r];  	o2 = order [r];  	if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  		list [r] = e1;  		order [r] = o1;  		list [l] = e2;  		order [l] = o2;  	}  	l = r;  	// sort complete' find other work from the stack.  }  else if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	int o1 = order [l]' o2 = order [m]' o3 = order [r]' otemp;  	if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  		temp = e1;  		e1 = e2;  		e2 = temp;  		otemp = o1;  		o1 = o2;  		o2 = otemp;  	}  	if ((c = comparer.Compare (e1' e3)) > 0 || (c == 0 && o1 > o3)) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  		otemp = o3;  		o3 = o2;  		o2 = o1;  		o1 = otemp;  	}  	else if ((c = comparer.Compare (e2' e3)) > 0 || (c == 0 && o2 > o3)) {  		temp = e2;  		e2 = e3;  		e3 = temp;  		otemp = o2;  		o2 = o3;  		o3 = otemp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		order [l] = o1;  		order [m] = o2;  		order [r] = o3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		order [l] = o1;  		list [m] = e3;  		order [m] = o3;  		list [r] = partition = e2;  		order [r] = order_partition = o2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		int order_i' order_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  				order_i = order [i];  			}  			while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  			do {  				--j;  				item_j = list [j];  				order_j = order [j];  			}  			while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  			order [i] = order_j;  			order [j] = order_i;  		}  		// Move the partition value into place.  		list [r] = item_i;  		order [r] = order_i;  		list [i] = partition;  		order [i] = order_partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	int o1 = order [l]' o2 = order [m]' o3 = order [r]' otemp;  	if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  		temp = e1;  		e1 = e2;  		e2 = temp;  		otemp = o1;  		o1 = o2;  		o2 = otemp;  	}  	if ((c = comparer.Compare (e1' e3)) > 0 || (c == 0 && o1 > o3)) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  		otemp = o3;  		o3 = o2;  		o2 = o1;  		o1 = otemp;  	}  	else if ((c = comparer.Compare (e2' e3)) > 0 || (c == 0 && o2 > o3)) {  		temp = e2;  		e2 = e3;  		e3 = temp;  		otemp = o2;  		o2 = o3;  		o3 = otemp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		order [l] = o1;  		order [m] = o2;  		order [r] = o3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		order [l] = o1;  		list [m] = e3;  		order [m] = o3;  		list [r] = partition = e2;  		order [r] = order_partition = o2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		int order_i' order_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  				order_i = order [i];  			}  			while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  			do {  				--j;  				item_j = list [j];  				order_j = order [j];  			}  			while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  			order [i] = order_j;  			order [j] = order_i;  		}  		// Move the partition value into place.  		list [r] = item_i;  		order [r] = order_i;  		list [i] = partition;  		order [i] = order_partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: if (l < r) {  	// Sort the items in the inclusive range l .. r  	// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  	int m = l + (r - l) / 2;  	T e1 = list [l]' e2 = list [m]' e3 = list [r]' temp;  	int o1 = order [l]' o2 = order [m]' o3 = order [r]' otemp;  	if ((c = comparer.Compare (e1' e2)) > 0 || (c == 0 && o1 > o2)) {  		temp = e1;  		e1 = e2;  		e2 = temp;  		otemp = o1;  		o1 = o2;  		o2 = otemp;  	}  	if ((c = comparer.Compare (e1' e3)) > 0 || (c == 0 && o1 > o3)) {  		temp = e3;  		e3 = e2;  		e2 = e1;  		e1 = temp;  		otemp = o3;  		o3 = o2;  		o2 = o1;  		o1 = otemp;  	}  	else if ((c = comparer.Compare (e2' e3)) > 0 || (c == 0 && o2 > o3)) {  		temp = e2;  		e2 = e3;  		e3 = temp;  		otemp = o2;  		o2 = o3;  		o3 = otemp;  	}  	if (l == r - 2) {  		// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  		list [l] = e1;  		list [m] = e2;  		list [r] = e3;  		order [l] = o1;  		order [m] = o2;  		order [r] = o3;  		l = r;  		// sort complete' find other work from the stack.  	}  	else {  		// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  		list [l] = e1;  		order [l] = o1;  		list [m] = e3;  		order [m] = o3;  		list [r] = partition = e2;  		order [r] = order_partition = o2;  		// Partition into three parts' items <= partition' items == partition' and items >= partition  		int i = l' j = r;  		T item_i' item_j;  		int order_i' order_j;  		for (; ;) {  			do {  				++i;  				item_i = list [i];  				order_i = order [i];  			}  			while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  			do {  				--j;  				item_j = list [j];  				order_j = order [j];  			}  			while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  			if (j < i)  				break;  			list [i] = item_j;  			list [j] = item_i;  			// swap items to continue the partition.  			order [i] = order_j;  			order [j] = order_i;  		}  		// Move the partition value into place.  		list [r] = item_i;  		order [r] = order_i;  		list [i] = partition;  		order [i] = order_partition;  		++i;  		// We have partitioned the list.   		//    Items in the inclusive range l .. j are <= partition.  		//    Items in the inclusive range i .. r are >= partition.  		//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  		// We now need to sort l .. j and i .. r.  		// To do this' we stack one of the lists for later processing' and change l and r to the other list.  		// If we always stack the larger of the two sub-parts' the stack cannot get greater  		// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  		if ((j - l) > (r - i)) {  			// The right partition is smaller. Stack the left' and get ready to sort the right.  			leftStack [stackPtr] = l;  			rightStack [stackPtr] = j;  			l = i;  		}  		else {  			// The left partition is smaller. Stack the right' and get ready to sort the left.  			leftStack [stackPtr] = i;  			rightStack [stackPtr] = r;  			r = j;  		}  		++stackPtr;  	}  }  else if (stackPtr > 0) {  	// We have a stacked sub-list to sort. Pop it off and sort it.  	--stackPtr;  	l = leftStack [stackPtr];  	r = rightStack [stackPtr];  }  else {  	// We have nothing left to sort.  	break;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: if (l == r - 2) {  	// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  	list [l] = e1;  	list [m] = e2;  	list [r] = e3;  	order [l] = o1;  	order [m] = o2;  	order [r] = o3;  	l = r;  	// sort complete' find other work from the stack.  }  else {  	// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  	list [l] = e1;  	order [l] = o1;  	list [m] = e3;  	order [m] = o3;  	list [r] = partition = e2;  	order [r] = order_partition = o2;  	// Partition into three parts' items <= partition' items == partition' and items >= partition  	int i = l' j = r;  	T item_i' item_j;  	int order_i' order_j;  	for (; ;) {  		do {  			++i;  			item_i = list [i];  			order_i = order [i];  		}  		while ((c = comparer.Compare (item_i' partition)) < 0 || (c == 0 && order_i < order_partition));  		do {  			--j;  			item_j = list [j];  			order_j = order [j];  		}  		while ((c = comparer.Compare (item_j' partition)) > 0 || (c == 0 && order_j > order_partition));  		if (j < i)  			break;  		list [i] = item_j;  		list [j] = item_i;  		// swap items to continue the partition.  		order [i] = order_j;  		order [j] = order_i;  	}  	// Move the partition value into place.  	list [r] = item_i;  	order [r] = order_i;  	list [i] = partition;  	order [i] = order_partition;  	++i;  	// We have partitioned the list.   	//    Items in the inclusive range l .. j are <= partition.  	//    Items in the inclusive range i .. r are >= partition.  	//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  	// We now need to sort l .. j and i .. r.  	// To do this' we stack one of the lists for later processing' and change l and r to the other list.  	// If we always stack the larger of the two sub-parts' the stack cannot get greater  	// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  	if ((j - l) > (r - i)) {  		// The right partition is smaller. Stack the left' and get ready to sort the right.  		leftStack [stackPtr] = l;  		rightStack [stackPtr] = j;  		l = i;  	}  	else {  		// The left partition is smaller. Stack the right' and get ready to sort the left.  		leftStack [stackPtr] = i;  		rightStack [stackPtr] = r;  		r = j;  	}  	++stackPtr;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l) {  	int m = l + (r - l) / 2;  	T middleItem = list [m];  	int comp = comparer.Compare (middleItem' item);  	if (comp < 0) {  		// middleItem < item  		l = m + 1;  	}  	else if (comp > 0) {  		r = m;  	}  	else {  		// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  		int lFound = l' rFound = r' found = m;  		// Find the start of the run.  		l = lFound;  		r = found;  		while (r > l) {  			m = l + (r - l) / 2;  			middleItem = list [m];  			comp = comparer.Compare (middleItem' item);  			if (comp < 0) {  				// middleItem < item  				l = m + 1;  			}  			else {  				r = m;  			}  		}  		System.Diagnostics.Debug.Assert (l == r);  		index = l;  		// Find the end of the run.  		l = found;  		r = rFound;  		while (r > l) {  			m = l + (r - l) / 2;  			middleItem = list [m];  			comp = comparer.Compare (middleItem' item);  			if (comp <= 0) {  				// middleItem <= item  				l = m + 1;  			}  			else {  				r = m;  			}  		}  		System.Diagnostics.Debug.Assert (l == r);  		return l - index;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l) {  	int m = l + (r - l) / 2;  	T middleItem = list [m];  	int comp = comparer.Compare (middleItem' item);  	if (comp < 0) {  		// middleItem < item  		l = m + 1;  	}  	else if (comp > 0) {  		r = m;  	}  	else {  		// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  		int lFound = l' rFound = r' found = m;  		// Find the start of the run.  		l = lFound;  		r = found;  		while (r > l) {  			m = l + (r - l) / 2;  			middleItem = list [m];  			comp = comparer.Compare (middleItem' item);  			if (comp < 0) {  				// middleItem < item  				l = m + 1;  			}  			else {  				r = m;  			}  		}  		System.Diagnostics.Debug.Assert (l == r);  		index = l;  		// Find the end of the run.  		l = found;  		r = rFound;  		while (r > l) {  			m = l + (r - l) / 2;  			middleItem = list [m];  			comp = comparer.Compare (middleItem' item);  			if (comp <= 0) {  				// middleItem <= item  				l = m + 1;  			}  			else {  				r = m;  			}  		}  		System.Diagnostics.Debug.Assert (l == r);  		return l - index;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l) {  	int m = l + (r - l) / 2;  	T middleItem = list [m];  	int comp = comparer.Compare (middleItem' item);  	if (comp < 0) {  		// middleItem < item  		l = m + 1;  	}  	else if (comp > 0) {  		r = m;  	}  	else {  		// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  		int lFound = l' rFound = r' found = m;  		// Find the start of the run.  		l = lFound;  		r = found;  		while (r > l) {  			m = l + (r - l) / 2;  			middleItem = list [m];  			comp = comparer.Compare (middleItem' item);  			if (comp < 0) {  				// middleItem < item  				l = m + 1;  			}  			else {  				r = m;  			}  		}  		System.Diagnostics.Debug.Assert (l == r);  		index = l;  		// Find the end of the run.  		l = found;  		r = rFound;  		while (r > l) {  			m = l + (r - l) / 2;  			middleItem = list [m];  			comp = comparer.Compare (middleItem' item);  			if (comp <= 0) {  				// middleItem <= item  				l = m + 1;  			}  			else {  				r = m;  			}  		}  		System.Diagnostics.Debug.Assert (l == r);  		return l - index;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: if (comp < 0) {  	// middleItem < item  	l = m + 1;  }  else if (comp > 0) {  	r = m;  }  else {  	// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  	int lFound = l' rFound = r' found = m;  	// Find the start of the run.  	l = lFound;  	r = found;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp < 0) {  			// middleItem < item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	index = l;  	// Find the end of the run.  	l = found;  	r = rFound;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp <= 0) {  			// middleItem <= item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	return l - index;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: if (comp < 0) {  	// middleItem < item  	l = m + 1;  }  else if (comp > 0) {  	r = m;  }  else {  	// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  	int lFound = l' rFound = r' found = m;  	// Find the start of the run.  	l = lFound;  	r = found;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp < 0) {  			// middleItem < item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	index = l;  	// Find the end of the run.  	l = found;  	r = rFound;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp <= 0) {  			// middleItem <= item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	return l - index;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: if (comp > 0) {  	r = m;  }  else {  	// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  	int lFound = l' rFound = r' found = m;  	// Find the start of the run.  	l = lFound;  	r = found;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp < 0) {  			// middleItem < item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	index = l;  	// Find the end of the run.  	l = found;  	r = rFound;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp <= 0) {  			// middleItem <= item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	return l - index;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: if (comp > 0) {  	r = m;  }  else {  	// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  	int lFound = l' rFound = r' found = m;  	// Find the start of the run.  	l = lFound;  	r = found;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp < 0) {  			// middleItem < item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	index = l;  	// Find the end of the run.  	l = found;  	r = rFound;  	while (r > l) {  		m = l + (r - l) / 2;  		middleItem = list [m];  		comp = comparer.Compare (middleItem' item);  		if (comp <= 0) {  			// middleItem <= item  			l = m + 1;  		}  		else {  			r = m;  		}  	}  	System.Diagnostics.Debug.Assert (l == r);  	return l - index;  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l) {  	m = l + (r - l) / 2;  	middleItem = list [m];  	comp = comparer.Compare (middleItem' item);  	if (comp < 0) {  		// middleItem < item  		l = m + 1;  	}  	else {  		r = m;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: m = l + (r - l) / 2;  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l) {  	m = l + (r - l) / 2;  	middleItem = list [m];  	comp = comparer.Compare (middleItem' item);  	if (comp <= 0) {  		// middleItem <= item  		l = m + 1;  	}  	else {  		r = m;  	}  }  
Magic Number,Wintellect.PowerCollections,Algorithms,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Algorithms.cs,BinarySearch,The following statement contains a magic number: m = l + (r - l) / 2;  
Magic Number,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,Insert,The following statement contains a magic number: if (index < count / 2) {  	// Inserting into the first half of the list. Move items with  	// lower index down in the buffer.  	start -= 1;  	if (start < 0)  		start += length;  	i = index + start;  	if (i >= length) {  		i -= length;  		if (length - 1 > start)  			Array.Copy (buffer' start + 1' buffer' start' length - 1 - start);  		buffer [length - 1] = buffer [0];  		// unneeded if end == 0' but doesn't hurt  		if (i > 0)  			Array.Copy (buffer' 1' buffer' 0' i);  	}  	else {  		if (i > start)  			Array.Copy (buffer' start + 1' buffer' start' i - start);  	}  }  else {  	// Inserting into the last half of the list. Move items with higher  	// index up in the buffer.  	i = index + start;  	if (i >= length)  		i -= length;  	if (i <= end) {  		if (end > i)  			Array.Copy (buffer' i' buffer' i + 1' end - i);  		end += 1;  		if (end >= length)  			end -= length;  	}  	else {  		if (end > 0)  			Array.Copy (buffer' 0' buffer' 1' end);  		buffer [0] = buffer [length - 1];  		if (length - 1 > i)  			Array.Copy (buffer' i' buffer' i + 1' length - 1 - i);  		end += 1;  	}  }  
Magic Number,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,InsertRange,The following statement contains a magic number: if (index < count / 2) {  	// Inserting into the first half of the list. Move items with  	// lower index down in the buffer.  	s = start;  	d = s - coll.Count;  	if (d < 0)  		d += length;  	start = d;  	int c = index;  	while (c > 0) {  		int chunk = c;  		if (length - d < chunk)  			chunk = length - d;  		if (length - s < chunk)  			chunk = length - s;  		Array.Copy (buffer' s' buffer' d' chunk);  		c -= chunk;  		if ((d += chunk) >= length)  			d -= length;  		if ((s += chunk) >= length)  			s -= length;  	}  }  else {  	// Inserting into the last half of the list. Move items with higher  	// index up in the buffer.  	s = end;  	d = s + coll.Count;  	if (d >= length)  		d -= length;  	end = d;  	int move = count - index;  	// number of items at end to move  	int c = move;  	while (c > 0) {  		int chunk = c;  		if (d > 0 && d < chunk)  			chunk = d;  		if (s > 0 && s < chunk)  			chunk = s;  		if ((d -= chunk) < 0)  			d += length;  		if ((s -= chunk) < 0)  			s += length;  		Array.Copy (buffer' s' buffer' d' chunk);  		c -= chunk;  	}  	d -= coll.Count;  	if (d < 0)  		d += length;  }  
Magic Number,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,RemoveAt,The following statement contains a magic number: if (index < count / 2) {  	// Removing in the first half of the list. Move items with  	// lower index up in the buffer.  	i = index + start;  	if (i >= length) {  		i -= length;  		if (i > 0)  			Array.Copy (buffer' 0' buffer' 1' i);  		buffer [0] = buffer [length - 1];  		if (length - 1 > start)  			Array.Copy (buffer' start' buffer' start + 1' length - 1 - start);  	}  	else {  		if (i > start)  			Array.Copy (buffer' start' buffer' start + 1' i - start);  	}  	buffer [start] = default(T);  	start += 1;  	if (start >= length)  		start -= length;  }  else {  	// Removing in the second half of the list. Move items with  	// higher indexes down in the buffer.  	i = index + start;  	if (i >= length)  		i -= length;  	end -= 1;  	if (end < 0)  		end = length - 1;  	if (i <= end) {  		if (end > i)  			Array.Copy (buffer' i + 1' buffer' i' end - i);  	}  	else {  		if (length - 1 > i)  			Array.Copy (buffer' i + 1' buffer' i' length - 1 - i);  		buffer [length - 1] = buffer [0];  		if (end > 0)  			Array.Copy (buffer' 1' buffer' 0' end);  	}  	buffer [end] = default(T);  }  
Magic Number,Wintellect.PowerCollections,Deque,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Deque.cs,RemoveRange,The following statement contains a magic number: if (index < dequeCount / 2) {  	// Removing in the first half of the list. Move items with  	// lower index up in the buffer.  	s = start + index;  	if (s >= length)  		s -= length;  	d = s + count;  	if (d >= length)  		d -= length;  	int c = index;  	while (c > 0) {  		int chunk = c;  		if (d > 0 && d < chunk)  			chunk = d;  		if (s > 0 && s < chunk)  			chunk = s;  		if ((d -= chunk) < 0)  			d += length;  		if ((s -= chunk) < 0)  			s += length;  		Array.Copy (buffer' s' buffer' d' chunk);  		c -= chunk;  	}  	// At this point' s == start  	for (c = 0; c < count; ++c) {  		buffer [s] = default(T);  		if (++s >= length)  			s -= length;  	}  	start = s;  }  else {  	// Removing in the second half of the list. Move items with  	// higher indexes down in the buffer.  	int move = dequeCount - index - count;  	s = end - move;  	if (s < 0)  		s += length;  	d = s - count;  	if (d < 0)  		d += length;  	int c = move;  	while (c > 0) {  		int chunk = c;  		if (length - d < chunk)  			chunk = length - d;  		if (length - s < chunk)  			chunk = length - s;  		Array.Copy (buffer' s' buffer' d' chunk);  		c -= chunk;  		if ((d += chunk) >= length)  			d -= length;  		if ((s += chunk) >= length)  			s -= length;  	}  	// At this point' s == end.  	for (c = 0; c < count; ++c) {  		if (--s < 0)  			s += length;  		buffer [s] = default(T);  	}  	end = s;  }  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,GetFullHash,The following statement contains a magic number: hash += ~(hash << 15);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,GetFullHash,The following statement contains a magic number: hash ^= (hash >> 10);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,GetFullHash,The following statement contains a magic number: hash += (hash << 3);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,GetFullHash,The following statement contains a magic number: hash ^= (hash >> 6);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,GetFullHash,The following statement contains a magic number: hash += ~(hash << 11);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,GetFullHash,The following statement contains a magic number: hash ^= (hash >> 16);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,EnsureEnoughSlots,The following statement contains a magic number: if (usedSlots + additionalItems > thresholdGrow) {  	// We need to expand the table. Figure out to what size.  	int newSize;  	newSize = Math.Max (totalSlots' MINSIZE);  	while ((int)(newSize * loadFactor) < usedSlots + additionalItems) {  		newSize *= 2;  		if (newSize <= 0) {  			// Must have overflowed the size of an int. Hard to believe we didn't run out of memory first.  			throw new InvalidOperationException (Strings.CollectionTooLarge);  		}  	}  	ResizeTable (newSize);  }  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,EnsureEnoughSlots,The following statement contains a magic number: while ((int)(newSize * loadFactor) < usedSlots + additionalItems) {  	newSize *= 2;  	if (newSize <= 0) {  		// Must have overflowed the size of an int. Hard to believe we didn't run out of memory first.  		throw new InvalidOperationException (Strings.CollectionTooLarge);  	}  }  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,EnsureEnoughSlots,The following statement contains a magic number: newSize *= 2;  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,ShrinkIfNeeded,The following statement contains a magic number: if (count < thresholdShrink) {  	int newSize;  	if (count > 0) {  		newSize = MINSIZE;  		while ((int)(newSize * loadFactor) < count)  			newSize *= 2;  	}  	else {  		// We've removed all the elements. Shrink to zero.  		newSize = 0;  	}  	ResizeTable (newSize);  }  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,ShrinkIfNeeded,The following statement contains a magic number: if (count > 0) {  	newSize = MINSIZE;  	while ((int)(newSize * loadFactor) < count)  		newSize *= 2;  }  else {  	// We've removed all the elements. Shrink to zero.  	newSize = 0;  }  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,ShrinkIfNeeded,The following statement contains a magic number: while ((int)(newSize * loadFactor) < count)  	newSize *= 2;  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,ShrinkIfNeeded,The following statement contains a magic number: newSize *= 2;  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,ResizeTable,The following statement contains a magic number: thresholdShrink = thresholdGrow / 3;  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Validate,The following statement contains a magic number: if (thresholdShrink > 1)  	Debug.Assert (thresholdGrow / 3 == thresholdShrink);  else  	Debug.Assert (thresholdGrow / 3 <= MINSIZE);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Validate,The following statement contains a magic number: if (thresholdShrink > 1)  	Debug.Assert (thresholdGrow / 3 == thresholdShrink);  else  	Debug.Assert (thresholdGrow / 3 <= MINSIZE);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Validate,The following statement contains a magic number: Debug.Assert (thresholdGrow / 3 == thresholdShrink);  
Magic Number,Wintellect.PowerCollections,Hash,C:\repos\xmj112288_Study\OpenSources\PowerCollection\Hash.cs,Validate,The following statement contains a magic number: Debug.Assert (thresholdGrow / 3 <= MINSIZE);  
Magic Number,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,Add,The following statement contains a magic number: if (hash.Find (keyValues' false' out existing)) {  	// There already is an item in the hash table equal to this key. Add the new value'  	// taking into account duplicates if needed.  	int existingCount = existing.Count;  	if (!allowDuplicateValues) {  		int valueHash = Util.GetHashCode (value' valueEqualityComparer);  		for (int i = 0; i < existingCount; ++i) {  			if (Util.GetHashCode (existing.Values [i]' valueEqualityComparer) == valueHash && valueEqualityComparer.Equals (existing.Values [i]' value)) {  				// Found an equal existing value. Replace it and we're done.  				existing.Values [i] = value;  				return;  			}  		}  	}  	// Add a new value to an existing key.  	if (existingCount == existing.Values.Length) {  		// Grow the array to make room.  		TValue[] newValues = new TValue[existingCount * 2];  		Array.Copy (existing.Values' newValues' existingCount);  		existing.Values = newValues;  	}  	existing.Values [existingCount] = value;  	existing.Count = existingCount + 1;  	// Update the hash table.  	hash.Find (existing' true' out keyValues);  	return;  }  else {  	// No item with this key. Add it.  	keyValues.Count = 1;  	keyValues.Values = new TValue[1] {  		value  	};  	hash.Insert (keyValues' true' out existing);  	return;  }  
Magic Number,Wintellect.PowerCollections,MultiDictionary,C:\repos\xmj112288_Study\OpenSources\PowerCollection\MultiDictionary.cs,Add,The following statement contains a magic number: if (existingCount == existing.Values.Length) {  	// Grow the array to make room.  	TValue[] newValues = new TValue[existingCount * 2];  	Array.Copy (existing.Values' newValues' existingCount);  	existing.Values = newValues;  }  
Magic Number,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,NCopiesOfNode,The following statement contains a magic number: while (copies > 0) {  	power.MarkShared ();  	if ((copies & n) != 0) {  		// This power of two is used in the final result.  		copies -= n;  		if (builder == null)  			builder = power;  		else  			builder = builder.Append (power' false);  	}  	n *= 2;  	power = power.Append (power' false);  }  
Magic Number,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,NCopiesOfNode,The following statement contains a magic number: n *= 2;  
Magic Number,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,Rebalance,The following statement contains a magic number: if (root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI [root.Depth - 2]))  	return;  
Magic Number,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,Rebalance,The following statement contains a magic number: if (root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI [root.Depth - 2]))  	return;  
Magic Number,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,Rebalance,The following statement contains a magic number: Debug.Assert (root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI [root.Depth - 2]));  
Magic Number,Wintellect.PowerCollections,BigList,C:\repos\xmj112288_Study\OpenSources\PowerCollection\BigList.cs,Rebalance,The following statement contains a magic number: Debug.Assert (root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI [root.Depth - 2]));  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x400)  	maxDepth = 21;  else if (count < 0x10000)  	maxDepth = 41;  else  	maxDepth = 65;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x400)  	maxDepth = 21;  else if (count < 0x10000)  	maxDepth = 41;  else  	maxDepth = 65;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x400)  	maxDepth = 21;  else if (count < 0x10000)  	maxDepth = 41;  else  	maxDepth = 65;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: maxDepth = 21;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x10000)  	maxDepth = 41;  else  	maxDepth = 65;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x10000)  	maxDepth = 41;  else  	maxDepth = 65;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: maxDepth = 41;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,GetNodeStack,The following statement contains a magic number: maxDepth = 65;  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The following statement contains a magic number: while (node != null) {  	// If we find a node with two red children' split it so it doesn't cause problems  	// when inserting a node.  	if (node.left != null && node.left.IsRed && node.right != null && node.right.IsRed) {  		node = InsertSplit (ggparent' gparent' parent' node' out rotated);  		if (needStack && rotated) {  			nodeStackPtr -= 2;  			if (nodeStackPtr < 0)  				nodeStackPtr = 0;  		}  	}  	// Keep track of parent' grandparent' great-grand parent.  	ggparent = gparent;  	gparent = parent;  	parent = node;  	// Compare the key and the node.   	int compare = comparer.Compare (item' node.item);  	if (compare == 0) {  		// Found a node with the data already. Check duplicate policy.  		if (dupPolicy == DuplicatePolicy.DoNothing) {  			previous = node.item;  			// Didn't insert after all. Return counts back to their previous value.  			for (int i = 0; i < nodeStackPtr; ++i)  				nodeStack [i].DecrementCount ();  			return false;  		}  		else if (dupPolicy == DuplicatePolicy.InsertFirst || dupPolicy == DuplicatePolicy.ReplaceFirst) {  			// Insert first by treating the key as less than nodes in the tree.  			duplicateFound = node;  			compare = -1;  		}  		else {  			Debug.Assert (dupPolicy == DuplicatePolicy.InsertLast || dupPolicy == DuplicatePolicy.ReplaceLast);  			// Insert last by treating the key as greater than nodes in the tree.  			duplicateFound = node;  			compare = 1;  		}  	}  	Debug.Assert (compare != 0);  	node.IncrementCount ();  	if (needStack)  		nodeStack [nodeStackPtr++] = node;  	// Move to the left or right as needed to find the insertion point.  	if (compare < 0) {  		node = node.left;  		wentLeft = true;  		wentRight = false;  	}  	else {  		node = node.right;  		wentRight = true;  		wentLeft = false;  	}  }  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The following statement contains a magic number: if (node.left != null && node.left.IsRed && node.right != null && node.right.IsRed) {  	node = InsertSplit (ggparent' gparent' parent' node' out rotated);  	if (needStack && rotated) {  		nodeStackPtr -= 2;  		if (nodeStackPtr < 0)  			nodeStackPtr = 0;  	}  }  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The following statement contains a magic number: if (needStack && rotated) {  	nodeStackPtr -= 2;  	if (nodeStackPtr < 0)  		nodeStackPtr = 0;  }  
Magic Number,Wintellect.PowerCollections,RedBlackTree,C:\repos\xmj112288_Study\OpenSources\PowerCollection\RedBlack.cs,Insert,The following statement contains a magic number: nodeStackPtr -= 2;  
