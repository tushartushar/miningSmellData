Implementation smell,Namespace,Class,File,Method,Description
Long Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The method has 182 lines of code.
Long Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The method has 141 lines of code.
Long Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The method has 138 lines of code.
Long Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The method has 346 lines of code.
Long Method,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The method has 127 lines of code.
Long Method,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The method has 204 lines of code.
Long Method,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The method has 107 lines of code.
Long Method,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The method has 163 lines of code.
Long Method,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The method has 522 lines of code.
Long Method,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The method has 193 lines of code.
Long Method,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ScheduleJobs,The method has 132 lines of code.
Complex Method,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,Cyclomatic complexity of the method is 9
Complex Method,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,TranslatedAdd,Cyclomatic complexity of the method is 10
Complex Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,BuildExpression,Cyclomatic complexity of the method is 21
Complex Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,Cyclomatic complexity of the method is 46
Complex Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,Cyclomatic complexity of the method is 24
Complex Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,Cyclomatic complexity of the method is 57
Complex Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetSet,Cyclomatic complexity of the method is 8
Complex Method,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,Cyclomatic complexity of the method is 55
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreTrigger,Cyclomatic complexity of the method is 11
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,GetTriggerState,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreCalendar,Cyclomatic complexity of the method is 10
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,AcquireNextTrigger,Cyclomatic complexity of the method is 13
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,TriggerFired,Cyclomatic complexity of the method is 11
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,TriggeredJobComplete,Cyclomatic complexity of the method is 15
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,FindFailedInstances,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,ClusterRecover,Cyclomatic complexity of the method is 16
Complex Method,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTriggersForJob,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,Cyclomatic complexity of the method is 14
Complex Method,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTriggerJobDataMap,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,Cyclomatic complexity of the method is 15
Complex Method,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,Cyclomatic complexity of the method is 13
Complex Method,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,Cyclomatic complexity of the method is 17
Complex Method,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,Cyclomatic complexity of the method is 12
Complex Method,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,ScheduleJob,Cyclomatic complexity of the method is 10
Complex Method,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,ScheduleJobs,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,Cyclomatic complexity of the method is 22
Complex Method,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,Cyclomatic complexity of the method is 20
Complex Method,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,GetScheduleBuilder,Cyclomatic complexity of the method is 15
Complex Method,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,UpdateAfterMisfire,Cyclomatic complexity of the method is 22
Complex Method,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,GetFireTimeAfter,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,Cyclomatic complexity of the method is 31
Complex Method,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,ValidateConfiguration,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,Cyclomatic complexity of the method is 71
Complex Method,Quartz.Job,DirectoryScanJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\DirectoryScanJob.cs,Execute,Cyclomatic complexity of the method is 11
Complex Method,Quartz.Job,FileScanJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\FileScanJob.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,Cyclomatic complexity of the method is 10
Complex Method,Quartz.Job,SendMailJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\SendMailJob.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Quartz.Impl.Calendar,AnnualCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\AnnualCalendar.cs,AnnualCalendar,Cyclomatic complexity of the method is 13
Complex Method,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,DailyCalendar,Cyclomatic complexity of the method is 15
Complex Method,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetNextIncludedTimeUtc,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.Calendar,HolidayCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\HolidayCalendar.cs,HolidayCalendar,Cyclomatic complexity of the method is 13
Complex Method,Quartz.Impl.Calendar,MonthlyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\MonthlyCalendar.cs,MonthlyCalendar,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.Calendar,WeeklyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\WeeklyCalendar.cs,WeeklyCalendar,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.Calendar,WeeklyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\WeeklyCalendar.cs,AreAllDaysExcluded,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.Matchers,StringMatcher,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Matchers\StringMatcher.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Impl.Matchers,AndMatcher,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Matchers\AndMatcher.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Quartz.Impl.Matchers,OrMatcher,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Matchers\OrMatcher.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,Cyclomatic complexity of the method is 11
Complex Method,Quartz.Util,DirtyFlagMap,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\DirtyFlagMap.cs,DirtyFlagMap,Cyclomatic complexity of the method is 16
Complex Method,Quartz.Util,Key,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\Key.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Quartz.Util,PropertiesParser,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\PropertiesParser.cs,GetPropertyGroup,Cyclomatic complexity of the method is 8
Complex Method,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,Cyclomatic complexity of the method is 39
Complex Method,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ScheduleJobs,Cyclomatic complexity of the method is 27
Complex Method,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ExecutePreProcessCommands,Cyclomatic complexity of the method is 19
Long Parameter List,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,DateOf,The method has 5 parameters.
Long Parameter List,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,DateOf,The method has 6 parameters.
Long Parameter List,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTime,The method has 5 parameters.
Long Parameter List,Quartz,SchedulerMetaData,C:\repos\xmj112288_Study\OpenSources\Quartz\SchedulerMetaData.cs,SchedulerMetaData,The method has 15 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,DBSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DBSemaphore.cs,DBSemaphore,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,IDriverDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\IDriverDelegate.cs,UpdateTriggerStateFromOtherStates,The method has 6 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,IDriverDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\IDriverDelegate.cs,UpdateTriggerGroupStateFromOtherStates,The method has 6 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,IDriverDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\IDriverDelegate.cs,HasMisfiredTriggersInState,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,DoUpdateOfMisfiredTrigger,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreTrigger,The method has 7 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreCalendar,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreCalendar,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,AcquireNextTriggers,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,HasMisfiredTriggersInState,The method has 5 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,UpdateTriggerStateFromOtherStates,The method has 6 parameters.
Long Parameter List,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,UpdateTriggerGroupStateFromOtherStates,The method has 6 parameters.
Long Parameter List,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,DailyTimeIntervalTriggerImpl,The method has 5 parameters.
Long Parameter List,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,DailyTimeIntervalTriggerImpl,The method has 6 parameters.
Long Parameter List,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,DailyTimeIntervalTriggerImpl,The method has 7 parameters.
Long Parameter List,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,DailyTimeIntervalTriggerImpl,The method has 8 parameters.
Long Parameter List,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,DailyTimeIntervalTriggerImpl,The method has 10 parameters.
Long Parameter List,Quartz.Impl.Triggers,CronTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CronTriggerImpl.cs,CronTriggerImpl,The method has 5 parameters.
Long Parameter List,Quartz.Impl.Triggers,CronTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CronTriggerImpl.cs,CronTriggerImpl,The method has 6 parameters.
Long Parameter List,Quartz.Impl.Triggers,CronTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CronTriggerImpl.cs,CronTriggerImpl,The method has 7 parameters.
Long Parameter List,Quartz.Impl.Triggers,CronTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CronTriggerImpl.cs,CronTriggerImpl,The method has 8 parameters.
Long Parameter List,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,SimpleTriggerImpl,The method has 5 parameters.
Long Parameter List,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,SimpleTriggerImpl,The method has 6 parameters.
Long Parameter List,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,SimpleTriggerImpl,The method has 8 parameters.
Long Parameter List,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,CalendarIntervalTriggerImpl,The method has 5 parameters.
Long Parameter List,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,CalendarIntervalTriggerImpl,The method has 6 parameters.
Long Parameter List,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,CalendarIntervalTriggerImpl,The method has 8 parameters.
Long Parameter List,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,CreateScheduler,The method has 6 parameters.
Long Parameter List,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,CreateScheduler,The method has 7 parameters.
Long Parameter List,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,CreateScheduler,The method has 8 parameters.
Long Parameter List,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,CreateScheduler,The method has 10 parameters.
Long Parameter List,Quartz.Impl,RemoteScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\RemoteScheduler.cs,AddCalendar,The method has 5 parameters.
Long Parameter List,Quartz.Impl,JobDetailImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\JobDetailImpl.cs,JobDetailImpl,The method has 5 parameters.
Long Parameter List,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The method has 5 parameters.
Long Parameter List,Quartz.Job,SendMailJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\SendMailJob.cs,SendMail,The method has 7 parameters.
Long Parameter List,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,DailyCalendar,The method has 8 parameters.
Long Parameter List,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,DailyCalendar,The method has 9 parameters.
Long Parameter List,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The method has 8 parameters.
Long Parameter List,Quartz.Spi,TriggerFiredBundle,C:\repos\xmj112288_Study\OpenSources\Quartz\SPI\TriggerFiredBundle.cs,TriggerFiredBundle,The method has 8 parameters.
Long Identifier,Quartz,CalendarIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\CalendarIntervalScheduleBuilder.cs,WithMisfireHandlingInstruction,The length of the parameter readMisfireInstructionFromString is 32.
Long Identifier,Quartz,CronScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\CronScheduleBuilder.cs,WithMisfireHandlingInstruction,The length of the parameter readMisfireInstructionFromString is 32.
Long Identifier,Quartz,SimpleScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\SimpleScheduleBuilder.cs,WithMisfireHandlingInstruction,The length of the parameter readMisfireInstructionFromString is 32.
Long Identifier,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,AcquireNextTrigger,The length of the parameter acquiredJobKeysForNoConcurrentExec is 34.
Long Identifier,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the parameter interruptJobsOnShutdownWithWait is 31.
Long Identifier,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,AcquireNextTriggers,The length of the parameter acquiredJobKeysForNoConcurrentExec is 34.
Long Statement,Quartz,CronScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\CronScheduleBuilder.cs,CronScheduleNoParseException,The length of the statement  "		throw new Exception ("CronExpression '" + presumedValidCronExpression + "' is invalid' which should not be possible' please report bug to Quartz developers."' e); " is 162.
Long Statement,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The length of the statement  "	startTimeOfDayDate = new DateTimeOffset (startTimeOfDayDate.DateTime' targetTimeZone.GetUtcOffset (startTimeOfDayDate.DateTime)); " is 129.
Long Statement,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The length of the statement  "	maxEndTimeOfDayDate = new DateTimeOffset (maxEndTimeOfDayDate.DateTime' targetTimeZone.GetUtcOffset (maxEndTimeOfDayDate.DateTime)); " is 132.
Long Statement,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,EvenHourDateBefore,The length of the statement  "	return new DateTimeOffset (date.Value.Year' date.Value.Month' date.Value.Day' date.Value.Hour' 0' 0' date.Value.Offset); " is 120.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,IsSatisfiedBy,The length of the statement  "	DateTimeOffset test = new DateTimeOffset (dateUtc.Year' dateUtc.Month' dateUtc.Day' dateUtc.Hour' dateUtc.Minute' dateUtc.Second' dateUtc.Offset).AddSeconds (-1); " is 162.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetNextInvalidTimeAfter,The length of the statement  "	DateTimeOffset lastDate = new DateTimeOffset (date.Year' date.Month' date.Day' date.Hour' date.Minute' date.Second' date.Offset).AddSeconds (-1); " is 145.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetNextInvalidTimeAfter,The length of the statement  "	//TODO: IMPROVE THIS! The following is a BAD solution to this problem. Performance will be very bad here' depending on the cron expression. It is' however A solution. " is 166.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,BuildExpression,The length of the statement  "			throw new FormatException ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented."); " is 121.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The length of the statement  "			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub)); " is 125.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The length of the statement  "			throw new FormatException ("The 'W' option does not make sense with values larger than 31 (max number of days in a month)"); " is 124.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The length of the statement  "				d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth); " is 121.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,SetCalendarHour,The length of the statement  "	DateTimeOffset d = new DateTimeOffset (date.Year' date.Month' date.Day' hourToSet' date.Minute' date.Second' date.Millisecond' date.Offset); " is 140.
Long Statement,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetHashCode,The length of the statement  "		return ((cronExpressionString != null ? cronExpressionString.GetHashCode () : 0) * 397) ^ (timeZone != null ? timeZone.GetHashCode () : 0); " is 139.
Long Statement,Quartz,JobExecutionException,C:\repos\xmj112288_Study\OpenSources\Quartz\JobExecutionException.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "Parameters: refire = {0}' unscheduleFiringTrigger = {1}' unscheduleAllTriggers = {2} \n {3}"' RefireImmediately' UnscheduleFiringTrigger' UnscheduleAllTriggers' base.ToString ()); " is 232.
Long Statement,Quartz,SchedulerException,C:\repos\xmj112288_Study\OpenSources\Quartz\SchedulerException.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0} [See nested exception: {1}]"' base.ToString ()' InnerException); " is 121.
Long Statement,Quartz.Impl.AdoJobStore,CalendarIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\CalendarIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The length of the statement  "	CalendarIntervalScheduleBuilder sb = CalendarIntervalScheduleBuilder.Create ().WithInterval (props.Int1' (IntervalUnit)Enum.Parse (typeof(IntervalUnit)' props.String1' true)).InTimeZone (tz).PreserveHourOfDayAcrossDaylightSavings (props.Boolean1).SkipDayIfHourDoesNotExist (props.Boolean2); " is 290.
Long Statement,Quartz.Impl.AdoJobStore,CronTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\CronTriggerPersistenceDelegate.cs,DeleteExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlDeleteCronTrigger' TablePrefix' SchedNameLiteral))) { " is 165.
Long Statement,Quartz.Impl.AdoJobStore,CronTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\CronTriggerPersistenceDelegate.cs,InsertExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlInsertCronTrigger' TablePrefix' SchedNameLiteral))) { " is 165.
Long Statement,Quartz.Impl.AdoJobStore,CronTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\CronTriggerPersistenceDelegate.cs,LoadExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlSelectCronTriggers' TablePrefix' SchedNameLiteral))) { " is 166.
Long Statement,Quartz.Impl.AdoJobStore,CronTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\CronTriggerPersistenceDelegate.cs,LoadExtendedTriggerProperties,The length of the statement  "		throw new InvalidOperationException ("No record found for selection of Trigger with key: '" + triggerKey + "' and statement: " + AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlSelectCronTriggers' TablePrefix' SchedNameLiteral)); " is 236.
Long Statement,Quartz.Impl.AdoJobStore,CronTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\CronTriggerPersistenceDelegate.cs,UpdateExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlUpdateCronTrigger' TablePrefix' SchedNameLiteral))) { " is 165.
Long Statement,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerProperties,The length of the statement  "	string daysStr = string.Join ("'"' days.Cast<int> ().Select (x => x.ToString (CultureInfo.InvariantCulture)).ToArray ()); " is 121.
Long Statement,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The length of the statement  "	DailyTimeIntervalScheduleBuilder scheduleBuilder = DailyTimeIntervalScheduleBuilder.Create ().WithInterval (interval' intervalUnit).WithRepeatCount (repeatCount); " is 162.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,DeleteExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlDeleteSimpleTrigger' TablePrefix' SchedNameLiteral))) { " is 167.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,InsertExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlInsertSimpleTrigger' TablePrefix' SchedNameLiteral))) { " is 167.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,InsertExtendedTriggerProperties,The length of the statement  "		DbAccessor.AddCommandParameter (cmd' "triggerRepeatInterval"' DbAccessor.GetDbTimeSpanValue (simpleTrigger.RepeatInterval)); " is 124.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,LoadExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlSelectSimpleTrigger' TablePrefix' SchedNameLiteral))) { " is 167.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,LoadExtendedTriggerProperties,The length of the statement  "		throw new InvalidOperationException ("No record found for selection of Trigger with key: '" + triggerKey + "' and statement: " + AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlSelectSimpleTrigger' TablePrefix' SchedNameLiteral)); " is 237.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,UpdateExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlUpdateSimpleTrigger' TablePrefix' SchedNameLiteral))) { " is 167.
Long Statement,Quartz.Impl.AdoJobStore,SimpleTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleTriggerPersistenceDelegate.cs,UpdateExtendedTriggerProperties,The length of the statement  "		DbAccessor.AddCommandParameter (cmd' "triggerRepeatInterval"' DbAccessor.GetDbTimeSpanValue (simpleTrigger.RepeatInterval)); " is 124.
Long Statement,Quartz.Impl.AdoJobStore,SimplePropertiesTriggerPersistenceDelegateSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimplePropertiesTriggerPersistenceDelegateSupport.cs,DeleteExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (DeleteSimplePropsTrigger' TablePrefix' SchedNameLiteral))) { " is 153.
Long Statement,Quartz.Impl.AdoJobStore,SimplePropertiesTriggerPersistenceDelegateSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimplePropertiesTriggerPersistenceDelegateSupport.cs,InsertExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (InsertSimplePropsTrigger' TablePrefix' SchedNameLiteral))) { " is 153.
Long Statement,Quartz.Impl.AdoJobStore,SimplePropertiesTriggerPersistenceDelegateSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimplePropertiesTriggerPersistenceDelegateSupport.cs,LoadExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (SelectSimplePropsTrigger' TablePrefix' SchedNameLiteral))) { " is 153.
Long Statement,Quartz.Impl.AdoJobStore,SimplePropertiesTriggerPersistenceDelegateSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimplePropertiesTriggerPersistenceDelegateSupport.cs,LoadExtendedTriggerProperties,The length of the statement  "	throw new InvalidOperationException ("No record found for selection of Trigger with key: '" + triggerKey + "' and statement: " + AdoJobStoreUtil.ReplaceTablePrefix (StdAdoConstants.SqlSelectSimpleTrigger' TablePrefix' SchedNameLiteral)); " is 237.
Long Statement,Quartz.Impl.AdoJobStore,SimplePropertiesTriggerPersistenceDelegateSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimplePropertiesTriggerPersistenceDelegateSupport.cs,UpdateExtendedTriggerProperties,The length of the statement  "	using (IDbCommand cmd = DbAccessor.PrepareCommand (conn' AdoJobStoreUtil.ReplaceTablePrefix (UpdateSimplePropsTrigger' TablePrefix' SchedNameLiteral))) { " is 153.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreCMT,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreCMT.cs,GetNonManagedTXConnection,The length of the statement  "		throw new JobPersistenceException (string.Format ("Failed to obtain DB connection from data source '{0}': {1}"' DataSource' sqle)' sqle); " is 137.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreCMT,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreCMT.cs,GetNonManagedTXConnection,The length of the statement  "		throw new JobPersistenceException (string.Format ("Failed to obtain DB connection from data source '{0}': {1}"' DataSource' e)' e); " is 131.
Long Statement,Quartz.Impl.AdoJobStore,DBSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DBSemaphore.cs,ReleaseLock,The length of the statement  "		Log.WarnFormat ("Lock '{0}' attempt to return by: {1} -- but not owner!"' new Exception ("stack-trace of wrongful returner")' lockName' Thread.CurrentThread.Name); " is 163.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,GetConnection,The length of the statement  "		throw new JobPersistenceException (string.Format ("Failed to obtain DB connection from data source '{0}': {1}"' DataSource' e)' e); " is 131.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Initialize,The length of the statement  "					const string DefaultLockSql = "SELECT * FROM {0}LOCKS WITH (UPDLOCK'ROWLOCK) WHERE " + ColumnSchedulerName + " = {1} AND LOCK_NAME = @lockName"; " is 144.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Initialize,The length of the statement  "					Log.InfoFormat ("Detected usage of SqlServerDelegate - defaulting 'selectWithLockSQL' to '" + DefaultLockSql + "'."' TablePrefix' "'" + InstanceName + "'"); " is 156.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Initialize,The length of the statement  "			Log.Warn ("Detected usage of SqlServerDelegate and UpdateLockRowSemaphore' removing 'quartz.jobStore.lockHandler.type' would allow more efficient SQL Server specific (UPDLOCK'ROWLOCK) row access"); " is 197.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Initialize,The length of the statement  "		if (DbProvider != null && DbProvider.Metadata.ConnectionType == typeof(SqlConnection) && !(Delegate is SqlServerDelegate)) { " is 124.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Initialize,The length of the statement  "			Log.Warn ("Detected usage of SQL Server provider without SqlServerDelegate' SqlServerDelegate would provide better performance"); " is 129.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,RecoverJobs,The length of the statement  "		Log.Info ("Recovering " + recoveringJobTriggers.Count + " jobs that were in-progress at the time of the last shut-down."); " is 122.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,RecoverMisfiredJobs,The length of the statement  "	bool hasMoreMisfiredTriggers = Delegate.HasMisfiredTriggersInState (conn' StateWaiting' MisfireTime' maxMisfiresToHandleAtATime' misfiredTriggers); " is 147.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,RecoverMisfiredJobs,The length of the statement  "		Log.Info ("Handling the first " + misfiredTriggers.Count + " triggers that missed their scheduled fire-time.  " + "More misfired triggers remain to be processed."); " is 164.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,UpdateMisfiredTrigger,The length of the statement  "		throw new JobPersistenceException (string.Format ("Couldn't update misfired trigger '{0}': {1}"' triggerKey' e.Message)' e); " is 124.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreJob,The length of the statement  "	ExecuteInLock ((LockOnInsert || replaceExisting) ? LockTriggerAccess : null' conn => StoreJob (conn' newJob' replaceExisting)); " is 127.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreTrigger,The length of the statement  "	ExecuteInLock ((LockOnInsert || replaceExisting) ? LockTriggerAccess : null' conn => StoreTrigger (conn' newTrigger' null' replaceExisting' StateWaiting' false' false)); " is 169.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreTrigger,The length of the statement  "		string message = String.Format ("Couldn't store trigger '{0}' for '{1}' job: {2}"' newTrigger.Key' newTrigger.JobKey' e.Message); " is 129.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,StoreCalendar,The length of the statement  "	ExecuteInLock ((LockOnInsert || updateTriggers) ? LockTriggerAccess : null' conn => StoreCalendar (conn' calName' calendar' replaceExisting' updateTriggers)); " is 158.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,RetrieveCalendar,The length of the statement  "		throw new JobPersistenceException ("Couldn't retrieve calendar because the BLOB couldn't be deserialized: " + e.Message' e); " is 124.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,CheckBlockedState,The length of the statement  "		throw new JobPersistenceException ("Couldn't determine if trigger should be in a blocked state '" + jobKey + "': " + e.Message' e); " is 131.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,PauseTriggerGroup,The length of the statement  "		Delegate.UpdateTriggerGroupStateFromOtherStates (conn' matcher' StatePaused' StateAcquired' StateWaiting' StateWaiting); " is 120.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,AcquireNextTriggers,The length of the statement  "		return (IList<IOperableTrigger>)ExecuteInNonManagedTXLock (LockTriggerAccess' conn => AcquireNextTrigger (conn' noLaterThan' maxCount' timeWindow)); " is 148.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,AcquireNextTriggers,The length of the statement  "		return (IList<IOperableTrigger>)ExecuteInNonManagedTXLock (null' /* passing null as lock name causes no lock to be made */conn => AcquireNextTrigger (conn' noLaterThan' maxCount' timeWindow)); " is 192.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,AcquireNextTrigger,The length of the statement  "				if (firstAcquiredTriggerFireTime != null && nextTrigger.GetNextFireTimeUtc () > (firstAcquiredTriggerFireTime.Value + timeWindow)) { " is 132.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,TriggerFired,The length of the statement  "	return new TriggerFiredBundle (job' trigger' cal' trigger.Key.Group.Equals (SchedulerConstants.DefaultRecoveryGroup)' SystemTime.UtcNow ()' trigger.GetPreviousFireTimeUtc ()' prevFireTime' trigger.GetNextFireTimeUtc ()); " is 220.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,TriggeredJobComplete,The length of the statement  "	ExecuteInNonManagedTXLock (LockTriggerAccess' conn => TriggeredJobComplete (conn' trigger' jobDetail' triggerInstCode)); " is 120.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,DoRecoverMisfires,The length of the statement  "		int misfireCount = (DoubleCheckLockMisfireHandler) ? Delegate.CountMisfiredTriggersInState (conn' StateWaiting' MisfireTime) : Int32.MaxValue; " is 142.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,FindFailedInstances,The length of the statement  "			Log.Warn ("This scheduler instance (" + InstanceId + ") is still " + "active but was recovered by another instance in the cluster.  " + "This may cause inconsistent behavior."); " is 177.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,ClusterRecover,The length of the statement  "		LogWarnIfNonZero (failedInstances.Count' "ClusterManager: detected " + failedInstances.Count + " failed or restarted instances."); " is 130.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,ClusterRecover,The length of the statement  "				IList<FiredTriggerRecord> firedTriggerRecs = Delegate.SelectInstancesFiredTriggerRecords (conn' rec.SchedulerInstanceId); " is 121.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,ClusterRecover,The length of the statement  "							SimpleTriggerImpl rcvryTrig = new SimpleTriggerImpl ("recover_" + rec.SchedulerInstanceId + "_" + Convert.ToString (recoverIds++' CultureInfo.InvariantCulture)' SchedulerConstants.DefaultRecoveryGroup' ftRec.FireTimestamp); " is 223.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,ClusterRecover,The length of the statement  "							jd.Put (SchedulerConstants.FailedJobOriginalTriggerFiretimeInMillisecoonds' Convert.ToString (ftRec.FireTimestamp' CultureInfo.InvariantCulture)); " is 146.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,ClusterRecover,The length of the statement  "				LogWarnIfNonZero (recoveredCount' "ClusterManager: ......Scheduled " + recoveredCount + " recoverable job(s) for recovery."); " is 125.
Long Statement,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,CloseConnection,The length of the statement  "			Log.Error ("Unexpected exception closing Connection." + "  This is often due to a Connection being returned after or during shutdown."' e); " is 139.
Long Statement,Quartz.Impl.AdoJobStore,SimpleSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleSemaphore.cs,ObtainLock,The length of the statement  "				log.Debug (string.Format (CultureInfo.InvariantCulture' "Lock '{0}' given to: {1}"' lockName' Thread.CurrentThread.Name)); " is 122.
Long Statement,Quartz.Impl.AdoJobStore,SimpleSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleSemaphore.cs,ObtainLock,The length of the statement  "			log.Debug (string.Format (CultureInfo.InvariantCulture' "Lock '{0}' already owned by: {1} -- but not owner!"' lockName' Thread.CurrentThread.Name)' new Exception ("stack-trace of wrongful returner")); " is 200.
Long Statement,Quartz.Impl.AdoJobStore,SimpleSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleSemaphore.cs,ReleaseLock,The length of the statement  "				log.Debug (string.Format (CultureInfo.InvariantCulture' "Lock '{0}' retuned by: {1}"' lockName' Thread.CurrentThread.Name)); " is 124.
Long Statement,Quartz.Impl.AdoJobStore,SimpleSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SimpleSemaphore.cs,ReleaseLock,The length of the statement  "			log.Debug (string.Format (CultureInfo.InvariantCulture' "Lock '{0}' attempt to retun by: {1} -- but not owner!"' lockName' Thread.CurrentThread.Name)' new Exception ("stack-trace of wrongful returner")); " is 203.
Long Statement,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTriggersForRecoveringJobs,The length of the statement  "				SimpleTriggerImpl rcvryTrig = new SimpleTriggerImpl ("recover_" + instanceId + "_" + Convert.ToString (dumId++' CultureInfo.InvariantCulture)' SchedulerConstants.DefaultRecoveryGroup' firedTime); " is 195.
Long Statement,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTriggersForRecoveringJobs,The length of the statement  "		jd.Put (SchedulerConstants.FailedJobOriginalTriggerFiretimeInMillisecoonds' Convert.ToString (trigger.StartTimeUtc' CultureInfo.InvariantCulture)); " is 147.
Long Statement,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The length of the statement  "					TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup)); " is 285.
Long Statement,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SerializeJobData,The length of the statement  "		throw new SerializationException ("Unable to serialize JobDataMap for insertion into " + "database because the value of property '" + GetKeyOfNonSerializableValue ((IDictionary)data) + "' is not serializable: " + e.Message); " is 224.
Long Statement,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,ConvertToProperty,The length of the statement  "			throw new IOException ("JobDataMap keys/values must be Strings " + "when the 'useProperties' property is set. " + " offending Key: " + key); " is 140.
Long Statement,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,ConvertToProperty,The length of the statement  "			throw new IOException ("JobDataMap values must be Strings " + "when the 'useProperties' property is set. " + " Key of offending value: " + key); " is 144.
Long Statement,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The length of the statement  "						Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name); " is 126.
Long Statement,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The length of the statement  "							throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral)); " is 216.
Long Statement,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The length of the statement  "				Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : "")); " is 137.
Long Statement,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The length of the statement  "						Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name); " is 126.
Long Statement,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The length of the statement  "							throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral)); " is 216.
Long Statement,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The length of the statement  "				Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : "")); " is 137.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Initialize,The length of the statement  "		sched.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occured instantiating job to be executed. job= '{0}'"' jobDetail.Key)' se); " is 167.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Initialize,The length of the statement  "		SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "Problem instantiating type '{0}'"' jobDetail.JobType.FullName)' e); " is 161.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Initialize,The length of the statement  "		sched.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occured instantiating job to be executed. job= '{0}'"' jobDetail.Key)' se); " is 167.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Error executing Job ({0}: couldn't begin execution."' jec.JobDetail.Key)' se); " is 158.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "					qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Error during veto of Job ({0}: couldn't finalize execution."' jec.JobDetail.Key)' se); " is 166.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "				log.Info (string.Format (CultureInfo.InvariantCulture' "Job {0} threw a JobExecutionException: "' jobDetail.Key)' jobExEx); " is 123.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Job ({0} threw an exception."' jec.JobDetail.Key)' se); " is 135.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "					qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Error executing Job ({0}: couldn't finalize execution."' jec.JobDetail.Key)' se); " is 161.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Error executing Job ({0}: couldn't finalize execution."' jec.JobDetail.Key)' se); " is 161.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,Run,The length of the statement  "				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occured while marking executed job complete. job= '{0}'"' jobDetail.Key)' jpe); " is 168.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,NotifyListenersBeginning,The length of the statement  "		qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Unable to notify TriggerListener(s) while firing trigger (Trigger and Job will NOT be fired!). trigger= {0} job= {1}"' ctx.Trigger.Key' ctx.JobDetail.Key)' se); " is 240.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,NotifyListenersBeginning,The length of the statement  "			qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Unable to notify JobListener(s) of vetoed execution while firing trigger (Trigger and Job will NOT be fired!). trigger= {0} job= {1}"' ctx.Trigger.Key' ctx.JobDetail.Key)' se); " is 256.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,NotifyListenersBeginning,The length of the statement  "		qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Unable to notify JobListener(s) of Job to be executed: (Job will NOT be executed!). trigger= {0} job= {1}"' ctx.Trigger.Key' ctx.JobDetail.Key)' se); " is 229.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,NotifyJobListenersComplete,The length of the statement  "		qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Unable to notify JobListener(s) of Job that was executed: (error will be ignored). trigger= {0} job= {1}"' ctx.Trigger.Key' ctx.JobDetail.Key)' se); " is 228.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,NotifyTriggerListenersComplete,The length of the statement  "		qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "Unable to notify TriggerListener(s) of Job that was executed: (error will be ignored). trigger= {0} job= {1}"' ctx.Trigger.Key' ctx.JobDetail.Key)' se); " is 232.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,CompleteTriggerRetryLoop,The length of the statement  "				qs.NotifySchedulerListenersError ("An error occured while marking executed job complete (will continue attempts). job= '" + jobDetail.Key + "'"' jpe); " is 150.
Long Statement,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,VetoedJobRetryLoop,The length of the statement  "			qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occured while marking executed job vetoed. job= '{0}'"' jobDetail.Key)' jpe); " is 166.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Initialize,The length of the statement  "	log.Info ("Scheduler meta-data: " + (new SchedulerMetaData (SchedulerName' SchedulerInstanceId' GetType ()' boundRemotely' RunningSince != null' InStandbyMode' IsShutdown' RunningSince' NumJobsExecuted' JobStoreClass' SupportsPersistence' Clustered' ThreadPoolClass' ThreadPoolSize' Version))); " is 294.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The length of the statement  "	log.Info (string.Format (CultureInfo.InvariantCulture' "Scheduler {0} shutting down."' resources.GetUniqueIdentifier ())); " is 122.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The length of the statement  "	if ((resources.InterruptJobsOnShutdown && !waitForJobsToComplete) || (resources.InterruptJobsOnShutdownWithWait && waitForJobsToComplete)) { " is 140.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The length of the statement  "	log.Info (string.Format (CultureInfo.InvariantCulture' "Scheduler {0} Shutdown complete."' resources.GetUniqueIdentifier ())); " is 126.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,ScheduleJob,The length of the statement  "			throw new SchedulerException (string.Format (CultureInfo.InvariantCulture' "Calendar not found: {0}"' trigger.CalendarName)); " is 125.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,ScheduleJob,The length of the statement  "			throw new SchedulerException (string.Format (CultureInfo.InvariantCulture' "Calendar not found: {0}"' trigger.CalendarName)); " is 125.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,DeleteJob,The length of the statement  "			StringBuilder sb = new StringBuilder ().Append ("Unable to unschedule trigger [").Append (trigger.Key).Append ("] while deleting job [").Append (jobKey).Append ("]"); " is 166.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,TriggerJob,The length of the statement  "	IOperableTrigger trig = new SimpleTriggerImpl (NewTriggerId ()' SchedulerConstants.DefaultGroup' jobKey.Name' jobKey.Group' SystemTime.UtcNow ()' null' 0' TimeSpan.Zero); " is 170.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifyTriggerListenersFired,The length of the statement  "			SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "TriggerListener '{0}' threw exception: {1}"' tl.Name' e.Message)' e); " is 163.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifyTriggerListenersMisfired,The length of the statement  "			SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "TriggerListener '{0}' threw exception: {1}"' tl.Name' e.Message)' e); " is 163.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifyTriggerListenersComplete,The length of the statement  "			SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "TriggerListener '{0}' threw exception: {1}"' tl.Name' e.Message)' e); " is 163.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifyJobListenersToBeExecuted,The length of the statement  "			SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "JobListener '{0}' threw exception: {1}"' jl.Name' e.Message)' e); " is 159.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifyJobListenersWasVetoed,The length of the statement  "			SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "JobListener '{0}' threw exception: {1}"' jl.Name' e.Message)' e); " is 159.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifyJobListenersWasExecuted,The length of the statement  "			SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "JobListener '{0}' threw exception: {1}"' jl.Name' e.Message)' e); " is 159.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersScheduled,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of scheduled job. Trigger={0}"' trigger.Key)' e); " is 146.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersUnscheduled,The length of the statement  "			log.ErrorFormat (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of unscheduled job. Trigger={0}"' e' (triggerKey == null ? "ALL DATA" : triggerKey.ToString ())); " is 185.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersFinalized,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of finalized trigger. Trigger={0}"' trigger.Key)' e); " is 150.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersPausedTriggers,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of paused group: {0}"' group)' e); " is 131.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersPausedTrigger,The length of the statement  "			log.ErrorFormat (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of paused trigger. Trigger={0}"' e' triggerKey); " is 136.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersResumedTriggers,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of resumed group: {0}"' group)' e); " is 132.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersResumedTrigger,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of resumed trigger. Trigger={0}"' triggerKey)' e); " is 147.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersPausedJob,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of paused job. Job={0}"' jobKey)' e); " is 134.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersPausedJobs,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of paused group: {0}"' group)' e); " is 131.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersResumedJob,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of resumed job: {0}"' jobKey)' e); " is 131.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NotifySchedulerListenersResumedJobs,The length of the statement  "			log.Error (string.Format (CultureInfo.InvariantCulture' "Error while notifying SchedulerListener of resumed group: {0}"' group)' e); " is 132.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Interrupt,The length of the statement  "				throw new UnableToInterruptJobException (string.Format (CultureInfo.InvariantCulture' "Job '{0}' can not be interrupted' since it does not implement {1}"' jobDetail.Key' typeof(IInterruptableJob).FullName)); " is 207.
Long Statement,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Interrupt,The length of the statement  "			throw new UnableToInterruptJobException ("Job " + jec.JobDetail.Key + " can not be interrupted' since it does not implement " + typeof(IInterruptableJob).Name); " is 160.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The length of the statement  "					triggers = qsRsrcs.JobStore.AcquireNextTriggers (now + idleWaitTime' Math.Min (availThreadCount' qsRsrcs.MaxBatchSize)' qsRsrcs.BatchTimeWindow); " is 145.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The length of the statement  "								qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2); " is 126.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The length of the statement  "								qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2); " is 169.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ErrorTriggerRetryLoop,The length of the statement  "					qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' bndle.Trigger.Key)' jpe); " is 155.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ErrorTriggerRetryLoop,The length of the statement  "				Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e); " is 124.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ReleaseTriggerRetryLoop,The length of the statement  "					qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' trigger.Key)' jpe); " is 149.
Long Statement,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ReleaseTriggerRetryLoop,The length of the statement  "				Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e); " is 124.
Long Statement,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The length of the statement  "	fireTimeStartDate = new DateTimeOffset (fireTimeStartDate.DateTime' this.TimeZone.GetUtcOffset (fireTimeStartDate.DateTime)); " is 125.
Long Statement,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,Validate,The length of the statement  "	if (repeatIntervalUnit != IntervalUnit.Second && repeatIntervalUnit != IntervalUnit.Minute && repeatIntervalUnit != IntervalUnit.Hour) { " is 136.
Long Statement,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,Validate,The length of the statement  "		throw new SchedulerException ("repeatInterval can not exceed 24 hours (" + SecondsInHour + " seconds). Given " + repeatInterval); " is 129.
Long Statement,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,Validate,The length of the statement  "		throw new SchedulerException ("repeatInterval can not exceed 24 hours (" + SecondsInHour / 60L + " minutes). Given " + repeatInterval); " is 135.
Long Statement,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,Validate,The length of the statement  "		throw new SchedulerException ("StartTimeOfDay " + startTimeOfDay + " should not come after endTimeOfDay " + endTimeOfDay); " is 122.
Long Statement,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetScheduleBuilder,The length of the statement  "	DailyTimeIntervalScheduleBuilder cb = DailyTimeIntervalScheduleBuilder.Create ().WithInterval (RepeatInterval' RepeatIntervalUnit).OnDaysOfTheWeek (DaysOfWeek).StartingDailyAt (StartTimeOfDay).EndingDailyAt (EndTimeOfDay); " is 222.
Long Statement,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,GetFireTimeAfter,The length of the statement  "	long numberOfTimesExecuted = (long)(((long)(afterMillis - startMillis).TotalMilliseconds / repeatInterval.TotalMilliseconds) + 1); " is 130.
Long Statement,Quartz.Impl.Triggers,AbstractTrigger,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\AbstractTrigger.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "Trigger '{0}':  triggerClass: '{1} calendar: '{2}' misfireInstruction: {3} nextFireTime: {4}"' FullName' GetType ().FullName' CalendarName' MisfireInstruction' GetNextFireTimeUtc ()); " is 236.
Long Statement,Quartz.Impl.Triggers,AbstractTrigger,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\AbstractTrigger.cs,GetTriggerBuilder,The length of the statement  "	TriggerBuilder b = TriggerBuilder.Create ().ForJob (JobKey).ModifiedByCalendar (CalendarName).UsingJobData (JobDataMap).WithDescription (Description).EndAt (EndTimeUtc).WithIdentity (Key).WithPriority (Priority).StartAt (StartTimeUtc).WithSchedule (GetScheduleBuilder ()); " is 272.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The length of the statement  "			while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) { " is 127.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The length of the statement  "			while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) { " is 127.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The length of the statement  "			while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) { " is 127.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The length of the statement  "			while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) { " is 127.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,DaylightSavingHourShiftOccuredAndAdvanceNeeded,The length of the statement  "		newTime = new DateTimeOffset (newTime.Year' newTime.Month' newTime.Day' initialHourOfDay' newTime.Minute' newTime.Second' newTime.Millisecond' TimeSpan.Zero); " is 158.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,MakeHourAdjustmentIfNeeded,The length of the statement  "		sTime = new DateTimeOffset (initalYear' initalMonth' initialDay' initialHourOfDay' sTime.Minute' sTime.Second' sTime.Millisecond' TimeSpan.Zero); " is 145.
Long Statement,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetScheduleBuilder,The length of the statement  "	CalendarIntervalScheduleBuilder cb = CalendarIntervalScheduleBuilder.Create ().WithInterval (RepeatInterval' RepeatIntervalUnit); " is 129.
Long Statement,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,CreateScheduler,The length of the statement  "	CreateScheduler (schedulerName' schedulerInstanceId' threadPool' DefaultThreadExecutor' jobStore' schedulerPluginMap' idleWaitTime' dbFailureRetryInterval); " is 156.
Long Statement,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,CreateScheduler,The length of the statement  "	CreateScheduler (schedulerName' schedulerInstanceId' threadPool' threadExecutor' jobStore' schedulerPluginMap' idleWaitTime' dbFailureRetryInterval' DefaultBatchMaxSize' DefaultBatchTimeWindow); " is 194.
Long Statement,Quartz.Impl,DirectSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\DirectSchedulerFactory.cs,GetScheduler,The length of the statement  "		throw new SchedulerException ("you must call createRemoteScheduler or createScheduler methods before calling getScheduler()"); " is 126.
Long Statement,Quartz.Impl,RemoteScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\RemoteScheduler.cs,GetMetaData,The length of the statement  "	return CallInGuard (x => new SchedulerMetaData (SchedulerName' SchedulerInstanceId' GetType ()' true' IsStarted' InStandbyMode' IsShutdown' x.RunningSince' x.NumJobsExecuted' x.JobStoreClass' x.SupportsPersistence' x.Clustered' x.ThreadPoolClass' x.ThreadPoolSize' x.Version)); " is 277.
Long Statement,Quartz.Impl,RemoteScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\RemoteScheduler.cs,Interrupt,The length of the statement  "		throw new UnableToInterruptJobException (InvalidateHandleCreateException ("Error communicating with remote scheduler."' re)); " is 125.
Long Statement,Quartz.Impl,RemoteScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\RemoteScheduler.cs,Interrupt,The length of the statement  "		throw new UnableToInterruptJobException (InvalidateHandleCreateException ("Error communicating with remote scheduler."' re)); " is 125.
Long Statement,Quartz.Impl,RemoteScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\RemoteScheduler.cs,GetRemoteScheduler,The length of the statement  "		string errorMessage = string.Format (CultureInfo.InvariantCulture' "Could not get handle to remote scheduler: {0}"' e.Message); " is 127.
Long Statement,Quartz.Impl,SchedulerRepository,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\SchedulerRepository.cs,Bind,The length of the statement  "			throw new SchedulerException (string.Format (CultureInfo.InvariantCulture' "Scheduler with name '{0}' already exists."' sched.SchedulerName)); " is 142.
Long Statement,Quartz.Impl,StdScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdScheduler.cs,GetMetaData,The length of the statement  "	return new SchedulerMetaData (SchedulerName' SchedulerInstanceId' GetType ()' false' IsStarted' InStandbyMode' IsShutdown' sched.RunningSince' sched.NumJobsExecuted' sched.JobStoreClass' sched.SupportsPersistence' sched.Clustered' sched.ThreadPoolClass' sched.ThreadPoolSize' sched.Version); " is 291.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Initialize,The length of the statement  "		throw new SchedulerConfigException (@"Could not find <quartz> configuration section from your application config or load default configuration from assembly." is 157.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,ValidateConfiguration,The length of the statement  "	List<FieldInfo> fields = new List<FieldInfo> (GetType ().GetFields (BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy)); " is 144.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "	string threadName = cfg.GetStringProperty (PropertySchedulerThreadName' "{0}_QuartzSchedulerThread".FormatInvariant (schedName)); " is 129.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		instanceIdGeneratorType = LoadType (cfg.GetStringProperty (PropertySchedulerInstanceIdGeneratorType)) ?? typeof(SimpleInstanceIdGenerator); " is 139.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "	bool interruptJobsOnShutdownWithWait = cfg.GetBooleanProperty (PropertySchedulerInterruptJobsOnShutdownWithWait' false); " is 120.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		Type proxyType = loadHelper.LoadType (cfg.GetStringProperty (PropertySchedulerProxyType)) ?? typeof(RemotingSchedulerProxyFactory); " is 131.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("Remotable proxy factory '{0}' could not be instantiated.".FormatInvariant (proxyType)' e); " is 131.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("JobFactory of type '{0}' props could not be configured.".FormatInvariant (jobFactoryType)' e); " is 135.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("InstanceIdGenerator of type '{0}' props could not be configured.".FormatInvariant (instanceIdGeneratorType)' e); " is 153.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		initException = new SchedulerException ("ThreadPool type '{0}' could not be instantiated.".FormatInvariant (tpType)' e); " is 120.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		initException = new SchedulerException ("ThreadPool type '{0}' props could not be configured.".FormatInvariant (tpType)' e); " is 124.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "				initException = new SchedulerException ("ConnectionProvider of type '{0}' could not be instantiated.".FormatInvariant (cpType)' e); " is 131.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "				initException = new SchedulerException ("ConnectionProvider type '{0}' props could not be configured.".FormatInvariant (cpType)' e); " is 132.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "					initException = new SchedulerException ("Named connection string '{0}' not found for DataSource: {1}".FormatInvariant (dsConnectionStringName' dataSourceName)); " is 160.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "				initException = new SchedulerException ("Connection string not specified for DataSource: {0}".FormatInvariant (dataSourceName)); " is 128.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "				initException = new SchedulerException ("Could not Initialize DataSource: {0}".FormatInvariant (dataSourceName)' exception); " is 124.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("Object serializer type '" + objectSerializerType + "' could not be instantiated."' e); " is 127.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		initException = new SchedulerException ("JobStore of type '{0}' could not be instantiated.".FormatInvariant (jsType)' e); " is 121.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		initException = new SchedulerException ("JobStore type '{0}' props could not be configured.".FormatInvariant (jsType)' e); " is 122.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "					initException = new SchedulerException ("JobStore LockHandler type '{0}' props could not be configured.".FormatInvariant (lockHandlerType)' e); " is 143.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "				initException = new SchedulerException ("JobStore LockHandler type '{0}' could not be instantiated.".FormatInvariant (lockHandlerType)' e); " is 139.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		NameValueCollection pp = cfg.GetPropertyGroup ("{0}.{1}".FormatInvariant (PropertyPluginPrefix' pluginNames [i])' true); " is 120.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("SchedulerPlugin type not specified for plugin '{0}'".FormatInvariant (pluginNames [i])); " is 129.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("SchedulerPlugin of type '{0}' could not be instantiated.".FormatInvariant (plugInType)' e); " is 132.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("JobStore SchedulerPlugin '{0}' props could not be configured.".FormatInvariant (plugInType)' e); " is 137.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		NameValueCollection lp = cfg.GetPropertyGroup ("{0}.{1}".FormatInvariant (PropertyJobListenerPrefix' jobListenerNames [i])' true); " is 130.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("JobListener type not specified for listener '{0}'".FormatInvariant (jobListenerNames [i])); " is 132.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("JobListener of type '{0}' could not be instantiated.".FormatInvariant (listenerType)' e); " is 130.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("JobListener '{0}' props could not be configured.".FormatInvariant (listenerType)' e); " is 126.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "		NameValueCollection lp = cfg.GetPropertyGroup ("{0}.{1}".FormatInvariant (PropertyTriggerListenerPrefix' triggerListenerNames [i])' true); " is 138.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("TriggerListener type not specified for listener '{0}'".FormatInvariant (triggerListenerNames [i])); " is 140.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("TriggerListener of type '{0}' could not be instantiated.".FormatInvariant (listenerType)' e); " is 134.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("TriggerListener '{0}' props could not be configured.".FormatInvariant (listenerType)' e); " is 130.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("Scheduler exporter of type '{0}' could not be instantiated.".FormatInvariant (exporterType)' e); " is 137.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("Scheduler exporter type '{0}' props could not be configured.".FormatInvariant (exporterType)' e); " is 138.
Long Statement,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The length of the statement  "			initException = new SchedulerException ("ThreadExecutor class '" + threadExecutorClass + "' could not be instantiated."' e); " is 124.
Long Statement,Quartz.Impl,JobDetailImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\JobDetailImpl.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "JobDetail '{0}':  jobType: '{1} persistJobDataAfterExecution: {2} concurrentExectionDisallowed: {3} isDurable: {4} requestsRecovers: {5}"' FullName' ((JobType == null) ? null : JobType.FullName)' PersistJobDataAfterExecution' ConcurrentExecutionDisallowed' Durable' RequestsRecovery); " is 337.
Long Statement,Quartz.Impl,JobDetailImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\JobDetailImpl.cs,GetJobBuilder,The length of the statement  "	JobBuilder b = JobBuilder.Create ().OfType (JobType).RequestRecovery (RequestsRecovery).StoreDurably (Durable).UsingJobData (JobDataMap).WithDescription (description).WithIdentity (Key); " is 186.
Long Statement,Quartz.Impl,JobExecutionContextImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\JobExecutionContextImpl.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "JobExecutionContext: trigger: '{0}' job: '{1}' fireTimeUtc: '{2:r}' scheduledFireTimeUtc: '{3:r}' previousFireTimeUtc: '{4:r}' nextFireTimeUtc: '{5:r}' recovering: {6} refireCount: {7}"' Trigger.Key' JobDetail.Key' FireTimeUtc' ScheduledFireTimeUtc' PreviousFireTimeUtc' NextFireTimeUtc' Recovering' RefireCount); " is 366.
Long Statement,Quartz.Job,DirectoryScanJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\DirectoryScanJob.cs,Execute,The length of the statement  "		throw new JobExecutionException ("Required parameter '" + DirectoryScanListenerName + "' not found in merged JobDataMap"); " is 122.
Long Statement,Quartz.Job,FileScanJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\FileScanJob.cs,Execute,The length of the statement  "		throw new JobExecutionException (string.Format (CultureInfo.InvariantCulture' "Required parameter '{0}' not found in JobDataMap"' FileName)); " is 141.
Long Statement,Quartz.Job,FileScanJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\FileScanJob.cs,Execute,The length of the statement  "		throw new JobExecutionException (string.Format (CultureInfo.InvariantCulture' "Required parameter '{0}' not found in JobDataMap"' FileScanListenerName)); " is 153.
Long Statement,Quartz.Job,FileScanJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\FileScanJob.cs,Execute,The length of the statement  "		throw new JobExecutionException (string.Format (CultureInfo.InvariantCulture' "FileScanListener named '{0}' not found in SchedulerContext"' listenerName)); " is 155.
Long Statement,Quartz.Job,SendMailJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\SendMailJob.cs,Execute,The length of the statement  "		throw new JobExecutionException (string.Format (CultureInfo.InvariantCulture' "Unable to send mail: {0}"' mailDesc)' ex' false); " is 128.
Long Statement,Quartz.Listener,JobChainingJobListener,C:\repos\xmj112288_Study\OpenSources\Quartz\Listener\JobChainingJobListener.cs,JobWasExecuted,The length of the statement  "	Log.Info (string.Format (CultureInfo.InvariantCulture' "Job '{0}' will now chain to Job '{1}'"' context.JobDetail.Key' sj)); " is 124.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,IsTimeIncluded,The length of the statement  "		if ((timeUtc > startOfDayInMillis && timeUtc < timeRangeStartingTimeInMillis) || (timeUtc > timeRangeEndingTimeInMillis && timeUtc < endOfDayInMillis)) { " is 153.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetNextIncludedTimeUtc,The length of the statement  "			if ((nextIncludedTime >= GetTimeRangeStartingTimeUtc (nextIncludedTime)) && (nextIncludedTime <= GetTimeRangeEndingTimeUtc (nextIncludedTime))) { " is 145.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetTimeRangeStartingTimeUtc,The length of the statement  "	DateTimeOffset rangeStartingTime = new DateTimeOffset (timeUtc.Year' timeUtc.Month' timeUtc.Day' rangeStartingHourOfDay' rangeStartingMinute' rangeStartingSecond' rangeStartingMillis' timeUtc.Offset); " is 200.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetTimeRangeEndingTimeUtc,The length of the statement  "	DateTimeOffset rangeEndingTime = new DateTimeOffset (timeUtc.Year' timeUtc.Month' timeUtc.Day' rangeEndingHourOfDay' rangeEndingMinute' rangeEndingSecond' rangeEndingMillis' timeUtc.Offset); " is 190.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Invalid time string '{0}'"' rangeStartingTimeString)); " is 129.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Invalid time string '{0}'"' rangeEndingTimeString)); " is 127.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "	SetTimeRange (rangeStartingHourOfDay' rangeStartingMinute' rangeStartingSecond' rangeStartingMillis' rangeEndingHourOfDay' rangeEndingMinute' rangeEndingSecond' rangeEndingMillis); " is 180.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "	startCal = new DateTimeOffset (startCal.Year' startCal.Month' startCal.Day' rangeStartingHourOfDay' rangeStartingMinute' rangeStartingSecond' rangeStartingMillis' TimeSpan.Zero); " is 178.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "	endCal = new DateTimeOffset (endCal.Year' endCal.Month' endCal.Day' rangeEndingHourOfDay' rangeEndingMinute' rangeEndingSecond' rangeEndingMillis' TimeSpan.Zero); " is 162.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "{0}{1}:{2}:{3}:{4}{5}{6}:{7}:{8}:{9}"' InvalidTimeRange' rangeStartingHourOfDay' rangeStartingMinute' rangeStartingSecond' rangeStartingMillis' Separator' rangeEndingHourOfDay' rangeEndingMinute' rangeEndingSecond' rangeEndingMillis)); " is 310.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The length of the statement  "	SetTimeRange (rangeStartingCalendarUtc.Hour' rangeStartingCalendarUtc.Minute' rangeStartingCalendarUtc.Second' rangeStartingCalendarUtc.Millisecond' rangeEndingCalendarUtc.Hour' rangeEndingCalendarUtc.Minute' rangeEndingCalendarUtc.Second' rangeEndingCalendarUtc.Millisecond); " is 276.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetHashCode,The length of the statement  "	return rangeStartingHourOfDay.GetHashCode () + rangeEndingHourOfDay.GetHashCode () + 2 * (rangeStartingMinute.GetHashCode () + rangeEndingMinute.GetHashCode ()) + 3 * (rangeStartingSecond.GetHashCode () + rangeEndingSecond.GetHashCode ()) + 4 * (rangeStartingMillis.GetHashCode () + rangeEndingMillis.GetHashCode ()) + 5 * baseHash; " is 332.
Long Statement,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,Equals,The length of the statement  "	return baseEqual && (InvertTimeRange == obj.InvertTimeRange) && (rangeStartingHourOfDay == obj.rangeStartingHourOfDay) && (rangeStartingMinute == obj.rangeStartingMinute) && (rangeStartingSecond == obj.rangeStartingSecond) && (rangeStartingMillis == obj.rangeStartingMillis) && (rangeEndingHourOfDay == obj.rangeEndingHourOfDay) && (rangeEndingMinute == obj.rangeEndingMinute) && (rangeEndingSecond == obj.rangeEndingSecond) && (rangeEndingMillis == obj.rangeEndingMillis); " is 473.
Long Statement,Quartz.Impl.Calendar,MonthlyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\MonthlyCalendar.cs,IsDayExcluded,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "The day parameter must be in the range of 1 to {0}"' MaxDaysInMonth)); " is 145.
Long Statement,Quartz.Simpl,SystemPropertyInstanceIdGenerator,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SystemPropertyInstanceIdGenerator.cs,GenerateInstanceId,The length of the statement  "		throw new SchedulerException ("No value for '" + SystemProperty + "' system property found' please configure your environment accordingly!"); " is 141.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "				HandleError (string.Format (CultureInfo.InvariantCulture' "No property on Job class {0} for property '{1}'"' obj.GetType ()' name)); " is 132.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "				HandleError (string.Format (CultureInfo.InvariantCulture' "Cannot set null to property on Job class {0} for property '{1}'"' obj.GetType ()' name)); " is 148.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "				HandleError (string.Format (CultureInfo.InvariantCulture' "Cannot set empty string to char property on Job class {0} for property '{1}'"' obj.GetType ()' name)); " is 161.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			object goodValue = paramType == typeof(TimeSpan) ? ObjectUtils.GetTimeSpanValueForProperty (prop' o) : ConvertValueIfNecessary (paramType' o); " is 142.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			HandleError (string.Format (CultureInfo.InvariantCulture' "The setter on Job class {0} for property '{1}' expects a {2} but was given {3}"' obj.GetType ()' name' paramType' o)' nfe); " is 182.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			HandleError (string.Format (CultureInfo.InvariantCulture' "The setter on Job class {0} for property '{1}' expects a {2} but was given a {3}"' obj.GetType ()' name' paramType' o.GetType ())); " is 190.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			HandleError (string.Format (CultureInfo.InvariantCulture' "The setter on Job class {0} for property '{1}' expects a {2} but was given {3}"' obj.GetType ()' name' paramType' o.GetType ())' e); " is 191.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			HandleError (string.Format (CultureInfo.InvariantCulture' "The setter on Job class {0} for property '{1}' could not be accessed."' obj.GetType ()' name)' e); " is 157.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			HandleError (string.Format (CultureInfo.InvariantCulture' "The setter on Job class {0} for property '{1}' could not be accessed."' obj.GetType ()' name)' e); " is 157.
Long Statement,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The length of the statement  "			HandleError (string.Format (CultureInfo.InvariantCulture' "The setter on Job class {0} for property '{1}' threw exception when processing."' obj.GetType ()' name)' e); " is 167.
Long Statement,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreCalendar,The length of the statement  "			throw new ObjectAlreadyExistsException (string.Format (CultureInfo.InvariantCulture' "Calendar with name '{0}' already exists."' name)); " is 136.
Long Statement,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,ApplyMisfire,The length of the statement  "	if (!tnft.HasValue || tnft.Value > misfireTime || tw.trigger.MisfireInstruction == MisfireInstruction.IgnoreMisfirePolicy) { " is 124.
Long Statement,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,AcquireNextTriggers,The length of the statement  "			if (firstAcquiredTriggerFireTime != null && tw.trigger.GetNextFireTimeUtc () > (firstAcquiredTriggerFireTime.Value + timeWindow)) { " is 131.
Long Statement,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,AcquireNextTriggers,The length of the statement  "		// If we did excluded triggers to prevent ACQUIRE state due to DisallowConcurrentExecution' we need to add them back to store. " is 126.
Long Statement,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,TriggersFired,The length of the statement  "			TriggerFiredBundle bndle = new TriggerFiredBundle (RetrieveJob (trigger.JobKey)' trigger' cal' false' SystemTime.UtcNow ()' trigger.GetPreviousFireTimeUtc ()' prevFireTime' trigger.GetNextFireTimeUtc ()); " is 204.
Long Statement,Quartz.Simpl,SimpleJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleJobFactory.cs,NewJob,The length of the statement  "			log.Debug (string.Format (CultureInfo.InvariantCulture' "Producing instance of Job '{0}'' class={1}"' jobDetail.Key' jobType.FullName)); " is 136.
Long Statement,Quartz.Simpl,SimpleJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleJobFactory.cs,NewJob,The length of the statement  "		SchedulerException se = new SchedulerException (string.Format (CultureInfo.InvariantCulture' "Problem instantiating class '{0}'"' jobDetail.JobType.FullName)' e); " is 162.
Long Statement,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,CreateWorkerThreads,The length of the statement  "		WorkerThread wt = new WorkerThread (this' string.Format (CultureInfo.InvariantCulture' "{0}-{1}"' ThreadNamePrefix' i)' ThreadPriority' MakeThreadsDaemons); " is 156.
Long Statement,Quartz.Simpl,RemotingSchedulerExporter,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RemotingSchedulerExporter.cs,Bind,The length of the statement  "		Log.Info (string.Format (CultureInfo.InvariantCulture' "Successfully marhalled remotable scheduler under name '{0}'"' bindName)); " is 129.
Long Statement,Quartz.Simpl,RemotingSchedulerExporter,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RemotingSchedulerExporter.cs,RegisterRemotingChannelIfNeeded,The length of the statement  "		Log.Info (string.Format (CultureInfo.InvariantCulture' "Registering remoting channel of type '{0}' to port ({1}) with name ({2})"' chan.GetType ()' port' chan.ChannelName)); " is 173.
Long Statement,Quartz.Util,ObjectUtils,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\ObjectUtils.cs,SetObjectProperties,The length of the statement  "			throw new SchedulerConfigException (string.Format (CultureInfo.InvariantCulture' "Could not parse property '{0}' into correct data type: {1}"' name' nfe.Message)' nfe); " is 168.
Long Statement,Quartz.Util,ObjectUtils,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\ObjectUtils.cs,SetObjectProperties,The length of the statement  "			throw new SchedulerConfigException (string.Format (CultureInfo.InvariantCulture' "Could not parse property '{0}' into correct data type: {1}"' name' nfe.Message)' nfe); " is 168.
Long Statement,Quartz.Util,ObjectUtils,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\ObjectUtils.cs,SetPropertyValue,The length of the statement  "		throw new MemberAccessException (string.Format (CultureInfo.InvariantCulture' "No writable property '{0}' found"' propertyName)); " is 129.
Long Statement,Quartz.Util,ObjectUtils,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\ObjectUtils.cs,SetPropertyValue,The length of the statement  "		throw new MemberAccessException (string.Format (CultureInfo.InvariantCulture' "Property '{0}' has no setter"' propertyName)); " is 125.
Long Statement,Quartz.Util,QuartzEnvironment,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\QuartzEnvironment.cs,GetEnvironmentVariable,The length of the statement  "		log.WarnFormat ("Unable to read environment variable '{0}' due to security exception' probably running under medium trust"' key); " is 129.
Long Statement,Quartz.Impl.AdoJobStore.Common,DbMetadata,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\Common\DbMetadata.cs,Init,The length of the statement  "			throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Couldn't parse parameter db type for database type '{0}'"' ProductName)); " is 148.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "		log.Debug ("Directive 'schedule-trigger-relative-to-replaced-trigger' not specified' defaulting to " + ScheduleTriggerRelativeToReplacedTrigger); " is 145.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "		IJobDetail jobDetail = JobBuilder.Create (jobType).WithIdentity (jobName' jobGroup).WithDescription (jobDescription).StoreDurably (jobDurability).RequestRecovery (jobRecoveryRequested).Build (); " is 194.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "			TimeSpan repeatInterval = repeatIntervalString == null ? TimeSpan.Zero : TimeSpan.FromMilliseconds (Convert.ToInt64 (repeatIntervalString)); " is 140.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "				((SimpleScheduleBuilder)sched).WithMisfireHandlingInstruction (ReadMisfireInstructionFromString (simpleTrigger.misfireinstruction)); " is 132.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "				((CronScheduleBuilder)sched).WithMisfireHandlingInstruction (ReadMisfireInstructionFromString (cronTrigger.misfireinstruction)); " is 128.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "			IntervalUnit intervalUnit = ParseDateIntervalTriggerIntervalUnit (calendarIntervalTrigger.repeatintervalunit.TrimEmptyToNull ()); " is 129.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "				((CalendarIntervalScheduleBuilder)sched).WithMisfireHandlingInstruction (ReadMisfireInstructionFromString (calendarIntervalTrigger.misfireinstruction)); " is 152.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ProcessInternal,The length of the statement  "		IMutableTrigger trigger = (IMutableTrigger)TriggerBuilder.Create ().WithIdentity (triggerName' triggerGroup).WithDescription (triggerDescription).ForJob (triggerJobName' triggerJobGroup).StartAt (triggerStartTime).EndAt (triggerEndTime).WithPriority (triggerPriority).ModifiedByCalendar (triggerCalendarRef).WithSchedule (sched).Build (); " is 338.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ReadMisfireInstructionFromString,The length of the statement  "	Constants c = new Constants (typeof(MisfireInstruction)' typeof(MisfireInstruction.CronTrigger)' typeof(MisfireInstruction.SimpleTrigger)); " is 139.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ScheduleJobs,The length of the statement  "							log.DebugFormat ("Adding trigger: {0} for job: {1} failed because the trigger already existed.  " + "This is likely due to a race condition between multiple instances " + "in the cluster.  Will try to reschedule instead."' trigger.Key' detail.Key); " is 248.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,ScheduleJobs,The length of the statement  "					log.Debug ("Adding trigger: " + trigger.Key + " for job: " + trigger.JobKey + " failed because the trigger already existed.  " + "This is likely due to a race condition between multiple instances " + "in the cluster.  Will try to reschedule instead."); " is 252.
Long Statement,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,DoRescheduleJob,The length of the statement  "	if (oldTrigger != null && trigger.StartTimeUtc - SystemTime.UtcNow () < TimeSpan.FromSeconds (5) && ScheduleTriggerRelativeToReplacedTrigger) { " is 143.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,BuildExpression,The conditional expression  "exprOn == DayOfMonth && expr.IndexOf ('L') != -1 && expr.Length > 1 && expr.IndexOf ("'") >= 0"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,BuildExpression,The conditional expression  "exprOn == DayOfWeek && expr.IndexOf ('L') != -1 && expr.Length > 1 && expr.IndexOf ("'") >= 0"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The conditional expression  "(c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The conditional expression  "c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The conditional expression  "(val < 0 || val > 59 || end > 59) && (val != AllSpecInt)"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The conditional expression  "(val < 0 || val > 23 || end > 23) && (val != AllSpecInt)"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The conditional expression  "(val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The conditional expression  "(val < 1 || val > 12 || end > 12) && (val != AllSpecInt)"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The conditional expression  "(val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)"  is complex.
Complex Conditional,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The conditional expression  "i2 == 0 && (type == Month || type == DayOfWeek || type == DayOfMonth)"  is complex.
Complex Conditional,Quartz.Impl.AdoJobStore,DBSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DBSemaphore.cs,SetExpandedSql,The conditional expression  "TablePrefix != null && SchedName != null && sql != null && insertSql != null"  is complex.
Complex Conditional,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The conditional expression  "(resources.InterruptJobsOnShutdown && !waitForJobsToComplete) || (resources.InterruptJobsOnShutdownWithWait && waitForJobsToComplete)"  is complex.
Complex Conditional,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,IsTimeIncluded,The conditional expression  "(timeUtc > startOfDayInMillis && timeUtc < timeRangeStartingTimeInMillis) || (timeUtc > timeRangeEndingTimeInMillis && timeUtc < endOfDayInMillis)"  is complex.
Complex Conditional,Quartz.Simpl,PropertySettingJobFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\PropertySettingJobFactory.cs,SetObjectProperties,The conditional expression  "paramType == typeof(char) && o != null && o is string && ((string)o).Length != 1"  is complex.
Virtual Method Call from Constructor,Quartz.Impl.AdoJobStore.Common,DbProvider,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\Common\DbProvider.cs,DbProvider,The constructor "DbProvider" calls a virtual method "GetPropertyGroups".
Virtual Method Call from Constructor,Quartz.Impl.AdoJobStore.Common,DbProvider,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\Common\DbProvider.cs,DbProvider,The constructor "DbProvider" calls a virtual method "GetDbMetadata".
Empty Catch Block,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,CompleteTriggerRetryLoop,The method has an empty catch block.
Empty Catch Block,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,VetoedJobRetryLoop,The method has an empty catch block.
Empty Catch Block,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The method has an empty catch block.
Empty Catch Block,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The method has an empty catch block.
Empty Catch Block,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The method has an empty catch block.
Empty Catch Block,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The method has an empty catch block.
Empty Catch Block,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,RunInThread,The method has an empty catch block.
Empty Catch Block,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,BlockForAvailableThreads,The method has an empty catch block.
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,Build,The following statement contains a magic number: if (endTimeOfDayUtc != null) {  	st.EndTimeOfDay = endTimeOfDayUtc;  }  else {  	st.EndTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,Build,The following statement contains a magic number: if (endTimeOfDayUtc != null) {  	st.EndTimeOfDay = endTimeOfDayUtc;  }  else {  	st.EndTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,Build,The following statement contains a magic number: if (endTimeOfDayUtc != null) {  	st.EndTimeOfDay = endTimeOfDayUtc;  }  else {  	st.EndTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,Build,The following statement contains a magic number: st.EndTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,Build,The following statement contains a magic number: st.EndTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,Build,The following statement contains a magic number: st.EndTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Second) {  	intervalInMillis = TimeSpan.FromSeconds (interval);  }  else if (intervalUnit == IntervalUnit.Minute) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60);  }  else if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Second) {  	intervalInMillis = TimeSpan.FromSeconds (interval);  }  else if (intervalUnit == IntervalUnit.Minute) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60);  }  else if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Second) {  	intervalInMillis = TimeSpan.FromSeconds (interval);  }  else if (intervalUnit == IntervalUnit.Minute) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60);  }  else if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Minute) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60);  }  else if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Minute) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60);  }  else if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Minute) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60);  }  else if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: intervalInMillis = TimeSpan.FromSeconds (interval * 60);  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: if (intervalUnit == IntervalUnit.Hour) {  	intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  }  else {  	throw new ArgumentException ("The IntervalUnit: " + intervalUnit + " is invalid for this trigger.");  }  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  
Magic Number,Quartz,DailyTimeIntervalScheduleBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DailyTimeIntervalScheduleBuilder.cs,EndingDailyAfterCount,The following statement contains a magic number: intervalInMillis = TimeSpan.FromSeconds (interval * 60 * 24);  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,TranslatedAdd,The following statement contains a magic number: switch (unit) {  case IntervalUnit.Day:  	return date.AddDays (amountToAdd);  case IntervalUnit.Hour:  	return date.AddHours (amountToAdd);  case IntervalUnit.Minute:  	return date.AddMinutes (amountToAdd);  case IntervalUnit.Month:  	return date.AddMonths (amountToAdd);  case IntervalUnit.Second:  	return date.AddSeconds (amountToAdd);  case IntervalUnit.Millisecond:  	return date.AddMilliseconds (amountToAdd);  case IntervalUnit.Week:  	return date.AddDays (amountToAdd * 7);  case IntervalUnit.Year:  	return date.AddYears (amountToAdd);  default:  	throw new ArgumentException ("Unknown IntervalUnit");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,TranslatedAdd,The following statement contains a magic number: return date.AddDays (amountToAdd * 7);  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,NextGivenMinuteDate,The following statement contains a magic number: if (minuteBase < 0 || minuteBase > 59) {  	throw new ArgumentException ("minuteBase must be >=0 and <= 59");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,NextGivenMinuteDate,The following statement contains a magic number: if (nextMinuteOccurance < 60) {  	return new DateTimeOffset (c.Year' c.Month' c.Day' c.Hour' nextMinuteOccurance' 0' 0' c.Offset);  }  else {  	return new DateTimeOffset (c.Year' c.Month' c.Day' c.Hour' 0' 0' 0' c.Offset).AddHours (1);  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,NextGivenSecondDate,The following statement contains a magic number: if (secondBase < 0 || secondBase > 59) {  	throw new ArgumentException ("secondBase must be >=0 and <= 59");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,NextGivenSecondDate,The following statement contains a magic number: if (nextSecondOccurance < 60) {  	return new DateTimeOffset (c.Year' c.Month' c.Day' c.Hour' c.Minute' nextSecondOccurance' 0' c.Offset);  }  else {  	return new DateTimeOffset (c.Year' c.Month' c.Day' c.Hour' c.Minute' 0' 0' c.Offset).AddMinutes (1);  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateHour,The following statement contains a magic number: if (hour < 0 || hour > 23) {  	throw new ArgumentException ("Invalid hour (must be >= 0 and <= 23).");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateMinute,The following statement contains a magic number: if (minute < 0 || minute > 59) {  	throw new ArgumentException ("Invalid minute (must be >= 0 and <= 59).");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateSecond,The following statement contains a magic number: if (second < 0 || second > 59) {  	throw new ArgumentException ("Invalid second (must be >= 0 and <= 59).");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateDayOfMonth,The following statement contains a magic number: if (day < 1 || day > 31) {  	throw new ArgumentException ("Invalid day of month.");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateMonth,The following statement contains a magic number: if (month < 1 || month > 12) {  	throw new ArgumentException ("Invalid month (must be >= 1 and <= 12.");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateYear,The following statement contains a magic number: if (year < 1970 || year > 2099) {  	throw new ArgumentException ("Invalid year (must be >= 1970 and <= 2099.");  }  
Magic Number,Quartz,DateBuilder,C:\repos\xmj112288_Study\OpenSources\Quartz\DateBuilder.cs,ValidateYear,The following statement contains a magic number: if (year < 1970 || year > 2099) {  	throw new ArgumentException ("Invalid year (must be >= 1970 and <= 2099.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("MAR"' 2);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("APR"' 3);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("MAY"' 4);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("JUN"' 5);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("JUL"' 6);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("AUG"' 7);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("SEP"' 8);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("OCT"' 9);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("NOV"' 10);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: monthMap.Add ("DEC"' 11);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: dayMap.Add ("MON"' 2);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: dayMap.Add ("TUE"' 3);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: dayMap.Add ("WED"' 4);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: dayMap.Add ("THU"' 5);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: dayMap.Add ("FRI"' 6);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CronExpression,The following statement contains a magic number: dayMap.Add ("SAT"' 7);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetNextInvalidTimeAfter,The following statement contains a magic number: while (difference == 1000) {  	DateTimeOffset? newDate = GetTimeAfter (lastDate);  	if (newDate == null) {  		break;  	}  	difference = (long)(newDate.Value - lastDate).TotalMilliseconds;  	if (difference == 1000) {  		lastDate = newDate.Value;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetNextInvalidTimeAfter,The following statement contains a magic number: while (difference == 1000) {  	DateTimeOffset? newDate = GetTimeAfter (lastDate);  	if (newDate == null) {  		break;  	}  	difference = (long)(newDate.Value - lastDate).TotalMilliseconds;  	if (difference == 1000) {  		lastDate = newDate.Value;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetNextInvalidTimeAfter,The following statement contains a magic number: if (difference == 1000) {  	lastDate = newDate.Value;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if ((c >= 'A') && (c <= 'Z') && (!s.Equals ("L")) && (!s.Equals ("LW")) && (!Regex.IsMatch (s' "^L-[0-9]*[W]?"))) {  	string sub = s.Substring (i' 3);  	int sval;  	int eval = -1;  	if (type == Month) {  		sval = GetMonthNumber (sub) + 1;  		if (sval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetMonthNumber (sub) + 1;  				if (eval <= 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  				}  			}  		}  	}  	else if (type == DayOfWeek) {  		sval = GetDayOfWeekNumber (sub);  		if (sval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  		if (s.Length > i + 3) {  			c = s [i + 3];  			if (c == '-') {  				i += 4;  				sub = s.Substring (i' 3);  				eval = GetDayOfWeekNumber (sub);  				if (eval < 0) {  					throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  				}  			}  			else if (c == '#') {  				try {  					i += 4;  					nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  					if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  						throw new Exception ();  					}  				}  				catch (Exception) {  					throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  				}  			}  			else if (c == 'L') {  				lastdayOfWeek = true;  				i++;  			}  		}  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  	}  	if (eval != -1) {  		incr = 1;  	}  	AddToSet (sval' eval' incr' type);  	return (i + 3);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == Month) {  	sval = GetMonthNumber (sub) + 1;  	if (sval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetMonthNumber (sub) + 1;  			if (eval <= 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  			}  		}  	}  }  else if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetMonthNumber (sub) + 1;  		if (eval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetMonthNumber (sub) + 1;  		if (eval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetMonthNumber (sub) + 1;  		if (eval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetMonthNumber (sub) + 1;  		if (eval <= 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  		}  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: c = s [i + 3];  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	i += 4;  	sub = s.Substring (i' 3);  	eval = GetMonthNumber (sub) + 1;  	if (eval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	i += 4;  	sub = s.Substring (i' 3);  	eval = GetMonthNumber (sub) + 1;  	if (eval <= 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Month value: '{0}'"' sub));  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: i += 4;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: sub = s.Substring (i' 3);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	sval = GetDayOfWeekNumber (sub);  	if (sval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  	if (s.Length > i + 3) {  		c = s [i + 3];  		if (c == '-') {  			i += 4;  			sub = s.Substring (i' 3);  			eval = GetDayOfWeekNumber (sub);  			if (eval < 0) {  				throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  			}  		}  		else if (c == '#') {  			try {  				i += 4;  				nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  				if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  					throw new Exception ();  				}  			}  			catch (Exception) {  				throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  			}  		}  		else if (c == 'L') {  			lastdayOfWeek = true;  			i++;  		}  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Illegal characters for this position: '{0}'"' sub));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetDayOfWeekNumber (sub);  		if (eval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  	}  	else if (c == '#') {  		try {  			i += 4;  			nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  			if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  				throw new Exception ();  			}  		}  		catch (Exception) {  			throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  		}  	}  	else if (c == 'L') {  		lastdayOfWeek = true;  		i++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetDayOfWeekNumber (sub);  		if (eval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  	}  	else if (c == '#') {  		try {  			i += 4;  			nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  			if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  				throw new Exception ();  			}  		}  		catch (Exception) {  			throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  		}  	}  	else if (c == 'L') {  		lastdayOfWeek = true;  		i++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetDayOfWeekNumber (sub);  		if (eval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  	}  	else if (c == '#') {  		try {  			i += 4;  			nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  			if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  				throw new Exception ();  			}  		}  		catch (Exception) {  			throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  		}  	}  	else if (c == 'L') {  		lastdayOfWeek = true;  		i++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetDayOfWeekNumber (sub);  		if (eval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  	}  	else if (c == '#') {  		try {  			i += 4;  			nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  			if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  				throw new Exception ();  			}  		}  		catch (Exception) {  			throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  		}  	}  	else if (c == 'L') {  		lastdayOfWeek = true;  		i++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetDayOfWeekNumber (sub);  		if (eval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  	}  	else if (c == '#') {  		try {  			i += 4;  			nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  			if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  				throw new Exception ();  			}  		}  		catch (Exception) {  			throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  		}  	}  	else if (c == 'L') {  		lastdayOfWeek = true;  		i++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (s.Length > i + 3) {  	c = s [i + 3];  	if (c == '-') {  		i += 4;  		sub = s.Substring (i' 3);  		eval = GetDayOfWeekNumber (sub);  		if (eval < 0) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  		}  	}  	else if (c == '#') {  		try {  			i += 4;  			nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  			if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  				throw new Exception ();  			}  		}  		catch (Exception) {  			throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  		}  	}  	else if (c == 'L') {  		lastdayOfWeek = true;  		i++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: c = s [i + 3];  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	i += 4;  	sub = s.Substring (i' 3);  	eval = GetDayOfWeekNumber (sub);  	if (eval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  }  else if (c == '#') {  	try {  		i += 4;  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  }  else if (c == 'L') {  	lastdayOfWeek = true;  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	i += 4;  	sub = s.Substring (i' 3);  	eval = GetDayOfWeekNumber (sub);  	if (eval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  }  else if (c == '#') {  	try {  		i += 4;  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  }  else if (c == 'L') {  	lastdayOfWeek = true;  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	i += 4;  	sub = s.Substring (i' 3);  	eval = GetDayOfWeekNumber (sub);  	if (eval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  }  else if (c == '#') {  	try {  		i += 4;  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  }  else if (c == 'L') {  	lastdayOfWeek = true;  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	i += 4;  	sub = s.Substring (i' 3);  	eval = GetDayOfWeekNumber (sub);  	if (eval < 0) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Invalid Day-of-Week value: '{0}'"' sub));  	}  }  else if (c == '#') {  	try {  		i += 4;  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  }  else if (c == 'L') {  	lastdayOfWeek = true;  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: i += 4;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: sub = s.Substring (i' 3);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '#') {  	try {  		i += 4;  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  }  else if (c == 'L') {  	lastdayOfWeek = true;  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '#') {  	try {  		i += 4;  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  }  else if (c == 'L') {  	lastdayOfWeek = true;  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: try {  	i += 4;  	nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  	if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  		throw new Exception ();  	}  }  catch (Exception) {  	throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: try {  	i += 4;  	nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  	if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  		throw new Exception ();  	}  }  catch (Exception) {  	throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: i += 4;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  	throw new Exception ();  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: return (i + 3);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '*' || c == '/') {  	if (c == '*' && (i + 1) >= s.Length) {  		AddToSet (AllSpecInt' -1' incr' type);  		return i + 1;  	}  	else if (c == '/' && ((i + 1) >= s.Length || s [i + 1] == ' ' || s [i + 1] == '\t')) {  		throw new FormatException ("'/' must be followed by an integer.");  	}  	else if (c == '*') {  		i++;  	}  	c = s [i];  	if (c == '/') {  		// is an increment specified?  		i++;  		if (i >= s.Length) {  			throw new FormatException ("Unexpected end of string.");  		}  		incr = GetNumericValue (s' i);  		i++;  		if (incr > 10) {  			i++;  		}  		if (incr > 59 && (type == Second || type == Minute)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  		}  		else if (incr > 23 && (type == Hour)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  		}  		else if (incr > 31 && (type == DayOfMonth)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  		}  		else if (incr > 7 && (type == DayOfWeek)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  		}  		else if (incr > 12 && (type == Month)) {  			throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  		}  	}  	else {  		incr = 1;  	}  	AddToSet (AllSpecInt' -1' incr' type);  	return i;  }  else if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '/') {  	// is an increment specified?  	i++;  	if (i >= s.Length) {  		throw new FormatException ("Unexpected end of string.");  	}  	incr = GetNumericValue (s' i);  	i++;  	if (incr > 10) {  		i++;  	}  	if (incr > 59 && (type == Second || type == Minute)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  	}  	else if (incr > 23 && (type == Hour)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  	}  	else if (incr > 31 && (type == DayOfMonth)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  	}  	else if (incr > 7 && (type == DayOfWeek)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  	}  	else if (incr > 12 && (type == Month)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  	}  }  else {  	incr = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '/') {  	// is an increment specified?  	i++;  	if (i >= s.Length) {  		throw new FormatException ("Unexpected end of string.");  	}  	incr = GetNumericValue (s' i);  	i++;  	if (incr > 10) {  		i++;  	}  	if (incr > 59 && (type == Second || type == Minute)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  	}  	else if (incr > 23 && (type == Hour)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  	}  	else if (incr > 31 && (type == DayOfMonth)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  	}  	else if (incr > 7 && (type == DayOfWeek)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  	}  	else if (incr > 12 && (type == Month)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  	}  }  else {  	incr = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '/') {  	// is an increment specified?  	i++;  	if (i >= s.Length) {  		throw new FormatException ("Unexpected end of string.");  	}  	incr = GetNumericValue (s' i);  	i++;  	if (incr > 10) {  		i++;  	}  	if (incr > 59 && (type == Second || type == Minute)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  	}  	else if (incr > 23 && (type == Hour)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  	}  	else if (incr > 31 && (type == DayOfMonth)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  	}  	else if (incr > 7 && (type == DayOfWeek)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  	}  	else if (incr > 12 && (type == Month)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  	}  }  else {  	incr = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '/') {  	// is an increment specified?  	i++;  	if (i >= s.Length) {  		throw new FormatException ("Unexpected end of string.");  	}  	incr = GetNumericValue (s' i);  	i++;  	if (incr > 10) {  		i++;  	}  	if (incr > 59 && (type == Second || type == Minute)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  	}  	else if (incr > 23 && (type == Hour)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  	}  	else if (incr > 31 && (type == DayOfMonth)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  	}  	else if (incr > 7 && (type == DayOfWeek)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  	}  	else if (incr > 12 && (type == Month)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  	}  }  else {  	incr = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '/') {  	// is an increment specified?  	i++;  	if (i >= s.Length) {  		throw new FormatException ("Unexpected end of string.");  	}  	incr = GetNumericValue (s' i);  	i++;  	if (incr > 10) {  		i++;  	}  	if (incr > 59 && (type == Second || type == Minute)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  	}  	else if (incr > 23 && (type == Hour)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  	}  	else if (incr > 31 && (type == DayOfMonth)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  	}  	else if (incr > 7 && (type == DayOfWeek)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  	}  	else if (incr > 12 && (type == Month)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  	}  }  else {  	incr = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '/') {  	// is an increment specified?  	i++;  	if (i >= s.Length) {  		throw new FormatException ("Unexpected end of string.");  	}  	incr = GetNumericValue (s' i);  	i++;  	if (incr > 10) {  		i++;  	}  	if (incr > 59 && (type == Second || type == Minute)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  	}  	else if (incr > 23 && (type == Hour)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  	}  	else if (incr > 31 && (type == DayOfMonth)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  	}  	else if (incr > 7 && (type == DayOfWeek)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  	}  	else if (incr > 12 && (type == Month)) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  	}  }  else {  	incr = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 10) {  	i++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 59 && (type == Second || type == Minute)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  }  else if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 59 && (type == Second || type == Minute)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  }  else if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 59 && (type == Second || type == Minute)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  }  else if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 59 && (type == Second || type == Minute)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  }  else if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 59 && (type == Second || type == Minute)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 60 : {0}"' incr));  }  else if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 23 && (type == Hour)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 24 : {0}"' incr));  }  else if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 31 && (type == DayOfMonth)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 31 : {0}"' incr));  }  else if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 7 && (type == DayOfWeek)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 7 : {0}"' incr));  }  else if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (incr > 12 && (type == Month)) {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Increment > 12 : {0}"' incr));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == 'L') {  	i++;  	if (type == DayOfMonth) {  		lastdayOfMonth = true;  	}  	if (type == DayOfWeek) {  		AddToSet (7' 7' 0' type);  	}  	if (type == DayOfMonth && s.Length > i) {  		c = s [i];  		if (c == '-') {  			ValueSet vs = GetValue (0' s' i + 1);  			lastdayOffset = vs.theValue;  			if (lastdayOffset > 30) {  				throw new FormatException ("Offset from last day must be <= 30");  			}  			i = vs.pos;  		}  		if (s.Length > i) {  			c = s [i];  			if (c == 'W') {  				nearestWeekday = true;  				i++;  			}  		}  	}  	return i;  }  else if (c >= '0' && c <= '9') {  	int val = Convert.ToInt32 (c.ToString (CultureInfo.InvariantCulture)' CultureInfo.InvariantCulture);  	i++;  	if (i >= s.Length) {  		AddToSet (val' -1' -1' type);  	}  	else {  		c = s [i];  		if (c >= '0' && c <= '9') {  			ValueSet vs = GetValue (val' s' i);  			val = vs.theValue;  			i = vs.pos;  		}  		i = CheckNext (i' s' val' type);  		return i;  	}  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "Unexpected character: {0}"' c));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	AddToSet (7' 7' 0' type);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfWeek) {  	AddToSet (7' 7' 0' type);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: AddToSet (7' 7' 0' type);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: AddToSet (7' 7' 0' type);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (type == DayOfMonth && s.Length > i) {  	c = s [i];  	if (c == '-') {  		ValueSet vs = GetValue (0' s' i + 1);  		lastdayOffset = vs.theValue;  		if (lastdayOffset > 30) {  			throw new FormatException ("Offset from last day must be <= 30");  		}  		i = vs.pos;  	}  	if (s.Length > i) {  		c = s [i];  		if (c == 'W') {  			nearestWeekday = true;  			i++;  		}  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (c == '-') {  	ValueSet vs = GetValue (0' s' i + 1);  	lastdayOffset = vs.theValue;  	if (lastdayOffset > 30) {  		throw new FormatException ("Offset from last day must be <= 30");  	}  	i = vs.pos;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,StoreExpressionVals,The following statement contains a magic number: if (lastdayOffset > 30) {  	throw new FormatException ("Offset from last day must be <= 30");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (c == 'L') {  	if (type == DayOfWeek) {  		if (val < 1 || val > 7) {  			throw new FormatException ("Day-of-Week values must be between 1 and 7");  		}  		lastdayOfWeek = true;  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "'L' option is not valid here. (pos={0})"' i));  	}  	ISortedSet<int> data = GetSet (type);  	data.Add (val);  	i++;  	return i;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (type == DayOfWeek) {  	if (val < 1 || val > 7) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  	lastdayOfWeek = true;  }  else {  	throw new FormatException (string.Format (CultureInfo.InvariantCulture' "'L' option is not valid here. (pos={0})"' i));  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (val < 1 || val > 7) {  	throw new FormatException ("Day-of-Week values must be between 1 and 7");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (c == 'W') {  	if (type == DayOfMonth) {  		nearestWeekday = true;  	}  	else {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "'W' option is not valid here. (pos={0})"' i));  	}  	if (val > 31) {  		throw new FormatException ("The 'W' option does not make sense with values larger than 31 (max number of days in a month)");  	}  	ISortedSet<int> data = GetSet (type);  	data.Add (val);  	i++;  	return i;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (val > 31) {  	throw new FormatException ("The 'W' option does not make sense with values larger than 31 (max number of days in a month)");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (c == '#') {  	if (type != DayOfWeek) {  		throw new FormatException (string.Format (CultureInfo.InvariantCulture' "'#' option is not valid here. (pos={0})"' i));  	}  	i++;  	try {  		nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  		if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  			throw new Exception ();  		}  	}  	catch (Exception) {  		throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  	}  	ISortedSet<int> data = GetSet (type);  	data.Add (val);  	i++;  	return i;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: try {  	nthdayOfWeek = Convert.ToInt32 (s.Substring (i)' CultureInfo.InvariantCulture);  	if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  		throw new Exception ();  	}  }  catch (Exception) {  	throw new FormatException ("A numeric value between 1 and 5 must follow the '#' option");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,CheckNext,The following statement contains a magic number: if (nthdayOfWeek < 1 || nthdayOfWeek > 5) {  	throw new Exception ();  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  		throw new FormatException ("Minute and Second values must be between 0 and 59");  	}  }  else if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  	throw new FormatException ("Minute and Second values must be between 0 and 59");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 0 || val > 59 || end > 59) && (val != AllSpecInt)) {  	throw new FormatException ("Minute and Second values must be between 0 and 59");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  		throw new FormatException ("Hour values must be between 0 and 23");  	}  }  else if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  	throw new FormatException ("Hour values must be between 0 and 23");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 0 || val > 23 || end > 23) && (val != AllSpecInt)) {  	throw new FormatException ("Hour values must be between 0 and 23");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day of month values must be between 1 and 31");  	}  }  else if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  	throw new FormatException ("Day of month values must be between 1 and 31");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 1 || val > 31 || end > 31) && (val != AllSpecInt) && (val != NoSpecInt)) {  	throw new FormatException ("Day of month values must be between 1 and 31");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  		throw new FormatException ("Month values must be between 1 and 12");  	}  }  else if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  	throw new FormatException ("Month values must be between 1 and 12");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val < 1 || val > 12 || end > 12) && (val != AllSpecInt)) {  	throw new FormatException ("Month values must be between 1 and 12");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfWeek) {  	if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  		throw new FormatException ("Day-of-Week values must be between 1 and 7");  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  	throw new FormatException ("Day-of-Week values must be between 1 and 7");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if ((val == 0 || val > 7 || end > 7) && (val != AllSpecInt) && (val != NoSpecInt)) {  	throw new FormatException ("Day-of-Week values must be between 1 and 7");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if (stopAt == -1) {  		stopAt = 59;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if (stopAt == -1) {  		stopAt = 59;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if (stopAt == -1) {  		stopAt = 59;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if (stopAt == -1) {  		stopAt = 59;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if (stopAt == -1) {  		stopAt = 59;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Second || type == Minute) {  	if (stopAt == -1) {  		stopAt = 59;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt == -1) {  	stopAt = 59;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: stopAt = 59;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Hour) {  	if (stopAt == -1) {  		stopAt = 23;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 0;  	}  }  else if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt == -1) {  	stopAt = 23;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: stopAt = 23;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfMonth) {  	if (stopAt == -1) {  		stopAt = 31;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt == -1) {  	stopAt = 31;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: stopAt = 31;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Month) {  	if (stopAt == -1) {  		stopAt = 12;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt == -1) {  	stopAt = 12;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: stopAt = 12;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == DayOfWeek) {  	if (stopAt == -1) {  		stopAt = 7;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1;  	}  }  else if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt == -1) {  	stopAt = 7;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: stopAt = 7;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (type == Year) {  	if (stopAt == -1) {  		stopAt = MaxYear;  	}  	if (startAt == -1 || startAt == AllSpecInt) {  		startAt = 1970;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (startAt == -1 || startAt == AllSpecInt) {  	startAt = 1970;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: startAt = 1970;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt < startAt) {  	switch (type) {  	case Second:  		max = 60;  		break;  	case Minute:  		max = 60;  		break;  	case Hour:  		max = 24;  		break;  	case Month:  		max = 12;  		break;  	case DayOfWeek:  		max = 7;  		break;  	case DayOfMonth:  		max = 31;  		break;  	case Year:  		throw new ArgumentException ("Start year must be less than stop year");  	default:  		throw new ArgumentException ("Unexpected type encountered");  	}  	stopAt += max;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt < startAt) {  	switch (type) {  	case Second:  		max = 60;  		break;  	case Minute:  		max = 60;  		break;  	case Hour:  		max = 24;  		break;  	case Month:  		max = 12;  		break;  	case DayOfWeek:  		max = 7;  		break;  	case DayOfMonth:  		max = 31;  		break;  	case Year:  		throw new ArgumentException ("Start year must be less than stop year");  	default:  		throw new ArgumentException ("Unexpected type encountered");  	}  	stopAt += max;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt < startAt) {  	switch (type) {  	case Second:  		max = 60;  		break;  	case Minute:  		max = 60;  		break;  	case Hour:  		max = 24;  		break;  	case Month:  		max = 12;  		break;  	case DayOfWeek:  		max = 7;  		break;  	case DayOfMonth:  		max = 31;  		break;  	case Year:  		throw new ArgumentException ("Start year must be less than stop year");  	default:  		throw new ArgumentException ("Unexpected type encountered");  	}  	stopAt += max;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt < startAt) {  	switch (type) {  	case Second:  		max = 60;  		break;  	case Minute:  		max = 60;  		break;  	case Hour:  		max = 24;  		break;  	case Month:  		max = 12;  		break;  	case DayOfWeek:  		max = 7;  		break;  	case DayOfMonth:  		max = 31;  		break;  	case Year:  		throw new ArgumentException ("Start year must be less than stop year");  	default:  		throw new ArgumentException ("Unexpected type encountered");  	}  	stopAt += max;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt < startAt) {  	switch (type) {  	case Second:  		max = 60;  		break;  	case Minute:  		max = 60;  		break;  	case Hour:  		max = 24;  		break;  	case Month:  		max = 12;  		break;  	case DayOfWeek:  		max = 7;  		break;  	case DayOfMonth:  		max = 31;  		break;  	case Year:  		throw new ArgumentException ("Start year must be less than stop year");  	default:  		throw new ArgumentException ("Unexpected type encountered");  	}  	stopAt += max;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: if (stopAt < startAt) {  	switch (type) {  	case Second:  		max = 60;  		break;  	case Minute:  		max = 60;  		break;  	case Hour:  		max = 24;  		break;  	case Month:  		max = 12;  		break;  	case DayOfWeek:  		max = 7;  		break;  	case DayOfMonth:  		max = 31;  		break;  	case Year:  		throw new ArgumentException ("Start year must be less than stop year");  	default:  		throw new ArgumentException ("Unexpected type encountered");  	}  	stopAt += max;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: switch (type) {  case Second:  	max = 60;  	break;  case Minute:  	max = 60;  	break;  case Hour:  	max = 24;  	break;  case Month:  	max = 12;  	break;  case DayOfWeek:  	max = 7;  	break;  case DayOfMonth:  	max = 31;  	break;  case Year:  	throw new ArgumentException ("Start year must be less than stop year");  default:  	throw new ArgumentException ("Unexpected type encountered");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: switch (type) {  case Second:  	max = 60;  	break;  case Minute:  	max = 60;  	break;  case Hour:  	max = 24;  	break;  case Month:  	max = 12;  	break;  case DayOfWeek:  	max = 7;  	break;  case DayOfMonth:  	max = 31;  	break;  case Year:  	throw new ArgumentException ("Start year must be less than stop year");  default:  	throw new ArgumentException ("Unexpected type encountered");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: switch (type) {  case Second:  	max = 60;  	break;  case Minute:  	max = 60;  	break;  case Hour:  	max = 24;  	break;  case Month:  	max = 12;  	break;  case DayOfWeek:  	max = 7;  	break;  case DayOfMonth:  	max = 31;  	break;  case Year:  	throw new ArgumentException ("Start year must be less than stop year");  default:  	throw new ArgumentException ("Unexpected type encountered");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: switch (type) {  case Second:  	max = 60;  	break;  case Minute:  	max = 60;  	break;  case Hour:  	max = 24;  	break;  case Month:  	max = 12;  	break;  case DayOfWeek:  	max = 7;  	break;  case DayOfMonth:  	max = 31;  	break;  case Year:  	throw new ArgumentException ("Start year must be less than stop year");  default:  	throw new ArgumentException ("Unexpected type encountered");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: switch (type) {  case Second:  	max = 60;  	break;  case Minute:  	max = 60;  	break;  case Hour:  	max = 24;  	break;  case Month:  	max = 12;  	break;  case DayOfWeek:  	max = 7;  	break;  case DayOfMonth:  	max = 31;  	break;  case Year:  	throw new ArgumentException ("Start year must be less than stop year");  default:  	throw new ArgumentException ("Unexpected type encountered");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: switch (type) {  case Second:  	max = 60;  	break;  case Minute:  	max = 60;  	break;  case Hour:  	max = 24;  	break;  case Month:  	max = 12;  	break;  case DayOfWeek:  	max = 7;  	break;  case DayOfMonth:  	max = 31;  	break;  case Year:  	throw new ArgumentException ("Start year must be less than stop year");  default:  	throw new ArgumentException ("Unexpected type encountered");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: max = 60;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: max = 60;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: max = 24;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: max = 12;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: max = 7;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,AddToSet,The following statement contains a magic number: max = 31;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while (!gotOne) {  	ISortedSet<int> st;  	int t;  	int sec = d.Second;  	// get second.................................................  	st = seconds.TailSet (sec);  	if (st != null && st.Count != 0) {  		sec = st.First ();  	}  	else {  		sec = seconds.First ();  		d = d.AddMinutes (1);  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' sec' d.Millisecond' d.Offset);  	int min = d.Minute;  	int hr = d.Hour;  	t = -1;  	// get minute.................................................  	st = minutes.TailSet (min);  	if (st != null && st.Count != 0) {  		t = min;  		min = st.First ();  	}  	else {  		min = minutes.First ();  		hr++;  	}  	if (min != t) {  		d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' 0' d.Millisecond' d.Offset);  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' min' d.Second' d.Millisecond' d.Offset);  	hr = d.Hour;  	int day = d.Day;  	t = -1;  	// get hour...................................................  	st = hours.TailSet (hr);  	if (st != null && st.Count != 0) {  		t = hr;  		hr = st.First ();  	}  	else {  		hr = hours.First ();  		day++;  	}  	if (hr != t) {  		int daysInMonth = DateTime.DaysInMonth (d.Year' d.Month);  		if (day > daysInMonth) {  			d = new DateTimeOffset (d.Year' d.Month' daysInMonth' d.Hour' 0' 0' d.Millisecond' d.Offset).AddDays (day - daysInMonth);  		}  		else {  			d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' 0' 0' d.Millisecond' d.Offset);  		}  		d = SetCalendarHour (d' hr);  		continue;  	}  	d = new DateTimeOffset (d.Year' d.Month' d.Day' hr' d.Minute' d.Second' d.Millisecond' d.Offset);  	day = d.Day;  	int mon = d.Month;  	t = -1;  	int tmon = mon;  	// get day...................................................  	bool dayOfMSpec = !daysOfMonth.Contains (NoSpec);  	bool dayOfWSpec = !daysOfWeek.Contains (NoSpec);  	if (dayOfMSpec && !dayOfWSpec) {  		// get day by day of month rule  		st = daysOfMonth.TailSet (day);  		if (lastdayOfMonth) {  			if (!nearestWeekday) {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				if (t > day) {  					mon++;  					if (mon > 12) {  						mon = 1;  						tmon = 3333;  						// ensure test of mon != tmon further below fails  						d = d.AddYears (1);  					}  					day = 1;  				}  			}  			else {  				t = day;  				day = GetLastDayOfMonth (mon' d.Year);  				day -= lastdayOffset;  				DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				int ldom = GetLastDayOfMonth (mon' d.Year);  				DayOfWeek dow = tcal.DayOfWeek;  				if (dow == System.DayOfWeek.Saturday && day == 1) {  					day += 2;  				}  				else if (dow == System.DayOfWeek.Saturday) {  					day -= 1;  				}  				else if (dow == System.DayOfWeek.Sunday && day == ldom) {  					day -= 2;  				}  				else if (dow == System.DayOfWeek.Sunday) {  					day += 1;  				}  				DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  				if (nTime.ToUniversalTime () < afterTimeUtc) {  					day = 1;  					mon++;  				}  			}  		}  		else if (nearestWeekday) {  			t = day;  			day = daysOfMonth.First ();  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  			if (tcal.ToUniversalTime () < afterTimeUtc) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else if (st != null && st.Count != 0) {  			t = day;  			day = st.First ();  			// make sure we don't over-run a short month' such as february  			int lastDay = GetLastDayOfMonth (mon' d.Year);  			if (day > lastDay) {  				day = daysOfMonth.First ();  				mon++;  			}  		}  		else {  			day = daysOfMonth.First ();  			mon++;  		}  		if (day != t || mon != tmon) {  			if (mon > 12) {  				d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  			}  			else {  				// This is to avoid a bug when moving from a month  				//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  				// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  				int lDay = DateTime.DaysInMonth (d.Year' mon);  				if (day <= lDay) {  					d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				}  				else {  					d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  				}  			}  			continue;  		}  	}  	else if (dayOfWSpec && !dayOfMSpec) {  		// get day by day of week rule  		if (lastdayOfWeek) {  			// are we looking for the last XXX day of  			// the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// did we already miss the  				// last one?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			// find date of last occurrence of this day in this month...  			while ((day + daysToAdd + 7) <= lDay) {  				daysToAdd += 7;  			}  			day += daysToAdd;  			if (daysToAdd > 0) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are not promoting the month  				continue;  			}  		}  		else if (nthdayOfWeek != 0) {  			// are we looking for the Nth XXX day in the month?  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			else if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			bool dayShifted = daysToAdd > 0;  			day += daysToAdd;  			int weekOfMonth = day / 7;  			if (day % 7 > 0) {  				weekOfMonth++;  			}  			daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  			day += daysToAdd;  			if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  				if (mon == 12) {  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0 || dayShifted) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  				// we are NOT promoting the month  				continue;  			}  		}  		else {  			int cDow = ((int)d.DayOfWeek) + 1;  			// current d-o-w  			int dow = daysOfWeek.First ();  			// desired  			// d-o-w  			st = daysOfWeek.TailSet (cDow);  			if (st != null && st.Count > 0) {  				dow = st.First ();  			}  			int daysToAdd = 0;  			if (cDow < dow) {  				daysToAdd = dow - cDow;  			}  			if (cDow > dow) {  				daysToAdd = dow + (7 - cDow);  			}  			int lDay = GetLastDayOfMonth (mon' d.Year);  			if (day + daysToAdd > lDay) {  				// will we pass the end of the month?  				if (mon == 12) {  					//will we pass the end of the year?  					d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  				}  				else {  					d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  				}  				// we are promoting the month  				continue;  			}  			else if (daysToAdd > 0) {  				// are we swithing days?  				d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  				continue;  			}  		}  	}  	else {  		// dayOfWSpec && !dayOfMSpec  		throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  	}  	d = new DateTimeOffset (d.Year' d.Month' day' d.Hour' d.Minute' d.Second' d.Offset);  	mon = d.Month;  	int year = d.Year;  	t = -1;  	// test for expressions that never generate a valid fire date'  	// but keep looping...  	if (year > MaxYear) {  		return null;  	}  	// get month...................................................  	st = months.TailSet ((mon));  	if (st != null && st.Count != 0) {  		t = mon;  		mon = st.First ();  	}  	else {  		mon = months.First ();  		year++;  	}  	if (mon != t) {  		d = new DateTimeOffset (year' mon' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (d.Year' mon' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	year = d.Year;  	t = -1;  	// get year...................................................  	st = years.TailSet ((year));  	if (st != null && st.Count != 0) {  		t = year;  		year = st.First ();  	}  	else {  		return null;  	}  	// ran out of years...  	if (year != t) {  		d = new DateTimeOffset (year' 1' 1' 0' 0' 0' d.Offset);  		continue;  	}  	d = new DateTimeOffset (year' d.Month' d.Day' d.Hour' d.Minute' d.Second' d.Offset);  	//apply the proper offset for this date  	d = new DateTimeOffset (d.Year' d.Month' d.Day' d.Hour' d.Minute' d.Second' this.TimeZone.GetUtcOffset (d.DateTime));  	gotOne = true;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfMSpec && !dayOfWSpec) {  	// get day by day of month rule  	st = daysOfMonth.TailSet (day);  	if (lastdayOfMonth) {  		if (!nearestWeekday) {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			if (t > day) {  				mon++;  				if (mon > 12) {  					mon = 1;  					tmon = 3333;  					// ensure test of mon != tmon further below fails  					d = d.AddYears (1);  				}  				day = 1;  			}  		}  		else {  			t = day;  			day = GetLastDayOfMonth (mon' d.Year);  			day -= lastdayOffset;  			DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			int ldom = GetLastDayOfMonth (mon' d.Year);  			DayOfWeek dow = tcal.DayOfWeek;  			if (dow == System.DayOfWeek.Saturday && day == 1) {  				day += 2;  			}  			else if (dow == System.DayOfWeek.Saturday) {  				day -= 1;  			}  			else if (dow == System.DayOfWeek.Sunday && day == ldom) {  				day -= 2;  			}  			else if (dow == System.DayOfWeek.Sunday) {  				day += 1;  			}  			DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  			if (nTime.ToUniversalTime () < afterTimeUtc) {  				day = 1;  				mon++;  			}  		}  	}  	else if (nearestWeekday) {  		t = day;  		day = daysOfMonth.First ();  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  		if (tcal.ToUniversalTime () < afterTimeUtc) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else if (st != null && st.Count != 0) {  		t = day;  		day = st.First ();  		// make sure we don't over-run a short month' such as february  		int lastDay = GetLastDayOfMonth (mon' d.Year);  		if (day > lastDay) {  			day = daysOfMonth.First ();  			mon++;  		}  	}  	else {  		day = daysOfMonth.First ();  		mon++;  	}  	if (day != t || mon != tmon) {  		if (mon > 12) {  			d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  		}  		else {  			// This is to avoid a bug when moving from a month  			//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  			// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  			int lDay = DateTime.DaysInMonth (d.Year' mon);  			if (day <= lDay) {  				d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			}  			else {  				d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  			}  		}  		continue;  	}  }  else if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfMonth) {  	if (!nearestWeekday) {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		if (t > day) {  			mon++;  			if (mon > 12) {  				mon = 1;  				tmon = 3333;  				// ensure test of mon != tmon further below fails  				d = d.AddYears (1);  			}  			day = 1;  		}  	}  	else {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  		if (nTime.ToUniversalTime () < afterTimeUtc) {  			day = 1;  			mon++;  		}  	}  }  else if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfMonth) {  	if (!nearestWeekday) {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		if (t > day) {  			mon++;  			if (mon > 12) {  				mon = 1;  				tmon = 3333;  				// ensure test of mon != tmon further below fails  				d = d.AddYears (1);  			}  			day = 1;  		}  	}  	else {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  		if (nTime.ToUniversalTime () < afterTimeUtc) {  			day = 1;  			mon++;  		}  	}  }  else if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfMonth) {  	if (!nearestWeekday) {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		if (t > day) {  			mon++;  			if (mon > 12) {  				mon = 1;  				tmon = 3333;  				// ensure test of mon != tmon further below fails  				d = d.AddYears (1);  			}  			day = 1;  		}  	}  	else {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  		if (nTime.ToUniversalTime () < afterTimeUtc) {  			day = 1;  			mon++;  		}  	}  }  else if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfMonth) {  	if (!nearestWeekday) {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		if (t > day) {  			mon++;  			if (mon > 12) {  				mon = 1;  				tmon = 3333;  				// ensure test of mon != tmon further below fails  				d = d.AddYears (1);  			}  			day = 1;  		}  	}  	else {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  		if (nTime.ToUniversalTime () < afterTimeUtc) {  			day = 1;  			mon++;  		}  	}  }  else if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfMonth) {  	if (!nearestWeekday) {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		if (t > day) {  			mon++;  			if (mon > 12) {  				mon = 1;  				tmon = 3333;  				// ensure test of mon != tmon further below fails  				d = d.AddYears (1);  			}  			day = 1;  		}  	}  	else {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  		if (nTime.ToUniversalTime () < afterTimeUtc) {  			day = 1;  			mon++;  		}  	}  }  else if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfMonth) {  	if (!nearestWeekday) {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		if (t > day) {  			mon++;  			if (mon > 12) {  				mon = 1;  				tmon = 3333;  				// ensure test of mon != tmon further below fails  				d = d.AddYears (1);  			}  			day = 1;  		}  	}  	else {  		t = day;  		day = GetLastDayOfMonth (mon' d.Year);  		day -= lastdayOffset;  		DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		int ldom = GetLastDayOfMonth (mon' d.Year);  		DayOfWeek dow = tcal.DayOfWeek;  		if (dow == System.DayOfWeek.Saturday && day == 1) {  			day += 2;  		}  		else if (dow == System.DayOfWeek.Saturday) {  			day -= 1;  		}  		else if (dow == System.DayOfWeek.Sunday && day == ldom) {  			day -= 2;  		}  		else if (dow == System.DayOfWeek.Sunday) {  			day += 1;  		}  		DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  		if (nTime.ToUniversalTime () < afterTimeUtc) {  			day = 1;  			mon++;  		}  	}  }  else if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (!nearestWeekday) {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	if (t > day) {  		mon++;  		if (mon > 12) {  			mon = 1;  			tmon = 3333;  			// ensure test of mon != tmon further below fails  			d = d.AddYears (1);  		}  		day = 1;  	}  }  else {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  	if (nTime.ToUniversalTime () < afterTimeUtc) {  		day = 1;  		mon++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (!nearestWeekday) {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	if (t > day) {  		mon++;  		if (mon > 12) {  			mon = 1;  			tmon = 3333;  			// ensure test of mon != tmon further below fails  			d = d.AddYears (1);  		}  		day = 1;  	}  }  else {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  	if (nTime.ToUniversalTime () < afterTimeUtc) {  		day = 1;  		mon++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (!nearestWeekday) {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	if (t > day) {  		mon++;  		if (mon > 12) {  			mon = 1;  			tmon = 3333;  			// ensure test of mon != tmon further below fails  			d = d.AddYears (1);  		}  		day = 1;  	}  }  else {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  	if (nTime.ToUniversalTime () < afterTimeUtc) {  		day = 1;  		mon++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (!nearestWeekday) {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	if (t > day) {  		mon++;  		if (mon > 12) {  			mon = 1;  			tmon = 3333;  			// ensure test of mon != tmon further below fails  			d = d.AddYears (1);  		}  		day = 1;  	}  }  else {  	t = day;  	day = GetLastDayOfMonth (mon' d.Year);  	day -= lastdayOffset;  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	DateTimeOffset nTime = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Millisecond' d.Offset);  	if (nTime.ToUniversalTime () < afterTimeUtc) {  		day = 1;  		mon++;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (t > day) {  	mon++;  	if (mon > 12) {  		mon = 1;  		tmon = 3333;  		// ensure test of mon != tmon further below fails  		d = d.AddYears (1);  	}  	day = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (t > day) {  	mon++;  	if (mon > 12) {  		mon = 1;  		tmon = 3333;  		// ensure test of mon != tmon further below fails  		d = d.AddYears (1);  	}  	day = 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon > 12) {  	mon = 1;  	tmon = 3333;  	// ensure test of mon != tmon further below fails  	d = d.AddYears (1);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon > 12) {  	mon = 1;  	tmon = 3333;  	// ensure test of mon != tmon further below fails  	d = d.AddYears (1);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: tmon = 3333;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Saturday && day == 1) {  	day += 2;  }  else if (dow == System.DayOfWeek.Saturday) {  	day -= 1;  }  else if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Saturday && day == 1) {  	day += 2;  }  else if (dow == System.DayOfWeek.Saturday) {  	day -= 1;  }  else if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: day += 2;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Saturday) {  	day -= 1;  }  else if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: day -= 2;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nearestWeekday) {  	t = day;  	day = daysOfMonth.First ();  	DateTimeOffset tcal = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	int ldom = GetLastDayOfMonth (mon' d.Year);  	DayOfWeek dow = tcal.DayOfWeek;  	if (dow == System.DayOfWeek.Saturday && day == 1) {  		day += 2;  	}  	else if (dow == System.DayOfWeek.Saturday) {  		day -= 1;  	}  	else if (dow == System.DayOfWeek.Sunday && day == ldom) {  		day -= 2;  	}  	else if (dow == System.DayOfWeek.Sunday) {  		day += 1;  	}  	tcal = new DateTimeOffset (tcal.Year' mon' day' hr' min' sec' d.Offset);  	if (tcal.ToUniversalTime () < afterTimeUtc) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else if (st != null && st.Count != 0) {  	t = day;  	day = st.First ();  	// make sure we don't over-run a short month' such as february  	int lastDay = GetLastDayOfMonth (mon' d.Year);  	if (day > lastDay) {  		day = daysOfMonth.First ();  		mon++;  	}  }  else {  	day = daysOfMonth.First ();  	mon++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Saturday && day == 1) {  	day += 2;  }  else if (dow == System.DayOfWeek.Saturday) {  	day -= 1;  }  else if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Saturday && day == 1) {  	day += 2;  }  else if (dow == System.DayOfWeek.Saturday) {  	day -= 1;  }  else if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: day += 2;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Saturday) {  	day -= 1;  }  else if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dow == System.DayOfWeek.Sunday && day == ldom) {  	day -= 2;  }  else if (dow == System.DayOfWeek.Sunday) {  	day += 1;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: day -= 2;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day != t || mon != tmon) {  	if (mon > 12) {  		d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  	}  	else {  		// This is to avoid a bug when moving from a month  		//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  		// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  		int lDay = DateTime.DaysInMonth (d.Year' mon);  		if (day <= lDay) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		}  		else {  			d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  		}  	}  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day != t || mon != tmon) {  	if (mon > 12) {  		d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  	}  	else {  		// This is to avoid a bug when moving from a month  		//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  		// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  		int lDay = DateTime.DaysInMonth (d.Year' mon);  		if (day <= lDay) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		}  		else {  			d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  		}  	}  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day != t || mon != tmon) {  	if (mon > 12) {  		d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  	}  	else {  		// This is to avoid a bug when moving from a month  		//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  		// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  		int lDay = DateTime.DaysInMonth (d.Year' mon);  		if (day <= lDay) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		}  		else {  			d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  		}  	}  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon > 12) {  	d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  }  else {  	// This is to avoid a bug when moving from a month  	//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  	// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  	int lDay = DateTime.DaysInMonth (d.Year' mon);  	if (day <= lDay) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	}  	else {  		d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon > 12) {  	d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  }  else {  	// This is to avoid a bug when moving from a month  	//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  	// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  	int lDay = DateTime.DaysInMonth (d.Year' mon);  	if (day <= lDay) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	}  	else {  		d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon > 12) {  	d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  }  else {  	// This is to avoid a bug when moving from a month  	//with 30 or 31 days to a month with less. Causes an invalid datetime to be instantiated.  	// ex. 0 29 0 30 1 ? 2009 with clock set to 1/30/2009  	int lDay = DateTime.DaysInMonth (d.Year' mon);  	if (day <= lDay) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	}  	else {  		d = new DateTimeOffset (d.Year' mon' lDay' 0' 0' 0' d.Offset).AddDays (day - lDay);  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: d = new DateTimeOffset (d.Year' 12' day' 0' 0' 0' d.Offset).AddMonths (mon - 12);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (dayOfWSpec && !dayOfMSpec) {  	// get day by day of week rule  	if (lastdayOfWeek) {  		// are we looking for the last XXX day of  		// the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// did we already miss the  			// last one?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		// find date of last occurrence of this day in this month...  		while ((day + daysToAdd + 7) <= lDay) {  			daysToAdd += 7;  		}  		day += daysToAdd;  		if (daysToAdd > 0) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are not promoting the month  			continue;  		}  	}  	else if (nthdayOfWeek != 0) {  		// are we looking for the Nth XXX day in the month?  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		else if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		bool dayShifted = daysToAdd > 0;  		day += daysToAdd;  		int weekOfMonth = day / 7;  		if (day % 7 > 0) {  			weekOfMonth++;  		}  		daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  		day += daysToAdd;  		if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  			if (mon == 12) {  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0 || dayShifted) {  			d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  			// we are NOT promoting the month  			continue;  		}  	}  	else {  		int cDow = ((int)d.DayOfWeek) + 1;  		// current d-o-w  		int dow = daysOfWeek.First ();  		// desired  		// d-o-w  		st = daysOfWeek.TailSet (cDow);  		if (st != null && st.Count > 0) {  			dow = st.First ();  		}  		int daysToAdd = 0;  		if (cDow < dow) {  			daysToAdd = dow - cDow;  		}  		if (cDow > dow) {  			daysToAdd = dow + (7 - cDow);  		}  		int lDay = GetLastDayOfMonth (mon' d.Year);  		if (day + daysToAdd > lDay) {  			// will we pass the end of the month?  			if (mon == 12) {  				//will we pass the end of the year?  				d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  			}  			else {  				d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  			}  			// we are promoting the month  			continue;  		}  		else if (daysToAdd > 0) {  			// are we swithing days?  			d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  			continue;  		}  	}  }  else {  	// dayOfWSpec && !dayOfMSpec  	throw new Exception ("Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.");  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (lastdayOfWeek) {  	// are we looking for the last XXX day of  	// the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// did we already miss the  		// last one?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	// find date of last occurrence of this day in this month...  	while ((day + daysToAdd + 7) <= lDay) {  		daysToAdd += 7;  	}  	day += daysToAdd;  	if (daysToAdd > 0) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are not promoting the month  		continue;  	}  }  else if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (cDow > dow) {  	daysToAdd = dow + (7 - cDow);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: daysToAdd = dow + (7 - cDow);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day + daysToAdd > lDay) {  	// did we already miss the  	// last one?  	if (mon == 12) {  		//will we pass the end of the year?  		d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  	}  	else {  		d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  	}  	// we are promoting the month  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day + daysToAdd > lDay) {  	// did we already miss the  	// last one?  	if (mon == 12) {  		//will we pass the end of the year?  		d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  	}  	else {  		d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  	}  	// we are promoting the month  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon == 12) {  	//will we pass the end of the year?  	d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  }  else {  	d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon == 12) {  	//will we pass the end of the year?  	d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  }  else {  	d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while ((day + daysToAdd + 7) <= lDay) {  	daysToAdd += 7;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: while ((day + daysToAdd + 7) <= lDay) {  	daysToAdd += 7;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: daysToAdd += 7;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (nthdayOfWeek != 0) {  	// are we looking for the Nth XXX day in the month?  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	else if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	bool dayShifted = daysToAdd > 0;  	day += daysToAdd;  	int weekOfMonth = day / 7;  	if (day % 7 > 0) {  		weekOfMonth++;  	}  	daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  	day += daysToAdd;  	if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  		if (mon == 12) {  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0 || dayShifted) {  		d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  		// we are NOT promoting the month  		continue;  	}  }  else {  	int cDow = ((int)d.DayOfWeek) + 1;  	// current d-o-w  	int dow = daysOfWeek.First ();  	// desired  	// d-o-w  	st = daysOfWeek.TailSet (cDow);  	if (st != null && st.Count > 0) {  		dow = st.First ();  	}  	int daysToAdd = 0;  	if (cDow < dow) {  		daysToAdd = dow - cDow;  	}  	if (cDow > dow) {  		daysToAdd = dow + (7 - cDow);  	}  	int lDay = GetLastDayOfMonth (mon' d.Year);  	if (day + daysToAdd > lDay) {  		// will we pass the end of the month?  		if (mon == 12) {  			//will we pass the end of the year?  			d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  		}  		else {  			d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  		}  		// we are promoting the month  		continue;  	}  	else if (daysToAdd > 0) {  		// are we swithing days?  		d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  		continue;  	}  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (cDow < dow) {  	daysToAdd = dow - cDow;  }  else if (cDow > dow) {  	daysToAdd = dow + (7 - cDow);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (cDow > dow) {  	daysToAdd = dow + (7 - cDow);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: daysToAdd = dow + (7 - cDow);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day % 7 > 0) {  	weekOfMonth++;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  	if (mon == 12) {  		d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  	}  	else {  		d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  	}  	// we are promoting the month  	continue;  }  else if (daysToAdd > 0 || dayShifted) {  	d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	// we are NOT promoting the month  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (daysToAdd < 0 || day > GetLastDayOfMonth (mon' d.Year)) {  	if (mon == 12) {  		d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  	}  	else {  		d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  	}  	// we are promoting the month  	continue;  }  else if (daysToAdd > 0 || dayShifted) {  	d = new DateTimeOffset (d.Year' mon' day' 0' 0' 0' d.Offset);  	// we are NOT promoting the month  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon == 12) {  	d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  }  else {  	d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon == 12) {  	d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  }  else {  	d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (cDow > dow) {  	daysToAdd = dow + (7 - cDow);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: daysToAdd = dow + (7 - cDow);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day + daysToAdd > lDay) {  	// will we pass the end of the month?  	if (mon == 12) {  		//will we pass the end of the year?  		d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  	}  	else {  		d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  	}  	// we are promoting the month  	continue;  }  else if (daysToAdd > 0) {  	// are we swithing days?  	d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (day + daysToAdd > lDay) {  	// will we pass the end of the month?  	if (mon == 12) {  		//will we pass the end of the year?  		d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  	}  	else {  		d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  	}  	// we are promoting the month  	continue;  }  else if (daysToAdd > 0) {  	// are we swithing days?  	d = new DateTimeOffset (d.Year' mon' day + daysToAdd' 0' 0' 0' d.Offset);  	continue;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon == 12) {  	//will we pass the end of the year?  	d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  }  else {  	d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: if (mon == 12) {  	//will we pass the end of the year?  	d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  }  else {  	d = new DateTimeOffset (d.Year' mon + 1' 1' 0' 0' 0' d.Offset);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetTimeAfter,The following statement contains a magic number: d = new DateTimeOffset (d.Year' mon - 11' 1' 0' 0' 0' d.Offset).AddYears (1);  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,SetCalendarHour,The following statement contains a magic number: if (hourToSet == 24) {  	hourToSet = 0;  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,SetCalendarHour,The following statement contains a magic number: if (hour == 24) {  	// inrement day  	d = d.AddDays (1);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return ((cronExpressionString != null ? cronExpressionString.GetHashCode () : 0) * 397) ^ (timeZone != null ? timeZone.GetHashCode () : 0);  }  
Magic Number,Quartz,CronExpression,C:\repos\xmj112288_Study\OpenSources\Quartz\CronExpression.cs,GetHashCode,The following statement contains a magic number: return ((cronExpressionString != null ? cronExpressionString.GetHashCode () : 0) * 397) ^ (timeZone != null ? timeZone.GetHashCode () : 0);  
Magic Number,Quartz,TimeOfDay,C:\repos\xmj112288_Study\OpenSources\Quartz\TimeOfDay.cs,Validate,The following statement contains a magic number: if (hour < 0 || hour > 23) {  	throw new ArgumentException ("Hour must be from 0 to 23");  }  
Magic Number,Quartz,TimeOfDay,C:\repos\xmj112288_Study\OpenSources\Quartz\TimeOfDay.cs,Validate,The following statement contains a magic number: if (minute < 0 || minute > 59) {  	throw new ArgumentException ("Minute must be from 0 to 59");  }  
Magic Number,Quartz,TimeOfDay,C:\repos\xmj112288_Study\OpenSources\Quartz\TimeOfDay.cs,Validate,The following statement contains a magic number: if (second < 0 || second > 59) {  	throw new ArgumentException ("Second must be from 0 to 59");  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (timeOfDayStr != null) {  	string[] nums = timeOfDayStr.Split (''');  	TimeOfDay startTimeOfDay;  	if (nums.Length >= 3) {  		int hour = Int32.Parse (nums [0]);  		int min = Int32.Parse (nums [1]);  		int sec = Int32.Parse (nums [2]);  		startTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  	}  	scheduleBuilder.StartingDailyAt (startTimeOfDay);  	TimeOfDay endTimeOfDay;  	if (nums.Length >= 6) {  		int hour = Int32.Parse (nums [3]);  		int min = Int32.Parse (nums [4]);  		int sec = Int32.Parse (nums [5]);  		endTimeOfDay = new TimeOfDay (hour' min' sec);  	}  	else {  		endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  	}  	scheduleBuilder.EndingDailyAt (endTimeOfDay);  }  else {  	scheduleBuilder.StartingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0));  	scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 3) {  	int hour = Int32.Parse (nums [0]);  	int min = Int32.Parse (nums [1]);  	int sec = Int32.Parse (nums [2]);  	startTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 3) {  	int hour = Int32.Parse (nums [0]);  	int min = Int32.Parse (nums [1]);  	int sec = Int32.Parse (nums [2]);  	startTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	startTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (0' 0' 0);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: if (nums.Length >= 6) {  	int hour = Int32.Parse (nums [3]);  	int min = Int32.Parse (nums [4]);  	int sec = Int32.Parse (nums [5]);  	endTimeOfDay = new TimeOfDay (hour' min' sec);  }  else {  	endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  }  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: endTimeOfDay = TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59);  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  
Magic Number,Quartz.Impl.AdoJobStore,DailyTimeIntervalTriggerPersistenceDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\DailyTimeIntervalTriggerPersistenceDelegate.cs,GetTriggerPropertyBundle,The following statement contains a magic number: scheduleBuilder.EndingDailyAt (TimeOfDay.HourMinuteAndSecondOfDay (23' 59' 59));  
Magic Number,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,JobStoreSupport,The following statement contains a magic number: ClusterCheckinInterval = TimeSpan.FromMilliseconds (7500);  
Magic Number,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,JobStoreSupport,The following statement contains a magic number: MaxMisfiresToHandleAtATime = 20;  
Magic Number,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,JobStoreSupport,The following statement contains a magic number: DbRetryInterval = TimeSpan.FromSeconds (15);  
Magic Number,Quartz.Impl.AdoJobStore,JobStoreSupport,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\JobStoreSupport.cs,CalcFailedIfAfter,The following statement contains a magic number: return rec.CheckinTimestamp.Add (ts).Add (TimeSpan.FromMilliseconds (7500));  
Magic Number,Quartz.Impl.AdoJobStore,SqlServerDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\SqlServerDelegate.cs,GetSelectNextTriggerToAcquireSql,The following statement contains a magic number: sqlSelectNextTriggerToAcquire = "SELECT TOP " + maxCount + " " + sqlSelectNextTriggerToAcquire.Substring (6);  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTriggerNamesForJob,The following statement contains a magic number: using (IDbCommand cmd = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectTriggersForJob))) {  	AddCommandParameter (cmd' "jobName"' jobKey.Name);  	AddCommandParameter (cmd' "jobGroup"' jobKey.Group);  	using (IDataReader rs = cmd.ExecuteReader ()) {  		List<TriggerKey> list = new List<TriggerKey> (10);  		while (rs.Read ()) {  			string trigName = rs.GetString (ColumnTriggerName);  			string trigGroup = rs.GetString (ColumnTriggerGroup);  			list.Add (new TriggerKey (trigName' trigGroup));  		}  		return list;  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTriggerNamesForJob,The following statement contains a magic number: using (IDataReader rs = cmd.ExecuteReader ()) {  	List<TriggerKey> list = new List<TriggerKey> (10);  	while (rs.Read ()) {  		string trigName = rs.GetString (ColumnTriggerName);  		string trigGroup = rs.GetString (ColumnTriggerGroup);  		list.Add (new TriggerKey (trigName' trigGroup));  	}  	return list;  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectJobDetail,The following statement contains a magic number: using (IDbCommand cmd = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectJobDetail))) {  	AddCommandParameter (cmd' "jobName"' jobKey.Name);  	AddCommandParameter (cmd' "jobGroup"' jobKey.Group);  	using (IDataReader rs = cmd.ExecuteReader ()) {  		JobDetailImpl job = null;  		if (rs.Read ()) {  			job = new JobDetailImpl ();  			job.Name = rs.GetString (ColumnJobName);  			job.Group = rs.GetString (ColumnJobGroup);  			job.Description = rs.GetString (ColumnDescription);  			job.JobType = loadHelper.LoadType (rs.GetString (ColumnJobClass));  			job.Durable = GetBooleanFromDbValue (rs [ColumnIsDurable]);  			job.RequestsRecovery = GetBooleanFromDbValue (rs [ColumnRequestsRecovery]);  			IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 6) : GetObjectFromBlob<IDictionary> (rs' 6);  			if (map != null) {  				job.JobDataMap = map as JobDataMap ?? new JobDataMap (map);  			}  		}  		return job;  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectJobDetail,The following statement contains a magic number: using (IDbCommand cmd = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectJobDetail))) {  	AddCommandParameter (cmd' "jobName"' jobKey.Name);  	AddCommandParameter (cmd' "jobGroup"' jobKey.Group);  	using (IDataReader rs = cmd.ExecuteReader ()) {  		JobDetailImpl job = null;  		if (rs.Read ()) {  			job = new JobDetailImpl ();  			job.Name = rs.GetString (ColumnJobName);  			job.Group = rs.GetString (ColumnJobGroup);  			job.Description = rs.GetString (ColumnDescription);  			job.JobType = loadHelper.LoadType (rs.GetString (ColumnJobClass));  			job.Durable = GetBooleanFromDbValue (rs [ColumnIsDurable]);  			job.RequestsRecovery = GetBooleanFromDbValue (rs [ColumnRequestsRecovery]);  			IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 6) : GetObjectFromBlob<IDictionary> (rs' 6);  			if (map != null) {  				job.JobDataMap = map as JobDataMap ?? new JobDataMap (map);  			}  		}  		return job;  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectJobDetail,The following statement contains a magic number: using (IDataReader rs = cmd.ExecuteReader ()) {  	JobDetailImpl job = null;  	if (rs.Read ()) {  		job = new JobDetailImpl ();  		job.Name = rs.GetString (ColumnJobName);  		job.Group = rs.GetString (ColumnJobGroup);  		job.Description = rs.GetString (ColumnDescription);  		job.JobType = loadHelper.LoadType (rs.GetString (ColumnJobClass));  		job.Durable = GetBooleanFromDbValue (rs [ColumnIsDurable]);  		job.RequestsRecovery = GetBooleanFromDbValue (rs [ColumnRequestsRecovery]);  		IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 6) : GetObjectFromBlob<IDictionary> (rs' 6);  		if (map != null) {  			job.JobDataMap = map as JobDataMap ?? new JobDataMap (map);  		}  	}  	return job;  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectJobDetail,The following statement contains a magic number: using (IDataReader rs = cmd.ExecuteReader ()) {  	JobDetailImpl job = null;  	if (rs.Read ()) {  		job = new JobDetailImpl ();  		job.Name = rs.GetString (ColumnJobName);  		job.Group = rs.GetString (ColumnJobGroup);  		job.Description = rs.GetString (ColumnDescription);  		job.JobType = loadHelper.LoadType (rs.GetString (ColumnJobClass));  		job.Durable = GetBooleanFromDbValue (rs [ColumnIsDurable]);  		job.RequestsRecovery = GetBooleanFromDbValue (rs [ColumnRequestsRecovery]);  		IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 6) : GetObjectFromBlob<IDictionary> (rs' 6);  		if (map != null) {  			job.JobDataMap = map as JobDataMap ?? new JobDataMap (map);  		}  	}  	return job;  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectJobDetail,The following statement contains a magic number: if (rs.Read ()) {  	job = new JobDetailImpl ();  	job.Name = rs.GetString (ColumnJobName);  	job.Group = rs.GetString (ColumnJobGroup);  	job.Description = rs.GetString (ColumnDescription);  	job.JobType = loadHelper.LoadType (rs.GetString (ColumnJobClass));  	job.Durable = GetBooleanFromDbValue (rs [ColumnIsDurable]);  	job.RequestsRecovery = GetBooleanFromDbValue (rs [ColumnRequestsRecovery]);  	IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 6) : GetObjectFromBlob<IDictionary> (rs' 6);  	if (map != null) {  		job.JobDataMap = map as JobDataMap ?? new JobDataMap (map);  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectJobDetail,The following statement contains a magic number: if (rs.Read ()) {  	job = new JobDetailImpl ();  	job.Name = rs.GetString (ColumnJobName);  	job.Group = rs.GetString (ColumnJobGroup);  	job.Description = rs.GetString (ColumnDescription);  	job.JobType = loadHelper.LoadType (rs.GetString (ColumnJobClass));  	job.Durable = GetBooleanFromDbValue (rs [ColumnIsDurable]);  	job.RequestsRecovery = GetBooleanFromDbValue (rs [ColumnRequestsRecovery]);  	IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 6) : GetObjectFromBlob<IDictionary> (rs' 6);  	if (map != null) {  		job.JobDataMap = map as JobDataMap ?? new JobDataMap (map);  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The following statement contains a magic number: using (IDbCommand cmd = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectTrigger))) {  	AddCommandParameter (cmd' "triggerName"' triggerKey.Name);  	AddCommandParameter (cmd' "triggerGroup"' triggerKey.Group);  	using (IDataReader rs = cmd.ExecuteReader ()) {  		if (rs.Read ()) {  			string jobName = rs.GetString (ColumnJobName);  			string jobGroup = rs.GetString (ColumnJobGroup);  			string description = rs.GetString (ColumnDescription);  			triggerType = rs.GetString (ColumnTriggerType);  			string calendarName = rs.GetString (ColumnCalendarName);  			int misFireInstr = rs.GetInt32 (ColumnMifireInstruction);  			int priority = rs.GetInt32 (ColumnPriority);  			IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 11) : GetObjectFromBlob<IDictionary> (rs' 11);  			DateTimeOffset? nextFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnNextFireTime]);  			DateTimeOffset? previousFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnPreviousFireTime]);  			DateTimeOffset startTimeUtc = GetDateTimeFromDbValue (rs [ColumnStartTime]) ?? DateTimeOffset.MinValue;  			DateTimeOffset? endTimeUtc = GetDateTimeFromDbValue (rs [ColumnEndTime]);  			// done reading  			rs.Close ();  			if (triggerType.Equals (TriggerTypeBlob)) {  				using (IDbCommand cmd2 = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectBlobTrigger))) {  					AddCommandParameter (cmd2' "triggerName"' triggerKey.Name);  					AddCommandParameter (cmd2' "triggerGroup"' triggerKey.Group);  					using (IDataReader rs2 = cmd2.ExecuteReader ()) {  						if (rs2.Read ()) {  							trigger = GetObjectFromBlob<IOperableTrigger> (rs2' 0);  						}  					}  				}  			}  			else {  				ITriggerPersistenceDelegate tDel = FindTriggerPersistenceDelegate (triggerType);  				if (tDel == null) {  					throw new JobPersistenceException ("No TriggerPersistenceDelegate for trigger discriminator type: " + triggerType);  				}  				TriggerPropertyBundle triggerProps = tDel.LoadExtendedTriggerProperties (conn' triggerKey);  				TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup));  				if (map != null) {  					tb.UsingJobData (map as JobDataMap ?? new JobDataMap (map));  				}  				trigger = (IOperableTrigger)tb.Build ();  				trigger.MisfireInstruction = misFireInstr;  				trigger.SetNextFireTimeUtc (nextFireTimeUtc);  				trigger.SetPreviousFireTimeUtc (previousFireTimeUtc);  				SetTriggerStateProperties (trigger' triggerProps);  			}  		}  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The following statement contains a magic number: using (IDbCommand cmd = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectTrigger))) {  	AddCommandParameter (cmd' "triggerName"' triggerKey.Name);  	AddCommandParameter (cmd' "triggerGroup"' triggerKey.Group);  	using (IDataReader rs = cmd.ExecuteReader ()) {  		if (rs.Read ()) {  			string jobName = rs.GetString (ColumnJobName);  			string jobGroup = rs.GetString (ColumnJobGroup);  			string description = rs.GetString (ColumnDescription);  			triggerType = rs.GetString (ColumnTriggerType);  			string calendarName = rs.GetString (ColumnCalendarName);  			int misFireInstr = rs.GetInt32 (ColumnMifireInstruction);  			int priority = rs.GetInt32 (ColumnPriority);  			IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 11) : GetObjectFromBlob<IDictionary> (rs' 11);  			DateTimeOffset? nextFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnNextFireTime]);  			DateTimeOffset? previousFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnPreviousFireTime]);  			DateTimeOffset startTimeUtc = GetDateTimeFromDbValue (rs [ColumnStartTime]) ?? DateTimeOffset.MinValue;  			DateTimeOffset? endTimeUtc = GetDateTimeFromDbValue (rs [ColumnEndTime]);  			// done reading  			rs.Close ();  			if (triggerType.Equals (TriggerTypeBlob)) {  				using (IDbCommand cmd2 = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectBlobTrigger))) {  					AddCommandParameter (cmd2' "triggerName"' triggerKey.Name);  					AddCommandParameter (cmd2' "triggerGroup"' triggerKey.Group);  					using (IDataReader rs2 = cmd2.ExecuteReader ()) {  						if (rs2.Read ()) {  							trigger = GetObjectFromBlob<IOperableTrigger> (rs2' 0);  						}  					}  				}  			}  			else {  				ITriggerPersistenceDelegate tDel = FindTriggerPersistenceDelegate (triggerType);  				if (tDel == null) {  					throw new JobPersistenceException ("No TriggerPersistenceDelegate for trigger discriminator type: " + triggerType);  				}  				TriggerPropertyBundle triggerProps = tDel.LoadExtendedTriggerProperties (conn' triggerKey);  				TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup));  				if (map != null) {  					tb.UsingJobData (map as JobDataMap ?? new JobDataMap (map));  				}  				trigger = (IOperableTrigger)tb.Build ();  				trigger.MisfireInstruction = misFireInstr;  				trigger.SetNextFireTimeUtc (nextFireTimeUtc);  				trigger.SetPreviousFireTimeUtc (previousFireTimeUtc);  				SetTriggerStateProperties (trigger' triggerProps);  			}  		}  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The following statement contains a magic number: using (IDataReader rs = cmd.ExecuteReader ()) {  	if (rs.Read ()) {  		string jobName = rs.GetString (ColumnJobName);  		string jobGroup = rs.GetString (ColumnJobGroup);  		string description = rs.GetString (ColumnDescription);  		triggerType = rs.GetString (ColumnTriggerType);  		string calendarName = rs.GetString (ColumnCalendarName);  		int misFireInstr = rs.GetInt32 (ColumnMifireInstruction);  		int priority = rs.GetInt32 (ColumnPriority);  		IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 11) : GetObjectFromBlob<IDictionary> (rs' 11);  		DateTimeOffset? nextFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnNextFireTime]);  		DateTimeOffset? previousFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnPreviousFireTime]);  		DateTimeOffset startTimeUtc = GetDateTimeFromDbValue (rs [ColumnStartTime]) ?? DateTimeOffset.MinValue;  		DateTimeOffset? endTimeUtc = GetDateTimeFromDbValue (rs [ColumnEndTime]);  		// done reading  		rs.Close ();  		if (triggerType.Equals (TriggerTypeBlob)) {  			using (IDbCommand cmd2 = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectBlobTrigger))) {  				AddCommandParameter (cmd2' "triggerName"' triggerKey.Name);  				AddCommandParameter (cmd2' "triggerGroup"' triggerKey.Group);  				using (IDataReader rs2 = cmd2.ExecuteReader ()) {  					if (rs2.Read ()) {  						trigger = GetObjectFromBlob<IOperableTrigger> (rs2' 0);  					}  				}  			}  		}  		else {  			ITriggerPersistenceDelegate tDel = FindTriggerPersistenceDelegate (triggerType);  			if (tDel == null) {  				throw new JobPersistenceException ("No TriggerPersistenceDelegate for trigger discriminator type: " + triggerType);  			}  			TriggerPropertyBundle triggerProps = tDel.LoadExtendedTriggerProperties (conn' triggerKey);  			TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup));  			if (map != null) {  				tb.UsingJobData (map as JobDataMap ?? new JobDataMap (map));  			}  			trigger = (IOperableTrigger)tb.Build ();  			trigger.MisfireInstruction = misFireInstr;  			trigger.SetNextFireTimeUtc (nextFireTimeUtc);  			trigger.SetPreviousFireTimeUtc (previousFireTimeUtc);  			SetTriggerStateProperties (trigger' triggerProps);  		}  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The following statement contains a magic number: using (IDataReader rs = cmd.ExecuteReader ()) {  	if (rs.Read ()) {  		string jobName = rs.GetString (ColumnJobName);  		string jobGroup = rs.GetString (ColumnJobGroup);  		string description = rs.GetString (ColumnDescription);  		triggerType = rs.GetString (ColumnTriggerType);  		string calendarName = rs.GetString (ColumnCalendarName);  		int misFireInstr = rs.GetInt32 (ColumnMifireInstruction);  		int priority = rs.GetInt32 (ColumnPriority);  		IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 11) : GetObjectFromBlob<IDictionary> (rs' 11);  		DateTimeOffset? nextFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnNextFireTime]);  		DateTimeOffset? previousFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnPreviousFireTime]);  		DateTimeOffset startTimeUtc = GetDateTimeFromDbValue (rs [ColumnStartTime]) ?? DateTimeOffset.MinValue;  		DateTimeOffset? endTimeUtc = GetDateTimeFromDbValue (rs [ColumnEndTime]);  		// done reading  		rs.Close ();  		if (triggerType.Equals (TriggerTypeBlob)) {  			using (IDbCommand cmd2 = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectBlobTrigger))) {  				AddCommandParameter (cmd2' "triggerName"' triggerKey.Name);  				AddCommandParameter (cmd2' "triggerGroup"' triggerKey.Group);  				using (IDataReader rs2 = cmd2.ExecuteReader ()) {  					if (rs2.Read ()) {  						trigger = GetObjectFromBlob<IOperableTrigger> (rs2' 0);  					}  				}  			}  		}  		else {  			ITriggerPersistenceDelegate tDel = FindTriggerPersistenceDelegate (triggerType);  			if (tDel == null) {  				throw new JobPersistenceException ("No TriggerPersistenceDelegate for trigger discriminator type: " + triggerType);  			}  			TriggerPropertyBundle triggerProps = tDel.LoadExtendedTriggerProperties (conn' triggerKey);  			TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup));  			if (map != null) {  				tb.UsingJobData (map as JobDataMap ?? new JobDataMap (map));  			}  			trigger = (IOperableTrigger)tb.Build ();  			trigger.MisfireInstruction = misFireInstr;  			trigger.SetNextFireTimeUtc (nextFireTimeUtc);  			trigger.SetPreviousFireTimeUtc (previousFireTimeUtc);  			SetTriggerStateProperties (trigger' triggerProps);  		}  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The following statement contains a magic number: if (rs.Read ()) {  	string jobName = rs.GetString (ColumnJobName);  	string jobGroup = rs.GetString (ColumnJobGroup);  	string description = rs.GetString (ColumnDescription);  	triggerType = rs.GetString (ColumnTriggerType);  	string calendarName = rs.GetString (ColumnCalendarName);  	int misFireInstr = rs.GetInt32 (ColumnMifireInstruction);  	int priority = rs.GetInt32 (ColumnPriority);  	IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 11) : GetObjectFromBlob<IDictionary> (rs' 11);  	DateTimeOffset? nextFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnNextFireTime]);  	DateTimeOffset? previousFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnPreviousFireTime]);  	DateTimeOffset startTimeUtc = GetDateTimeFromDbValue (rs [ColumnStartTime]) ?? DateTimeOffset.MinValue;  	DateTimeOffset? endTimeUtc = GetDateTimeFromDbValue (rs [ColumnEndTime]);  	// done reading  	rs.Close ();  	if (triggerType.Equals (TriggerTypeBlob)) {  		using (IDbCommand cmd2 = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectBlobTrigger))) {  			AddCommandParameter (cmd2' "triggerName"' triggerKey.Name);  			AddCommandParameter (cmd2' "triggerGroup"' triggerKey.Group);  			using (IDataReader rs2 = cmd2.ExecuteReader ()) {  				if (rs2.Read ()) {  					trigger = GetObjectFromBlob<IOperableTrigger> (rs2' 0);  				}  			}  		}  	}  	else {  		ITriggerPersistenceDelegate tDel = FindTriggerPersistenceDelegate (triggerType);  		if (tDel == null) {  			throw new JobPersistenceException ("No TriggerPersistenceDelegate for trigger discriminator type: " + triggerType);  		}  		TriggerPropertyBundle triggerProps = tDel.LoadExtendedTriggerProperties (conn' triggerKey);  		TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup));  		if (map != null) {  			tb.UsingJobData (map as JobDataMap ?? new JobDataMap (map));  		}  		trigger = (IOperableTrigger)tb.Build ();  		trigger.MisfireInstruction = misFireInstr;  		trigger.SetNextFireTimeUtc (nextFireTimeUtc);  		trigger.SetPreviousFireTimeUtc (previousFireTimeUtc);  		SetTriggerStateProperties (trigger' triggerProps);  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdAdoDelegate,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdAdoDelegate.cs,SelectTrigger,The following statement contains a magic number: if (rs.Read ()) {  	string jobName = rs.GetString (ColumnJobName);  	string jobGroup = rs.GetString (ColumnJobGroup);  	string description = rs.GetString (ColumnDescription);  	triggerType = rs.GetString (ColumnTriggerType);  	string calendarName = rs.GetString (ColumnCalendarName);  	int misFireInstr = rs.GetInt32 (ColumnMifireInstruction);  	int priority = rs.GetInt32 (ColumnPriority);  	IDictionary map = CanUseProperties ? GetMapFromProperties (rs' 11) : GetObjectFromBlob<IDictionary> (rs' 11);  	DateTimeOffset? nextFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnNextFireTime]);  	DateTimeOffset? previousFireTimeUtc = GetDateTimeFromDbValue (rs [ColumnPreviousFireTime]);  	DateTimeOffset startTimeUtc = GetDateTimeFromDbValue (rs [ColumnStartTime]) ?? DateTimeOffset.MinValue;  	DateTimeOffset? endTimeUtc = GetDateTimeFromDbValue (rs [ColumnEndTime]);  	// done reading  	rs.Close ();  	if (triggerType.Equals (TriggerTypeBlob)) {  		using (IDbCommand cmd2 = PrepareCommand (conn' ReplaceTablePrefix (SqlSelectBlobTrigger))) {  			AddCommandParameter (cmd2' "triggerName"' triggerKey.Name);  			AddCommandParameter (cmd2' "triggerGroup"' triggerKey.Group);  			using (IDataReader rs2 = cmd2.ExecuteReader ()) {  				if (rs2.Read ()) {  					trigger = GetObjectFromBlob<IOperableTrigger> (rs2' 0);  				}  			}  		}  	}  	else {  		ITriggerPersistenceDelegate tDel = FindTriggerPersistenceDelegate (triggerType);  		if (tDel == null) {  			throw new JobPersistenceException ("No TriggerPersistenceDelegate for trigger discriminator type: " + triggerType);  		}  		TriggerPropertyBundle triggerProps = tDel.LoadExtendedTriggerProperties (conn' triggerKey);  		TriggerBuilder tb = TriggerBuilder.Create ().WithDescription (description).WithPriority (priority).StartAt (startTimeUtc).EndAt (endTimeUtc).WithIdentity (triggerKey).ModifiedByCalendar (calendarName).WithSchedule (triggerProps.ScheduleBuilder).ForJob (new JobKey (jobName' jobGroup));  		if (map != null) {  			tb.UsingJobData (map as JobDataMap ?? new JobDataMap (map));  		}  		trigger = (IOperableTrigger)tb.Build ();  		trigger.MisfireInstruction = misFireInstr;  		trigger.SetNextFireTimeUtc (nextFireTimeUtc);  		trigger.SetPreviousFireTimeUtc (previousFireTimeUtc);  		SetTriggerStateProperties (trigger' triggerProps);  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			bool found;  			using (IDataReader rs = cmd.ExecuteReader ()) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  				}  				found = rs.Read ();  			}  			if (!found) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			bool found;  			using (IDataReader rs = cmd.ExecuteReader ()) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  				}  				found = rs.Read ();  			}  			if (!found) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			bool found;  			using (IDataReader rs = cmd.ExecuteReader ()) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  				}  				found = rs.Read ();  			}  			if (!found) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			bool found;  			using (IDataReader rs = cmd.ExecuteReader ()) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  				}  				found = rs.Read ();  			}  			if (!found) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: try {  	using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  		AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  		bool found;  		using (IDataReader rs = cmd.ExecuteReader ()) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			found = rs.Read ();  		}  		if (!found) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  			}  			using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  				AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  				int res = cmd2.ExecuteNonQuery ();  				if (res != 1) {  					if (count < 3) {  						// pause a bit to give another thread some time to commit the insert of the new lock row  						try {  							Thread.Sleep (TimeSpan.FromSeconds (1));  						}  						catch (ThreadInterruptedException) {  							Thread.CurrentThread.Interrupt ();  						}  						// try again ...  						continue;  					}  					throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  				}  			}  			break;  			// obtained lock' no need to retry  		}  	}  }  catch (Exception sqle) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  	}  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: try {  	using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  		AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  		bool found;  		using (IDataReader rs = cmd.ExecuteReader ()) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			found = rs.Read ();  		}  		if (!found) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  			}  			using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  				AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  				int res = cmd2.ExecuteNonQuery ();  				if (res != 1) {  					if (count < 3) {  						// pause a bit to give another thread some time to commit the insert of the new lock row  						try {  							Thread.Sleep (TimeSpan.FromSeconds (1));  						}  						catch (ThreadInterruptedException) {  							Thread.CurrentThread.Interrupt ();  						}  						// try again ...  						continue;  					}  					throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  				}  			}  			break;  			// obtained lock' no need to retry  		}  	}  }  catch (Exception sqle) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  	}  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: try {  	using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  		AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  		bool found;  		using (IDataReader rs = cmd.ExecuteReader ()) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			found = rs.Read ();  		}  		if (!found) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  			}  			using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  				AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  				int res = cmd2.ExecuteNonQuery ();  				if (res != 1) {  					if (count < 3) {  						// pause a bit to give another thread some time to commit the insert of the new lock row  						try {  							Thread.Sleep (TimeSpan.FromSeconds (1));  						}  						catch (ThreadInterruptedException) {  							Thread.CurrentThread.Interrupt ();  						}  						// try again ...  						continue;  					}  					throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  				}  			}  			break;  			// obtained lock' no need to retry  		}  	}  }  catch (Exception sqle) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  	}  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  	AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  	bool found;  	using (IDataReader rs = cmd.ExecuteReader ()) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  		}  		found = rs.Read ();  	}  	if (!found) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  		}  		using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  			AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  			int res = cmd2.ExecuteNonQuery ();  			if (res != 1) {  				if (count < 3) {  					// pause a bit to give another thread some time to commit the insert of the new lock row  					try {  						Thread.Sleep (TimeSpan.FromSeconds (1));  					}  					catch (ThreadInterruptedException) {  						Thread.CurrentThread.Interrupt ();  					}  					// try again ...  					continue;  				}  				throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  			}  		}  		break;  		// obtained lock' no need to retry  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (!found) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  	}  	using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  		AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  		int res = cmd2.ExecuteNonQuery ();  		if (res != 1) {  			if (count < 3) {  				// pause a bit to give another thread some time to commit the insert of the new lock row  				try {  					Thread.Sleep (TimeSpan.FromSeconds (1));  				}  				catch (ThreadInterruptedException) {  					Thread.CurrentThread.Interrupt ();  				}  				// try again ...  				continue;  			}  			throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  		}  	}  	break;  	// obtained lock' no need to retry  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  	AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  	int res = cmd2.ExecuteNonQuery ();  	if (res != 1) {  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (res != 1) {  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (count < 3) {  	// pause a bit to give another thread some time to commit the insert of the new lock row  	try {  		Thread.Sleep (TimeSpan.FromSeconds (1));  	}  	catch (ThreadInterruptedException) {  		Thread.CurrentThread.Interrupt ();  	}  	// try again ...  	continue;  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (Log.IsDebugEnabled) {  	Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  }  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  
Magic Number,Quartz.Impl.AdoJobStore,StdRowLockSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\StdRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (count < 3) {  	// pause a bit to give another thread some time to commit the insert of the new lock row  	try {  		Thread.Sleep (TimeSpan.FromSeconds (1));  	}  	catch (ThreadInterruptedException) {  		Thread.CurrentThread.Interrupt ();  	}  	// try again ...  	continue;  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			int numUpdate = cmd.ExecuteNonQuery ();  			if (numUpdate < 1) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			int numUpdate = cmd.ExecuteNonQuery ();  			if (numUpdate < 1) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			int numUpdate = cmd.ExecuteNonQuery ();  			if (numUpdate < 1) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: do {  	count++;  	try {  		using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  			AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  			}  			int numUpdate = cmd.ExecuteNonQuery ();  			if (numUpdate < 1) {  				if (Log.IsDebugEnabled) {  					Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  				}  				using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  					AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  					int res = cmd2.ExecuteNonQuery ();  					if (res != 1) {  						if (count < 3) {  							// pause a bit to give another thread some time to commit the insert of the new lock row  							try {  								Thread.Sleep (TimeSpan.FromSeconds (1));  							}  							catch (ThreadInterruptedException) {  								Thread.CurrentThread.Interrupt ();  							}  							// try again ...  							continue;  						}  						throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  					}  				}  				break;  				// obtained lock' no need to retry  			}  		}  	}  	catch (Exception sqle) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  		}  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  	}  }  while (count < 2);  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: try {  	using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  		AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  		}  		int numUpdate = cmd.ExecuteNonQuery ();  		if (numUpdate < 1) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  			}  			using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  				AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  				int res = cmd2.ExecuteNonQuery ();  				if (res != 1) {  					if (count < 3) {  						// pause a bit to give another thread some time to commit the insert of the new lock row  						try {  							Thread.Sleep (TimeSpan.FromSeconds (1));  						}  						catch (ThreadInterruptedException) {  							Thread.CurrentThread.Interrupt ();  						}  						// try again ...  						continue;  					}  					throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  				}  			}  			break;  			// obtained lock' no need to retry  		}  	}  }  catch (Exception sqle) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  	}  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: try {  	using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  		AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  		}  		int numUpdate = cmd.ExecuteNonQuery ();  		if (numUpdate < 1) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  			}  			using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  				AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  				int res = cmd2.ExecuteNonQuery ();  				if (res != 1) {  					if (count < 3) {  						// pause a bit to give another thread some time to commit the insert of the new lock row  						try {  							Thread.Sleep (TimeSpan.FromSeconds (1));  						}  						catch (ThreadInterruptedException) {  							Thread.CurrentThread.Interrupt ();  						}  						// try again ...  						continue;  					}  					throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  				}  			}  			break;  			// obtained lock' no need to retry  		}  	}  }  catch (Exception sqle) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  	}  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: try {  	using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  		AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  		}  		int numUpdate = cmd.ExecuteNonQuery ();  		if (numUpdate < 1) {  			if (Log.IsDebugEnabled) {  				Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  			}  			using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  				AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  				int res = cmd2.ExecuteNonQuery ();  				if (res != 1) {  					if (count < 3) {  						// pause a bit to give another thread some time to commit the insert of the new lock row  						try {  							Thread.Sleep (TimeSpan.FromSeconds (1));  						}  						catch (ThreadInterruptedException) {  							Thread.CurrentThread.Interrupt ();  						}  						// try again ...  						continue;  					}  					throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  				}  			}  			break;  			// obtained lock' no need to retry  		}  	}  }  catch (Exception sqle) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  	}  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new LockException ("Failure obtaining db row lock: " + sqle.Message' sqle);  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: using (IDbCommand cmd = AdoUtil.PrepareCommand (conn' expandedSQL)) {  	AdoUtil.AddCommandParameter (cmd' "lockName"' lockName);  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Lock '{0}' is being obtained: {1}"' lockName' Thread.CurrentThread.Name);  	}  	int numUpdate = cmd.ExecuteNonQuery ();  	if (numUpdate < 1) {  		if (Log.IsDebugEnabled) {  			Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  		}  		using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  			AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  			int res = cmd2.ExecuteNonQuery ();  			if (res != 1) {  				if (count < 3) {  					// pause a bit to give another thread some time to commit the insert of the new lock row  					try {  						Thread.Sleep (TimeSpan.FromSeconds (1));  					}  					catch (ThreadInterruptedException) {  						Thread.CurrentThread.Interrupt ();  					}  					// try again ...  					continue;  				}  				throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  			}  		}  		break;  		// obtained lock' no need to retry  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (numUpdate < 1) {  	if (Log.IsDebugEnabled) {  		Log.DebugFormat ("Inserting new lock row for lock: '{0}' being obtained by thread: {1}"' lockName' Thread.CurrentThread.Name);  	}  	using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  		AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  		int res = cmd2.ExecuteNonQuery ();  		if (res != 1) {  			if (count < 3) {  				// pause a bit to give another thread some time to commit the insert of the new lock row  				try {  					Thread.Sleep (TimeSpan.FromSeconds (1));  				}  				catch (ThreadInterruptedException) {  					Thread.CurrentThread.Interrupt ();  				}  				// try again ...  				continue;  			}  			throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  		}  	}  	break;  	// obtained lock' no need to retry  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: using (IDbCommand cmd2 = AdoUtil.PrepareCommand (conn' expandedInsertSQL)) {  	AdoUtil.AddCommandParameter (cmd2' "lockName"' lockName);  	int res = cmd2.ExecuteNonQuery ();  	if (res != 1) {  		if (count < 3) {  			// pause a bit to give another thread some time to commit the insert of the new lock row  			try {  				Thread.Sleep (TimeSpan.FromSeconds (1));  			}  			catch (ThreadInterruptedException) {  				Thread.CurrentThread.Interrupt ();  			}  			// try again ...  			continue;  		}  		throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  	}  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (res != 1) {  	if (count < 3) {  		// pause a bit to give another thread some time to commit the insert of the new lock row  		try {  			Thread.Sleep (TimeSpan.FromSeconds (1));  		}  		catch (ThreadInterruptedException) {  			Thread.CurrentThread.Interrupt ();  		}  		// try again ...  		continue;  	}  	throw new Exception (AdoJobStoreUtil.ReplaceTablePrefix ("No row exists' and one could not be inserted in table " + TablePrefixSubst + TableLocks + " for lock named: " + lockName' TablePrefix' SchedulerNameLiteral));  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (count < 3) {  	// pause a bit to give another thread some time to commit the insert of the new lock row  	try {  		Thread.Sleep (TimeSpan.FromSeconds (1));  	}  	catch (ThreadInterruptedException) {  		Thread.CurrentThread.Interrupt ();  	}  	// try again ...  	continue;  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (Log.IsDebugEnabled) {  	Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  }  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: Log.DebugFormat ("Lock '{0}' was not obtained by: {1}{2}"' lockName' Thread.CurrentThread.Name' (count < 3 ? " - will try again." : ""));  
Magic Number,Quartz.Impl.AdoJobStore,UpdateLockRowSemaphore,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\AdoJobStore\UpdateRowLockSemaphore.cs,ExecuteSQL,The following statement contains a magic number: if (count < 3) {  	// pause a bit to give another thread some time to commit the insert of the new lock row  	try {  		Thread.Sleep (TimeSpan.FromSeconds (1));  	}  	catch (ThreadInterruptedException) {  		Thread.CurrentThread.Interrupt ();  	}  	// try again ...  	continue;  }  
Magic Number,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,CompleteTriggerRetryLoop,The following statement contains a magic number: while (!shutdownRequested && !qs.IsShuttingDown) {  	try {  		Thread.Sleep (qs.DbRetryInterval);  		// retry per config setting (the db connection must be failed)  		qs.NotifyJobStoreJobComplete (trigger' jobDetail' instCode);  		return true;  	}  	catch (JobPersistenceException jpe) {  		if (count % 4 == 0)  			qs.NotifySchedulerListenersError ("An error occured while marking executed job complete (will continue attempts). job= '" + jobDetail.Key + "'"' jpe);  	}  	catch (ThreadInterruptedException) {  	}  	count++;  }  
Magic Number,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,CompleteTriggerRetryLoop,The following statement contains a magic number: try {  	Thread.Sleep (qs.DbRetryInterval);  	// retry per config setting (the db connection must be failed)  	qs.NotifyJobStoreJobComplete (trigger' jobDetail' instCode);  	return true;  }  catch (JobPersistenceException jpe) {  	if (count % 4 == 0)  		qs.NotifySchedulerListenersError ("An error occured while marking executed job complete (will continue attempts). job= '" + jobDetail.Key + "'"' jpe);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Core,JobRunShell,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\JobRunShell.cs,CompleteTriggerRetryLoop,The following statement contains a magic number: if (count % 4 == 0)  	qs.NotifySchedulerListenersError ("An error occured while marking executed job complete (will continue attempts). job= '" + jobDetail.Key + "'"' jpe);  
Magic Number,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The following statement contains a magic number: if (waitForJobsToComplete) {  	while (jobMgr.NumJobsCurrentlyExecuting > 0) {  		try {  			Thread.Sleep (100);  		}  		catch (ThreadInterruptedException) {  		}  	}  }  
Magic Number,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The following statement contains a magic number: while (jobMgr.NumJobsCurrentlyExecuting > 0) {  	try {  		Thread.Sleep (100);  	}  	catch (ThreadInterruptedException) {  	}  }  
Magic Number,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The following statement contains a magic number: try {  	Thread.Sleep (100);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,Shutdown,The following statement contains a magic number: Thread.Sleep (100);  
Magic Number,Quartz.Core,QuartzScheduler,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzScheduler.cs,NextLong,The following statement contains a magic number: temporaryLong = (temporaryLong << 32) + random.Next ();  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: while (!halted) {  	try {  		// check if we're supposed to pause...  		lock (sigLock) {  			while (paused && !halted) {  				try {  					// wait until togglePause(false) is called...  					Monitor.Wait (sigLock' 1000);  				}  				catch (ThreadInterruptedException) {  				}  			}  			if (halted) {  				break;  			}  		}  		int availThreadCount = qsRsrcs.ThreadPool.BlockForAvailableThreads ();  		if (availThreadCount > 0)// will always be true' due to semantics of blockForAvailableThreads...  		 {  			IList<IOperableTrigger> triggers = null;  			DateTimeOffset now = SystemTime.UtcNow ();  			ClearSignaledSchedulingChange ();  			try {  				triggers = qsRsrcs.JobStore.AcquireNextTriggers (now + idleWaitTime' Math.Min (availThreadCount' qsRsrcs.MaxBatchSize)' qsRsrcs.BatchTimeWindow);  				lastAcquireFailed = false;  				if (log.IsDebugEnabled) {  					log.DebugFormat ("Batch acquisition of {0} triggers"' (triggers == null ? 0 : triggers.Count));  				}  			}  			catch (JobPersistenceException jpe) {  				if (!lastAcquireFailed) {  					qs.NotifySchedulerListenersError ("An error occurred while scanning for the next trigger to fire."' jpe);  				}  				lastAcquireFailed = true;  			}  			catch (Exception e) {  				if (!lastAcquireFailed) {  					Log.Error ("quartzSchedulerThreadLoop: RuntimeException " + e.Message' e);  				}  				lastAcquireFailed = true;  			}  			if (triggers != null && triggers.Count > 0) {  				now = SystemTime.UtcNow ();  				DateTimeOffset triggerTime = triggers [0].GetNextFireTimeUtc ().Value;  				TimeSpan timeUntilTrigger = triggerTime - now;  				while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  					if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  						break;  					}  					lock (sigLock) {  						if (halted) {  							break;  						}  						if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  							try {  								// we could have blocked a long while  								// on 'synchronize'' so we must recompute  								now = SystemTime.UtcNow ();  								timeUntilTrigger = triggerTime - now;  								if (timeUntilTrigger > TimeSpan.Zero) {  									Monitor.Wait (sigLock' timeUntilTrigger);  								}  							}  							catch (ThreadInterruptedException) {  							}  						}  					}  					if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  						break;  					}  					now = SystemTime.UtcNow ();  					timeUntilTrigger = triggerTime - now;  				}  				// this happens if releaseIfScheduleChangedSignificantly decided to release triggers  				if (triggers.Count == 0) {  					continue;  				}  				// set triggers to 'executing'  				IList<TriggerFiredResult> bndles = new List<TriggerFiredResult> ();  				bool goAhead = true;  				lock (sigLock) {  					goAhead = !halted;  				}  				if (goAhead) {  					try {  						IList<TriggerFiredResult> res = qsRsrcs.JobStore.TriggersFired (triggers);  						if (res != null) {  							bndles = res;  						}  					}  					catch (SchedulerException se) {  						qs.NotifySchedulerListenersError ("An error occurred while firing triggers '" + triggers + "'"' se);  						// QTZ-179 : a problem occurred interacting with the triggers from the db  						// we release them and loop again  						foreach (IOperableTrigger t in triggers) {  							ReleaseTriggerRetryLoop (t);  						}  						continue;  					}  				}  				for (int i = 0; i < bndles.Count; i++) {  					TriggerFiredResult result = bndles [i];  					TriggerFiredBundle bndle = result.TriggerFiredBundle;  					Exception exception = result.Exception;  					IOperableTrigger trigger = triggers [i];  					// TODO SQL exception?  					if (exception != null && (exception is DbException || exception.InnerException is DbException)) {  						Log.Error ("DbException while firing trigger " + trigger' exception);  						// db connection must have failed... keep  						// retrying until it's up...  						ReleaseTriggerRetryLoop (trigger);  						continue;  					}  					// it's possible to get 'null' if the triggers was paused'  					// blocked' or other similar occurrences that prevent it being  					// fired at this time...  or if the scheduler was shutdown (halted)  					if (bndle == null) {  						try {  							qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  						}  						catch (SchedulerException se) {  							qs.NotifySchedulerListenersError ("An error occurred while releasing triggers '" + trigger.Key + "'"' se);  							// db connection must have failed... keep retrying  							// until it's up...  							ReleaseTriggerRetryLoop (trigger);  						}  						continue;  					}  					// TODO: improvements:  					//  					// 2- make sure we can get a job runshell before firing trigger' or  					//   don't let that throw an exception (right now it never does'  					//   but the signature says it can).  					// 3- acquire more triggers at a time (based on num threads available?)  					JobRunShell shell = null;  					try {  						shell = qsRsrcs.JobRunShellFactory.CreateJobRunShell (bndle);  						shell.Initialize (qs);  					}  					catch (SchedulerException) {  						try {  							qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  						}  						catch (SchedulerException se2) {  							qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2);  							// db connection must have failed... keep retrying  							// until it's up...  							ErrorTriggerRetryLoop (bndle);  						}  						continue;  					}  					if (qsRsrcs.ThreadPool.RunInThread (shell) == false) {  						try {  							// this case should never happen' as it is indicative of the  							// scheduler being shutdown or a bug in the thread pool or  							// a thread pool being used concurrently - which the docs  							// say not to do...  							Log.Error ("ThreadPool.runInThread() return false!");  							qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  						}  						catch (SchedulerException se2) {  							qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2);  							// db connection must have failed... keep retrying  							// until it's up...  							ReleaseTriggerRetryLoop (trigger);  						}  					}  				}  				continue;  				// while (!halted)  			}  		}  		else// if(availThreadCount > 0)  		 {  			// should never happen' if threadPool.blockForAvailableThreads() follows contract  			continue;  			// while (!halted)  		}  		DateTimeOffset utcNow = SystemTime.UtcNow ();  		DateTimeOffset waitTime = utcNow.Add (GetRandomizedIdleWaitTime ());  		TimeSpan timeUntilContinue = waitTime - utcNow;  		lock (sigLock) {  			if (!halted) {  				try {  					Monitor.Wait (sigLock' timeUntilContinue);  				}  				catch (ThreadInterruptedException) {  				}  			}  		}  	}  	catch (Exception re) {  		if (Log != null) {  			Log.Error ("Runtime error occurred in main trigger firing loop."' re);  		}  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: while (!halted) {  	try {  		// check if we're supposed to pause...  		lock (sigLock) {  			while (paused && !halted) {  				try {  					// wait until togglePause(false) is called...  					Monitor.Wait (sigLock' 1000);  				}  				catch (ThreadInterruptedException) {  				}  			}  			if (halted) {  				break;  			}  		}  		int availThreadCount = qsRsrcs.ThreadPool.BlockForAvailableThreads ();  		if (availThreadCount > 0)// will always be true' due to semantics of blockForAvailableThreads...  		 {  			IList<IOperableTrigger> triggers = null;  			DateTimeOffset now = SystemTime.UtcNow ();  			ClearSignaledSchedulingChange ();  			try {  				triggers = qsRsrcs.JobStore.AcquireNextTriggers (now + idleWaitTime' Math.Min (availThreadCount' qsRsrcs.MaxBatchSize)' qsRsrcs.BatchTimeWindow);  				lastAcquireFailed = false;  				if (log.IsDebugEnabled) {  					log.DebugFormat ("Batch acquisition of {0} triggers"' (triggers == null ? 0 : triggers.Count));  				}  			}  			catch (JobPersistenceException jpe) {  				if (!lastAcquireFailed) {  					qs.NotifySchedulerListenersError ("An error occurred while scanning for the next trigger to fire."' jpe);  				}  				lastAcquireFailed = true;  			}  			catch (Exception e) {  				if (!lastAcquireFailed) {  					Log.Error ("quartzSchedulerThreadLoop: RuntimeException " + e.Message' e);  				}  				lastAcquireFailed = true;  			}  			if (triggers != null && triggers.Count > 0) {  				now = SystemTime.UtcNow ();  				DateTimeOffset triggerTime = triggers [0].GetNextFireTimeUtc ().Value;  				TimeSpan timeUntilTrigger = triggerTime - now;  				while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  					if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  						break;  					}  					lock (sigLock) {  						if (halted) {  							break;  						}  						if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  							try {  								// we could have blocked a long while  								// on 'synchronize'' so we must recompute  								now = SystemTime.UtcNow ();  								timeUntilTrigger = triggerTime - now;  								if (timeUntilTrigger > TimeSpan.Zero) {  									Monitor.Wait (sigLock' timeUntilTrigger);  								}  							}  							catch (ThreadInterruptedException) {  							}  						}  					}  					if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  						break;  					}  					now = SystemTime.UtcNow ();  					timeUntilTrigger = triggerTime - now;  				}  				// this happens if releaseIfScheduleChangedSignificantly decided to release triggers  				if (triggers.Count == 0) {  					continue;  				}  				// set triggers to 'executing'  				IList<TriggerFiredResult> bndles = new List<TriggerFiredResult> ();  				bool goAhead = true;  				lock (sigLock) {  					goAhead = !halted;  				}  				if (goAhead) {  					try {  						IList<TriggerFiredResult> res = qsRsrcs.JobStore.TriggersFired (triggers);  						if (res != null) {  							bndles = res;  						}  					}  					catch (SchedulerException se) {  						qs.NotifySchedulerListenersError ("An error occurred while firing triggers '" + triggers + "'"' se);  						// QTZ-179 : a problem occurred interacting with the triggers from the db  						// we release them and loop again  						foreach (IOperableTrigger t in triggers) {  							ReleaseTriggerRetryLoop (t);  						}  						continue;  					}  				}  				for (int i = 0; i < bndles.Count; i++) {  					TriggerFiredResult result = bndles [i];  					TriggerFiredBundle bndle = result.TriggerFiredBundle;  					Exception exception = result.Exception;  					IOperableTrigger trigger = triggers [i];  					// TODO SQL exception?  					if (exception != null && (exception is DbException || exception.InnerException is DbException)) {  						Log.Error ("DbException while firing trigger " + trigger' exception);  						// db connection must have failed... keep  						// retrying until it's up...  						ReleaseTriggerRetryLoop (trigger);  						continue;  					}  					// it's possible to get 'null' if the triggers was paused'  					// blocked' or other similar occurrences that prevent it being  					// fired at this time...  or if the scheduler was shutdown (halted)  					if (bndle == null) {  						try {  							qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  						}  						catch (SchedulerException se) {  							qs.NotifySchedulerListenersError ("An error occurred while releasing triggers '" + trigger.Key + "'"' se);  							// db connection must have failed... keep retrying  							// until it's up...  							ReleaseTriggerRetryLoop (trigger);  						}  						continue;  					}  					// TODO: improvements:  					//  					// 2- make sure we can get a job runshell before firing trigger' or  					//   don't let that throw an exception (right now it never does'  					//   but the signature says it can).  					// 3- acquire more triggers at a time (based on num threads available?)  					JobRunShell shell = null;  					try {  						shell = qsRsrcs.JobRunShellFactory.CreateJobRunShell (bndle);  						shell.Initialize (qs);  					}  					catch (SchedulerException) {  						try {  							qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  						}  						catch (SchedulerException se2) {  							qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2);  							// db connection must have failed... keep retrying  							// until it's up...  							ErrorTriggerRetryLoop (bndle);  						}  						continue;  					}  					if (qsRsrcs.ThreadPool.RunInThread (shell) == false) {  						try {  							// this case should never happen' as it is indicative of the  							// scheduler being shutdown or a bug in the thread pool or  							// a thread pool being used concurrently - which the docs  							// say not to do...  							Log.Error ("ThreadPool.runInThread() return false!");  							qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  						}  						catch (SchedulerException se2) {  							qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2);  							// db connection must have failed... keep retrying  							// until it's up...  							ReleaseTriggerRetryLoop (trigger);  						}  					}  				}  				continue;  				// while (!halted)  			}  		}  		else// if(availThreadCount > 0)  		 {  			// should never happen' if threadPool.blockForAvailableThreads() follows contract  			continue;  			// while (!halted)  		}  		DateTimeOffset utcNow = SystemTime.UtcNow ();  		DateTimeOffset waitTime = utcNow.Add (GetRandomizedIdleWaitTime ());  		TimeSpan timeUntilContinue = waitTime - utcNow;  		lock (sigLock) {  			if (!halted) {  				try {  					Monitor.Wait (sigLock' timeUntilContinue);  				}  				catch (ThreadInterruptedException) {  				}  			}  		}  	}  	catch (Exception re) {  		if (Log != null) {  			Log.Error ("Runtime error occurred in main trigger firing loop."' re);  		}  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: try {  	// check if we're supposed to pause...  	lock (sigLock) {  		while (paused && !halted) {  			try {  				// wait until togglePause(false) is called...  				Monitor.Wait (sigLock' 1000);  			}  			catch (ThreadInterruptedException) {  			}  		}  		if (halted) {  			break;  		}  	}  	int availThreadCount = qsRsrcs.ThreadPool.BlockForAvailableThreads ();  	if (availThreadCount > 0)// will always be true' due to semantics of blockForAvailableThreads...  	 {  		IList<IOperableTrigger> triggers = null;  		DateTimeOffset now = SystemTime.UtcNow ();  		ClearSignaledSchedulingChange ();  		try {  			triggers = qsRsrcs.JobStore.AcquireNextTriggers (now + idleWaitTime' Math.Min (availThreadCount' qsRsrcs.MaxBatchSize)' qsRsrcs.BatchTimeWindow);  			lastAcquireFailed = false;  			if (log.IsDebugEnabled) {  				log.DebugFormat ("Batch acquisition of {0} triggers"' (triggers == null ? 0 : triggers.Count));  			}  		}  		catch (JobPersistenceException jpe) {  			if (!lastAcquireFailed) {  				qs.NotifySchedulerListenersError ("An error occurred while scanning for the next trigger to fire."' jpe);  			}  			lastAcquireFailed = true;  		}  		catch (Exception e) {  			if (!lastAcquireFailed) {  				Log.Error ("quartzSchedulerThreadLoop: RuntimeException " + e.Message' e);  			}  			lastAcquireFailed = true;  		}  		if (triggers != null && triggers.Count > 0) {  			now = SystemTime.UtcNow ();  			DateTimeOffset triggerTime = triggers [0].GetNextFireTimeUtc ().Value;  			TimeSpan timeUntilTrigger = triggerTime - now;  			while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  				if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  					break;  				}  				lock (sigLock) {  					if (halted) {  						break;  					}  					if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  						try {  							// we could have blocked a long while  							// on 'synchronize'' so we must recompute  							now = SystemTime.UtcNow ();  							timeUntilTrigger = triggerTime - now;  							if (timeUntilTrigger > TimeSpan.Zero) {  								Monitor.Wait (sigLock' timeUntilTrigger);  							}  						}  						catch (ThreadInterruptedException) {  						}  					}  				}  				if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  					break;  				}  				now = SystemTime.UtcNow ();  				timeUntilTrigger = triggerTime - now;  			}  			// this happens if releaseIfScheduleChangedSignificantly decided to release triggers  			if (triggers.Count == 0) {  				continue;  			}  			// set triggers to 'executing'  			IList<TriggerFiredResult> bndles = new List<TriggerFiredResult> ();  			bool goAhead = true;  			lock (sigLock) {  				goAhead = !halted;  			}  			if (goAhead) {  				try {  					IList<TriggerFiredResult> res = qsRsrcs.JobStore.TriggersFired (triggers);  					if (res != null) {  						bndles = res;  					}  				}  				catch (SchedulerException se) {  					qs.NotifySchedulerListenersError ("An error occurred while firing triggers '" + triggers + "'"' se);  					// QTZ-179 : a problem occurred interacting with the triggers from the db  					// we release them and loop again  					foreach (IOperableTrigger t in triggers) {  						ReleaseTriggerRetryLoop (t);  					}  					continue;  				}  			}  			for (int i = 0; i < bndles.Count; i++) {  				TriggerFiredResult result = bndles [i];  				TriggerFiredBundle bndle = result.TriggerFiredBundle;  				Exception exception = result.Exception;  				IOperableTrigger trigger = triggers [i];  				// TODO SQL exception?  				if (exception != null && (exception is DbException || exception.InnerException is DbException)) {  					Log.Error ("DbException while firing trigger " + trigger' exception);  					// db connection must have failed... keep  					// retrying until it's up...  					ReleaseTriggerRetryLoop (trigger);  					continue;  				}  				// it's possible to get 'null' if the triggers was paused'  				// blocked' or other similar occurrences that prevent it being  				// fired at this time...  or if the scheduler was shutdown (halted)  				if (bndle == null) {  					try {  						qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  					}  					catch (SchedulerException se) {  						qs.NotifySchedulerListenersError ("An error occurred while releasing triggers '" + trigger.Key + "'"' se);  						// db connection must have failed... keep retrying  						// until it's up...  						ReleaseTriggerRetryLoop (trigger);  					}  					continue;  				}  				// TODO: improvements:  				//  				// 2- make sure we can get a job runshell before firing trigger' or  				//   don't let that throw an exception (right now it never does'  				//   but the signature says it can).  				// 3- acquire more triggers at a time (based on num threads available?)  				JobRunShell shell = null;  				try {  					shell = qsRsrcs.JobRunShellFactory.CreateJobRunShell (bndle);  					shell.Initialize (qs);  				}  				catch (SchedulerException) {  					try {  						qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  					}  					catch (SchedulerException se2) {  						qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2);  						// db connection must have failed... keep retrying  						// until it's up...  						ErrorTriggerRetryLoop (bndle);  					}  					continue;  				}  				if (qsRsrcs.ThreadPool.RunInThread (shell) == false) {  					try {  						// this case should never happen' as it is indicative of the  						// scheduler being shutdown or a bug in the thread pool or  						// a thread pool being used concurrently - which the docs  						// say not to do...  						Log.Error ("ThreadPool.runInThread() return false!");  						qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  					}  					catch (SchedulerException se2) {  						qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2);  						// db connection must have failed... keep retrying  						// until it's up...  						ReleaseTriggerRetryLoop (trigger);  					}  				}  			}  			continue;  			// while (!halted)  		}  	}  	else// if(availThreadCount > 0)  	 {  		// should never happen' if threadPool.blockForAvailableThreads() follows contract  		continue;  		// while (!halted)  	}  	DateTimeOffset utcNow = SystemTime.UtcNow ();  	DateTimeOffset waitTime = utcNow.Add (GetRandomizedIdleWaitTime ());  	TimeSpan timeUntilContinue = waitTime - utcNow;  	lock (sigLock) {  		if (!halted) {  			try {  				Monitor.Wait (sigLock' timeUntilContinue);  			}  			catch (ThreadInterruptedException) {  			}  		}  	}  }  catch (Exception re) {  	if (Log != null) {  		Log.Error ("Runtime error occurred in main trigger firing loop."' re);  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: try {  	// check if we're supposed to pause...  	lock (sigLock) {  		while (paused && !halted) {  			try {  				// wait until togglePause(false) is called...  				Monitor.Wait (sigLock' 1000);  			}  			catch (ThreadInterruptedException) {  			}  		}  		if (halted) {  			break;  		}  	}  	int availThreadCount = qsRsrcs.ThreadPool.BlockForAvailableThreads ();  	if (availThreadCount > 0)// will always be true' due to semantics of blockForAvailableThreads...  	 {  		IList<IOperableTrigger> triggers = null;  		DateTimeOffset now = SystemTime.UtcNow ();  		ClearSignaledSchedulingChange ();  		try {  			triggers = qsRsrcs.JobStore.AcquireNextTriggers (now + idleWaitTime' Math.Min (availThreadCount' qsRsrcs.MaxBatchSize)' qsRsrcs.BatchTimeWindow);  			lastAcquireFailed = false;  			if (log.IsDebugEnabled) {  				log.DebugFormat ("Batch acquisition of {0} triggers"' (triggers == null ? 0 : triggers.Count));  			}  		}  		catch (JobPersistenceException jpe) {  			if (!lastAcquireFailed) {  				qs.NotifySchedulerListenersError ("An error occurred while scanning for the next trigger to fire."' jpe);  			}  			lastAcquireFailed = true;  		}  		catch (Exception e) {  			if (!lastAcquireFailed) {  				Log.Error ("quartzSchedulerThreadLoop: RuntimeException " + e.Message' e);  			}  			lastAcquireFailed = true;  		}  		if (triggers != null && triggers.Count > 0) {  			now = SystemTime.UtcNow ();  			DateTimeOffset triggerTime = triggers [0].GetNextFireTimeUtc ().Value;  			TimeSpan timeUntilTrigger = triggerTime - now;  			while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  				if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  					break;  				}  				lock (sigLock) {  					if (halted) {  						break;  					}  					if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  						try {  							// we could have blocked a long while  							// on 'synchronize'' so we must recompute  							now = SystemTime.UtcNow ();  							timeUntilTrigger = triggerTime - now;  							if (timeUntilTrigger > TimeSpan.Zero) {  								Monitor.Wait (sigLock' timeUntilTrigger);  							}  						}  						catch (ThreadInterruptedException) {  						}  					}  				}  				if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  					break;  				}  				now = SystemTime.UtcNow ();  				timeUntilTrigger = triggerTime - now;  			}  			// this happens if releaseIfScheduleChangedSignificantly decided to release triggers  			if (triggers.Count == 0) {  				continue;  			}  			// set triggers to 'executing'  			IList<TriggerFiredResult> bndles = new List<TriggerFiredResult> ();  			bool goAhead = true;  			lock (sigLock) {  				goAhead = !halted;  			}  			if (goAhead) {  				try {  					IList<TriggerFiredResult> res = qsRsrcs.JobStore.TriggersFired (triggers);  					if (res != null) {  						bndles = res;  					}  				}  				catch (SchedulerException se) {  					qs.NotifySchedulerListenersError ("An error occurred while firing triggers '" + triggers + "'"' se);  					// QTZ-179 : a problem occurred interacting with the triggers from the db  					// we release them and loop again  					foreach (IOperableTrigger t in triggers) {  						ReleaseTriggerRetryLoop (t);  					}  					continue;  				}  			}  			for (int i = 0; i < bndles.Count; i++) {  				TriggerFiredResult result = bndles [i];  				TriggerFiredBundle bndle = result.TriggerFiredBundle;  				Exception exception = result.Exception;  				IOperableTrigger trigger = triggers [i];  				// TODO SQL exception?  				if (exception != null && (exception is DbException || exception.InnerException is DbException)) {  					Log.Error ("DbException while firing trigger " + trigger' exception);  					// db connection must have failed... keep  					// retrying until it's up...  					ReleaseTriggerRetryLoop (trigger);  					continue;  				}  				// it's possible to get 'null' if the triggers was paused'  				// blocked' or other similar occurrences that prevent it being  				// fired at this time...  or if the scheduler was shutdown (halted)  				if (bndle == null) {  					try {  						qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  					}  					catch (SchedulerException se) {  						qs.NotifySchedulerListenersError ("An error occurred while releasing triggers '" + trigger.Key + "'"' se);  						// db connection must have failed... keep retrying  						// until it's up...  						ReleaseTriggerRetryLoop (trigger);  					}  					continue;  				}  				// TODO: improvements:  				//  				// 2- make sure we can get a job runshell before firing trigger' or  				//   don't let that throw an exception (right now it never does'  				//   but the signature says it can).  				// 3- acquire more triggers at a time (based on num threads available?)  				JobRunShell shell = null;  				try {  					shell = qsRsrcs.JobRunShellFactory.CreateJobRunShell (bndle);  					shell.Initialize (qs);  				}  				catch (SchedulerException) {  					try {  						qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  					}  					catch (SchedulerException se2) {  						qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2);  						// db connection must have failed... keep retrying  						// until it's up...  						ErrorTriggerRetryLoop (bndle);  					}  					continue;  				}  				if (qsRsrcs.ThreadPool.RunInThread (shell) == false) {  					try {  						// this case should never happen' as it is indicative of the  						// scheduler being shutdown or a bug in the thread pool or  						// a thread pool being used concurrently - which the docs  						// say not to do...  						Log.Error ("ThreadPool.runInThread() return false!");  						qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  					}  					catch (SchedulerException se2) {  						qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2);  						// db connection must have failed... keep retrying  						// until it's up...  						ReleaseTriggerRetryLoop (trigger);  					}  				}  			}  			continue;  			// while (!halted)  		}  	}  	else// if(availThreadCount > 0)  	 {  		// should never happen' if threadPool.blockForAvailableThreads() follows contract  		continue;  		// while (!halted)  	}  	DateTimeOffset utcNow = SystemTime.UtcNow ();  	DateTimeOffset waitTime = utcNow.Add (GetRandomizedIdleWaitTime ());  	TimeSpan timeUntilContinue = waitTime - utcNow;  	lock (sigLock) {  		if (!halted) {  			try {  				Monitor.Wait (sigLock' timeUntilContinue);  			}  			catch (ThreadInterruptedException) {  			}  		}  	}  }  catch (Exception re) {  	if (Log != null) {  		Log.Error ("Runtime error occurred in main trigger firing loop."' re);  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: lock (sigLock) {  	while (paused && !halted) {  		try {  			// wait until togglePause(false) is called...  			Monitor.Wait (sigLock' 1000);  		}  		catch (ThreadInterruptedException) {  		}  	}  	if (halted) {  		break;  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: while (paused && !halted) {  	try {  		// wait until togglePause(false) is called...  		Monitor.Wait (sigLock' 1000);  	}  	catch (ThreadInterruptedException) {  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: try {  	// wait until togglePause(false) is called...  	Monitor.Wait (sigLock' 1000);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: Monitor.Wait (sigLock' 1000);  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: if (availThreadCount > 0)// will always be true' due to semantics of blockForAvailableThreads...   {  	IList<IOperableTrigger> triggers = null;  	DateTimeOffset now = SystemTime.UtcNow ();  	ClearSignaledSchedulingChange ();  	try {  		triggers = qsRsrcs.JobStore.AcquireNextTriggers (now + idleWaitTime' Math.Min (availThreadCount' qsRsrcs.MaxBatchSize)' qsRsrcs.BatchTimeWindow);  		lastAcquireFailed = false;  		if (log.IsDebugEnabled) {  			log.DebugFormat ("Batch acquisition of {0} triggers"' (triggers == null ? 0 : triggers.Count));  		}  	}  	catch (JobPersistenceException jpe) {  		if (!lastAcquireFailed) {  			qs.NotifySchedulerListenersError ("An error occurred while scanning for the next trigger to fire."' jpe);  		}  		lastAcquireFailed = true;  	}  	catch (Exception e) {  		if (!lastAcquireFailed) {  			Log.Error ("quartzSchedulerThreadLoop: RuntimeException " + e.Message' e);  		}  		lastAcquireFailed = true;  	}  	if (triggers != null && triggers.Count > 0) {  		now = SystemTime.UtcNow ();  		DateTimeOffset triggerTime = triggers [0].GetNextFireTimeUtc ().Value;  		TimeSpan timeUntilTrigger = triggerTime - now;  		while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  			if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  				break;  			}  			lock (sigLock) {  				if (halted) {  					break;  				}  				if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  					try {  						// we could have blocked a long while  						// on 'synchronize'' so we must recompute  						now = SystemTime.UtcNow ();  						timeUntilTrigger = triggerTime - now;  						if (timeUntilTrigger > TimeSpan.Zero) {  							Monitor.Wait (sigLock' timeUntilTrigger);  						}  					}  					catch (ThreadInterruptedException) {  					}  				}  			}  			if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  				break;  			}  			now = SystemTime.UtcNow ();  			timeUntilTrigger = triggerTime - now;  		}  		// this happens if releaseIfScheduleChangedSignificantly decided to release triggers  		if (triggers.Count == 0) {  			continue;  		}  		// set triggers to 'executing'  		IList<TriggerFiredResult> bndles = new List<TriggerFiredResult> ();  		bool goAhead = true;  		lock (sigLock) {  			goAhead = !halted;  		}  		if (goAhead) {  			try {  				IList<TriggerFiredResult> res = qsRsrcs.JobStore.TriggersFired (triggers);  				if (res != null) {  					bndles = res;  				}  			}  			catch (SchedulerException se) {  				qs.NotifySchedulerListenersError ("An error occurred while firing triggers '" + triggers + "'"' se);  				// QTZ-179 : a problem occurred interacting with the triggers from the db  				// we release them and loop again  				foreach (IOperableTrigger t in triggers) {  					ReleaseTriggerRetryLoop (t);  				}  				continue;  			}  		}  		for (int i = 0; i < bndles.Count; i++) {  			TriggerFiredResult result = bndles [i];  			TriggerFiredBundle bndle = result.TriggerFiredBundle;  			Exception exception = result.Exception;  			IOperableTrigger trigger = triggers [i];  			// TODO SQL exception?  			if (exception != null && (exception is DbException || exception.InnerException is DbException)) {  				Log.Error ("DbException while firing trigger " + trigger' exception);  				// db connection must have failed... keep  				// retrying until it's up...  				ReleaseTriggerRetryLoop (trigger);  				continue;  			}  			// it's possible to get 'null' if the triggers was paused'  			// blocked' or other similar occurrences that prevent it being  			// fired at this time...  or if the scheduler was shutdown (halted)  			if (bndle == null) {  				try {  					qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  				}  				catch (SchedulerException se) {  					qs.NotifySchedulerListenersError ("An error occurred while releasing triggers '" + trigger.Key + "'"' se);  					// db connection must have failed... keep retrying  					// until it's up...  					ReleaseTriggerRetryLoop (trigger);  				}  				continue;  			}  			// TODO: improvements:  			//  			// 2- make sure we can get a job runshell before firing trigger' or  			//   don't let that throw an exception (right now it never does'  			//   but the signature says it can).  			// 3- acquire more triggers at a time (based on num threads available?)  			JobRunShell shell = null;  			try {  				shell = qsRsrcs.JobRunShellFactory.CreateJobRunShell (bndle);  				shell.Initialize (qs);  			}  			catch (SchedulerException) {  				try {  					qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  				}  				catch (SchedulerException se2) {  					qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2);  					// db connection must have failed... keep retrying  					// until it's up...  					ErrorTriggerRetryLoop (bndle);  				}  				continue;  			}  			if (qsRsrcs.ThreadPool.RunInThread (shell) == false) {  				try {  					// this case should never happen' as it is indicative of the  					// scheduler being shutdown or a bug in the thread pool or  					// a thread pool being used concurrently - which the docs  					// say not to do...  					Log.Error ("ThreadPool.runInThread() return false!");  					qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  				}  				catch (SchedulerException se2) {  					qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2);  					// db connection must have failed... keep retrying  					// until it's up...  					ReleaseTriggerRetryLoop (trigger);  				}  			}  		}  		continue;  		// while (!halted)  	}  }  else// if(availThreadCount > 0)   {  	// should never happen' if threadPool.blockForAvailableThreads() follows contract  	continue;  	// while (!halted)  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: if (triggers != null && triggers.Count > 0) {  	now = SystemTime.UtcNow ();  	DateTimeOffset triggerTime = triggers [0].GetNextFireTimeUtc ().Value;  	TimeSpan timeUntilTrigger = triggerTime - now;  	while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  		if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  			break;  		}  		lock (sigLock) {  			if (halted) {  				break;  			}  			if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  				try {  					// we could have blocked a long while  					// on 'synchronize'' so we must recompute  					now = SystemTime.UtcNow ();  					timeUntilTrigger = triggerTime - now;  					if (timeUntilTrigger > TimeSpan.Zero) {  						Monitor.Wait (sigLock' timeUntilTrigger);  					}  				}  				catch (ThreadInterruptedException) {  				}  			}  		}  		if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  			break;  		}  		now = SystemTime.UtcNow ();  		timeUntilTrigger = triggerTime - now;  	}  	// this happens if releaseIfScheduleChangedSignificantly decided to release triggers  	if (triggers.Count == 0) {  		continue;  	}  	// set triggers to 'executing'  	IList<TriggerFiredResult> bndles = new List<TriggerFiredResult> ();  	bool goAhead = true;  	lock (sigLock) {  		goAhead = !halted;  	}  	if (goAhead) {  		try {  			IList<TriggerFiredResult> res = qsRsrcs.JobStore.TriggersFired (triggers);  			if (res != null) {  				bndles = res;  			}  		}  		catch (SchedulerException se) {  			qs.NotifySchedulerListenersError ("An error occurred while firing triggers '" + triggers + "'"' se);  			// QTZ-179 : a problem occurred interacting with the triggers from the db  			// we release them and loop again  			foreach (IOperableTrigger t in triggers) {  				ReleaseTriggerRetryLoop (t);  			}  			continue;  		}  	}  	for (int i = 0; i < bndles.Count; i++) {  		TriggerFiredResult result = bndles [i];  		TriggerFiredBundle bndle = result.TriggerFiredBundle;  		Exception exception = result.Exception;  		IOperableTrigger trigger = triggers [i];  		// TODO SQL exception?  		if (exception != null && (exception is DbException || exception.InnerException is DbException)) {  			Log.Error ("DbException while firing trigger " + trigger' exception);  			// db connection must have failed... keep  			// retrying until it's up...  			ReleaseTriggerRetryLoop (trigger);  			continue;  		}  		// it's possible to get 'null' if the triggers was paused'  		// blocked' or other similar occurrences that prevent it being  		// fired at this time...  or if the scheduler was shutdown (halted)  		if (bndle == null) {  			try {  				qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  			}  			catch (SchedulerException se) {  				qs.NotifySchedulerListenersError ("An error occurred while releasing triggers '" + trigger.Key + "'"' se);  				// db connection must have failed... keep retrying  				// until it's up...  				ReleaseTriggerRetryLoop (trigger);  			}  			continue;  		}  		// TODO: improvements:  		//  		// 2- make sure we can get a job runshell before firing trigger' or  		//   don't let that throw an exception (right now it never does'  		//   but the signature says it can).  		// 3- acquire more triggers at a time (based on num threads available?)  		JobRunShell shell = null;  		try {  			shell = qsRsrcs.JobRunShellFactory.CreateJobRunShell (bndle);  			shell.Initialize (qs);  		}  		catch (SchedulerException) {  			try {  				qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  			}  			catch (SchedulerException se2) {  				qs.NotifySchedulerListenersError ("An error occurred while placing job's triggers in error state '" + trigger.Key + "'"' se2);  				// db connection must have failed... keep retrying  				// until it's up...  				ErrorTriggerRetryLoop (bndle);  			}  			continue;  		}  		if (qsRsrcs.ThreadPool.RunInThread (shell) == false) {  			try {  				// this case should never happen' as it is indicative of the  				// scheduler being shutdown or a bug in the thread pool or  				// a thread pool being used concurrently - which the docs  				// say not to do...  				Log.Error ("ThreadPool.runInThread() return false!");  				qsRsrcs.JobStore.TriggeredJobComplete (trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  			}  			catch (SchedulerException se2) {  				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while placing job's triggers in error state '{0}'"' trigger.Key)' se2);  				// db connection must have failed... keep retrying  				// until it's up...  				ReleaseTriggerRetryLoop (trigger);  			}  		}  	}  	continue;  	// while (!halted)  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,Run,The following statement contains a magic number: while (timeUntilTrigger > TimeSpan.FromMilliseconds (2)) {  	if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  		break;  	}  	lock (sigLock) {  		if (halted) {  			break;  		}  		if (!IsCandidateNewTimeEarlierWithinReason (triggerTime' false)) {  			try {  				// we could have blocked a long while  				// on 'synchronize'' so we must recompute  				now = SystemTime.UtcNow ();  				timeUntilTrigger = triggerTime - now;  				if (timeUntilTrigger > TimeSpan.Zero) {  					Monitor.Wait (sigLock' timeUntilTrigger);  				}  			}  			catch (ThreadInterruptedException) {  			}  		}  	}  	if (ReleaseIfScheduleChangedSignificantly (triggers' triggerTime)) {  		break;  	}  	now = SystemTime.UtcNow ();  	timeUntilTrigger = triggerTime - now;  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,IsCandidateNewTimeEarlierWithinReason,The following statement contains a magic number: lock (sigLock) {  	if (!IsScheduleChanged ()) {  		return false;  	}  	bool earlier = false;  	if (!GetSignaledNextFireTimeUtc ().HasValue) {  		earlier = true;  	}  	else if (GetSignaledNextFireTimeUtc ().Value < oldTimeUtc) {  		earlier = true;  	}  	if (earlier) {  		// so the new time is considered earlier' but is it enough earlier?  		TimeSpan diff = oldTimeUtc - SystemTime.UtcNow ();  		if (diff < (qsRsrcs.JobStore.SupportsPersistence ? TimeSpan.FromMilliseconds (70) : TimeSpan.FromMilliseconds (7))) {  			earlier = false;  		}  	}  	if (clearSignal) {  		ClearSignaledSchedulingChange ();  	}  	return earlier;  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,IsCandidateNewTimeEarlierWithinReason,The following statement contains a magic number: lock (sigLock) {  	if (!IsScheduleChanged ()) {  		return false;  	}  	bool earlier = false;  	if (!GetSignaledNextFireTimeUtc ().HasValue) {  		earlier = true;  	}  	else if (GetSignaledNextFireTimeUtc ().Value < oldTimeUtc) {  		earlier = true;  	}  	if (earlier) {  		// so the new time is considered earlier' but is it enough earlier?  		TimeSpan diff = oldTimeUtc - SystemTime.UtcNow ();  		if (diff < (qsRsrcs.JobStore.SupportsPersistence ? TimeSpan.FromMilliseconds (70) : TimeSpan.FromMilliseconds (7))) {  			earlier = false;  		}  	}  	if (clearSignal) {  		ClearSignaledSchedulingChange ();  	}  	return earlier;  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,IsCandidateNewTimeEarlierWithinReason,The following statement contains a magic number: if (earlier) {  	// so the new time is considered earlier' but is it enough earlier?  	TimeSpan diff = oldTimeUtc - SystemTime.UtcNow ();  	if (diff < (qsRsrcs.JobStore.SupportsPersistence ? TimeSpan.FromMilliseconds (70) : TimeSpan.FromMilliseconds (7))) {  		earlier = false;  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,IsCandidateNewTimeEarlierWithinReason,The following statement contains a magic number: if (earlier) {  	// so the new time is considered earlier' but is it enough earlier?  	TimeSpan diff = oldTimeUtc - SystemTime.UtcNow ();  	if (diff < (qsRsrcs.JobStore.SupportsPersistence ? TimeSpan.FromMilliseconds (70) : TimeSpan.FromMilliseconds (7))) {  		earlier = false;  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,IsCandidateNewTimeEarlierWithinReason,The following statement contains a magic number: if (diff < (qsRsrcs.JobStore.SupportsPersistence ? TimeSpan.FromMilliseconds (70) : TimeSpan.FromMilliseconds (7))) {  	earlier = false;  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,IsCandidateNewTimeEarlierWithinReason,The following statement contains a magic number: if (diff < (qsRsrcs.JobStore.SupportsPersistence ? TimeSpan.FromMilliseconds (70) : TimeSpan.FromMilliseconds (7))) {  	earlier = false;  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ErrorTriggerRetryLoop,The following statement contains a magic number: try {  	while (!halted) {  		try {  			Thread.Sleep (DbFailureRetryInterval);  			// retry every N seconds (the db connection must be failed)  			retryCount++;  			qsRsrcs.JobStore.TriggeredJobComplete (bndle.Trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  			retryCount = 0;  			break;  		}  		catch (JobPersistenceException jpe) {  			if (retryCount % 4 == 0) {  				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' bndle.Trigger.Key)' jpe);  			}  		}  		catch (ThreadInterruptedException e) {  			Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e);  		}  		catch (Exception e) {  			Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: Exception {0}"' e.Message)' e);  		}  	}  }  finally {  	if (retryCount == 0) {  		Log.Info ("ReleaseTriggerRetryLoop: connection restored.");  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ErrorTriggerRetryLoop,The following statement contains a magic number: while (!halted) {  	try {  		Thread.Sleep (DbFailureRetryInterval);  		// retry every N seconds (the db connection must be failed)  		retryCount++;  		qsRsrcs.JobStore.TriggeredJobComplete (bndle.Trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  		retryCount = 0;  		break;  	}  	catch (JobPersistenceException jpe) {  		if (retryCount % 4 == 0) {  			qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' bndle.Trigger.Key)' jpe);  		}  	}  	catch (ThreadInterruptedException e) {  		Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e);  	}  	catch (Exception e) {  		Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: Exception {0}"' e.Message)' e);  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ErrorTriggerRetryLoop,The following statement contains a magic number: try {  	Thread.Sleep (DbFailureRetryInterval);  	// retry every N seconds (the db connection must be failed)  	retryCount++;  	qsRsrcs.JobStore.TriggeredJobComplete (bndle.Trigger' bndle.JobDetail' SchedulerInstruction.SetAllJobTriggersError);  	retryCount = 0;  	break;  }  catch (JobPersistenceException jpe) {  	if (retryCount % 4 == 0) {  		qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' bndle.Trigger.Key)' jpe);  	}  }  catch (ThreadInterruptedException e) {  	Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e);  }  catch (Exception e) {  	Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: Exception {0}"' e.Message)' e);  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ErrorTriggerRetryLoop,The following statement contains a magic number: if (retryCount % 4 == 0) {  	qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' bndle.Trigger.Key)' jpe);  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ReleaseTriggerRetryLoop,The following statement contains a magic number: try {  	while (!halted) {  		try {  			Thread.Sleep (DbFailureRetryInterval);  			// retry every N seconds (the db connection must be failed)  			retryCount++;  			qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  			retryCount = 0;  			break;  		}  		catch (JobPersistenceException jpe) {  			if (retryCount % 4 == 0) {  				qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' trigger.Key)' jpe);  			}  		}  		catch (ThreadInterruptedException e) {  			Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e);  		}  		catch (Exception e) {  			Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: Exception {0}"' e.Message)' e);  		}  	}  }  finally {  	if (retryCount == 0) {  		Log.Info ("ReleaseTriggerRetryLoop: connection restored.");  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ReleaseTriggerRetryLoop,The following statement contains a magic number: while (!halted) {  	try {  		Thread.Sleep (DbFailureRetryInterval);  		// retry every N seconds (the db connection must be failed)  		retryCount++;  		qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  		retryCount = 0;  		break;  	}  	catch (JobPersistenceException jpe) {  		if (retryCount % 4 == 0) {  			qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' trigger.Key)' jpe);  		}  	}  	catch (ThreadInterruptedException e) {  		Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e);  	}  	catch (Exception e) {  		Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: Exception {0}"' e.Message)' e);  	}  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ReleaseTriggerRetryLoop,The following statement contains a magic number: try {  	Thread.Sleep (DbFailureRetryInterval);  	// retry every N seconds (the db connection must be failed)  	retryCount++;  	qsRsrcs.JobStore.ReleaseAcquiredTrigger (trigger);  	retryCount = 0;  	break;  }  catch (JobPersistenceException jpe) {  	if (retryCount % 4 == 0) {  		qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' trigger.Key)' jpe);  	}  }  catch (ThreadInterruptedException e) {  	Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: InterruptedException {0}"' e.Message)' e);  }  catch (Exception e) {  	Log.Error (string.Format (CultureInfo.InvariantCulture' "ReleaseTriggerRetryLoop: Exception {0}"' e.Message)' e);  }  
Magic Number,Quartz.Core,QuartzSchedulerThread,C:\repos\xmj112288_Study\OpenSources\Quartz\Core\QuartzSchedulerThread.cs,ReleaseTriggerRetryLoop,The following statement contains a magic number: if (retryCount % 4 == 0) {  	qs.NotifySchedulerListenersError (string.Format (CultureInfo.InvariantCulture' "An error occurred while releasing trigger '{0}'"' trigger.Key)' jpe);  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (endTimeOfDay == null) {  	fireTimeEndDate = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTime).Value;  }  else {  	fireTimeEndDate = endTimeOfDay.GetTimeOfDayForDate (fireTime).Value;  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (endTimeOfDay == null) {  	fireTimeEndDate = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTime).Value;  }  else {  	fireTimeEndDate = endTimeOfDay.GetTimeOfDayForDate (fireTime).Value;  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (endTimeOfDay == null) {  	fireTimeEndDate = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTime).Value;  }  else {  	fireTimeEndDate = endTimeOfDay.GetTimeOfDayForDate (fireTime).Value;  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: fireTimeEndDate = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTime).Value;  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: fireTimeEndDate = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTime).Value;  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: fireTimeEndDate = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTime).Value;  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (fireTime > fireTimeEndDate) {  	// Check to see if fireTime has pass fireTime's end of day. If not' we need to advance by one day.  	DateTimeOffset fireTimeEndOfDay = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTimeEndDate).Value;  	if (fireTime > fireTimeEndOfDay) {  		fireTime = AdvanceToNextDayOfWeek (fireTime.Value' false);  	}  	else {  		fireTime = AdvanceToNextDayOfWeek (fireTime.Value' true);  	}  	if (fireTime == null) {  		return null;  	}  	// Check to see if next day fireTime is before startTimeOfDay' if not' we need to set to startTimeOfDay.  	DateTimeOffset nextDayfireTimeStartDate = StartTimeOfDay.GetTimeOfDayForDate (fireTime).Value;  	if (fireTime < nextDayfireTimeStartDate) {  		fireTime = nextDayfireTimeStartDate;  	}  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (fireTime > fireTimeEndDate) {  	// Check to see if fireTime has pass fireTime's end of day. If not' we need to advance by one day.  	DateTimeOffset fireTimeEndOfDay = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTimeEndDate).Value;  	if (fireTime > fireTimeEndOfDay) {  		fireTime = AdvanceToNextDayOfWeek (fireTime.Value' false);  	}  	else {  		fireTime = AdvanceToNextDayOfWeek (fireTime.Value' true);  	}  	if (fireTime == null) {  		return null;  	}  	// Check to see if next day fireTime is before startTimeOfDay' if not' we need to set to startTimeOfDay.  	DateTimeOffset nextDayfireTimeStartDate = StartTimeOfDay.GetTimeOfDayForDate (fireTime).Value;  	if (fireTime < nextDayfireTimeStartDate) {  		fireTime = nextDayfireTimeStartDate;  	}  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (fireTime > fireTimeEndDate) {  	// Check to see if fireTime has pass fireTime's end of day. If not' we need to advance by one day.  	DateTimeOffset fireTimeEndOfDay = new TimeOfDay (23' 59' 59).GetTimeOfDayForDate (fireTimeEndDate).Value;  	if (fireTime > fireTimeEndOfDay) {  		fireTime = AdvanceToNextDayOfWeek (fireTime.Value' false);  	}  	else {  		fireTime = AdvanceToNextDayOfWeek (fireTime.Value' true);  	}  	if (fireTime == null) {  		return null;  	}  	// Check to see if next day fireTime is before startTimeOfDay' if not' we need to set to startTimeOfDay.  	DateTimeOffset nextDayfireTimeStartDate = StartTimeOfDay.GetTimeOfDayForDate (fireTime).Value;  	if (fireTime < nextDayfireTimeStartDate) {  		fireTime = nextDayfireTimeStartDate;  	}  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,AdvanceToNextDayOfWeek,The following statement contains a magic number: if (forceToAdvanceNextDay || !daysOfWeek.Contains (dayOfWeekOfFireTime)) {  	// Advance one day at a time until next available date.  	for (int i = 1; i <= 7; i++) {  		fireTimeStartDateCal = fireTimeStartDateCal.AddDays (1);  		dayOfWeekOfFireTime = fireTimeStartDateCal.DayOfWeek;  		if (daysOfWeek.Contains (dayOfWeekOfFireTime)) {  			fireTime = fireTimeStartDateCal;  			break;  		}  	}  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,AdvanceToNextDayOfWeek,The following statement contains a magic number: for (int i = 1; i <= 7; i++) {  	fireTimeStartDateCal = fireTimeStartDateCal.AddDays (1);  	dayOfWeekOfFireTime = fireTimeStartDateCal.DayOfWeek;  	if (daysOfWeek.Contains (dayOfWeekOfFireTime)) {  		fireTime = fireTimeStartDateCal;  		break;  	}  }  
Magic Number,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,Validate,The following statement contains a magic number: if (repeatIntervalUnit == IntervalUnit.Hour && repeatInterval > 24) {  	throw new SchedulerException ("repeatInterval can not exceed 24 hours. Given " + repeatInterval + " hours.");  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Second) {  	long jumpCount = secondsAfterStart / repeatLong;  	if (secondsAfterStart % repeatLong != 0) {  		jumpCount++;  	}  	time = sTime.AddSeconds (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Minute) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L);  	if (secondsAfterStart % (repeatLong * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddMinutes (RepeatInterval * (int)jumpCount);  }  else if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Hour) {  	long jumpCount = secondsAfterStart / (repeatLong * 60L * 60L);  	if (secondsAfterStart % (repeatLong * 60L * 60L) != 0) {  		jumpCount++;  	}  	time = sTime.AddHours (RepeatInterval * (int)jumpCount);  }  else {  	// intervals a day or greater ...  	int initialHourOfDay = sTime.Hour;  	if (RepeatIntervalUnit == IntervalUnit.Day) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays (RepeatInterval * jumpCount);  		}  		// now baby-step the rest of the way there...  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Week) {  		// Because intervals greater than an hour have an non-fixed number   		// of seconds in them (due to daylight savings' variation number of   		// days in each month' leap year' etc. ) we can't jump forward an  		// exact number of seconds to calculate the fire time as we can  		// with the second' minute and hour intervals.   But' rather  		// than slowly crawling our way there by iteratively adding the   		// increment to the start time until we reach the "after time"'  		// we can first make a big leap most of the way there...  		long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  		// if we need to make a big jump' jump most of the way there'   		// but not all the way because in some cases we may over-shoot or under-shoot  		if (jumpCount > 20) {  			if (jumpCount < 50) {  				jumpCount = (long)(jumpCount * 0.80);  			}  			else if (jumpCount < 500) {  				jumpCount = (long)(jumpCount * 0.90);  			}  			else {  				jumpCount = (long)(jumpCount * 0.95);  			}  			sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  		}  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddDays (RepeatInterval * 7);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Month) {  		// because of the large variation in size of months' and   		// because months are already large blocks of time' we will  		// just advance via brute-force iteration.  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddMonths (RepeatInterval);  		}  		time = sTime;  	}  	else if (RepeatIntervalUnit == IntervalUnit.Year) {  		sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  		//apply the timezone because we are comparing only the DateTime portions.  		while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  			MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  			//hours can shift due to DST  		}  		while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  			sTime = sTime.AddYears (RepeatInterval);  		}  		time = sTime;  	}  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Day) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays (RepeatInterval * jumpCount);  	}  	// now baby-step the rest of the way there...  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays (RepeatInterval * jumpCount);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays (RepeatInterval * jumpCount);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays (RepeatInterval * jumpCount);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays (RepeatInterval * jumpCount);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays (RepeatInterval * jumpCount);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays (RepeatInterval * jumpCount);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: jumpCount = (long)(jumpCount * 0.80);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: jumpCount = (long)(jumpCount * 0.90);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: jumpCount = (long)(jumpCount * 0.95);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (RepeatIntervalUnit == IntervalUnit.Week) {  	// Because intervals greater than an hour have an non-fixed number   	// of seconds in them (due to daylight savings' variation number of   	// days in each month' leap year' etc. ) we can't jump forward an  	// exact number of seconds to calculate the fire time as we can  	// with the second' minute and hour intervals.   But' rather  	// than slowly crawling our way there by iteratively adding the   	// increment to the start time until we reach the "after time"'  	// we can first make a big leap most of the way there...  	long jumpCount = secondsAfterStart / (repeatLong * 7L * 24L * 60L * 60L);  	// if we need to make a big jump' jump most of the way there'   	// but not all the way because in some cases we may over-shoot or under-shoot  	if (jumpCount > 20) {  		if (jumpCount < 50) {  			jumpCount = (long)(jumpCount * 0.80);  		}  		else if (jumpCount < 500) {  			jumpCount = (long)(jumpCount * 0.90);  		}  		else {  			jumpCount = (long)(jumpCount * 0.95);  		}  		sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  	}  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddDays (RepeatInterval * 7);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Month) {  	// because of the large variation in size of months' and   	// because months are already large blocks of time' we will  	// just advance via brute-force iteration.  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddMonths (RepeatInterval);  	}  	time = sTime;  }  else if (RepeatIntervalUnit == IntervalUnit.Year) {  	sTime = TimeZoneUtil.ConvertTime (sTime' this.TimeZone);  	//apply the timezone because we are comparing only the DateTime portions.  	while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  		MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  		//hours can shift due to DST  	}  	while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  		sTime = sTime.AddYears (RepeatInterval);  	}  	time = sTime;  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount > 20) {  	if (jumpCount < 50) {  		jumpCount = (long)(jumpCount * 0.80);  	}  	else if (jumpCount < 500) {  		jumpCount = (long)(jumpCount * 0.90);  	}  	else {  		jumpCount = (long)(jumpCount * 0.95);  	}  	sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 50) {  	jumpCount = (long)(jumpCount * 0.80);  }  else if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: jumpCount = (long)(jumpCount * 0.80);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: if (jumpCount < 500) {  	jumpCount = (long)(jumpCount * 0.90);  }  else {  	jumpCount = (long)(jumpCount * 0.95);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: jumpCount = (long)(jumpCount * 0.90);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: jumpCount = (long)(jumpCount * 0.95);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: sTime = sTime.AddDays ((int)(RepeatInterval * jumpCount * 7));  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: while (sTime.UtcDateTime < afterTime.Value.UtcDateTime && sTime.Year < YearToGiveupSchedulingAt) {  	sTime = sTime.AddDays (RepeatInterval * 7);  	MakeHourAdjustmentIfNeeded (ref sTime' initialHourOfDay);  	//hours can shift due to DST  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: sTime = sTime.AddDays (RepeatInterval * 7);  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: while (DaylightSavingHourShiftOccuredAndAdvanceNeeded (ref sTime' initialHourOfDay) && sTime.Year < YearToGiveupSchedulingAt) {  	sTime = sTime.AddDays (RepeatInterval * 7);  }  
Magic Number,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetFireTimeAfter,The following statement contains a magic number: sTime = sTime.AddDays (RepeatInterval * 7);  
Magic Number,Quartz.Impl,StdSchedulerFactory,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\StdSchedulerFactory.cs,Instantiate,The following statement contains a magic number: if (idleWaitTime > TimeSpan.Zero && idleWaitTime < TimeSpan.FromMilliseconds (1000)) {  	throw new SchedulerException ("quartz.scheduler.idleWaitTime of less than 1000ms is not legal.");  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: try {  	//with this variable will be done the swithcing  	string osName = Environment.GetEnvironmentVariable ("OS");  	if (osName == null) {  		throw new JobExecutionException ("Could not read environment variable for OS");  	}  	if (osName.ToLower ().IndexOf ("windows") > -1) {  		cmd = new string[args.Length + 2];  		cmd [0] = "cmd.exe";  		cmd [1] = "/C";  		for (int i = 0; i < args.Length; i++) {  			cmd [i + 2] = args [i];  		}  	}  	else if (osName.ToLower ().IndexOf ("linux") > -1) {  		cmd = new String[3];  		cmd [0] = "/bin/sh";  		cmd [1] = "-c";  		cmd [2] = args [0] + " " + args [1];  	}  	else {  		// try this...   		cmd = args;  	}  	// Executes the command  	string temp = "";  	for (int i = 1; i < cmd.Length; i++) {  		temp += cmd [i] + " ";  	}  	temp = temp.Trim ();  	Log.Info (string.Format (CultureInfo.InvariantCulture' "About to run {0} {1}..."' cmd [0]' temp));  	Process proc = new Process ();  	proc.StartInfo.FileName = cmd [0];  	proc.StartInfo.Arguments = temp;  	proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;  	proc.StartInfo.CreateNoWindow = true;  	proc.StartInfo.UseShellExecute = false;  	proc.StartInfo.RedirectStandardError = true;  	proc.StartInfo.RedirectStandardOutput = true;  	if (!String.IsNullOrEmpty (workingDirectory)) {  		proc.StartInfo.WorkingDirectory = workingDirectory;  	}  	proc.Start ();  	// Consumes the stdout from the process  	StreamConsumer stdoutConsumer = new StreamConsumer (this' proc.StandardOutput.BaseStream' StreamTypeStandardOutput);  	// Consumes the stderr from the process  	if (consumeStreams) {  		StreamConsumer stderrConsumer = new StreamConsumer (this' proc.StandardError.BaseStream' StreamTypeError);  		stdoutConsumer.Start ();  		stderrConsumer.Start ();  	}  	if (wait) {  		proc.WaitForExit ();  		result = proc.ExitCode;  	}  	// any error message?  }  catch (Exception x) {  	throw new JobExecutionException ("Error launching native command: " + x.Message' x' false);  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: try {  	//with this variable will be done the swithcing  	string osName = Environment.GetEnvironmentVariable ("OS");  	if (osName == null) {  		throw new JobExecutionException ("Could not read environment variable for OS");  	}  	if (osName.ToLower ().IndexOf ("windows") > -1) {  		cmd = new string[args.Length + 2];  		cmd [0] = "cmd.exe";  		cmd [1] = "/C";  		for (int i = 0; i < args.Length; i++) {  			cmd [i + 2] = args [i];  		}  	}  	else if (osName.ToLower ().IndexOf ("linux") > -1) {  		cmd = new String[3];  		cmd [0] = "/bin/sh";  		cmd [1] = "-c";  		cmd [2] = args [0] + " " + args [1];  	}  	else {  		// try this...   		cmd = args;  	}  	// Executes the command  	string temp = "";  	for (int i = 1; i < cmd.Length; i++) {  		temp += cmd [i] + " ";  	}  	temp = temp.Trim ();  	Log.Info (string.Format (CultureInfo.InvariantCulture' "About to run {0} {1}..."' cmd [0]' temp));  	Process proc = new Process ();  	proc.StartInfo.FileName = cmd [0];  	proc.StartInfo.Arguments = temp;  	proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;  	proc.StartInfo.CreateNoWindow = true;  	proc.StartInfo.UseShellExecute = false;  	proc.StartInfo.RedirectStandardError = true;  	proc.StartInfo.RedirectStandardOutput = true;  	if (!String.IsNullOrEmpty (workingDirectory)) {  		proc.StartInfo.WorkingDirectory = workingDirectory;  	}  	proc.Start ();  	// Consumes the stdout from the process  	StreamConsumer stdoutConsumer = new StreamConsumer (this' proc.StandardOutput.BaseStream' StreamTypeStandardOutput);  	// Consumes the stderr from the process  	if (consumeStreams) {  		StreamConsumer stderrConsumer = new StreamConsumer (this' proc.StandardError.BaseStream' StreamTypeError);  		stdoutConsumer.Start ();  		stderrConsumer.Start ();  	}  	if (wait) {  		proc.WaitForExit ();  		result = proc.ExitCode;  	}  	// any error message?  }  catch (Exception x) {  	throw new JobExecutionException ("Error launching native command: " + x.Message' x' false);  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: try {  	//with this variable will be done the swithcing  	string osName = Environment.GetEnvironmentVariable ("OS");  	if (osName == null) {  		throw new JobExecutionException ("Could not read environment variable for OS");  	}  	if (osName.ToLower ().IndexOf ("windows") > -1) {  		cmd = new string[args.Length + 2];  		cmd [0] = "cmd.exe";  		cmd [1] = "/C";  		for (int i = 0; i < args.Length; i++) {  			cmd [i + 2] = args [i];  		}  	}  	else if (osName.ToLower ().IndexOf ("linux") > -1) {  		cmd = new String[3];  		cmd [0] = "/bin/sh";  		cmd [1] = "-c";  		cmd [2] = args [0] + " " + args [1];  	}  	else {  		// try this...   		cmd = args;  	}  	// Executes the command  	string temp = "";  	for (int i = 1; i < cmd.Length; i++) {  		temp += cmd [i] + " ";  	}  	temp = temp.Trim ();  	Log.Info (string.Format (CultureInfo.InvariantCulture' "About to run {0} {1}..."' cmd [0]' temp));  	Process proc = new Process ();  	proc.StartInfo.FileName = cmd [0];  	proc.StartInfo.Arguments = temp;  	proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;  	proc.StartInfo.CreateNoWindow = true;  	proc.StartInfo.UseShellExecute = false;  	proc.StartInfo.RedirectStandardError = true;  	proc.StartInfo.RedirectStandardOutput = true;  	if (!String.IsNullOrEmpty (workingDirectory)) {  		proc.StartInfo.WorkingDirectory = workingDirectory;  	}  	proc.Start ();  	// Consumes the stdout from the process  	StreamConsumer stdoutConsumer = new StreamConsumer (this' proc.StandardOutput.BaseStream' StreamTypeStandardOutput);  	// Consumes the stderr from the process  	if (consumeStreams) {  		StreamConsumer stderrConsumer = new StreamConsumer (this' proc.StandardError.BaseStream' StreamTypeError);  		stdoutConsumer.Start ();  		stderrConsumer.Start ();  	}  	if (wait) {  		proc.WaitForExit ();  		result = proc.ExitCode;  	}  	// any error message?  }  catch (Exception x) {  	throw new JobExecutionException ("Error launching native command: " + x.Message' x' false);  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: try {  	//with this variable will be done the swithcing  	string osName = Environment.GetEnvironmentVariable ("OS");  	if (osName == null) {  		throw new JobExecutionException ("Could not read environment variable for OS");  	}  	if (osName.ToLower ().IndexOf ("windows") > -1) {  		cmd = new string[args.Length + 2];  		cmd [0] = "cmd.exe";  		cmd [1] = "/C";  		for (int i = 0; i < args.Length; i++) {  			cmd [i + 2] = args [i];  		}  	}  	else if (osName.ToLower ().IndexOf ("linux") > -1) {  		cmd = new String[3];  		cmd [0] = "/bin/sh";  		cmd [1] = "-c";  		cmd [2] = args [0] + " " + args [1];  	}  	else {  		// try this...   		cmd = args;  	}  	// Executes the command  	string temp = "";  	for (int i = 1; i < cmd.Length; i++) {  		temp += cmd [i] + " ";  	}  	temp = temp.Trim ();  	Log.Info (string.Format (CultureInfo.InvariantCulture' "About to run {0} {1}..."' cmd [0]' temp));  	Process proc = new Process ();  	proc.StartInfo.FileName = cmd [0];  	proc.StartInfo.Arguments = temp;  	proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;  	proc.StartInfo.CreateNoWindow = true;  	proc.StartInfo.UseShellExecute = false;  	proc.StartInfo.RedirectStandardError = true;  	proc.StartInfo.RedirectStandardOutput = true;  	if (!String.IsNullOrEmpty (workingDirectory)) {  		proc.StartInfo.WorkingDirectory = workingDirectory;  	}  	proc.Start ();  	// Consumes the stdout from the process  	StreamConsumer stdoutConsumer = new StreamConsumer (this' proc.StandardOutput.BaseStream' StreamTypeStandardOutput);  	// Consumes the stderr from the process  	if (consumeStreams) {  		StreamConsumer stderrConsumer = new StreamConsumer (this' proc.StandardError.BaseStream' StreamTypeError);  		stdoutConsumer.Start ();  		stderrConsumer.Start ();  	}  	if (wait) {  		proc.WaitForExit ();  		result = proc.ExitCode;  	}  	// any error message?  }  catch (Exception x) {  	throw new JobExecutionException ("Error launching native command: " + x.Message' x' false);  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: if (osName.ToLower ().IndexOf ("windows") > -1) {  	cmd = new string[args.Length + 2];  	cmd [0] = "cmd.exe";  	cmd [1] = "/C";  	for (int i = 0; i < args.Length; i++) {  		cmd [i + 2] = args [i];  	}  }  else if (osName.ToLower ().IndexOf ("linux") > -1) {  	cmd = new String[3];  	cmd [0] = "/bin/sh";  	cmd [1] = "-c";  	cmd [2] = args [0] + " " + args [1];  }  else {  	// try this...   	cmd = args;  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: if (osName.ToLower ().IndexOf ("windows") > -1) {  	cmd = new string[args.Length + 2];  	cmd [0] = "cmd.exe";  	cmd [1] = "/C";  	for (int i = 0; i < args.Length; i++) {  		cmd [i + 2] = args [i];  	}  }  else if (osName.ToLower ().IndexOf ("linux") > -1) {  	cmd = new String[3];  	cmd [0] = "/bin/sh";  	cmd [1] = "-c";  	cmd [2] = args [0] + " " + args [1];  }  else {  	// try this...   	cmd = args;  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: if (osName.ToLower ().IndexOf ("windows") > -1) {  	cmd = new string[args.Length + 2];  	cmd [0] = "cmd.exe";  	cmd [1] = "/C";  	for (int i = 0; i < args.Length; i++) {  		cmd [i + 2] = args [i];  	}  }  else if (osName.ToLower ().IndexOf ("linux") > -1) {  	cmd = new String[3];  	cmd [0] = "/bin/sh";  	cmd [1] = "-c";  	cmd [2] = args [0] + " " + args [1];  }  else {  	// try this...   	cmd = args;  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: if (osName.ToLower ().IndexOf ("windows") > -1) {  	cmd = new string[args.Length + 2];  	cmd [0] = "cmd.exe";  	cmd [1] = "/C";  	for (int i = 0; i < args.Length; i++) {  		cmd [i + 2] = args [i];  	}  }  else if (osName.ToLower ().IndexOf ("linux") > -1) {  	cmd = new String[3];  	cmd [0] = "/bin/sh";  	cmd [1] = "-c";  	cmd [2] = args [0] + " " + args [1];  }  else {  	// try this...   	cmd = args;  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: cmd = new string[args.Length + 2];  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: for (int i = 0; i < args.Length; i++) {  	cmd [i + 2] = args [i];  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: cmd [i + 2] = args [i];  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: if (osName.ToLower ().IndexOf ("linux") > -1) {  	cmd = new String[3];  	cmd [0] = "/bin/sh";  	cmd [1] = "-c";  	cmd [2] = args [0] + " " + args [1];  }  else {  	// try this...   	cmd = args;  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: if (osName.ToLower ().IndexOf ("linux") > -1) {  	cmd = new String[3];  	cmd [0] = "/bin/sh";  	cmd [1] = "-c";  	cmd [2] = args [0] + " " + args [1];  }  else {  	// try this...   	cmd = args;  }  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: cmd = new String[3];  
Magic Number,Quartz.Job,NativeJob,C:\repos\xmj112288_Study\OpenSources\Quartz\Job\NativeJob.cs,RunNativeCommand,The following statement contains a magic number: cmd [2] = args [0] + " " + args [1];  
Magic Number,Quartz.Impl.Calendar,AnnualCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\AnnualCalendar.cs,GetHashCode,The following statement contains a magic number: return excludeDays.GetHashCode () + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,CronCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\CronCalendar.cs,GetHashCode,The following statement contains a magic number: return CronExpression.GetHashCode () + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if ((rangeStartingTime.Length < 2) || (rangeStartingTime.Length > 4)) {  	throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Invalid time string '{0}'"' rangeStartingTimeString));  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if ((rangeStartingTime.Length < 2) || (rangeStartingTime.Length > 4)) {  	throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Invalid time string '{0}'"' rangeStartingTimeString));  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeStartingTime.Length > 2) {  	rangeStartingSecond = Convert.ToInt32 (rangeStartingTime [2]' CultureInfo.InvariantCulture);  }  else {  	rangeStartingSecond = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeStartingTime.Length > 2) {  	rangeStartingSecond = Convert.ToInt32 (rangeStartingTime [2]' CultureInfo.InvariantCulture);  }  else {  	rangeStartingSecond = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: rangeStartingSecond = Convert.ToInt32 (rangeStartingTime [2]' CultureInfo.InvariantCulture);  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeStartingTime.Length == 4) {  	rangeStartingMillis = Convert.ToInt32 (rangeStartingTime [3]' CultureInfo.InvariantCulture);  }  else {  	rangeStartingMillis = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeStartingTime.Length == 4) {  	rangeStartingMillis = Convert.ToInt32 (rangeStartingTime [3]' CultureInfo.InvariantCulture);  }  else {  	rangeStartingMillis = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: rangeStartingMillis = Convert.ToInt32 (rangeStartingTime [3]' CultureInfo.InvariantCulture);  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if ((rangeEndingTime.Length < 2) || (rangeEndingTime.Length > 4)) {  	throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Invalid time string '{0}'"' rangeEndingTimeString));  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if ((rangeEndingTime.Length < 2) || (rangeEndingTime.Length > 4)) {  	throw new ArgumentException (string.Format (CultureInfo.InvariantCulture' "Invalid time string '{0}'"' rangeEndingTimeString));  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeEndingTime.Length > 2) {  	rangeEndingSecond = Convert.ToInt32 (rangeEndingTime [2]' CultureInfo.InvariantCulture);  }  else {  	rangeEndingSecond = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeEndingTime.Length > 2) {  	rangeEndingSecond = Convert.ToInt32 (rangeEndingTime [2]' CultureInfo.InvariantCulture);  }  else {  	rangeEndingSecond = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: rangeEndingSecond = Convert.ToInt32 (rangeEndingTime [2]' CultureInfo.InvariantCulture);  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeEndingTime.Length == 4) {  	rangeEndingMillis = Convert.ToInt32 (rangeEndingTime [3]' CultureInfo.InvariantCulture);  }  else {  	rangeEndingMillis = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: if (rangeEndingTime.Length == 4) {  	rangeEndingMillis = Convert.ToInt32 (rangeEndingTime [3]' CultureInfo.InvariantCulture);  }  else {  	rangeEndingMillis = 0;  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,SetTimeRange,The following statement contains a magic number: rangeEndingMillis = Convert.ToInt32 (rangeEndingTime [3]' CultureInfo.InvariantCulture);  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,Validate,The following statement contains a magic number: if (hourOfDay < 0 || hourOfDay > 23) {  	throw new ArgumentException (InvalidHourOfDay + hourOfDay);  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,Validate,The following statement contains a magic number: if (minute < 0 || minute > 59) {  	throw new ArgumentException (InvalidMinute + minute);  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,Validate,The following statement contains a magic number: if (second < 0 || second > 59) {  	throw new ArgumentException (InvalidSecond + second);  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,Validate,The following statement contains a magic number: if (millis < 0 || millis > 999) {  	throw new ArgumentException (InvalidMillis + millis);  }  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetHashCode,The following statement contains a magic number: return rangeStartingHourOfDay.GetHashCode () + rangeEndingHourOfDay.GetHashCode () + 2 * (rangeStartingMinute.GetHashCode () + rangeEndingMinute.GetHashCode ()) + 3 * (rangeStartingSecond.GetHashCode () + rangeEndingSecond.GetHashCode ()) + 4 * (rangeStartingMillis.GetHashCode () + rangeEndingMillis.GetHashCode ()) + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetHashCode,The following statement contains a magic number: return rangeStartingHourOfDay.GetHashCode () + rangeEndingHourOfDay.GetHashCode () + 2 * (rangeStartingMinute.GetHashCode () + rangeEndingMinute.GetHashCode ()) + 3 * (rangeStartingSecond.GetHashCode () + rangeEndingSecond.GetHashCode ()) + 4 * (rangeStartingMillis.GetHashCode () + rangeEndingMillis.GetHashCode ()) + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetHashCode,The following statement contains a magic number: return rangeStartingHourOfDay.GetHashCode () + rangeEndingHourOfDay.GetHashCode () + 2 * (rangeStartingMinute.GetHashCode () + rangeEndingMinute.GetHashCode ()) + 3 * (rangeStartingSecond.GetHashCode () + rangeEndingSecond.GetHashCode ()) + 4 * (rangeStartingMillis.GetHashCode () + rangeEndingMillis.GetHashCode ()) + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,DailyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\DailyCalendar.cs,GetHashCode,The following statement contains a magic number: return rangeStartingHourOfDay.GetHashCode () + rangeEndingHourOfDay.GetHashCode () + 2 * (rangeStartingMinute.GetHashCode () + rangeEndingMinute.GetHashCode ()) + 3 * (rangeStartingSecond.GetHashCode () + rangeEndingSecond.GetHashCode ()) + 4 * (rangeStartingMillis.GetHashCode () + rangeEndingMillis.GetHashCode ()) + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,HolidayCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\HolidayCalendar.cs,GetHashCode,The following statement contains a magic number: return ExcludedDates.GetHashCode () + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,MonthlyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\MonthlyCalendar.cs,AreAllDaysExcluded,The following statement contains a magic number: for (int i = 1; i <= 31; i++) {  	if (IsDayExcluded (i) == false) {  		return false;  	}  }  
Magic Number,Quartz.Impl.Calendar,MonthlyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\MonthlyCalendar.cs,GetHashCode,The following statement contains a magic number: return DaysExcluded.GetHashCode () + 5 * baseHash;  
Magic Number,Quartz.Impl.Calendar,WeeklyCalendar,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Calendar\WeeklyCalendar.cs,GetHashCode,The following statement contains a magic number: return DaysExcluded.GetHashCode () + 5 * baseHash;  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreJob,The following statement contains a magic number: lock (lockObject) {  	if (jobsByKey.ContainsKey (jw.key)) {  		if (!replaceExisting) {  			throw new ObjectAlreadyExistsException (newJob);  		}  		repl = true;  	}  	if (!repl) {  		// get job group  		IDictionary<JobKey' JobWrapper> grpMap;  		if (!jobsByGroup.TryGetValue (newJob.Key.Group' out grpMap)) {  			grpMap = new Dictionary<JobKey' JobWrapper> (100);  			jobsByGroup [newJob.Key.Group] = grpMap;  		}  		// add to jobs by group  		grpMap [newJob.Key] = jw;  		// add to jobs by FQN map  		jobsByKey [jw.key] = jw;  	}  	else {  		// update job detail  		JobWrapper orig = jobsByKey [jw.key];  		orig.jobDetail = jw.jobDetail;  	}  }  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreJob,The following statement contains a magic number: if (!repl) {  	// get job group  	IDictionary<JobKey' JobWrapper> grpMap;  	if (!jobsByGroup.TryGetValue (newJob.Key.Group' out grpMap)) {  		grpMap = new Dictionary<JobKey' JobWrapper> (100);  		jobsByGroup [newJob.Key.Group] = grpMap;  	}  	// add to jobs by group  	grpMap [newJob.Key] = jw;  	// add to jobs by FQN map  	jobsByKey [jw.key] = jw;  }  else {  	// update job detail  	JobWrapper orig = jobsByKey [jw.key];  	orig.jobDetail = jw.jobDetail;  }  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreJob,The following statement contains a magic number: if (!jobsByGroup.TryGetValue (newJob.Key.Group' out grpMap)) {  	grpMap = new Dictionary<JobKey' JobWrapper> (100);  	jobsByGroup [newJob.Key.Group] = grpMap;  }  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreJob,The following statement contains a magic number: grpMap = new Dictionary<JobKey' JobWrapper> (100);  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreTrigger,The following statement contains a magic number: lock (lockObject) {  	TriggerWrapper wrapper;  	if (triggersByKey.TryGetValue (tw.key' out wrapper)) {  		if (!replaceExisting) {  			throw new ObjectAlreadyExistsException (newTrigger);  		}  		// don't delete orphaned job' this trigger has the job anyways  		RemoveTrigger (newTrigger.Key' false);  	}  	if (RetrieveJob (newTrigger.JobKey) == null) {  		throw new JobPersistenceException ("The job (" + newTrigger.JobKey + ") referenced by the trigger does not exist.");  	}  	// add to triggers array  	triggers.Add (tw);  	// add to triggers by group  	IDictionary<TriggerKey' TriggerWrapper> grpMap;  	triggersByGroup.TryGetValue (newTrigger.Key.Group' out grpMap);  	if (grpMap == null) {  		grpMap = new Dictionary<TriggerKey' TriggerWrapper> (100);  		triggersByGroup [newTrigger.Key.Group] = grpMap;  	}  	grpMap [newTrigger.Key] = tw;  	// add to triggers by FQN map  	triggersByKey [tw.key] = tw;  	if (pausedTriggerGroups.Contains (newTrigger.Key.Group) || pausedJobGroups.Contains (newTrigger.JobKey.Group)) {  		tw.state = InternalTriggerState.Paused;  		if (blockedJobs.Contains (tw.jobKey)) {  			tw.state = InternalTriggerState.PausedAndBlocked;  		}  	}  	else if (blockedJobs.Contains (tw.jobKey)) {  		tw.state = InternalTriggerState.Blocked;  	}  	else {  		timeTriggers.Add (tw);  	}  }  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreTrigger,The following statement contains a magic number: if (grpMap == null) {  	grpMap = new Dictionary<TriggerKey' TriggerWrapper> (100);  	triggersByGroup [newTrigger.Key.Group] = grpMap;  }  
Magic Number,Quartz.Simpl,RAMJobStore,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\RAMJobStore.cs,StoreTrigger,The following statement contains a magic number: grpMap = new Dictionary<TriggerKey' TriggerWrapper> (100);  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: lock (nextRunnableLock) {  	log.Debug ("Shutting down threadpool...");  	isShutdown = true;  	if (workers == null)// case where the pool wasn't even initialize()ed  	 {  		return;  	}  	// signal each worker thread to shut down  	foreach (WorkerThread thread in workers) {  		if (thread != null) {  			thread.Shutdown ();  		}  	}  	Monitor.PulseAll (nextRunnableLock);  	if (waitForJobsToComplete) {  		// wait for hand-off in runInThread to complete...  		while (handoffPending) {  			try {  				Monitor.Wait (nextRunnableLock' 100);  			}  			catch (ThreadInterruptedException) {  			}  		}  		// Wait until all worker threads are shut down  		while (busyWorkers.Count > 0) {  			LinkedListNode<WorkerThread> wt = busyWorkers.First;  			try {  				log.DebugFormat (CultureInfo.InvariantCulture' "Waiting for thread {0} to shut down"' wt.Value.Name);  				// note: with waiting infinite time the  				// application may appear to 'hang'.  				Monitor.Wait (nextRunnableLock' 2000);  			}  			catch (ThreadInterruptedException) {  			}  		}  		while (workers.Count > 0) {  			int index = workers.Count - 1;  			WorkerThread wt = workers [index];  			try {  				wt.Join ();  				workers.RemoveAt (index);  			}  			catch (ThreadStateException) {  			}  		}  		log.Debug ("No executing jobs remaining' all threads stopped.");  	}  	log.Debug ("Shutdown of threadpool complete.");  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: lock (nextRunnableLock) {  	log.Debug ("Shutting down threadpool...");  	isShutdown = true;  	if (workers == null)// case where the pool wasn't even initialize()ed  	 {  		return;  	}  	// signal each worker thread to shut down  	foreach (WorkerThread thread in workers) {  		if (thread != null) {  			thread.Shutdown ();  		}  	}  	Monitor.PulseAll (nextRunnableLock);  	if (waitForJobsToComplete) {  		// wait for hand-off in runInThread to complete...  		while (handoffPending) {  			try {  				Monitor.Wait (nextRunnableLock' 100);  			}  			catch (ThreadInterruptedException) {  			}  		}  		// Wait until all worker threads are shut down  		while (busyWorkers.Count > 0) {  			LinkedListNode<WorkerThread> wt = busyWorkers.First;  			try {  				log.DebugFormat (CultureInfo.InvariantCulture' "Waiting for thread {0} to shut down"' wt.Value.Name);  				// note: with waiting infinite time the  				// application may appear to 'hang'.  				Monitor.Wait (nextRunnableLock' 2000);  			}  			catch (ThreadInterruptedException) {  			}  		}  		while (workers.Count > 0) {  			int index = workers.Count - 1;  			WorkerThread wt = workers [index];  			try {  				wt.Join ();  				workers.RemoveAt (index);  			}  			catch (ThreadStateException) {  			}  		}  		log.Debug ("No executing jobs remaining' all threads stopped.");  	}  	log.Debug ("Shutdown of threadpool complete.");  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: if (waitForJobsToComplete) {  	// wait for hand-off in runInThread to complete...  	while (handoffPending) {  		try {  			Monitor.Wait (nextRunnableLock' 100);  		}  		catch (ThreadInterruptedException) {  		}  	}  	// Wait until all worker threads are shut down  	while (busyWorkers.Count > 0) {  		LinkedListNode<WorkerThread> wt = busyWorkers.First;  		try {  			log.DebugFormat (CultureInfo.InvariantCulture' "Waiting for thread {0} to shut down"' wt.Value.Name);  			// note: with waiting infinite time the  			// application may appear to 'hang'.  			Monitor.Wait (nextRunnableLock' 2000);  		}  		catch (ThreadInterruptedException) {  		}  	}  	while (workers.Count > 0) {  		int index = workers.Count - 1;  		WorkerThread wt = workers [index];  		try {  			wt.Join ();  			workers.RemoveAt (index);  		}  		catch (ThreadStateException) {  		}  	}  	log.Debug ("No executing jobs remaining' all threads stopped.");  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: if (waitForJobsToComplete) {  	// wait for hand-off in runInThread to complete...  	while (handoffPending) {  		try {  			Monitor.Wait (nextRunnableLock' 100);  		}  		catch (ThreadInterruptedException) {  		}  	}  	// Wait until all worker threads are shut down  	while (busyWorkers.Count > 0) {  		LinkedListNode<WorkerThread> wt = busyWorkers.First;  		try {  			log.DebugFormat (CultureInfo.InvariantCulture' "Waiting for thread {0} to shut down"' wt.Value.Name);  			// note: with waiting infinite time the  			// application may appear to 'hang'.  			Monitor.Wait (nextRunnableLock' 2000);  		}  		catch (ThreadInterruptedException) {  		}  	}  	while (workers.Count > 0) {  		int index = workers.Count - 1;  		WorkerThread wt = workers [index];  		try {  			wt.Join ();  			workers.RemoveAt (index);  		}  		catch (ThreadStateException) {  		}  	}  	log.Debug ("No executing jobs remaining' all threads stopped.");  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: while (handoffPending) {  	try {  		Monitor.Wait (nextRunnableLock' 100);  	}  	catch (ThreadInterruptedException) {  	}  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: try {  	Monitor.Wait (nextRunnableLock' 100);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: Monitor.Wait (nextRunnableLock' 100);  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: while (busyWorkers.Count > 0) {  	LinkedListNode<WorkerThread> wt = busyWorkers.First;  	try {  		log.DebugFormat (CultureInfo.InvariantCulture' "Waiting for thread {0} to shut down"' wt.Value.Name);  		// note: with waiting infinite time the  		// application may appear to 'hang'.  		Monitor.Wait (nextRunnableLock' 2000);  	}  	catch (ThreadInterruptedException) {  	}  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: try {  	log.DebugFormat (CultureInfo.InvariantCulture' "Waiting for thread {0} to shut down"' wt.Value.Name);  	// note: with waiting infinite time the  	// application may appear to 'hang'.  	Monitor.Wait (nextRunnableLock' 2000);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,Shutdown,The following statement contains a magic number: Monitor.Wait (nextRunnableLock' 2000);  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,RunInThread,The following statement contains a magic number: lock (nextRunnableLock) {  	handoffPending = true;  	// Wait until a worker thread is available  	while ((availWorkers.Count < 1) && !isShutdown) {  		try {  			Monitor.Wait (nextRunnableLock' 500);  		}  		catch (ThreadInterruptedException) {  		}  	}  	if (!isShutdown) {  		WorkerThread wt = availWorkers.First.Value;  		availWorkers.RemoveFirst ();  		busyWorkers.AddLast (wt);  		wt.Run (runnable);  	}  	else {  		// If the thread pool is going down' execute the Runnable  		// within a new additional worker thread (no thread from the pool).  		WorkerThread wt = new WorkerThread (this' "WorkerThread-LastJob"' prio' MakeThreadsDaemons' runnable);  		busyWorkers.AddLast (wt);  		workers.Add (wt);  		wt.Start ();  	}  	Monitor.PulseAll (nextRunnableLock);  	handoffPending = false;  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,RunInThread,The following statement contains a magic number: while ((availWorkers.Count < 1) && !isShutdown) {  	try {  		Monitor.Wait (nextRunnableLock' 500);  	}  	catch (ThreadInterruptedException) {  	}  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,RunInThread,The following statement contains a magic number: try {  	Monitor.Wait (nextRunnableLock' 500);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,RunInThread,The following statement contains a magic number: Monitor.Wait (nextRunnableLock' 500);  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,BlockForAvailableThreads,The following statement contains a magic number: lock (nextRunnableLock) {  	while ((availWorkers.Count < 1 || handoffPending) && !isShutdown) {  		try {  			Monitor.Wait (nextRunnableLock' 500);  		}  		catch (ThreadInterruptedException) {  		}  	}  	return availWorkers.Count;  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,BlockForAvailableThreads,The following statement contains a magic number: while ((availWorkers.Count < 1 || handoffPending) && !isShutdown) {  	try {  		Monitor.Wait (nextRunnableLock' 500);  	}  	catch (ThreadInterruptedException) {  	}  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,BlockForAvailableThreads,The following statement contains a magic number: try {  	Monitor.Wait (nextRunnableLock' 500);  }  catch (ThreadInterruptedException) {  }  
Magic Number,Quartz.Simpl,SimpleThreadPool,C:\repos\xmj112288_Study\OpenSources\Quartz\Simpl\SimpleThreadPool.cs,BlockForAvailableThreads,The following statement contains a magic number: Monitor.Wait (nextRunnableLock' 500);  
Magic Number,Quartz.Util,PropertiesParser,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\PropertiesParser.cs,ReadFromStream,The following statement contains a magic number: using (StreamReader sr = new StreamReader (stream)) {  	string line;  	while ((line = sr.ReadLine ()) != null) {  		line = line.TrimStart ();  		if (line.StartsWith ("#")) {  			// comment line   			continue;  		}  		if (line.StartsWith ("!END")) {  			// special end condition  			break;  		}  		string[] lineItems = line.Split (new char[] {  			'='  		}' 2);  		if (lineItems.Length == 2) {  			props [lineItems [0].Trim ()] = lineItems [1].Trim ();  		}  	}  }  
Magic Number,Quartz.Util,PropertiesParser,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\PropertiesParser.cs,ReadFromStream,The following statement contains a magic number: using (StreamReader sr = new StreamReader (stream)) {  	string line;  	while ((line = sr.ReadLine ()) != null) {  		line = line.TrimStart ();  		if (line.StartsWith ("#")) {  			// comment line   			continue;  		}  		if (line.StartsWith ("!END")) {  			// special end condition  			break;  		}  		string[] lineItems = line.Split (new char[] {  			'='  		}' 2);  		if (lineItems.Length == 2) {  			props [lineItems [0].Trim ()] = lineItems [1].Trim ();  		}  	}  }  
Magic Number,Quartz.Util,PropertiesParser,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\PropertiesParser.cs,ReadFromStream,The following statement contains a magic number: while ((line = sr.ReadLine ()) != null) {  	line = line.TrimStart ();  	if (line.StartsWith ("#")) {  		// comment line   		continue;  	}  	if (line.StartsWith ("!END")) {  		// special end condition  		break;  	}  	string[] lineItems = line.Split (new char[] {  		'='  	}' 2);  	if (lineItems.Length == 2) {  		props [lineItems [0].Trim ()] = lineItems [1].Trim ();  	}  }  
Magic Number,Quartz.Util,PropertiesParser,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\PropertiesParser.cs,ReadFromStream,The following statement contains a magic number: while ((line = sr.ReadLine ()) != null) {  	line = line.TrimStart ();  	if (line.StartsWith ("#")) {  		// comment line   		continue;  	}  	if (line.StartsWith ("!END")) {  		// special end condition  		break;  	}  	string[] lineItems = line.Split (new char[] {  		'='  	}' 2);  	if (lineItems.Length == 2) {  		props [lineItems [0].Trim ()] = lineItems [1].Trim ();  	}  }  
Magic Number,Quartz.Util,PropertiesParser,C:\repos\xmj112288_Study\OpenSources\Quartz\Util\PropertiesParser.cs,ReadFromStream,The following statement contains a magic number: if (lineItems.Length == 2) {  	props [lineItems [0].Trim ()] = lineItems [1].Trim ();  }  
Magic Number,Quartz.Xml,XMLSchedulingDataProcessor,C:\repos\xmj112288_Study\OpenSources\Quartz\Xml\XMLSchedulingDataProcessor.cs,DoRescheduleJob,The following statement contains a magic number: if (oldTrigger != null && trigger.StartTimeUtc - SystemTime.UtcNow () < TimeSpan.FromSeconds (5) && ScheduleTriggerRelativeToReplacedTrigger) {  	Log.DebugFormat ("Using relative scheduling for trigger with key {0}"' trigger.Key);  	var oldTriggerPreviousFireTime = oldTrigger.GetPreviousFireTimeUtc ();  	trigger.StartTimeUtc = oldTrigger.StartTimeUtc;  	((IOperableTrigger)trigger).SetPreviousFireTimeUtc (oldTriggerPreviousFireTime);  	((IOperableTrigger)trigger).SetNextFireTimeUtc (trigger.GetFireTimeAfter (oldTriggerPreviousFireTime));  }  
Missing Default,Quartz.Impl.Triggers,DailyTimeIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\DailyTimeIntervalTriggerImpl.cs,GetScheduleBuilder,The following switch statement is missing a default case: switch (MisfireInstruction) {  case Quartz.MisfireInstruction.DailyTimeIntervalTrigger.DoNothing:  	cb.WithMisfireHandlingInstructionDoNothing ();  	break;  case Quartz.MisfireInstruction.DailyTimeIntervalTrigger.FireOnceNow:  	cb.WithMisfireHandlingInstructionFireAndProceed ();  	break;  }  
Missing Default,Quartz.Impl.Triggers,CronTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CronTriggerImpl.cs,GetScheduleBuilder,The following switch statement is missing a default case: switch (MisfireInstruction) {  case Quartz.MisfireInstruction.CronTrigger.DoNothing:  	cb.WithMisfireHandlingInstructionDoNothing ();  	break;  case Quartz.MisfireInstruction.CronTrigger.FireOnceNow:  	cb.WithMisfireHandlingInstructionFireAndProceed ();  	break;  }  
Missing Default,Quartz.Impl.Triggers,SimpleTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\SimpleTriggerImpl.cs,GetScheduleBuilder,The following switch statement is missing a default case: switch (MisfireInstruction) {  case Quartz.MisfireInstruction.SimpleTrigger.FireNow:  	sb.WithMisfireHandlingInstructionFireNow ();  	break;  case Quartz.MisfireInstruction.SimpleTrigger.RescheduleNextWithExistingCount:  	sb.WithMisfireHandlingInstructionNextWithExistingCount ();  	break;  case Quartz.MisfireInstruction.SimpleTrigger.RescheduleNextWithRemainingCount:  	sb.WithMisfireHandlingInstructionNextWithRemainingCount ();  	break;  case Quartz.MisfireInstruction.SimpleTrigger.RescheduleNowWithExistingRepeatCount:  	sb.WithMisfireHandlingInstructionNowWithExistingCount ();  	break;  case Quartz.MisfireInstruction.SimpleTrigger.RescheduleNowWithRemainingRepeatCount:  	sb.WithMisfireHandlingInstructionNowWithRemainingCount ();  	break;  }  
Missing Default,Quartz.Impl.Triggers,CalendarIntervalTriggerImpl,C:\repos\xmj112288_Study\OpenSources\Quartz\Impl\Triggers\CalendarIntervalTriggerImpl.cs,GetScheduleBuilder,The following switch statement is missing a default case: switch (MisfireInstruction) {  case Quartz.MisfireInstruction.CalendarIntervalTrigger.DoNothing:  	cb.WithMisfireHandlingInstructionDoNothing ();  	break;  case Quartz.MisfireInstruction.CalendarIntervalTrigger.FireOnceNow:  	cb.WithMisfireHandlingInstructionFireAndProceed ();  	break;  }  
