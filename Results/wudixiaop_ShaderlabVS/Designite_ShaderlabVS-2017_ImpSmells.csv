Implementation smell,Namespace,Class,File,Method,Description
Long Method,ShaderlabVS,CommentsHelper,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabShortcuts.cs,CommentOrUnCommentBlock,The method has 117 lines of code.
Complex Method,ShaderlabVS,ShaderlabBracesTagger,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabBracesMatching.cs,FindMatchingBrace,Cyclomatic complexity of the method is 9
Complex Method,ShaderlabVS,ShaderlabCompletionCommandHandlder,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,Exec,Cyclomatic complexity of the method is 9
Complex Method,ShaderlabVS,ShaderlabOutlining,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabOutlining.cs,GetTags,Cyclomatic complexity of the method is 8
Long Parameter List,ShaderlabVS,ShaderlabBracesTagger,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabBracesMatching.cs,FindMatchingBrace,The method has 5 parameters. Parameters: startPoint' openChar' closedChar' IsMatchingClosedChar' matchedPosition
Long Parameter List,ShaderlabVS,ShaderlabCompletionCommandHandlder,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,Exec,The method has 5 parameters. Parameters: pguidCmdGroup' nCmdID' nCmdexecopt' pvaIn' pvaOut
Long Parameter List,ShaderlabVS,ShaderlabVSBraceCompletionContextProvider,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,TryCreateContext,The method has 5 parameters. Parameters: textView' openingPoint' openingBrace' closingBrace' context
Long Parameter List,ShaderlabVS,ShaderlabShortcuts,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabShortcuts.cs,Exec,The method has 5 parameters. Parameters: pguidCmdGroup' nCmdID' nCmdexecopt' pvaIn' pvaOut
Long Parameter List,ShaderlabVS,SignatureHelpCommand,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabSignatureHelp.cs,Exec,The method has 5 parameters. Parameters: pguidCmdGroup' nCmdID' nCmdexecopt' pvaIn' pvaOut
Long Identifier,ShaderlabVS,ShaderlabVSClassificationDefinition,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabVSType.cs,,The length of the parameter ShaderlabUnityKeywordsParaType is 30.
Long Statement,ShaderlabVS,ShaderlabBracesTagger,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabBracesMatching.cs,GetTags,The length of the statement  "                    yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(currentCharSnapPoint.Value' 1)' new TextMarkerTag(Constants.ShaderlabBracesMarker)); " is 141.
Long Statement,ShaderlabVS,ShaderlabBracesTagger,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabBracesMatching.cs,GetTags,The length of the statement  "                    yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(matchedPosition.Value' 1)' new TextMarkerTag(Constants.ShaderlabBracesMarker)); " is 136.
Long Statement,ShaderlabVS,ShaderlabBracesTagger,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabBracesMatching.cs,GetTags,The length of the statement  "                    yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(lastCharSnapShot.Value' 1)' new TextMarkerTag(Constants.ShaderlabBracesMarker)); " is 137.
Long Statement,ShaderlabVS,ShaderlabBracesTagger,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabBracesMatching.cs,GetTags,The length of the statement  "                    yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(matchedPosition.Value' 1)' new TextMarkerTag(Constants.ShaderlabBracesMarker)); " is 136.
Long Statement,ShaderlabVS,ShaderlabCompletionSource,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,AugmentCompletionSession,The length of the statement  "            completionSets.Add(new CompletionSet("Token"' "Token"' FindTokenSpanAtPosition(session.GetTriggerPoint(this.textBuffer)' session)' completionList' null)); " is 154.
Long Statement,ShaderlabVS,ShaderlabCompletionCommandHandlder,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,TriggerCompletion,The length of the statement  "            SnapshotPoint? caretPoint = textView.Caret.Position.Point.GetPoint(textBuffer => !textBuffer.ContentType.IsOfType("projection")' PositionAffinity.Predecessor); " is 159.
Long Statement,ShaderlabVS,ShaderlabCompletionCommandHandlder,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,TriggerCompletion,The length of the statement  "                completionSession = completionHandlerProvider.CompletionBroker.CreateCompletionSession(textView' caretPoint.Value.Snapshot.CreateTrackingPoint(caretPoint.Value.Position' PointTrackingMode.Positive)' true); " is 205.
Long Statement,ShaderlabVS,SignatureHelpCommand,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabSignatureHelp.cs,Exec,The length of the statement  "                    if (ShaderlabDataManager.Instance.UnityBuiltinFunctions.Any(f => f.Name.Equals(word' StringComparison.CurrentCultureIgnoreCase)) " is 128.
Long Statement,ShaderlabVS,SignatureHelpCommand,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabSignatureHelp.cs,Exec,The length of the statement  "                        || ShaderlabDataManager.Instance.HLSLCGFunctions.Any(f => f.Name.Equals(word' StringComparison.CurrentCultureIgnoreCase))) " is 122.
Long Statement,ShaderlabVS,SignatureHelpCommandProvider,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabSignatureHelp.cs,VsTextViewCreated,The length of the statement  "            textView.Properties.GetOrCreateSingletonProperty( () => new SignatureHelpCommand(textViewAdapter' textView' NavigatorServices.GetTextStructureNavigator(textView.TextBuffer)' SignartureBroker)); " is 193.
Magic Number,ShaderlabVS,ShaderlabCompletionSource,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabCodeCompletion.cs,GetImageFromAssetByName,The following statement contains a magic number: string currentAssemblyDir = (new FileInfo(Assembly.GetExecutingAssembly().CodeBase.Substring(8))).DirectoryName;
Magic Number,ShaderlabVS,ShaderlabOutlining,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabOutlining.cs,GetTags,The following statement contains a magic number: foreach (Region region in currentRegions)              {                  if (region.Start >= startLineNumber && region.End <= endLineNumber)                  {                      // We need to determine where the start point is. there are some scenarios:                      //    1. the '{' is not in a new line' but it's at the end of a code line                      //    2. the '{' at the begin of a line (if we ingore the white chars)                      //                      var line = entire.Snapshot.GetLineFromLineNumber(region.Start);                      string lineText = line.GetText();                        int offset = lineText.LastIndexOf("{");                        // let's assume the default is that '{' is the #1 scenario                      //                      SnapshotPoint regionStart = entire.Snapshot.GetLineFromLineNumber(region.Start).Start + offset;                        // if in #2 scenario                      //                      if (region.Start >= 0 && (lineText.Trim().Equals("{") || lineText.Trim().StartsWith("{")))                      {                          regionStart = entire.Snapshot.GetLineFromLineNumber(region.Start - 1).End;                      }                        SnapshotPoint regionEnd = entire.Snapshot.GetLineFromLineNumber(region.End).End;                        StringBuilder hoverText = new StringBuilder();                      int nonWhiteIndex = Utilities.IndexOfNonWhitespaceCharacter(lineText);                        for (int i = regionStart.GetContainingLine().LineNumber; i <= regionEnd.GetContainingLine().LineNumber; )                      {                                                   string hoverTextLine = entire.Snapshot.GetLineFromLineNumber(i).GetText();                            if(Utilities.IndexOfNonWhitespaceCharacter(hoverTextLine) >= nonWhiteIndex)                          {                               // Remove some the white chars                              //                              hoverText.AppendLine(hoverTextLine.Substring(nonWhiteIndex));                          }                          else                          {                              hoverText.AppendLine(hoverTextLine);                          }                            if (i - regionStart.GetContainingLine().LineNumber >= 8)                          {                              hoverText.AppendLine("...");                              break;                          }                            i++;                      }                        OutliningRegionTag tag = new OutliningRegionTag(false' false' "..."' hoverText.ToString());                        yield return new TagSpan<OutliningRegionTag>(new SnapshotSpan(regionStart' regionEnd)' tag);                  }              }
Magic Number,ShaderlabVS,ShaderlabQuickInfoSource,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabQuickInfo.cs,AugmentQuickInfoSession,The following statement contains a magic number: if (!string.IsNullOrEmpty(info))              {                  applicableToSpan = currentSnapshot.CreateTrackingSpan(span.Start.Position' 9' SpanTrackingMode.EdgeInclusive);                  quickInfoContent.Add(info);                  return;              }
Magic Number,ShaderlabVS,CommentsHelper,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabShortcuts.cs,CommentOrUnCommentBlock,The following statement contains a magic number: if (start.HasValue && end.HasValue)              {                  using (var editor = start.Value.Snapshot.TextBuffer.CreateEdit())                  {                      int startLineNumber = start.Value.GetContainingLine().LineNumber;                      int endLineNumber = end.Value.GetContainingLine().LineNumber;                        if (comment)                      {                          // Do comment Action                          //                          int min = Int32.MaxValue;                            // get the mini postion to place the comment                          //                          for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              string lineText = start.Value.Snapshot.GetLineFromLineNumber(i).GetText();                              int firstOfNonWhiteIndex = Utilities.IndexOfNonWhitespaceCharacter(lineText);                              if (firstOfNonWhiteIndex >= 0 && firstOfNonWhiteIndex < min)                              {                                  min = firstOfNonWhiteIndex;                              }                          }                            for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              var line = start.Value.Snapshot.GetLineFromLineNumber(i);                              string lineText = line.GetText();                              if (string.IsNullOrWhiteSpace(lineText))                              {                                  continue;                              }                                editor.Insert(line.Start.Position + min' "//");                          }                      }                      else                      {                          // Do uncomment action                          //                          for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              var line = start.Value.Snapshot.GetLineFromLineNumber(i);                              string lineText = line.GetText();                              string lineTextAfterTrim = lineText.Trim();                              if (lineTextAfterTrim.StartsWith("//"))                              {                                  int commentIndex = lineText.IndexOf("//");                                    if (commentIndex != -1)                                  {                                      editor.Delete(line.Start.Position + commentIndex' 2);                                  }                              }                              else                              {                                  if (lineTextAfterTrim.EndsWith("*/"))                                  {                                      int endCommentIndex = lineText.IndexOf("*/");                                      editor.Delete(line.Start.Position + endCommentIndex' 2);                                  }                                    if (lineTextAfterTrim.StartsWith("/*"))                                  {                                      int startCommentIndex = lineText.IndexOf("/*");                                      editor.Delete(line.Start.Position + startCommentIndex' 2);                                  }                                    if (startLineNumber != endLineNumber && lineTextAfterTrim.StartsWith("*"))                                  {                                      int startCommentIndex = lineText.IndexOf("*");                                      editor.Delete(line.Start.Position + startCommentIndex' 1);                                  }                              }                          }                      }                        // Apply the modification                      //                      editor.Apply();                  }                    return true;              }
Magic Number,ShaderlabVS,CommentsHelper,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabShortcuts.cs,CommentOrUnCommentBlock,The following statement contains a magic number: if (start.HasValue && end.HasValue)              {                  using (var editor = start.Value.Snapshot.TextBuffer.CreateEdit())                  {                      int startLineNumber = start.Value.GetContainingLine().LineNumber;                      int endLineNumber = end.Value.GetContainingLine().LineNumber;                        if (comment)                      {                          // Do comment Action                          //                          int min = Int32.MaxValue;                            // get the mini postion to place the comment                          //                          for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              string lineText = start.Value.Snapshot.GetLineFromLineNumber(i).GetText();                              int firstOfNonWhiteIndex = Utilities.IndexOfNonWhitespaceCharacter(lineText);                              if (firstOfNonWhiteIndex >= 0 && firstOfNonWhiteIndex < min)                              {                                  min = firstOfNonWhiteIndex;                              }                          }                            for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              var line = start.Value.Snapshot.GetLineFromLineNumber(i);                              string lineText = line.GetText();                              if (string.IsNullOrWhiteSpace(lineText))                              {                                  continue;                              }                                editor.Insert(line.Start.Position + min' "//");                          }                      }                      else                      {                          // Do uncomment action                          //                          for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              var line = start.Value.Snapshot.GetLineFromLineNumber(i);                              string lineText = line.GetText();                              string lineTextAfterTrim = lineText.Trim();                              if (lineTextAfterTrim.StartsWith("//"))                              {                                  int commentIndex = lineText.IndexOf("//");                                    if (commentIndex != -1)                                  {                                      editor.Delete(line.Start.Position + commentIndex' 2);                                  }                              }                              else                              {                                  if (lineTextAfterTrim.EndsWith("*/"))                                  {                                      int endCommentIndex = lineText.IndexOf("*/");                                      editor.Delete(line.Start.Position + endCommentIndex' 2);                                  }                                    if (lineTextAfterTrim.StartsWith("/*"))                                  {                                      int startCommentIndex = lineText.IndexOf("/*");                                      editor.Delete(line.Start.Position + startCommentIndex' 2);                                  }                                    if (startLineNumber != endLineNumber && lineTextAfterTrim.StartsWith("*"))                                  {                                      int startCommentIndex = lineText.IndexOf("*");                                      editor.Delete(line.Start.Position + startCommentIndex' 1);                                  }                              }                          }                      }                        // Apply the modification                      //                      editor.Apply();                  }                    return true;              }
Magic Number,ShaderlabVS,CommentsHelper,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabShortcuts.cs,CommentOrUnCommentBlock,The following statement contains a magic number: if (start.HasValue && end.HasValue)              {                  using (var editor = start.Value.Snapshot.TextBuffer.CreateEdit())                  {                      int startLineNumber = start.Value.GetContainingLine().LineNumber;                      int endLineNumber = end.Value.GetContainingLine().LineNumber;                        if (comment)                      {                          // Do comment Action                          //                          int min = Int32.MaxValue;                            // get the mini postion to place the comment                          //                          for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              string lineText = start.Value.Snapshot.GetLineFromLineNumber(i).GetText();                              int firstOfNonWhiteIndex = Utilities.IndexOfNonWhitespaceCharacter(lineText);                              if (firstOfNonWhiteIndex >= 0 && firstOfNonWhiteIndex < min)                              {                                  min = firstOfNonWhiteIndex;                              }                          }                            for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              var line = start.Value.Snapshot.GetLineFromLineNumber(i);                              string lineText = line.GetText();                              if (string.IsNullOrWhiteSpace(lineText))                              {                                  continue;                              }                                editor.Insert(line.Start.Position + min' "//");                          }                      }                      else                      {                          // Do uncomment action                          //                          for (int i = startLineNumber; i <= endLineNumber; i++)                          {                              var line = start.Value.Snapshot.GetLineFromLineNumber(i);                              string lineText = line.GetText();                              string lineTextAfterTrim = lineText.Trim();                              if (lineTextAfterTrim.StartsWith("//"))                              {                                  int commentIndex = lineText.IndexOf("//");                                    if (commentIndex != -1)                                  {                                      editor.Delete(line.Start.Position + commentIndex' 2);                                  }                              }                              else                              {                                  if (lineTextAfterTrim.EndsWith("*/"))                                  {                                      int endCommentIndex = lineText.IndexOf("*/");                                      editor.Delete(line.Start.Position + endCommentIndex' 2);                                  }                                    if (lineTextAfterTrim.StartsWith("/*"))                                  {                                      int startCommentIndex = lineText.IndexOf("/*");                                      editor.Delete(line.Start.Position + startCommentIndex' 2);                                  }                                    if (startLineNumber != endLineNumber && lineTextAfterTrim.StartsWith("*"))                                  {                                      int startCommentIndex = lineText.IndexOf("*");                                      editor.Delete(line.Start.Position + startCommentIndex' 1);                                  }                              }                          }                      }                        // Apply the modification                      //                      editor.Apply();                  }                    return true;              }
Magic Number,ShaderlabVS,ShaderlabClassifier,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabVS.cs,GetTags,The following statement contains a magic number: do              {                  token = scanner.NextToken();                  int pos = scanner.GetPos();                  int length = scanner.GetLength();                    if (pos < 0 || length < 0 || pos > text.Length)                  {                      continue;                  }                    if (pos + length > text.Length)                  {                      length = text.Length - pos;                  }                    if (classTypeDict.TryGetValue((ShaderlabToken)token' out cf))                  {                      switch ((ShaderlabToken)token)                      {                          case ShaderlabToken.HLSLCGKEYWORD:                          case ShaderlabToken.UNITYKEYWORD:                          case ShaderlabToken.UNITYKEYWORD_PARA:                          case ShaderlabToken.HLSLCGDATATYPE:                          case ShaderlabToken.HLSLCGFUNCTION:                          case ShaderlabToken.UNITYFUNCTION:                          case ShaderlabToken.UNITYMACROS:                          case ShaderlabToken.UNITYDATATYPE:                          case ShaderlabToken.UNITYVALUES:                              length = length - 2;                              scanner.PushbackText(length + 1);                              break;                          case ShaderlabToken.HLSLCGKEYWORDSPECIAL:                              pos--;                              length = length - 1;                              scanner.PushbackText(length);                              break;                          case ShaderlabToken.STRING_LITERAL:                          case ShaderlabToken.COMMENT:                              pos--;                              break;                      }                        if (pos < 0 || length < 0 || pos > text.Length)                      {                          continue;                      }                        yield return new TagSpan<ClassificationTag>(new SnapshotSpan(spans[0].Snapshot' new Span(pos' length))'                                                                  new ClassificationTag(cf));                    }                } while (token > (int)Tokens.EOF);
Missing Default,ShaderlabVS,ShaderlabShortcuts,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabShortcuts.cs,QueryStatus,The following switch statement is missing a default case: switch ((VSConstants.VSStd2KCmdID)prgCmds[i].cmdID)                      {                          case VSConstants.VSStd2KCmdID.FORMATDOCUMENT:                          case VSConstants.VSStd2KCmdID.FORMATSELECTION:                          case VSConstants.VSStd2KCmdID.COMMENT_BLOCK:                          case VSConstants.VSStd2KCmdID.COMMENTBLOCK:                          case VSConstants.VSStd2KCmdID.UNCOMMENT_BLOCK:                          case VSConstants.VSStd2KCmdID.UNCOMMENTBLOCK:                          case VSConstants.VSStd2KCmdID.HELP:                              prgCmds[i].cmdf = (uint)(OLECMDF.OLECMDF_ENABLED | OLECMDF.OLECMDF_SUPPORTED);                              return VSConstants.S_OK;                      }
Missing Default,ShaderlabVS,ShaderlabClassifier,C:\repos\wudixiaop_ShaderlabVS\Src\ShaderlabVS\ShaderlabVS.cs,GetTags,The following switch statement is missing a default case: switch ((ShaderlabToken)token)                      {                          case ShaderlabToken.HLSLCGKEYWORD:                          case ShaderlabToken.UNITYKEYWORD:                          case ShaderlabToken.UNITYKEYWORD_PARA:                          case ShaderlabToken.HLSLCGDATATYPE:                          case ShaderlabToken.HLSLCGFUNCTION:                          case ShaderlabToken.UNITYFUNCTION:                          case ShaderlabToken.UNITYMACROS:                          case ShaderlabToken.UNITYDATATYPE:                          case ShaderlabToken.UNITYVALUES:                              length = length - 2;                              scanner.PushbackText(length + 1);                              break;                          case ShaderlabToken.HLSLCGKEYWORDSPECIAL:                              pos--;                              length = length - 1;                              scanner.PushbackText(length);                              break;                          case ShaderlabToken.STRING_LITERAL:                          case ShaderlabToken.COMMENT:                              pos--;                              break;                      }
