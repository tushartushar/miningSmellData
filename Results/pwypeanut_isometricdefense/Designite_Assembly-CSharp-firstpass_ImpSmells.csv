Implementation smell,Namespace,Class,File,Method,Description
Long Method,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ClosestPointOnTriangle,The method has 187 lines of code.
Long Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The method has 124 lines of code.
Long Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The method has 137 lines of code.
Long Method,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The method has 160 lines of code.
Long Method,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The method has 105 lines of code.
Long Method,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The method has 110 lines of code.
Complex Method,Pathfinding,AstarData,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphsPartAdditive,Cyclomatic complexity of the method is 12
Complex Method,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ClosestPointOnTriangle,Cyclomatic complexity of the method is 25
Complex Method,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,DistanceSegmentSegment3D,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,AnimationLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,GraphModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\GraphModifier.cs,TriggerEvent,Cyclomatic complexity of the method is 19
Complex Method,Pathfinding,NodeLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink.cs,LinkObjects,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,ThreadControlQueue,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,Pop,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,ThreadControlQueue,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,PopNoBlock,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Trace,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,PathHandler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,Cyclomatic complexity of the method is 13
Complex Method,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,Cyclomatic complexity of the method is 21
Complex Method,Pathfinding,GraphCollision,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,Check,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,Cyclomatic complexity of the method is 25
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ScanInternal,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateNodePositionCollision,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,Cyclomatic complexity of the method is 24
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,Cyclomatic complexity of the method is 14
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,Cyclomatic complexity of the method is 29
Complex Method,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,Cyclomatic complexity of the method is 26
Complex Method,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,OnDrawGizmos,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,TriangleMeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,Open,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,TriangleMeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,GetPortal,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,ScanInternal,Cyclomatic complexity of the method is 17
Complex Method,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,Cyclomatic complexity of the method is 19
Complex Method,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,Cyclomatic complexity of the method is 43
Complex Method,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,Cyclomatic complexity of the method is 19
Complex Method,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,ValidateLine,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,Apply,Cyclomatic complexity of the method is 14
Complex Method,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothSimple,Cyclomatic complexity of the method is 16
Complex Method,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,Cyclomatic complexity of the method is 12
Complex Method,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,Prepare,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,DebugString,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,Cyclomatic complexity of the method is 14
Complex Method,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,Cyclomatic complexity of the method is 21
Complex Method,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding.Serialization,UnityObjectConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeExtraInfo,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeNodes,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,Cyclomatic complexity of the method is 14
Long Parameter List,Pathfinding,AstarSplines,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CatmullRom,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarSplines,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CatmullRomOLD,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,DistancePointSegment,The method has 6 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,DistancePointSegment2,The method has 6 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,MapTo,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPointOptimized,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactor,The method has 6 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactor,The method has 6 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,IRaycastableGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,Linecast,The method has 5 parameters.
Long Parameter List,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetNodeConnection,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearest,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForceBoth,The method has 6 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The method has 6 parameters.
Long Parameter List,Pathfinding,TriangleMeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,GetPortal,The method has 6 parameters.
Long Parameter List,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The method has 7 parameters.
Long Parameter List,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The method has 5 parameters.
Long Parameter List,Pathfinding,IFunnelGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,BuildFunnelCorridor,The method has 5 parameters.
Long Parameter List,Pathfinding,MonoModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\Modifiers.cs,Apply,The method has 6 parameters.
Long Parameter List,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,GetPointOnCubic,The method has 5 parameters.
Long Parameter List,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,BFS,The method has 5 parameters.
Long Parameter List,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPointWorld,The method has 5 parameters.
Long Parameter List,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The method has 5 parameters.
Long Parameter List,Pathfinding.Threading,Parallel,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarParallel.cs,For,The method has 5 parameters.
Long Parameter List,Pathfinding.Threading,Parallel,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarParallel.cs,ForLoop,The method has 5 parameters.
Long Statement,Pathfinding,AstarData,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphs,The length of the statement  "				Debug.Log ("Invalid data file (cannot read zip).\nThe data is either corrupt or it was saved using a 3.0.x or earlier version of the system"); " is 142.
Long Statement,Pathfinding,AstarData,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphsPartAdditive,The length of the statement  "				Debug.LogWarning ("Guid Conflict when importing graphs additively. Imported graph will get a new Guid.\nThis message is (relatively) harmless."); " is 145.
Long Statement,Pathfinding,AstarData,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarData.cs,AddGraph,The length of the statement  "		Debug.LogError ("No NavGraph of type '" + type + "' could be found' " + graphTypes.Length + " graph types are avaliable"); " is 122.
Long Statement,Pathfinding,AstarData,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarData.cs,AddGraph,The length of the statement  "		throw new System.Exception ("Graph Count Limit Reached. You cannot have more than " + GraphNode.MaxGraphCount + " graphs. Some compiler directives can change this limit' e.g ASTAR_MORE_AREAS' look under the " + "'Optimizations' tab in the A* Inspector"); " is 254.
Long Statement,Pathfinding,AstarData,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarData.cs,GetNode,The length of the statement  "				Debug.LogError ("Node index is out of range : "+nodeIndex+ " [0-"+(graph.nodes.Length-1)+"]"+" (graph "+graphIndex+")");" is 120.
Long Statement,Pathfinding,AstarSplines,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CatmullRom,The length of the statement  "					tension*percentCompleteSquared);*/return previous * (-0.5F * percentCompleteCubed + percentCompleteSquared - 0.5F * percentComplete) + start * (1.5F * percentCompleteCubed + -2.5F * percentCompleteSquared + 1.0F) + end * (-1.5F * percentCompleteCubed + 2.0F * percentCompleteSquared + 0.5F * percentComplete) + next * (0.5F * percentCompleteCubed - 0.5F * percentCompleteSquared); " is 380.
Long Statement,Pathfinding,AstarSplines,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CatmullRomOLD,The length of the statement  "	return previous * (-0.5F * percentCompleteCubed + percentCompleteSquared - 0.5F * percentComplete) + start * (1.5F * percentCompleteCubed + -2.5F * percentCompleteSquared + 1.0F) + end * (-1.5F * percentCompleteCubed + 2.0F * percentCompleteSquared + 0.5F * percentComplete) + next * (0.5F * percentCompleteCubed - 0.5F * percentCompleteSquared); " is 346.
Long Statement,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "		if (((polyPoints [i].y <= p.y && p.y < polyPoints [j].y) || (polyPoints [j].y <= p.y && p.y < polyPoints [i].y)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.y - polyPoints [i].y) / (polyPoints [j].y - polyPoints [i].y) + polyPoints [i].x)) " is 248.
Long Statement,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "		if (((polyPoints [i].z <= p.z && p.z < polyPoints [j].z) || (polyPoints [j].z <= p.z && p.z < polyPoints [i].z)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.z - polyPoints [i].z) / (polyPoints [j].z - polyPoints [i].z) + polyPoints [i].x)) " is 248.
Long Statement,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The length of the statement  "	//Debug.Log ("U1 "+u.ToString ("0.00")+" U2 "+u2.ToString ("0.00")+"\nP1: "+(start1 + dir1*u)+"\nP2: "+(start2 + dir2*u2)+"\nStart1: "+start1+"  End1: "+end1); " is 159.
Long Statement,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The length of the statement  "	Color c = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f); " is 125.
Long Statement,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The length of the statement  "		Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f); " is 130.
Long Statement,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The length of the statement  "			Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length])); " is 133.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "			throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug"); " is 249.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "		//Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size ("+numberOfItems +" "+binaryHeap.Length+")"); " is 154.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "			//binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /* \todo Wouldn't it be more efficient with '<' instead of '<=' ? * / " is 129.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "			/*if (binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /* \todo Wouldn't it be more efficient with '<' instead of '<=' ? *" is 131.
Long Statement,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The length of the statement  "	return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]); " is 135.
Long Statement,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	//This function assumes that connections from the n1'n2 nodes never need to be removed in the future (e.g because the nodes move or something) " is 142.
Long Statement,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	uint cost = (uint)Mathf.RoundToInt (((Int3)(StartTransform.position - EndTransform.position)).costMagnitude * costFactor); " is 122.
Long Statement,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The length of the statement  "				Vector3 tangent = Vector3.Dot (normal' (Vector3)(other.Position - this.Position) ) > 0 ? link.transform.right*0.5f : -link.transform.right*0.5f;" is 144.
Long Statement,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The length of the statement  "				Debug.DrawLine ( link.transform.position -tangent * link.portalWidth' link.transform.position +tangent * link.portalWidth' Color.red);" is 134.
Long Statement,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOther,The length of the statement  "	return a == connections [0] ? (connections [1] as NodeLink3Node).GetOtherInternal (this) : (connections [0] as NodeLink3Node).GetOtherInternal (this); " is 150.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,InternalOnPostScan,The length of the statement  "	startNode = AstarPath.active.astarData.pointGraph.AddNode (new NodeLink3Node (AstarPath.active)' (Int3)StartTransform.position); " is 128.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,InternalOnPostScan,The length of the statement  "	endNode = AstarPath.active.astarData.pointGraph.AddNode (new NodeLink3Node (AstarPath.active)' (Int3)EndTransform.position); " is 124.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "	//This function assumes that connections from the n1'n2 nodes never need to be removed in the future (e.g because the nodes move or something) " is 142.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "	uint cost = (uint)Mathf.RoundToInt (((Int3)(StartTransform.position - EndTransform.position)).costMagnitude * costFactor); " is 122.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error"); " is 122.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The length of the statement  "	//Gizmos.DrawLine ( transform.position - transform.right*0.5f*portalWidth' transform.position + transform.right*0.5f*portalWidth ); " is 131.
Long Statement,Pathfinding,PathPool,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\PathPool.cs,Recycle,The length of the statement  "			throw new ArgumentException ("Cannot recycle path of type '" + path.GetType ().Name + "' in a pool for path type '" + typeof(T).Name + "'.\n" + "Most likely the path type does not have support for recycling. Please do not call Recycle () on that path"); " is 253.
Long Statement,Pathfinding,ThreadControlQueue,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,Pop,The length of the statement  "				throw new System.InvalidOperationException ("More receivers are blocked than specified in constructor (" + blockedReceivers + " > " + numReceivers + ")"); " is 154.
Long Statement,Pathfinding,ThreadControlQueue,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,PopNoBlock,The length of the statement  "					throw new System.InvalidOperationException ("More receivers are blocked than specified in constructor (" + blockedReceivers + " > " + numReceivers + ")"); " is 154.
Long Statement,Pathfinding,MeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Nodes\GraphNode.cs,ContainsPoint,The length of the statement  "		if (((GetVertex (i).z <= p.z && p.z < GetVertex (j).z) || (GetVertex (j).z <= p.z && p.z < GetVertex (i).z)) && (p.x < (GetVertex (j).x - GetVertex (i).x) * (p.z - GetVertex (i).z) / (GetVertex (j).z - GetVertex (i).z) + GetVertex (i).x)) " is 238.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The length of the statement  "		return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale); " is 143.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,ErrorCheck,The length of the statement  "		throw new System.Exception ("The path has never been reset. Use pooling API or call Reset() after creating the path with the default constructor."); " is 148.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,ErrorCheck,The length of the statement  "		throw new System.Exception ("This path has already been processed. Do not request a path with the same path object twice."); " is 124.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Reset,The length of the statement  "		throw new System.NullReferenceException ("No AstarPath object found in the scene. " + "Make sure there is one or do not create paths in Awake"); " is 144.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Claim,The length of the statement  "		throw new System.ArgumentException ("You have already claimed the path with that object (" + o.ToString () + "). Are you claiming the path with the same object twice?"); " is 169.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,ReleaseSilent,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which is not claimed at all (most likely it has been pooled already). " + "Are you releasing the path with the same object (" + o.ToString () + ") twice?"); " is 218.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,ReleaseSilent,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which has not been claimed with this object (" + o.ToString () + "). " + "Are you releasing the path with the same object twice?"); " is 193.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Release,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which is not claimed at all (most likely it has been pooled already). " + "Are you releasing the path with the same object (" + o.ToString () + ") twice?"); " is 218.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Release,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which has not been claimed with this object (" + o.ToString () + "). " + "Are you releasing the path with the same object twice?"); " is 193.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Trace,The length of the statement  "			Debug.LogWarning ("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs' Trace function)"); " is 135.
Long Statement,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,DebugString,The length of the statement  "				+"\nStart Point = "+p.startPoint+"\n"+"Start Node graph: "+p.startNode.graphIndex+" End Node graph: "+p.endNode.graphIndex+" is 123.
Long Statement,Pathfinding,PathHandler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The length of the statement  "		PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][]; " is 133.
Long Statement,Pathfinding,PathHandler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The length of the statement  "		//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")"); " is 122.
Long Statement,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,Intersection,The length of the statement  "	IntRect r = new IntRect (System.Math.Max (a.xmin' b.xmin)' System.Math.Max (a.ymin' b.ymin)' System.Math.Min (a.xmax' b.xmax)' System.Math.Min (a.ymax' b.ymax)); " is 161.
Long Statement,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,Union,The length of the statement  "	IntRect r = new IntRect (System.Math.Min (a.xmin' b.xmin)' System.Math.Min (a.ymin' b.ymin)' System.Math.Max (a.xmax' b.xmax)' System.Math.Max (a.ymax' b.ymax)); " is 161.
Long Statement,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,ExpandToContain,The length of the statement  "	IntRect r = new IntRect (System.Math.Min (xmin' x)' System.Math.Min (ymin' y)' System.Math.Max (xmax' x)' System.Math.Max (ymax' y)); " is 133.
Long Statement,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,Rotate,The length of the statement  "	return new IntRect (System.Math.Min (p1x' p2x)' System.Math.Min (p1y' p2y)' System.Math.Max (p1x' p2x)' System.Math.Max (p1y' p2y)); " is 132.
Long Statement,Pathfinding,TargetMover,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\ExampleScenes\ExampleScripts\TargetMover.cs,UpdateTargetPosition,The length of the statement  "	if (Physics.Raycast (cam.ScreenPointToRay (Input.mousePosition)' out hit' Mathf.Infinity' mask) && hit.point != target.position) { " is 130.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,GetNearest,The length of the statement  "	//Debug.LogError ("This function (GetNearest) is not implemented in the navigation graph generator : Type "+this.GetType ().Name); " is 130.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,GetNearestForce,The length of the statement  "	//Debug.LogError ("This should not be called if not GetNearest has been overriden' and if GetNearest has been overriden' you should override this function too' always return a node which returns true when passed to constraint.Suitable (node)"); " is 244.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,Scan,The length of the statement  "	throw new System.Exception ("This method is deprecated. Please use AstarPath.active.Scan or if you really want this.ScanInternal which has the same functionality as this method had."); " is 184.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "		c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.Penalty / (float)AstarPath.active.debugRoof); " is 134.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "			c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.G / (float)AstarPath.active.debugRoof); " is 129.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "			c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.H / (float)AstarPath.active.debugRoof); " is 129.
Long Statement,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "			c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.F / (float)AstarPath.active.debugRoof); " is 129.
Long Statement,Pathfinding,GraphCollision,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The length of the statement  "					Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit); " is 121.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,OnDestroy,The length of the statement  "	//Clean up a reference in a static variable which otherwise should point to this graph forever and stop the GC from collecting it " is 129.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GenerateMatrix,The length of the statement  "	SetMatrix (Matrix4x4.TRS (boundsMatrix.MultiplyPoint3x4 (-new Vector3 (size.x' 0' size.y) * 0.5F)' Quaternion.Euler (rotation)' new Vector3 (nodeSize * aspectRatio' 1' nodeSize))); " is 180.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearest,The length of the statement  "	nn.clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' x - 0.5f' x + 0.5f) + 0.5f' y' Mathf.Clamp (zf' z - 0.5f' z + 0.5f) + 0.5f)); " is 153.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "		clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' x - 0.5f' x + 0.5f) + 0.5f' y' Mathf.Clamp (zf' z - 0.5f' z + 0.5f) + 0.5f)); " is 150.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The length of the statement  "			Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)"); " is 172.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The length of the statement  "				//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too " is 130.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The length of the statement  "			physicsRect = new IntRect (Mathf.RoundToInt (min.x - 0.5F)' Mathf.RoundToInt (min.z - 0.5F)' Mathf.RoundToInt (max.x - 0.5F)' Mathf.RoundToInt (max.z - 0.5F)); " is 159.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The length of the statement  "				after calculation since their erosion might not be correctly calculated (nodes outside erosionRect2 would maybe have effect)" is 124.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,PostDeserialization,The length of the statement  "		Debug.LogWarning ("Node data did not match with bounds data. Probably a change to the bounds/width/depth data was made after scanning the graph just prior to saving it. Nodes will be discarded"); " is 195.
Long Statement,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,PostDeserialization,The length of the statement  "				Debug.LogError ("Deserialization Error : Couldn't cast the node to the appropriate type - GridGenerator. Check the CreateNodes function"); " is 138.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RelocateNodes,The length of the statement  "	if (vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length) { " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The length of the statement  "		Debug.LogError ("Couldn't cast graph to the appropriate type (graph isn't a Navmesh type graph' it doesn't implement the INavmesh interface)"); " is 143.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The length of the statement  "				if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) { " is 123.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The length of the statement  "	IntRect r2 = new IntRect (Mathf.FloorToInt (bounds.min.x * Int3.Precision)' Mathf.FloorToInt (bounds.min.z * Int3.Precision)' Mathf.FloorToInt (bounds.max.x * Int3.Precision)' Mathf.FloorToInt (bounds.max.z * Int3.Precision)); " is 226.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ClosestPointOnNode,The length of the statement  "	return Polygon.ClosestPointOnTriangle ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos); " is 131.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (Polygon.IsClockwise ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' pos) && Polygon.IsClockwise ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos) && Polygon.IsClockwise ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' pos)) { " is 264.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (!Polygon.IsClockwiseMargin ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' (Vector3)vertices [node.v2])) { " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (Polygon.IsClockwiseMargin ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' pos) && Polygon.IsClockwiseMargin ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos) && Polygon.IsClockwiseMargin ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' pos)) { " is 282.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "			}*///Debug.Log ("NavMesh - Old vertice count "+vertices.Length+"' new vertice count "+c+" "+maxX+" "+maxZ+" "+maxX*maxZ); " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "		Debug.LogError ("One or more triangles are identical to other triangles' this is not a good thing to have in a navmesh\nIncreasing the scale of the mesh might help\nNumber of triangles with error: " + identicalError + "\n"); " is 224.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "	//Debug.Log ("Graph Generation - NavMesh - Time to compute graph "+((Time.realtimeSinceStartup-startTime)*1000F).ToString ("0")+"ms"); " is 134.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RebuildBBTree,The length of the statement  "	//BBTrees is a A* Pathfinding Project Pro only feature - The Pro version can be bought in the Unity Asset Store or on arongranberg.com " is 134.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,Sort,The length of the statement  "			if (a [i].x > a [i + 1].x || (a [i].x == a [i + 1].x && (a [i].y > a [i + 1].y || (a [i].y == a [i + 1].y && a [i].z > a [i + 1].z)))) { " is 136.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,SerializeMeshNodes,The length of the statement  "			Debug.LogError ("Serialization Error : Couldn't cast the node to the appropriate type - NavMeshGenerator. Omitting node data."); " is 128.
Long Statement,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,SetConnectionInternal,The length of the statement  "		gridFlags = (ushort)(gridFlags & ~((ushort)1 << GridFlagsConnectionOffset << dir) | (value ? (ushort)1 : (ushort)0) << GridFlagsConnectionOffset << dir); " is 153.
Long Statement,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,Open,The length of the statement  "					//Debug.Log ("Path better from " + NodeIndex + " to " + otherPN.node.NodeIndex + " " + (pathNode.G+tmpCost+path.GetTraversalCost(other)) + " < " + otherPN.G); " is 158.
Long Statement,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,Open,The length of the statement  "					//Debug.Log ("Path better from " + otherPN.node.NodeIndex + " to " + NodeIndex + " " + (otherPN.G+tmpCost+path.GetTraversalCost (this)) + " < " + pathNode.G); " is 158.
Long Statement,Pathfinding,TriangleMeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,ClosestPointOnNode,The length of the statement  "	return Pathfinding.Polygon.ClosestPointOnTriangle ((Vector3)g.GetVertex (v0)' (Vector3)g.GetVertex (v1)' (Vector3)g.GetVertex (v2)' p); " is 135.
Long Statement,Pathfinding,TriangleMeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,ContainsPoint,The length of the statement  "	//return Polygon.IsClockwiseMargin (a'b' p) && Polygon.IsClockwiseMargin (b'c' p) && Polygon.IsClockwiseMargin (c'a' p); " is 120.
Long Statement,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,GetNearestForce,The length of the statement  "	//Debug.LogError ("This function (GetNearest) is not implemented in the navigation graph generator : Type "+this.GetType ().Name); " is 130.
Long Statement,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,IsValidConnection,The length of the statement  "	if ((!Mathf.Approximately (limits.x' 0) && Mathf.Abs (dir.x) > limits.x) || (!Mathf.Approximately (limits.y' 0) && Mathf.Abs (dir.y) > limits.y) || (!Mathf.Approximately (limits.z' 0) && Mathf.Abs (dir.z) > limits.z)) { " is 219.
Long Statement,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,IsValidConnection,The length of the statement  "				if (!Physics.SphereCast (ray' thickRaycastRadius' dist' mask) && !Physics.SphereCast (invertRay' thickRaycastRadius' dist' mask)) { " is 131.
Long Statement,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,LocalToWorldPosition,The length of the statement  "	/** \bug Change to XY plane' matrix should handle rotation */return new Vector3 ((x + width * 0.5f) * nodeSize' 0' (y + width * 0.5f) * nodeSize); " is 146.
Long Statement,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The length of the statement  "			if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) { " is 141.
Long Statement,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "			if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) { " is 399.
Long Statement,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "					mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3])); " is 165.
Long Statement,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "					mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3])); " is 165.
Long Statement,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "					while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face. " is 131.
Long Statement,Pathfinding,AlternativePath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\AlternativePath.cs,InversePrevious,The length of the statement  "			Debug.LogWarning ("Penalty for some nodes has been reset while this modifier was active. Penalties might not be correctly set."); " is 129.
Long Statement,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The length of the statement  "	while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) { " is 155.
Long Statement,Pathfinding,ModifierConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\Modifiers.cs,Convert,The length of the statement  "		return ModifierData.VectorPath | (AnyBits (input' ModifierData.StrictNodePath) ? ModifierData.StrictVectorPath : ModifierData.None); " is 132.
Long Statement,Pathfinding,ModifierConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\Modifiers.cs,Convert,The length of the statement  "	Debug.LogError ("This part should not be reached - Error in ModifierConverted\nInput: " + input + " (" + (int)input + ")\nOutput: " + output + " (" + (int)output + ")"); " is 169.
Long Statement,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The length of the statement  "		Debug.LogWarning ("Max Segment Length is <= 0 which would cause DivByZero-exception or other nasty errors (avoid this)"); " is 121.
Long Statement,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The length of the statement  "		Vector3 endVel1 = i < path.Count - 2 ? ((path [i + 2] - path [i + 1]).normalized - (path [i] - path [i + 1]).normalized).normalized : (path [i + 1] - path [i]).normalized; " is 171.
Long Statement,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The length of the statement  "		pStart = AstarMath.NearestPointStrict ((Vector3)p.path [0].position' (Vector3)p.path [1 >= p.path.Count ? 0 : 1].position' pStart); " is 131.
Long Statement,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The length of the statement  "		pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd); " is 160.
Long Statement,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The length of the statement  "		//Vector3[] newPath = new Vector3[p.vectorPath.Length+(exactStartPoint != Exactness.SnapToNode ? 1 : 0) + (exactEndPoint  != Exactness.SnapToNode ? 1 : 0)]; " is 156.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - (b == endNode ? hTarget : b.position)).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 149.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - (a == endNode ? hTarget : a.position)).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 149.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - b.position).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 122.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - a.position).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 122.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,Prepare,The length of the statement  "	//Tell the NNConstraint which node was found as the start node if it is a PathNNConstraint and not a normal NNConstraint " is 120.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,Prepare,The length of the statement  "		LogError ("There is no valid path to the target (start area: " + startNode.Area + "' target area: " + endNode.Area + ")"); " is 122.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,Initialize,The length of the statement  "				callback += ResetCosts; /* \todo Might interfere with other paths since other paths might be calculated before #callback is called *" is 132.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The length of the statement  "			//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag " is 131.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,DebugString,The length of the statement  "			//text.Append (pathHandler.open == null ? "Null" : (pathHandler.open.numberOfItems-2).ToString ());// -2 because numberOfItems includes the next item to be added and item zero is not used " is 187.
Long Statement,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,DebugString,The length of the statement  "				+"\nStart Point = "+p.startPoint+"\n"+"Start Node graph: "+p.startNode.graphIndex+" End Node graph: "+p.endNode.graphIndex+" is 123.
Long Statement,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The length of the statement  "		output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   "); " is 152.
Long Statement,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The length of the statement  "	output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20)); " is 198.
Long Statement,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The length of the statement  "					p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0); " is 152.
Long Statement,Pathfinding,Profile,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\ProfileHelper.cs,Control,The length of the statement  "		throw new System.Exception ("Control numbers do not match (" + name + " " + other.name + ") " + this.ControlValue () + " != " + other.ControlValue ()); " is 151.
Long Statement,Pathfinding,Profile,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\ProfileHelper.cs,ToString,The length of the statement  "	string s = name + " #" + counter + " " + w.Elapsed.TotalMilliseconds.ToString ("0.0 ms") + " avg: " + (w.Elapsed.TotalMilliseconds / counter).ToString ("0.00 ms"); " is 163.
Long Statement,Pathfinding.Util,ObjectPool,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\ObjectPool.cs,Release,The length of the statement  "			throw new System.InvalidOperationException ("The object is released even though it is in the pool. Are you releasing it twice?"); " is 129.
Long Statement,Pathfinding.Serialization,UnityObjectConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The length of the statement  "		UnityReferenceHelper[] helpers = UnityEngine.Object.FindObjectsOfType (typeof(UnityReferenceHelper)) as UnityReferenceHelper[]; " is 127.
Long Statement,Pathfinding.Serialization,VectorConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The length of the statement  "		return new Vector4 (CastFloat (values ["x"])' CastFloat (values ["y"])' CastFloat (values ["z"])' CastFloat (values ["w"])); " is 124.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeExtraInfo,The length of the statement  "			throw new System.Exception ("Some graphs are not consistent in their GetNodes calls' sequential calls give different results."); " is 128.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeNodeConnections,The length of the statement  "					throw new IndexOutOfRangeException ("Node.connections.Length != Node.connectionCosts.Length. In node "+i+" in graph "+index);" is 125.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,OpenDeserialize,The length of the statement  "		Debug.LogWarning ("Trying to load data from a newer version of the A* Pathfinding Project\nCurrent version: " + AstarPath.Version + " Data version: " + meta.version); " is 166.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,OpenDeserialize,The length of the statement  "		Debug.LogWarning ("Trying to load data from an older version of the A* Pathfinding Project\nCurrent version: " + AstarPath.Version + " Data version: " + meta.version + "\nThis is usually fine' it just means you have upgraded to a new version.\nHowever node data (not settings) can get corrupted between versions' so it is recommended" + "to recalculate any caches (those for faster startup) and resave any files. Even if it seems to load fine' it might cause subtle bugs.\n"); " is 476.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeGraphs,The length of the statement  "			throw new FileNotFoundException ("Could not find data for graph " + i + " in zip. Entry 'graph+" + i + jsonExt + "' does not exist"); " is 133.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeGraphs,The length of the statement  "			throw new System.Exception ("Guid in graph file not equal to guid defined in meta file. Have you edited the data manually?\n" + graphs [i].guid.ToString () + " != " + meta.guids [i]); " is 183.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,The length of the statement  "			throw new System.Exception ("Node references not found in the data. Was this loaded from an older version of the A* Pathfinding Project?"); " is 139.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,The length of the statement  "			throw new System.Exception ("Some graph(s) has thrown an exception during GetNodes' or some graph(s) have deserialized more or fewer nodes than were serialized"' e); " is 165.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,The length of the statement  "				throw new System.Exception ("Node references for graph " + i + " not found in the data. Was this loaded from an older version of the A* Pathfinding Project?"); " is 159.
Long Statement,Pathfinding.Serialization,SerializeSettings,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,OnGUI,The length of the statement  "	prettyPrint = UnityEditor.EditorGUILayout.Toggle (new GUIContent ("Pretty Print"' "Format Json data for readability. Yields slightly smaller files when turned off")' prettyPrint); " is 179.
Complex Conditional,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The conditional expression  "((polyPoints [i].y <= p.y && p.y < polyPoints [j].y) || (polyPoints [j].y <= p.y && p.y < polyPoints [i].y)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.y - polyPoints [i].y) / (polyPoints [j].y - polyPoints [i].y) + polyPoints [i].x)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The conditional expression  "((polyPoints [i].z <= p.z && p.z < polyPoints [j].z) || (polyPoints [j].z <= p.z && p.z < polyPoints [i].z)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.z - polyPoints [i].z) / (polyPoints [j].z - polyPoints [i].z) + polyPoints [i].x)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,Intersects,The conditional expression  "u < 0F || u > 1F || u2 < 0F || u2 > 1F"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactorRaySegment,The conditional expression  "(den >= 0 && nom2 > den) || (den < 0 && nom2 <= den)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The conditional expression  "u < 0F || u > 1F || u2 < 0F || u2 > 1F"  is complex.
Complex Conditional,Pathfinding,MeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Nodes\GraphNode.cs,ContainsPoint,The conditional expression  "((GetVertex (i).z <= p.z && p.z < GetVertex (j).z) || (GetVertex (j).z <= p.z && p.z < GetVertex (i).z)) && (p.x < (GetVertex (j).x - GetVertex (i).x) * (p.z - GetVertex (i).z) / (GetVertex (j).z - GetVertex (i).z) + GetVertex (i).x)"  is complex.
Complex Conditional,Pathfinding,TargetMover,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\ExampleScenes\ExampleScripts\TargetMover.cs,OnGUI,The conditional expression  "onlyOnDoubleClick && cam != null && Event.current.type == EventType.MouseDown && Event.current.clickCount == 2"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RelocateNodes,The conditional expression  "vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The conditional expression  "allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The conditional expression  "node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,Sort,The conditional expression  "a [i].x > a [i + 1].x || (a [i].x == a [i + 1].x && (a [i].y > a [i + 1].y || (a [i].y == a [i + 1].y && a [i].z > a [i + 1].z)))"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,SerializeExtraInfo,The conditional expression  "nodes == null || originalVertices == null || _vertices == null || originalVertices.Length != _vertices.Length"  is complex.
Complex Conditional,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,GetNearestForce,The conditional expression  "constraint == null || (dist < minConstDist && dist < maxDistSqr && constraint.Suitable (node))"  is complex.
Complex Conditional,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,IsValidConnection,The conditional expression  "(!Mathf.Approximately (limits.x' 0) && Mathf.Abs (dir.x) > limits.x) || (!Mathf.Approximately (limits.y' 0) && Mathf.Abs (dir.y) > limits.y) || (!Mathf.Approximately (limits.z' 0) && Mathf.Abs (dir.z) > limits.z)"  is complex.
Complex Conditional,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The conditional expression  "!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")"  is complex.
Complex Conditional,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The conditional expression  "!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")"  is complex.
Complex Conditional,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,Apply,The conditional expression  "path == null || path.Count == 0 || vectorPath == null || vectorPath.Count != path.Count"  is complex.
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ComputeVertexHash,The following statement contains a magic number: return (int)(n & ((1 << 30) - 1));  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return t2 * t2 * t2 * p0 + 3 * t2 * t2 * t * p1 + 3 * t2 * t * t * p2 + t * t * t * p3;  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return t2 * t2 * t2 * p0 + 3 * t2 * t2 * t * p1 + 3 * t2 * t * t * p2 + t * t * t * p3;  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ConvexHull,The following statement contains a magic number: lock (hullCache) {  	List<Vector3> hull = hullCache;  	hull.Clear ();  	int pointOnHull = 0;  	for (int i = 1; i < points.Length; i++)  		if (points [i].x < points [pointOnHull].x)  			pointOnHull = i;  	int startpoint = pointOnHull;  	int counter = 0;  	do {  		hull.Add (points [pointOnHull]);  		int endpoint = 0;  		for (int i = 0; i < points.Length; i++)  			if (endpoint == pointOnHull || !Left (points [pointOnHull]' points [endpoint]' points [i]))  				endpoint = i;  		pointOnHull = endpoint;  		counter++;  		if (counter > 10000) {  			Debug.LogWarning ("Infinite Loop in Convex Hull Calculation");  			break;  		}  	}  	while (pointOnHull != startpoint);  	return hull.ToArray ();  }  
Magic Number,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ConvexHull,The following statement contains a magic number: do {  	hull.Add (points [pointOnHull]);  	int endpoint = 0;  	for (int i = 0; i < points.Length; i++)  		if (endpoint == pointOnHull || !Left (points [pointOnHull]' points [endpoint]' points [i]))  			endpoint = i;  	pointOnHull = endpoint;  	counter++;  	if (counter > 10000) {  		Debug.LogWarning ("Infinite Loop in Convex Hull Calculation");  		break;  	}  }  while (pointOnHull != startpoint);  
Magic Number,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ConvexHull,The following statement contains a magic number: if (counter > 10000) {  	Debug.LogWarning ("Infinite Loop in Convex Hull Calculation");  	break;  }  
Magic Number,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,Subdivide,The following statement contains a magic number: for (int p = 0; p < path.Length - 1; p++) {  	float step = 1.0F / Mathf.Pow (2' subdivisions);  	for (float i = 0; i < 1.0F; i += step) {  		path2 [c] = Vector3.Lerp (path [p]' path [p + 1]' Mathf.SmoothStep (0' 1' i));  		c++;  	}  }  
Magic Number,Pathfinding,Polygon,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\AstarMath.cs,ClosestPointOnTriangle,The following statement contains a magic number: return ClosestPointOnTriangle (triangle [0]' triangle [1]' triangle [2]' point);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,AnimationLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,The following statement contains a magic number: for (int i = 0; i < sequence.Length; i++) {  	LinkClip c = sequence [i];  	if (c == null) {  		endPosition = position;  		return;  	}  	anim [c.clip.name].enabled = true;  	anim [c.clip.name].weight = 1;  	for (int repeat = 0; repeat < c.loopCount; repeat++) {  		anim [c.clip.name].normalizedTime = 0;  		anim.Sample ();  		Vector3 soffset = root.position - transform.position;  		if (i > 0) {  			position += prevOffset - soffset;  		}  		else {  			firstOffset = soffset;  		}  		for (int t = 0; t <= 20; t++) {  			float tf = t / 20.0f;  			anim [c.clip.name].normalizedTime = tf;  			anim.Sample ();  			Vector3 tmp = position + (root.position - transform.position) + c.velocity * tf * c.clip.length;  			trace.Add (tmp);  		}  		position = position + c.velocity * 1 * c.clip.length;  		anim [c.clip.name].normalizedTime = 1;  		anim.Sample ();  		Vector3 eoffset = root.position - transform.position;  		prevOffset = eoffset;  	}  	anim [c.clip.name].enabled = false;  	anim [c.clip.name].weight = 0;  }  
Magic Number,Pathfinding,AnimationLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,The following statement contains a magic number: for (int repeat = 0; repeat < c.loopCount; repeat++) {  	anim [c.clip.name].normalizedTime = 0;  	anim.Sample ();  	Vector3 soffset = root.position - transform.position;  	if (i > 0) {  		position += prevOffset - soffset;  	}  	else {  		firstOffset = soffset;  	}  	for (int t = 0; t <= 20; t++) {  		float tf = t / 20.0f;  		anim [c.clip.name].normalizedTime = tf;  		anim.Sample ();  		Vector3 tmp = position + (root.position - transform.position) + c.velocity * tf * c.clip.length;  		trace.Add (tmp);  	}  	position = position + c.velocity * 1 * c.clip.length;  	anim [c.clip.name].normalizedTime = 1;  	anim.Sample ();  	Vector3 eoffset = root.position - transform.position;  	prevOffset = eoffset;  }  
Magic Number,Pathfinding,AnimationLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,The following statement contains a magic number: for (int t = 0; t <= 20; t++) {  	float tf = t / 20.0f;  	anim [c.clip.name].normalizedTime = tf;  	anim.Sample ();  	Vector3 tmp = position + (root.position - transform.position) + c.velocity * tf * c.clip.length;  	trace.Add (tmp);  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: if (numberOfItems == binaryHeap.Length) {  	int newSize = System.Math.Max (binaryHeap.Length + 4' (int)System.Math.Round (binaryHeap.Length * growthFactor));  	if (newSize > 1 << 18) {  		throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");  	}  	PathNode[] tmp = new PathNode[newSize];  	for (int i = 0; i < binaryHeap.Length; i++) {  		tmp [i] = binaryHeap [i];  	}  	binaryHeap = tmp;  	//Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size ("+numberOfItems +" "+binaryHeap.Length+")");  	//numberOfItems--;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: if (numberOfItems == binaryHeap.Length) {  	int newSize = System.Math.Max (binaryHeap.Length + 4' (int)System.Math.Round (binaryHeap.Length * growthFactor));  	if (newSize > 1 << 18) {  		throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");  	}  	PathNode[] tmp = new PathNode[newSize];  	for (int i = 0; i < binaryHeap.Length; i++) {  		tmp [i] = binaryHeap [i];  	}  	binaryHeap = tmp;  	//Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size ("+numberOfItems +" "+binaryHeap.Length+")");  	//numberOfItems--;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: if (newSize > 1 << 18) {  	throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: while (bubbleIndex != 1) {  	int parentIndex = bubbleIndex / 2;  	if (nodeF < binaryHeap [parentIndex].F) {  		//binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /* \todo Wouldn't it be more efficient with '<' instead of '<=' ? * /  		//Node tmpValue = binaryHeap[parentIndex];  		//tmpValue.heapIndex = bubbleIndex;//HeapIndex  		binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  		binaryHeap [parentIndex] = node;  		//binaryHeap[bubbleIndex];  		//binaryHeap[bubbleIndex].heapIndex = bubbleIndex; //Heap index  		//binaryHeap[parentIndex].heapIndex = parentIndex; //Heap index  		bubbleIndex = parentIndex;  	}  	else {  		/*if (binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /* \todo Wouldn't it be more efficient with '<' instead of '<=' ? * 					Node tmpValue = binaryHeap[parentIndex]; 					 					//tmpValue.heapIndex = bubbleIndex;//HeapIndex 					 					 					binaryHeap[parentIndex] = binaryHeap[bubbleIndex]; 					binaryHeap[bubbleIndex] = tmpValue; 					 					bubbleIndex = parentIndex; 				} else {*/break;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	parent = swapItem;  	int p2 = parent * 2;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F >= binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F >= binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F >= binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		PathNode tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  }  while (parent != swapItem);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Rebuild,The following statement contains a magic number: for (int i = 2; i < numberOfItems; i++) {  	int bubbleIndex = i;  	PathNode node = binaryHeap [i];  	uint nodeF = node.F;  	while (bubbleIndex != 1) {  		int parentIndex = bubbleIndex / 2;  		if (nodeF < binaryHeap [parentIndex].F) {  			//Node tmpValue = binaryHeap[parentIndex];  			binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  			binaryHeap [parentIndex] = node;  			bubbleIndex = parentIndex;  		}  		else {  			break;  		}  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Rebuild,The following statement contains a magic number: for (int i = 2; i < numberOfItems; i++) {  	int bubbleIndex = i;  	PathNode node = binaryHeap [i];  	uint nodeF = node.F;  	while (bubbleIndex != 1) {  		int parentIndex = bubbleIndex / 2;  		if (nodeF < binaryHeap [parentIndex].F) {  			//Node tmpValue = binaryHeap[parentIndex];  			binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  			binaryHeap [parentIndex] = node;  			bubbleIndex = parentIndex;  		}  		else {  			break;  		}  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Rebuild,The following statement contains a magic number: while (bubbleIndex != 1) {  	int parentIndex = bubbleIndex / 2;  	if (nodeF < binaryHeap [parentIndex].F) {  		//Node tmpValue = binaryHeap[parentIndex];  		binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  		binaryHeap [parentIndex] = node;  		bubbleIndex = parentIndex;  	}  	else {  		break;  	}  }  
Magic Number,Pathfinding,Int3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 9 + y * 10 + z * 11;  
Magic Number,Pathfinding,Int3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 9 + y * 10 + z * 11;  
Magic Number,Pathfinding,Int3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 9 + y * 10 + z * 11;  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 49157 + y * 98317;  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 49157 + y * 98317;  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: r = r % 4;  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,NodeLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink.cs,DrawGizmoBezier,The following statement contains a magic number: for (int i = 1; i <= 20; i++) {  	float t = i / 20.0f;  	Vector3 p = AstarMath.CubicBezier (p1' p1c' p2c' p2' t);  	Gizmos.DrawLine (prev' p);  	prev = p;  }  
Magic Number,Pathfinding,NodeLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink.cs,LinkObjects,The following statement contains a magic number: if (tfs.Length == 2) {  	LinkObjects (tfs [0]' tfs [1]' false);  }  
Magic Number,Pathfinding,NodeLink,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink.cs,UnlinkObjects,The following statement contains a magic number: if (tfs.Length == 2) {  	LinkObjects (tfs [0]' tfs [1]' true);  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,DrawGizmoBezier,The following statement contains a magic number: for (int i = 1; i <= 20; i++) {  	float t = i / 20.0f;  	Vector3 p = AstarMath.CubicBezier (p1' p1c' p2c' p2' t);  	Gizmos.DrawLine (prev' p);  	prev = p;  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: if (StartTransform != null) {  	DrawCircle (StartTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (StartTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: if (EndTransform != null) {  	DrawCircle (EndTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (EndTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The following statement contains a magic number: if (this.connections.Length < 2)  	return false;  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The following statement contains a magic number: if (this.connections.Length != 2)  	throw new System.Exception ("Invalid NodeLink3Node. Expected 2 connections' found " + this.connections.Length);  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOther,The following statement contains a magic number: if (this.connections.Length < 2)  	return null;  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOther,The following statement contains a magic number: if (this.connections.Length != 2)  	throw new System.Exception ("Invalid NodeLink3Node. Expected 2 connections' found " + this.connections.Length);  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOtherInternal,The following statement contains a magic number: if (this.connections.Length < 2)  	return null;  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (true) {  	NNInfo n1 = AstarPath.active.GetNearest (StartTransform.position' nn);  	same &= n1.node == connectedNode1 && n1.node != null;  	connectedNode1 = n1.node as MeshNode;  	clamped1 = n1.clampedPosition;  	if (connectedNode1 != null)  		Debug.DrawRay ((Vector3)connectedNode1.position' Vector3.up * 5' Color.red);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (connectedNode1 != null)  	Debug.DrawRay ((Vector3)connectedNode1.position' Vector3.up * 5' Color.red);  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: Debug.DrawRay ((Vector3)connectedNode1.position' Vector3.up * 5' Color.red);  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (true) {  	NNInfo n2 = AstarPath.active.GetNearest (EndTransform.position' nn);  	same &= n2.node == connectedNode2 && n2.node != null;  	connectedNode2 = n2.node as MeshNode;  	clamped2 = n2.clampedPosition;  	if (connectedNode2 != null)  		Debug.DrawRay ((Vector3)connectedNode2.position' Vector3.up * 5' Color.cyan);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (connectedNode2 != null)  	Debug.DrawRay ((Vector3)connectedNode2.position' Vector3.up * 5' Color.cyan);  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: Debug.DrawRay ((Vector3)connectedNode2.position' Vector3.up * 5' Color.cyan);  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int a = 0; a < connectedNode1.GetVertexCount (); a++) {  	Int3 va1 = connectedNode1.GetVertex (a);  	Int3 va2 = connectedNode1.GetVertex ((a + 1) % connectedNode1.GetVertexCount ());  	if (Int3.DotLong ((va2 - va1).Normal2D ()' dir) > 0)  		continue;  	for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  		Int3 vb1 = connectedNode2.GetVertex (b);  		Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  		if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  			continue;  		//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  		//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  		//Debug.Break ();  		if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  			float t1 = 0;  			float t2 = 1;  			t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  			t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  			if (t2 < t1) {  				Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  			}  			else {  				Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  				Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  				startNode.portalA = pa;  				startNode.portalB = pb;  				endNode.portalA = pb;  				endNode.portalB = pa;  				//Add connections between nodes' or replace old connections if existing  				connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				return;  			}  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int a = 0; a < connectedNode1.GetVertexCount (); a++) {  	Int3 va1 = connectedNode1.GetVertex (a);  	Int3 va2 = connectedNode1.GetVertex ((a + 1) % connectedNode1.GetVertexCount ());  	if (Int3.DotLong ((va2 - va1).Normal2D ()' dir) > 0)  		continue;  	for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  		Int3 vb1 = connectedNode2.GetVertex (b);  		Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  		if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  			continue;  		//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  		//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  		//Debug.Break ();  		if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  			float t1 = 0;  			float t2 = 1;  			t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  			t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  			if (t2 < t1) {  				Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  			}  			else {  				Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  				Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  				startNode.portalA = pa;  				startNode.portalB = pb;  				endNode.portalA = pb;  				endNode.portalB = pa;  				//Add connections between nodes' or replace old connections if existing  				connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				return;  			}  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  	Int3 vb1 = connectedNode2.GetVertex (b);  	Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  	if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  		continue;  	//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  	//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  	//Debug.Break ();  	if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  		float t1 = 0;  		float t2 = 1;  		t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  		t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  		if (t2 < t1) {  			Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  		}  		else {  			Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  			Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  			startNode.portalA = pa;  			startNode.portalB = pb;  			endNode.portalA = pb;  			endNode.portalB = pa;  			//Add connections between nodes' or replace old connections if existing  			connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			return;  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  	Int3 vb1 = connectedNode2.GetVertex (b);  	Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  	if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  		continue;  	//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  	//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  	//Debug.Break ();  	if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  		float t1 = 0;  		float t2 = 1;  		t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  		t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  		if (t2 < t1) {  			Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  		}  		else {  			Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  			Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  			startNode.portalA = pa;  			startNode.portalB = pb;  			endNode.portalA = pb;  			endNode.portalB = pa;  			//Add connections between nodes' or replace old connections if existing  			connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			return;  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  	float t1 = 0;  	float t2 = 1;  	t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  	t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  	if (t2 < t1) {  		Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  	}  	else {  		Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  		Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  		startNode.portalA = pa;  		startNode.portalB = pb;  		endNode.portalA = pb;  		endNode.portalB = pa;  		//Add connections between nodes' or replace old connections if existing  		connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		return;  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  	float t1 = 0;  	float t2 = 1;  	t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  	t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  	if (t2 < t1) {  		Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  	}  	else {  		Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  		Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  		startNode.portalA = pa;  		startNode.portalB = pb;  		endNode.portalA = pb;  		endNode.portalB = pa;  		//Add connections between nodes' or replace old connections if existing  		connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		return;  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,DrawGizmoBezier,The following statement contains a magic number: for (int i = 1; i <= 20; i++) {  	float t = i / 20.0f;  	Vector3 p = AstarMath.CubicBezier (p1' p1c' p2c' p2' t);  	Gizmos.DrawLine (prev' p);  	prev = p;  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: if (StartTransform != null) {  	DrawCircle (StartTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (StartTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: if (EndTransform != null) {  	DrawCircle (EndTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (EndTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: switch (heuristic) {  case Heuristic.Euclidean:  	return (uint)(((GetHTarget () - node.position).costMagnitude) * heuristicScale);  case Heuristic.Manhattan:  	Int3 p2 = node.position;  	return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale);  case Heuristic.DiagonalManhattan:  	Int3 p = GetHTarget () - node.position;  	p.x = System.Math.Abs (p.x);  	p.y = System.Math.Abs (p.y);  	p.z = System.Math.Abs (p.z);  	int diag = System.Math.Min (p.x' p.z);  	int diag2 = System.Math.Max (p.x' p.z);  	return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  }  
Magic Number,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: switch (heuristic) {  case Heuristic.Euclidean:  	return (uint)(((GetHTarget () - node.position).costMagnitude) * heuristicScale);  case Heuristic.Manhattan:  	Int3 p2 = node.position;  	return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale);  case Heuristic.DiagonalManhattan:  	Int3 p = GetHTarget () - node.position;  	p.x = System.Math.Abs (p.x);  	p.y = System.Math.Abs (p.y);  	p.z = System.Math.Abs (p.z);  	int diag = System.Math.Min (p.x' p.z);  	int diag2 = System.Math.Max (p.x' p.z);  	return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  }  
Magic Number,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  
Magic Number,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  
Magic Number,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Trace,The following statement contains a magic number: while (c != null) {  	c = c.parent;  	count++;  	if (count > 1024) {  		Debug.LogWarning ("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs' Trace function)");  		break;  	}  }  
Magic Number,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,Trace,The following statement contains a magic number: if (count > 1024) {  	Debug.LogWarning ("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs' Trace function)");  	break;  }  
Magic Number,Pathfinding,PathHandler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The following statement contains a magic number: if (bucketNumber >= nodes.Length) {  	//At least increase the size to:  	//Current size * 1.5  	//Current size + 2 or  	//bucketNumber  	PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][];  	for (int i = 0; i < nodes.Length; i++)  		newNodes [i] = nodes [i];  	//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")");  	bool[] newBucketNew = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketNew [i] = bucketNew [i];  	bool[] newBucketCreated = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketCreated [i] = bucketCreated [i];  	nodes = newNodes;  	bucketNew = newBucketNew;  	bucketCreated = newBucketCreated;  }  
Magic Number,Pathfinding,PathHandler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The following statement contains a magic number: if (bucketNumber >= nodes.Length) {  	//At least increase the size to:  	//Current size * 1.5  	//Current size + 2 or  	//bucketNumber  	PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][];  	for (int i = 0; i < nodes.Length; i++)  		newNodes [i] = nodes [i];  	//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")");  	bool[] newBucketNew = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketNew [i] = bucketNew [i];  	bool[] newBucketCreated = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketCreated [i] = bucketCreated [i];  	nodes = newNodes;  	bucketNew = newBucketNew;  	bucketCreated = newBucketCreated;  }  
Magic Number,Pathfinding,PathHandler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The following statement contains a magic number: if (bucketNumber >= nodes.Length) {  	//At least increase the size to:  	//Current size * 1.5  	//Current size + 2 or  	//bucketNumber  	PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][];  	for (int i = 0; i < nodes.Length; i++)  		newNodes [i] = nodes [i];  	//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")");  	bool[] newBucketNew = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketNew [i] = bucketNew [i];  	bool[] newBucketCreated = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketCreated [i] = bucketCreated [i];  	nodes = newNodes;  	bucketNew = newBucketNew;  	bucketCreated = newBucketCreated;  }  
Magic Number,Pathfinding,TagMask,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,ToString,The following statement contains a magic number: return "" + System.Convert.ToString (tagsChange' 2) + "\n" + System.Convert.ToString (tagsSet' 2);  
Magic Number,Pathfinding,TagMask,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,ToString,The following statement contains a magic number: return "" + System.Convert.ToString (tagsChange' 2) + "\n" + System.Convert.ToString (tagsSet' 2);  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,WillUpdateNode,The following statement contains a magic number: if (trackChangedNodes && node != null) {  	if (changedNodes == null) {  		changedNodes = ListPool<GraphNode>.Claim ();  		backupData = ListPool<ulong>.Claim ();  		backupPositionData = ListPool<Int3>.Claim ();  	}  	changedNodes.Add (node);  	backupPositionData.Add (node.position);  	backupData.Add ((ulong)node.Penalty << 32 | (ulong)node.Flags);  }  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,WillUpdateNode,The following statement contains a magic number: backupData.Add ((ulong)node.Penalty << 32 | (ulong)node.Flags);  
Magic Number,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,IntRect,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,MineBotAI,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\ExampleScenes\ExampleScripts\MineBotAI.cs,Start,The following statement contains a magic number: anim ["forward"].layer = 10;  
Magic Number,Pathfinding,TargetMover,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\ExampleScenes\ExampleScripts\TargetMover.cs,OnGUI,The following statement contains a magic number: if (onlyOnDoubleClick && cam != null && Event.current.type == EventType.MouseDown && Event.current.clickCount == 2) {  	UpdateTargetPosition ();  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: while (true) {  	RaycastHit hit;  	Raycast (cpos' out hit' out walkable);  	if (hit.transform == null) {  		//Raycast did not hit anything  		break;  	}  	else {  		//Make sure we didn't hit the same position  		if (hit.point != prevHit || hits.Count == 0) {  			cpos = hit.point - up * RaycastErrorMargin;  			prevHit = hit.point;  			numberSame = 0;  			hits.Add (hit);  		}  		else {  			cpos -= up * 0.001F;  			numberSame++;  			//Check if we are hitting the same position all the time' even though we are decrementing the cpos variable  			if (numberSame > 10) {  				Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  				break;  			}  		}  	}  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: if (hit.transform == null) {  	//Raycast did not hit anything  	break;  }  else {  	//Make sure we didn't hit the same position  	if (hit.point != prevHit || hits.Count == 0) {  		cpos = hit.point - up * RaycastErrorMargin;  		prevHit = hit.point;  		numberSame = 0;  		hits.Add (hit);  	}  	else {  		cpos -= up * 0.001F;  		numberSame++;  		//Check if we are hitting the same position all the time' even though we are decrementing the cpos variable  		if (numberSame > 10) {  			Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  			break;  		}  	}  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: if (hit.point != prevHit || hits.Count == 0) {  	cpos = hit.point - up * RaycastErrorMargin;  	prevHit = hit.point;  	numberSame = 0;  	hits.Add (hit);  }  else {  	cpos -= up * 0.001F;  	numberSame++;  	//Check if we are hitting the same position all the time' even though we are decrementing the cpos variable  	if (numberSame > 10) {  		Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  		break;  	}  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: if (numberSame > 10) {  	Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  	break;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GridGraph,The following statement contains a magic number: unclampedSize = new Vector2 (10' 10);  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GridGraph,The following statement contains a magic number: unclampedSize = new Vector2 (10' 10);  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [2] = width;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [3] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [4] = -width + 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [5] = width + 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [6] = width - 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [7] = -width - 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [2] = straightCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [3] = straightCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [4] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [5] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [6] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [7] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [2] = 0;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [3] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [4] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [5] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [6] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [7] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [2] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [3] = 0;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [4] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [5] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [6] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [7] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ScanInternal,The following statement contains a magic number: if (width > 1024 || depth > 1024) {  	Debug.LogError ("One of the grid's sides is longer than 1024 nodes");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ScanInternal,The following statement contains a magic number: if (width > 1024 || depth > 1024) {  	Debug.LogError ("One of the grid's sides is longer than 1024 nodes");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * Width + x];  			if (!node.Walkable) {  				/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  			else {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!this.HasNodeConnection (node' i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.Walkable = false;  				}  			}  		}  	}  	//Recalculate connections  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * Width + x];  			CalculateConnections (nodes' x' z' node);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = zmin; z < zmax; z++) {  	for (int x = xmin; x < xmax; x++) {  		GridNode node = nodes [z * Width + x];  		if (!node.Walkable) {  			/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  		else {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!this.HasNodeConnection (node' i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.Walkable = false;  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = xmin; x < xmax; x++) {  	GridNode node = nodes [z * Width + x];  	if (!node.Walkable) {  		/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  	else {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!this.HasNodeConnection (node' i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.Walkable = false;  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!node.Walkable) {  	/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  else {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!this.HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Walkable = false;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (!this.HasNodeConnection (node' i)) {  		anyFalseConnections = true;  		break;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (erodeIterations + erosionFirstTag > 31) {  	Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * width + x] as GridNode;  			if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  				for (int i = 0; i < 4; i++) {  					GridNode other = GetNodeConnection (node' i);  					if (other != null) {  						uint tag = other.Tag;  						if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  							other.Tag = (uint)(erosionFirstTag + it);  						}  					}  				}  			}  			else if (node.Walkable && it == 0) {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!HasNodeConnection (node' i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * width + x] as GridNode;  			if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  				for (int i = 0; i < 4; i++) {  					GridNode other = GetNodeConnection (node' i);  					if (other != null) {  						uint tag = other.Tag;  						if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  							other.Tag = (uint)(erosionFirstTag + it);  						}  					}  				}  			}  			else if (node.Walkable && it == 0) {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!HasNodeConnection (node' i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = zmin; z < zmax; z++) {  	for (int x = xmin; x < xmax; x++) {  		GridNode node = nodes [z * width + x] as GridNode;  		if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  			for (int i = 0; i < 4; i++) {  				GridNode other = GetNodeConnection (node' i);  				if (other != null) {  					uint tag = other.Tag;  					if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  						other.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  		else if (node.Walkable && it == 0) {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!HasNodeConnection (node' i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = zmin; z < zmax; z++) {  	for (int x = xmin; x < xmax; x++) {  		GridNode node = nodes [z * width + x] as GridNode;  		if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  			for (int i = 0; i < 4; i++) {  				GridNode other = GetNodeConnection (node' i);  				if (other != null) {  					uint tag = other.Tag;  					if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  						other.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  		else if (node.Walkable && it == 0) {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!HasNodeConnection (node' i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = xmin; x < xmax; x++) {  	GridNode node = nodes [z * width + x] as GridNode;  	if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  		for (int i = 0; i < 4; i++) {  			GridNode other = GetNodeConnection (node' i);  			if (other != null) {  				uint tag = other.Tag;  				if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  					other.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  	else if (node.Walkable && it == 0) {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!HasNodeConnection (node' i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.Tag = (uint)(erosionFirstTag + it);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = xmin; x < xmax; x++) {  	GridNode node = nodes [z * width + x] as GridNode;  	if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  		for (int i = 0; i < 4; i++) {  			GridNode other = GetNodeConnection (node' i);  			if (other != null) {  				uint tag = other.Tag;  				if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  					other.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  	else if (node.Walkable && it == 0) {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!HasNodeConnection (node' i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.Tag = (uint)(erosionFirstTag + it);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  	for (int i = 0; i < 4; i++) {  		GridNode other = GetNodeConnection (node' i);  		if (other != null) {  			uint tag = other.Tag;  			if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  				other.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  else if (node.Walkable && it == 0) {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Tag = (uint)(erosionFirstTag + it);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  	for (int i = 0; i < 4; i++) {  		GridNode other = GetNodeConnection (node' i);  		if (other != null) {  			uint tag = other.Tag;  			if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  				other.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  else if (node.Walkable && it == 0) {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Tag = (uint)(erosionFirstTag + it);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	GridNode other = GetNodeConnection (node' i);  	if (other != null) {  		uint tag = other.Tag;  		if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  			other.Tag = (uint)(erosionFirstTag + it);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (node.Walkable && it == 0) {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Tag = (uint)(erosionFirstTag + it);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (!HasNodeConnection (node' i)) {  		anyFalseConnections = true;  		break;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners == null) {  	corners = new int[4];  }  else {  	for (int i = 0; i < 4; i++) {  		corners [i] = 0;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners == null) {  	corners = new int[4];  }  else {  	for (int i = 0; i < 4; i++) {  		corners [i] = 0;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: corners = new int[4];  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	corners [i] = 0;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0' j = 3; i < 4; j = i' i++) {  	int nx = x + neighbourXOffsets [i];  	int nz = z + neighbourZOffsets [i];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i]] as GridNode;  	if (IsValidConnection (node' other)) {  		node.SetConnectionInternal (i' true);  		//SetNodeConnection (node' i' true);  		corners [i]++;  		corners [j]++;  	}  	else {  		node.SetConnectionInternal (i' false);  		//SetNodeConnection (node' i' false);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0' j = 3; i < 4; j = i' i++) {  	int nx = x + neighbourXOffsets [i];  	int nz = z + neighbourZOffsets [i];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i]] as GridNode;  	if (IsValidConnection (node' other)) {  		node.SetConnectionInternal (i' true);  		//SetNodeConnection (node' i' true);  		corners [i]++;  		corners [j]++;  	}  	else {  		node.SetConnectionInternal (i' false);  		//SetNodeConnection (node' i' false);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int z = 0; z < depth; z++) {  	for (int x = 0; x < width; x++) {  		node = nodes [z * width + x] as GridNode;  		if (!node.Walkable) {  			// || node.activePath != AstarPath.active.debugPath)    			continue;  		}  		//Gizmos.color = node.walkable ? Color.green : Color.red;  		//Gizmos.DrawSphere (node.position'0.2F);  		Gizmos.color = NodeColor (node' AstarPath.active.debugPathData);  		//if (true) {  		//	Gizmos.DrawCube (node.position'Vector3.one*nodeSize);  		//}  		//else   		if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {  			if (InSearchTree (node' AstarPath.active.debugPath)) {  				PathNode nodeR = debugData.GetPathNode (node);  				if (nodeR != null && nodeR.parent != null) {  					Gizmos.DrawLine ((Vector3)node.position' (Vector3)nodeR.parent.node.position);  				}  			}  		}  		else {  			for (int i = 0; i < 8; i++) {  				GridNode other = GetNodeConnection (node' i);  				if (other != null) {  					Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	node = nodes [z * width + x] as GridNode;  	if (!node.Walkable) {  		// || node.activePath != AstarPath.active.debugPath)    		continue;  	}  	//Gizmos.color = node.walkable ? Color.green : Color.red;  	//Gizmos.DrawSphere (node.position'0.2F);  	Gizmos.color = NodeColor (node' AstarPath.active.debugPathData);  	//if (true) {  	//	Gizmos.DrawCube (node.position'Vector3.one*nodeSize);  	//}  	//else   	if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {  		if (InSearchTree (node' AstarPath.active.debugPath)) {  			PathNode nodeR = debugData.GetPathNode (node);  			if (nodeR != null && nodeR.parent != null) {  				Gizmos.DrawLine ((Vector3)node.position' (Vector3)nodeR.parent.node.position);  			}  		}  	}  	else {  		for (int i = 0; i < 8; i++) {  			GridNode other = GetNodeConnection (node' i);  			if (other != null) {  				Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {  	if (InSearchTree (node' AstarPath.active.debugPath)) {  		PathNode nodeR = debugData.GetPathNode (node);  		if (nodeR != null && nodeR.parent != null) {  			Gizmos.DrawLine ((Vector3)node.position' (Vector3)nodeR.parent.node.position);  		}  	}  }  else {  	for (int i = 0; i < 8; i++) {  		GridNode other = GetNodeConnection (node' i);  		if (other != null) {  			Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = GetNodeConnection (node' i);  	if (other != null) {  		Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [2] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (b.extents.x' -b.extents.y' b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [3] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (b.extents.x' -b.extents.y' -b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [4] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' b.extents.y' b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [5] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' b.extents.y' -b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [6] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' -b.extents.y' b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [7] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' -b.extents.y' -b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: for (int i = 1; i < 8; i++) {  	min = Vector3.Min (min' p [i]);  	max = Vector3.Max (max' p [i]);  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CheckConnection,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	return HasNodeConnection (node' dir);  }  else {  	int dir1 = (dir - 4 - 1) & 0x3;  	int dir2 = (dir - 4 + 1) & 0x3;  	if (!HasNodeConnection (node' dir1) || !HasNodeConnection (node' dir2)) {  		return false;  	}  	else {  		GridNode n1 = nodes [node.NodeInGridIndex + neighbourOffsets [dir1]];  		GridNode n2 = nodes [node.NodeInGridIndex + neighbourOffsets [dir2]];  		if (!n1.Walkable || !n2.Walkable) {  			return false;  		}  		if (!HasNodeConnection (n2' dir1) || !HasNodeConnection (n1' dir2)) {  			return false;  		}  	}  	return true;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\GridGenerator.cs,CheckConnection,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	return HasNodeConnection (node' dir);  }  else {  	int dir1 = (dir - 4 - 1) & 0x3;  	int dir2 = (dir - 4 + 1) & 0x3;  	if (!HasNodeConnection (node' dir1) || !HasNodeConnection (node' dir2)) {  		return false;  	}  	else {  		GridNode n1 = nodes [node.NodeInGridIndex + neighbourOffsets [dir1]];  		GridNode n2 = nodes [node.NodeInGridIndex + neighbourOffsets [dir2]];  		if (!n1.Walkable || !n2.Walkable) {  			return false;  		}  		if (!HasNodeConnection (n2' dir1) || !HasNodeConnection (n1' dir2)) {  			return false;  		}  	}  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int b = 0; b < 3; b++) {  	if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  		search = false;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int b = 0; b < 3; b++) {  	if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  		search = false;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int b = 0; b < 3; b++) {  	if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  		search = false;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  	search = false;  	break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  	search = false;  	break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (a == 3) {  	left.Add ((Vector3)n1.position);  	right.Add ((Vector3)n1.position);  	left.Add ((Vector3)n2.position);  	right.Add ((Vector3)n2.position);  }  else {  	left.Add ((Vector3)n1.GetVertex (a));  	right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (a == 3) {  	left.Add ((Vector3)n1.position);  	right.Add ((Vector3)n1.position);  	left.Add ((Vector3)n2.position);  	right.Add ((Vector3)n2.position);  }  else {  	left.Add ((Vector3)n1.GetVertex (a));  	right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int v = 0; v < 3; v++) {  	Int3 p = node.GetVertex (v);  	Vector3 vert = (Vector3)p;  	//Vector2 vert2D = new Vector2 (vert.x'vert.z);  	if (r2.Contains (p.x' p.z)) {  		//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  		inside = true;  		break;  	}  	if (vert.x < r.xMin)  		allLeft++;  	if (vert.x > r.xMax)  		allRight++;  	if (vert.z < r.yMin)  		allTop++;  	if (vert.z > r.yMax)  		allBottom++;  	//if (!bounds.Contains (node[v]) {  	//	inside = false;  	//	break;  	//}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int v = 0; v < 3; v++) {  	int v2 = v > 1 ? 0 : v + 1;  	Int3 vert1 = node.GetVertex (v);  	Int3 vert2 = node.GetVertex (v2);  	if (Polygon.Intersects (a' b' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (a' c' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (c' d' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (d' b' vert1' vert2)) {  		inside = true;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: nodes = new TriangleMeshNode[triangles.Length / 3];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v0 = triangles [i * 3];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v1 = triangles [i * 3 + 1];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v2 = triangles [i * 3 + 2];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v2 = triangles [i * 3 + 2];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			GraphNode other = nodes [x / 3];  			connections.Add (other as MeshNode);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: i += 3
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		GraphNode other = nodes [x / 3];  		connections.Add (other as MeshNode);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: x += 3
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i + 1]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 1] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count >= 3) {  	identicalError++;  	Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  	Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count >= 3) {  	identicalError++;  	Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  	Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count >= 3) {  	identicalError++;  	Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  	Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  	Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: Debug.DrawLine ((Vector3)vertices [triangles [x]]' (Vector3)vertices [triangles [x + 2]]' Color.red);  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: Debug.DrawLine ((Vector3)vertices [triangles [x + 2]]' (Vector3)vertices [triangles [x + 1]]' Color.red);  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count == 2) {  	GraphNode other = nodes [x / 3];  	connections.Add (other as MeshNode);  	connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count == 2) {  	GraphNode other = nodes [x / 3];  	connections.Add (other as MeshNode);  	connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		if (other != null)  			del (other);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 0.5f;  		left.Add (middle - cross);  		right.Add (middle + cross);  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  	rClear = true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  	rClear = true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  	lClear = true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,FloodFill,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		if (other != null && other.Area != region) {  			other.Area = region;  			stack.Push (other);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,UpdateRecursiveG,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		PathNode otherPN = handler.GetPathNode (other);  		if (otherPN.parent == pathNode && otherPN.pathID == pid)  			other.UpdateRecursiveG (path' otherPN' handler);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,Open,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		if (!path.CanTraverse (other))  			continue;  		PathNode otherPN = handler.GetPathNode (other);  		if (otherPN.pathID != pid) {  			otherPN.parent = pathNode;  			otherPN.pathID = pid;  			otherPN.cost = neighbourCosts [i];  			otherPN.H = path.CalculateHScore (other);  			other.UpdateG (path' otherPN);  			//Debug.Log ("G " + otherPN.G + " F " + otherPN.F);  			handler.PushNode (otherPN);  			//Debug.DrawRay ((Vector3)otherPN.node.Position' Vector3.up'Color.blue);  		}  		else {  			//If not we can test if the path from the current node to this one is a better one then the one already used  			uint tmpCost = neighbourCosts [i];  			if (pathNode.G + tmpCost + path.GetTraversalCost (other) < otherPN.G) {  				//Debug.Log ("Path better from " + NodeIndex + " to " + otherPN.node.NodeIndex + " " + (pathNode.G+tmpCost+path.GetTraversalCost(other)) + " < " + otherPN.G);  				otherPN.cost = tmpCost;  				otherPN.parent = pathNode;  				other.UpdateRecursiveG (path' otherPN' handler);  				//Or if the path from this node ("other") to the current ("current") is better  			}  			else if (otherPN.G + tmpCost + path.GetTraversalCost (this) < pathNode.G) {  				//Debug.Log ("Path better from " + otherPN.node.NodeIndex + " to " + NodeIndex + " " + (otherPN.G+tmpCost+path.GetTraversalCost (this)) + " < " + pathNode.G);  				pathNode.parent = otherPN;  				pathNode.cost = tmpCost;  				UpdateRecursiveG (path' pathNode' handler);  			}  		}  	}  }  
Magic Number,Pathfinding,TriangleMeshNode,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,GetVertexCount,The following statement contains a magic number: return 3;  
Magic Number,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,AddNode,The following statement contains a magic number: if (nodes == null || nodeCount == nodes.Length) {  	PointNode[] nds = new PointNode[nodes != null ? System.Math.Max (nodes.Length + 4' nodes.Length * 2) : 4];  	for (int i = 0; i < nodeCount; i++)  		nds [i] = nodes [i];  	nodes = nds;  }  
Magic Number,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,AddNode,The following statement contains a magic number: if (nodes == null || nodeCount == nodes.Length) {  	PointNode[] nds = new PointNode[nodes != null ? System.Math.Max (nodes.Length + 4' nodes.Length * 2) : 4];  	for (int i = 0; i < nodeCount; i++)  		nds [i] = nodes [i];  	nodes = nds;  }  
Magic Number,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,AddNode,The following statement contains a magic number: if (nodes == null || nodeCount == nodes.Length) {  	PointNode[] nds = new PointNode[nodes != null ? System.Math.Max (nodes.Length + 4' nodes.Length * 2) : 4];  	for (int i = 0; i < nodeCount; i++)  		nds [i] = nodes [i];  	nodes = nds;  }  
Magic Number,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,ScanInternal,The following statement contains a magic number: if (maxDistance >= 0) {  	//To avoid too many allocations' these lists are reused for each node  	List<PointNode> connections = new List<PointNode> (3);  	List<uint> costs = new List<uint> (3);  	//Loop through all nodes and add connections to other nodes  	for (int i = 0; i < nodes.Length; i++) {  		connections.Clear ();  		costs.Clear ();  		PointNode node = nodes [i];  		// Only brute force is available in the free version  		for (int j = 0; j < nodes.Length; j++) {  			if (i == j)  				continue;  			PointNode other = nodes [j];  			float dist = 0;  			if (IsValidConnection (node' other' out dist)) {  				connections.Add (other);  				/** \todo Is this equal to .costMagnitude */costs.Add ((uint)Mathf.RoundToInt (dist * Int3.FloatPrecision));  			}  		}  		node.connections = connections.ToArray ();  		node.connectionCosts = costs.ToArray ();  	}  }  
Magic Number,Pathfinding,PointGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\PointGenerator.cs,ScanInternal,The following statement contains a magic number: if (maxDistance >= 0) {  	//To avoid too many allocations' these lists are reused for each node  	List<PointNode> connections = new List<PointNode> (3);  	List<uint> costs = new List<uint> (3);  	//Loop through all nodes and add connections to other nodes  	for (int i = 0; i < nodes.Length; i++) {  		connections.Clear ();  		costs.Clear ();  		PointNode node = nodes [i];  		// Only brute force is available in the free version  		for (int j = 0; j < nodes.Length; j++) {  			if (i == j)  				continue;  			PointNode other = nodes [j];  			float dist = 0;  			if (IsValidConnection (node' other' out dist)) {  				connections.Add (other);  				/** \todo Is this equal to .costMagnitude */costs.Add ((uint)Mathf.RoundToInt (dist * Int3.FloatPrecision));  			}  		}  		node.connections = connections.ToArray ();  		node.connectionCosts = costs.ToArray ();  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: x = x + width / 2;  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c2;  }  else {  	c = c.c1;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c2;  }  else {  	c = c.c1;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: y = y + width / 2;  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c3;  }  else {  	c = c.c0;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c3;  }  else {  	c = c.c0;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: y = y + width / 2;  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	string[] brokenString;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			//Trim the current line  			brokenString = currentText.Split (splitIdentifier' 50);  			//Split the line into an array' separating the original line by blank spaces  			switch (brokenString [0]) {  			case "v":  				vertices++;  				break;  			case "vt":  				vt++;  				break;  			case "vn":  				vn++;  				break;  			case "f":  				face = face + brokenString.Length - 1;  				triangles = triangles + 3 * (brokenString.Length - 2);  				/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	string[] brokenString;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			//Trim the current line  			brokenString = currentText.Split (splitIdentifier' 50);  			//Split the line into an array' separating the original line by blank spaces  			switch (brokenString [0]) {  			case "v":  				vertices++;  				break;  			case "vt":  				vt++;  				break;  			case "vn":  				vn++;  				break;  			case "f":  				face = face + brokenString.Length - 1;  				triangles = triangles + 3 * (brokenString.Length - 2);  				/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	string[] brokenString;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			//Trim the current line  			brokenString = currentText.Split (splitIdentifier' 50);  			//Split the line into an array' separating the original line by blank spaces  			switch (brokenString [0]) {  			case "v":  				vertices++;  				break;  			case "vt":  				vt++;  				break;  			case "vn":  				vn++;  				break;  			case "f":  				face = face + brokenString.Length - 1;  				triangles = triangles + 3 * (brokenString.Length - 2);  				/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		//Trim the current line  		brokenString = currentText.Split (splitIdentifier' 50);  		//Split the line into an array' separating the original line by blank spaces  		switch (brokenString [0]) {  		case "v":  			vertices++;  			break;  		case "vt":  			vt++;  			break;  		case "vn":  			vn++;  			break;  		case "f":  			face = face + brokenString.Length - 1;  			triangles = triangles + 3 * (brokenString.Length - 2);  			/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		//Trim the current line  		brokenString = currentText.Split (splitIdentifier' 50);  		//Split the line into an array' separating the original line by blank spaces  		switch (brokenString [0]) {  		case "v":  			vertices++;  			break;  		case "vt":  			vt++;  			break;  		case "vn":  			vn++;  			break;  		case "f":  			face = face + brokenString.Length - 1;  			triangles = triangles + 3 * (brokenString.Length - 2);  			/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		//Trim the current line  		brokenString = currentText.Split (splitIdentifier' 50);  		//Split the line into an array' separating the original line by blank spaces  		switch (brokenString [0]) {  		case "v":  			vertices++;  			break;  		case "vt":  			vt++;  			break;  		case "vn":  			vn++;  			break;  		case "f":  			face = face + brokenString.Length - 1;  			triangles = triangles + 3 * (brokenString.Length - 2);  			/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	//Trim the current line  	brokenString = currentText.Split (splitIdentifier' 50);  	//Split the line into an array' separating the original line by blank spaces  	switch (brokenString [0]) {  	case "v":  		vertices++;  		break;  	case "vt":  		vt++;  		break;  	case "vn":  		vn++;  		break;  	case "f":  		face = face + brokenString.Length - 1;  		triangles = triangles + 3 * (brokenString.Length - 2);  		/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	//Trim the current line  	brokenString = currentText.Split (splitIdentifier' 50);  	//Split the line into an array' separating the original line by blank spaces  	switch (brokenString [0]) {  	case "v":  		vertices++;  		break;  	case "vt":  		vt++;  		break;  	case "vn":  		vn++;  		break;  	case "f":  		face = face + brokenString.Length - 1;  		triangles = triangles + 3 * (brokenString.Length - 2);  		/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	//Trim the current line  	brokenString = currentText.Split (splitIdentifier' 50);  	//Split the line into an array' separating the original line by blank spaces  	switch (brokenString [0]) {  	case "v":  		vertices++;  		break;  	case "vt":  		vt++;  		break;  	case "vn":  		vn++;  		break;  	case "f":  		face = face + brokenString.Length - 1;  		triangles = triangles + 3 * (brokenString.Length - 2);  		/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: brokenString = currentText.Split (splitIdentifier' 50);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "v":  	vertices++;  	break;  case "vt":  	vt++;  	break;  case "vn":  	vn++;  	break;  case "f":  	face = face + brokenString.Length - 1;  	triangles = triangles + 3 * (brokenString.Length - 2);  	/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "v":  	vertices++;  	break;  case "vt":  	vt++;  	break;  case "vn":  	vn++;  	break;  case "f":  	face = face + brokenString.Length - 1;  	triangles = triangles + 3 * (brokenString.Length - 2);  	/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: triangles = triangles + 3 * (brokenString.Length - 2);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: triangles = triangles + 3 * (brokenString.Length - 2);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: brokenString = currentText.Split (splitIdentifier' 50);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  	Vector3 temp = new Vector3 ();  	brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  	//Separate the face into individual components (vert' uv' normal)  	temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  	if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  	 {  		if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  		 {  			temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  		}  		temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  	}  	j++;  	mesh.faceData [f2] = temp;  	intArray.Add (f2);  	f2++;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  	Vector3 temp = new Vector3 ();  	brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  	//Separate the face into individual components (vert' uv' normal)  	temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  	if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  	 {  		if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  		 {  			temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  		}  		temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  	}  	j++;  	mesh.faceData [f2] = temp;  	intArray.Add (f2);  	f2++;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal   {  	if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  	 {  		temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  	}  	temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  
Magic Number,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.   {  	mesh.triangles [f] = intArray [0];  	f++;  	mesh.triangles [f] = intArray [j];  	f++;  	mesh.triangles [f] = intArray [j + 1];  	f++;  	j++;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (left.Count <= 3) {  	return false;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (left [1] == left [2] && right [1] == right [2]) {  	//System.Console.WriteLine ("Removing identical left and right");  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (left [1] == left [2] && right [1] == right [2]) {  	//System.Console.WriteLine ("Removing identical left and right");  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (left [1] == left [2] && right [1] == right [2]) {  	//System.Console.WriteLine ("Removing identical left and right");  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (left.Count <= 3) {  	return false;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (swPoint == left [1]) {  	swPoint = right [2];  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: swPoint = right [2];  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) {  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  	swPoint = left [2];  	if (swPoint == left [1]) {  		swPoint = right [2];  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) {  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  	swPoint = left [2];  	if (swPoint == left [1]) {  		swPoint = right [2];  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) {  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  	swPoint = left [2];  	if (swPoint == left [1]) {  		swPoint = right [2];  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (left.Count <= 3) {  	return false;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: swPoint = left [2];  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (swPoint == left [1]) {  	swPoint = right [2];  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: swPoint = right [2];  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: for (int i = 2; i < left.Count; i++) {  	if (funnelPath.Count > 2000) {  		Debug.LogWarning ("Avoiding infinite loop. Remove this check if you have this long paths.");  		break;  	}  	Vector3 pLeft = left [i];  	Vector3 pRight = right [i];  	/*Debug.DrawLine (portalApex'portalLeft'Color.red); 				Debug.DrawLine (portalApex'portalRight'Color.yellow); 				Debug.DrawLine (portalApex'left'Color.cyan); 				Debug.DrawLine (portalApex'right'Color.cyan);*/if (Polygon.TriangleArea2 (portalApex' portalRight' pRight) >= 0) {  		if (portalApex == portalRight || Polygon.TriangleArea2 (portalApex' portalLeft' pRight) <= 0) {  			portalRight = pRight;  			rightIndex = i;  		}  		else {  			funnelPath.Add (portalLeft);  			portalApex = portalLeft;  			apexIndex = leftIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  	if (Polygon.TriangleArea2 (portalApex' portalLeft' pLeft) <= 0) {  		if (portalApex == portalLeft || Polygon.TriangleArea2 (portalApex' portalRight' pLeft) >= 0) {  			portalLeft = pLeft;  			leftIndex = i;  		}  		else {  			funnelPath.Add (portalRight);  			portalApex = portalRight;  			apexIndex = rightIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: for (int i = 2; i < left.Count; i++) {  	if (funnelPath.Count > 2000) {  		Debug.LogWarning ("Avoiding infinite loop. Remove this check if you have this long paths.");  		break;  	}  	Vector3 pLeft = left [i];  	Vector3 pRight = right [i];  	/*Debug.DrawLine (portalApex'portalLeft'Color.red); 				Debug.DrawLine (portalApex'portalRight'Color.yellow); 				Debug.DrawLine (portalApex'left'Color.cyan); 				Debug.DrawLine (portalApex'right'Color.cyan);*/if (Polygon.TriangleArea2 (portalApex' portalRight' pRight) >= 0) {  		if (portalApex == portalRight || Polygon.TriangleArea2 (portalApex' portalLeft' pRight) <= 0) {  			portalRight = pRight;  			rightIndex = i;  		}  		else {  			funnelPath.Add (portalLeft);  			portalApex = portalLeft;  			apexIndex = leftIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  	if (Polygon.TriangleArea2 (portalApex' portalLeft' pLeft) <= 0) {  		if (portalApex == portalLeft || Polygon.TriangleArea2 (portalApex' portalRight' pLeft) >= 0) {  			portalLeft = pLeft;  			leftIndex = i;  		}  		else {  			funnelPath.Add (portalRight);  			portalApex = portalRight;  			apexIndex = rightIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (funnelPath.Count > 2000) {  	Debug.LogWarning ("Avoiding infinite loop. Remove this check if you have this long paths.");  	break;  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (nodes.Capacity < nodes.Count * 3) {  	nodes.Capacity = nodes.Count * 3;  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (nodes.Capacity < nodes.Count * 3) {  	nodes.Capacity = nodes.Count * 3;  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes.Capacity = nodes.Count * 3;  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3] = nodes [j];  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (j != preLength - 1) {  	nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  	nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (j != preLength - 1) {  	nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  	nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (j != preLength - 1) {  	nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  	nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: while (i < nodes.Count - 2) {  	Vector3 start = nodes [i];  	Vector3 end = nodes [i + 2];  	/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  	System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  	watch.Start ();  	if (ValidateLine (null' null' start' end)) {  		//Debug.Log ("+++ Simplified "+i+" +++");  		//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  		nodes.RemoveAt (i + 1);  		//i++;  	}  	else {  		//Debug.DrawLine (start'end'Color.red);  		i++;  	}  	watch.Stop ();  	//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: while (i < nodes.Count - 2) {  	Vector3 start = nodes [i];  	Vector3 end = nodes [i + 2];  	/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  	System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  	watch.Start ();  	if (ValidateLine (null' null' start' end)) {  		//Debug.Log ("+++ Simplified "+i+" +++");  		//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  		nodes.RemoveAt (i + 1);  		//i++;  	}  	else {  		//Debug.DrawLine (start'end'Color.red);  		i++;  	}  	watch.Stop ();  	//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	//subdivided[counter] = path[i];  	//counter++;  	float dist = (path [i] - path [i + 1]).magnitude;  	Vector3 startVel1 = preEndVel;  	Vector3 endVel1 = i < path.Count - 2 ? ((path [i + 2] - path [i + 1]).normalized - (path [i] - path [i + 1]).normalized).normalized : (path [i + 1] - path [i]).normalized;  	Vector3 startVel = startVel1 * dist * factor;  	Vector3 endVel = endVel1 * dist * factor;  	Vector3 start = path [i];  	Vector3 end = path [i + 1];  	//Vector3 p1 = start + startVel;  	//Vector3 p2 = end - endVel;  	float onedivdist = 1F / dist;  	for (float t = 0; t <= dist; t += maxSegmentLength) {  		float t2 = t * onedivdist;  		subdivided.Add (GetPointOnCubic (start' end' startVel' endVel' t2));  		//counter++;  	}  	preEndVel = endVel1;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	//subdivided[counter] = path[i];  	//counter++;  	float dist = (path [i] - path [i + 1]).magnitude;  	Vector3 startVel1 = preEndVel;  	Vector3 endVel1 = i < path.Count - 2 ? ((path [i + 2] - path [i + 1]).normalized - (path [i] - path [i + 1]).normalized).normalized : (path [i + 1] - path [i]).normalized;  	Vector3 startVel = startVel1 * dist * factor;  	Vector3 endVel = endVel1 * dist * factor;  	Vector3 start = path [i];  	Vector3 end = path [i + 1];  	//Vector3 p1 = start + startVel;  	//Vector3 p2 = end - endVel;  	float onedivdist = 1F / dist;  	for (float t = 0; t <= dist; t += maxSegmentLength) {  		float t2 = t * onedivdist;  		subdivided.Add (GetPointOnCubic (start' end' startVel' endVel' t2));  		//counter++;  	}  	preEndVel = endVel1;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (path.Count <= 2 || iterations <= 0) {  	return path;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (iterations > 12) {  	Debug.LogWarning ("A very high iteration count was passed' won't let this one through");  	return path;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  	setSecond = true;  	secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  	setSecond = true;  	secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setFirst) {  	subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2] = current;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setFirst) {  	subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2] = current;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2] = current;  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setSecond) {  	subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2 + 1] = next;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setSecond) {  	subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2 + 1] = next;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2 + 1] = next;  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothSimple,The following statement contains a magic number: if (path.Count < 2) {  	return path;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	Vector3 tangent1 = Vector3.zero;  	Vector3 tangent2 = Vector3.zero;  	if (i == 0) {  		tangent1 = path [i + 1] - path [i];  	}  	else {  		tangent1 = path [i + 1] - path [i - 1];  	}  	if (i == path.Count - 2) {  		tangent2 = path [i] - path [i + 1];  	}  	else {  		tangent2 = path [i] - path [i + 2];  	}  	tangent1 *= bezierTangentLength;  	tangent2 *= bezierTangentLength;  	Vector3 v1 = path [i];  	Vector3 v2 = v1 + tangent1;  	Vector3 v4 = path [i + 1];  	Vector3 v3 = v4 + tangent2;  	for (int j = 0; j < subMult; j++) {  		subdivided.Add (AstarMath.CubicBezier (v1' v2' v3' v4' (float)j / subMult));  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	Vector3 tangent1 = Vector3.zero;  	Vector3 tangent2 = Vector3.zero;  	if (i == 0) {  		tangent1 = path [i + 1] - path [i];  	}  	else {  		tangent1 = path [i + 1] - path [i - 1];  	}  	if (i == path.Count - 2) {  		tangent2 = path [i] - path [i + 1];  	}  	else {  		tangent2 = path [i] - path [i + 2];  	}  	tangent1 *= bezierTangentLength;  	tangent2 *= bezierTangentLength;  	Vector3 v1 = path [i];  	Vector3 v2 = v1 + tangent1;  	Vector3 v4 = path [i + 1];  	Vector3 v3 = v4 + tangent2;  	for (int j = 0; j < subMult; j++) {  		subdivided.Add (AstarMath.CubicBezier (v1' v2' v3' v4' (float)j / subMult));  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: if (i == path.Count - 2) {  	tangent2 = path [i] - path [i + 1];  }  else {  	tangent2 = path [i] - path [i + 2];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: if (i == path.Count - 2) {  	tangent2 = path [i] - path [i + 1];  }  else {  	tangent2 = path [i] - path [i + 2];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: tangent2 = path [i] - path [i + 2];  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (p.vectorPath.Count == 0) {  	return;  }  else if (p.vectorPath.Count < 2 && !addPoints) {  	//Vector3[] arr = new Vector3[2];  	//arr[0] = p.vectorPath[0];  	//arr[1] = p.vectorPath[0];  	//p.vectorPath = arr;  	p.vectorPath.Add (p.vectorPath [0]);  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (p.vectorPath.Count < 2 && !addPoints) {  	//Vector3[] arr = new Vector3[2];  	//arr[0] = p.vectorPath[0];  	//arr[1] = p.vectorPath[0];  	//p.vectorPath = arr;  	p.vectorPath.Add (p.vectorPath [0]);  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Original) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Original) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  
Magic Number,Pathfinding,StartEndModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f' 0.4f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f' 0.4f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f' 0.4f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmosSelected,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmosSelected,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmosSelected,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f);  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.StartFastProfile (4);  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.EndFastProfile (4);  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.StartFastProfile (7);  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.EndFastProfile (7);  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if (System.DateTime.UtcNow.Ticks >= targetTick) {  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return;  	}  	counter = 0;  	if (searchedNodes > 1000000) {  		throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  	}  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if (System.DateTime.UtcNow.Ticks >= targetTick) {  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return;  	}  	counter = 0;  	if (searchedNodes > 1000000) {  		throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  	}  }  
Magic Number,Pathfinding,ABPath,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: if (searchedNodes > 1000000) {  	throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  }  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,InitializeFastProfile,The following statement contains a magic number: fastProfileNames = new string[profileNames.Length + 2];  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,InitializeFastProfile,The following statement contains a magic number: fastProfileNames [fastProfileNames.Length - 2] = "__Control1__";  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: StartFastProfile (fastProfiles.Length - 2);  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < 1000; i++) {  	StartFastProfile (fastProfiles.Length - 1);  	EndFastProfile (fastProfiles.Length - 1);  }  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: EndFastProfile (fastProfiles.Length - 2);  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: while (mx - mn > 0.01f) {  	float mid = (mn + mx) / 2;  	Vector3 p = InvoluteOfCircle (a' mid);  	if ((p - prev).sqrMagnitude < clearance * clearance) {  		mn = mid;  	}  	else {  		mx = mid;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: for (int i = 0; i < previousPoints.Count; i++) {  	Vector3 dir = previousPoints [i];  	float magn = dir.magnitude;  	if (magn > 0)  		dir /= magn;  	float newMagn = radius;  	//magn > radius ? radius : magn;  	dir *= newMagn;  	bool worked = false;  	GraphHitInfo hit;  	int tests = 0;  	do {  		Vector3 pt = p + dir;  		if (g.Linecast (p' pt' nn.node' out hit)) {  			pt = hit.point;  		}  		for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  			Vector3 qt = (pt - p) * q + p;  			worked = true;  			for (int j = 0; j < i; j++) {  				if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  			if (worked) {  				previousPoints [i] = qt;  				break;  			}  		}  		if (!worked) {  			// Abort after 5 tries  			if (tests > 8) {  				worked = true;  			}  			else {  				clearanceRadius *= 0.9f;  				// This will pick points in 2D closer to the edge of the circle with a higher probability  				dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  				dir.y = 0;  				tests++;  			}  		}  	}  	while (!worked);  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: for (int i = 0; i < previousPoints.Count; i++) {  	Vector3 dir = previousPoints [i];  	float magn = dir.magnitude;  	if (magn > 0)  		dir /= magn;  	float newMagn = radius;  	//magn > radius ? radius : magn;  	dir *= newMagn;  	bool worked = false;  	GraphHitInfo hit;  	int tests = 0;  	do {  		Vector3 pt = p + dir;  		if (g.Linecast (p' pt' nn.node' out hit)) {  			pt = hit.point;  		}  		for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  			Vector3 qt = (pt - p) * q + p;  			worked = true;  			for (int j = 0; j < i; j++) {  				if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  			if (worked) {  				previousPoints [i] = qt;  				break;  			}  		}  		if (!worked) {  			// Abort after 5 tries  			if (tests > 8) {  				worked = true;  			}  			else {  				clearanceRadius *= 0.9f;  				// This will pick points in 2D closer to the edge of the circle with a higher probability  				dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  				dir.y = 0;  				tests++;  			}  		}  	}  	while (!worked);  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: do {  	Vector3 pt = p + dir;  	if (g.Linecast (p' pt' nn.node' out hit)) {  		pt = hit.point;  	}  	for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  		Vector3 qt = (pt - p) * q + p;  		worked = true;  		for (int j = 0; j < i; j++) {  			if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  		if (worked) {  			previousPoints [i] = qt;  			break;  		}  	}  	if (!worked) {  		// Abort after 5 tries  		if (tests > 8) {  			worked = true;  		}  		else {  			clearanceRadius *= 0.9f;  			// This will pick points in 2D closer to the edge of the circle with a higher probability  			dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  			dir.y = 0;  			tests++;  		}  	}  }  while (!worked);  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: do {  	Vector3 pt = p + dir;  	if (g.Linecast (p' pt' nn.node' out hit)) {  		pt = hit.point;  	}  	for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  		Vector3 qt = (pt - p) * q + p;  		worked = true;  		for (int j = 0; j < i; j++) {  			if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  		if (worked) {  			previousPoints [i] = qt;  			break;  		}  	}  	if (!worked) {  		// Abort after 5 tries  		if (tests > 8) {  			worked = true;  		}  		else {  			clearanceRadius *= 0.9f;  			// This will pick points in 2D closer to the edge of the circle with a higher probability  			dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  			dir.y = 0;  			tests++;  		}  	}  }  while (!worked);  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (!worked) {  	// Abort after 5 tries  	if (tests > 8) {  		worked = true;  	}  	else {  		clearanceRadius *= 0.9f;  		// This will pick points in 2D closer to the edge of the circle with a higher probability  		dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  		dir.y = 0;  		tests++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (!worked) {  	// Abort after 5 tries  	if (tests > 8) {  		worked = true;  	}  	else {  		clearanceRadius *= 0.9f;  		// This will pick points in 2D closer to the edge of the circle with a higher probability  		dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  		dir.y = 0;  		tests++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (tests > 8) {  	worked = true;  }  else {  	clearanceRadius *= 0.9f;  	// This will pick points in 2D closer to the edge of the circle with a higher probability  	dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  	dir.y = 0;  	tests++;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (tests > 8) {  	worked = true;  }  else {  	clearanceRadius *= 0.9f;  	// This will pick points in 2D closer to the edge of the circle with a higher probability  	dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  	dir.y = 0;  	tests++;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Count; i++) {  	TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  	if (tnode != null) {  		float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  		tot += a;  		accs.Add (tot);  	}  	else {  		GridNode gnode = nodes [i] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float a = gg.nodeSize * gg.nodeSize;  			tot += a;  			accs.Add (tot);  		}  		else {  			accs.Add (tot);  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (tnode != null) {  	float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  	tot += a;  	accs.Add (tot);  }  else {  	GridNode gnode = nodes [i] as GridNode;  	if (gnode != null) {  		GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  		float a = gg.nodeSize * gg.nodeSize;  		tot += a;  		accs.Add (tot);  	}  	else {  		accs.Add (tot);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: while (!worked) {  	worked = true;  	//If no valid points can be found' progressively lower the clearance radius until such a point is found  	if (testCount >= testLimit) {  		clearanceRadius *= 0.8f;  		testLimit += 10;  		if (testLimit > 100)  			clearanceRadius = 0;  	}  	float tg = (float)rnd.NextDouble () * tot;  	int v = accs.BinarySearch (tg);  	if (v < 0)  		v = ~v;  	if (v >= nodes.Count) {  		// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  		worked = false;  		continue;  	}  	TriangleMeshNode node = nodes [v] as TriangleMeshNode;  	Vector3 p;  	if (node != null) {  		// Find a random point inside the triangle  		float v1;  		float v2;  		do {  			v1 = (float)rnd.NextDouble ();  			v2 = (float)rnd.NextDouble ();  		}  		while (v1 + v2 > 1);  		p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  	}  	else {  		GridNode gnode = nodes [v] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float v1 = (float)rnd.NextDouble ();  			float v2 = (float)rnd.NextDouble ();  			p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  		}  		else {  			//Point nodes have no area' so we break directly instead  			pts.Add ((Vector3)nodes [v].position);  			break;  		}  	}  	// Test if it is some distance away from the other points  	if (clearanceRadius > 0) {  		for (int j = 0; j < pts.Count; j++) {  			if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  	}  	if (worked) {  		pts.Add (p);  		break;  	}  	else {  		testCount++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: while (!worked) {  	worked = true;  	//If no valid points can be found' progressively lower the clearance radius until such a point is found  	if (testCount >= testLimit) {  		clearanceRadius *= 0.8f;  		testLimit += 10;  		if (testLimit > 100)  			clearanceRadius = 0;  	}  	float tg = (float)rnd.NextDouble () * tot;  	int v = accs.BinarySearch (tg);  	if (v < 0)  		v = ~v;  	if (v >= nodes.Count) {  		// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  		worked = false;  		continue;  	}  	TriangleMeshNode node = nodes [v] as TriangleMeshNode;  	Vector3 p;  	if (node != null) {  		// Find a random point inside the triangle  		float v1;  		float v2;  		do {  			v1 = (float)rnd.NextDouble ();  			v2 = (float)rnd.NextDouble ();  		}  		while (v1 + v2 > 1);  		p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  	}  	else {  		GridNode gnode = nodes [v] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float v1 = (float)rnd.NextDouble ();  			float v2 = (float)rnd.NextDouble ();  			p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  		}  		else {  			//Point nodes have no area' so we break directly instead  			pts.Add ((Vector3)nodes [v].position);  			break;  		}  	}  	// Test if it is some distance away from the other points  	if (clearanceRadius > 0) {  		for (int j = 0; j < pts.Count; j++) {  			if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  	}  	if (worked) {  		pts.Add (p);  		break;  	}  	else {  		testCount++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: while (!worked) {  	worked = true;  	//If no valid points can be found' progressively lower the clearance radius until such a point is found  	if (testCount >= testLimit) {  		clearanceRadius *= 0.8f;  		testLimit += 10;  		if (testLimit > 100)  			clearanceRadius = 0;  	}  	float tg = (float)rnd.NextDouble () * tot;  	int v = accs.BinarySearch (tg);  	if (v < 0)  		v = ~v;  	if (v >= nodes.Count) {  		// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  		worked = false;  		continue;  	}  	TriangleMeshNode node = nodes [v] as TriangleMeshNode;  	Vector3 p;  	if (node != null) {  		// Find a random point inside the triangle  		float v1;  		float v2;  		do {  			v1 = (float)rnd.NextDouble ();  			v2 = (float)rnd.NextDouble ();  		}  		while (v1 + v2 > 1);  		p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  	}  	else {  		GridNode gnode = nodes [v] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float v1 = (float)rnd.NextDouble ();  			float v2 = (float)rnd.NextDouble ();  			p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  		}  		else {  			//Point nodes have no area' so we break directly instead  			pts.Add ((Vector3)nodes [v].position);  			break;  		}  	}  	// Test if it is some distance away from the other points  	if (clearanceRadius > 0) {  		for (int j = 0; j < pts.Count; j++) {  			if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  	}  	if (worked) {  		pts.Add (p);  		break;  	}  	else {  		testCount++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (testCount >= testLimit) {  	clearanceRadius *= 0.8f;  	testLimit += 10;  	if (testLimit > 100)  		clearanceRadius = 0;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (testCount >= testLimit) {  	clearanceRadius *= 0.8f;  	testLimit += 10;  	if (testLimit > 100)  		clearanceRadius = 0;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: testLimit += 10;  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (testLimit > 100)  	clearanceRadius = 0;  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (node != null) {  	// Find a random point inside the triangle  	float v1;  	float v2;  	do {  		v1 = (float)rnd.NextDouble ();  		v2 = (float)rnd.NextDouble ();  	}  	while (v1 + v2 > 1);  	p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  }  else {  	GridNode gnode = nodes [v] as GridNode;  	if (gnode != null) {  		GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  		float v1 = (float)rnd.NextDouble ();  		float v2 = (float)rnd.NextDouble ();  		p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  	}  	else {  		//Point nodes have no area' so we break directly instead  		pts.Add ((Vector3)nodes [v].position);  		break;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  
Magic Number,Pathfinding,Profile,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\ProfileHelper.cs,Stop,The following statement contains a magic number: if (this.control == 1 << 30)  	this.control = control;  else if (this.control != control)  	throw new System.Exception ("Control numbers do not match " + this.control + " != " + control);  
Magic Number,Pathfinding.Util,Checksum,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarChecksum.cs,GetChecksum,The following statement contains a magic number: for (int i = 0; i < Value.Length; i++) {  	CRCVal = (CRCVal >> 8) ^ CRCTable [(CRCVal & 0xff) ^ Value [i]];  }  
Magic Number,Pathfinding.Util,Checksum,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarChecksum.cs,GetChecksum,The following statement contains a magic number: CRCVal = (CRCVal >> 8) ^ CRCTable [(CRCVal & 0xff) ^ Value [i]];  
Magic Number,Pathfinding.Util,Memory,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: while (index < length) {  	Buffer.BlockCopy (array' 0' array' index' Math.Min (block' length - index));  	index += block;  	block *= 2;  }  
Magic Number,Pathfinding.Util,Memory,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: block *= 2;  
Magic Number,Pathfinding.Util,Memory,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: while (index < length) {  	Buffer.BlockCopy (array' 0' array' index * byteSize' Math.Min (block' length - index) * byteSize);  	index += block;  	block *= 2;  }  
Magic Number,Pathfinding.Util,Memory,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: block *= 2;  
Magic Number,Pathfinding.Util,Memory,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: while (index < length) {  	Buffer.BlockCopy (array' 0' array' index * byteSize' Math.Min (block' totalSize - index) * byteSize);  	index += block;  	block *= 2;  }  
Magic Number,Pathfinding.Util,Memory,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: block *= 2;  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: if (str.Length < 32)  	throw new System.FormatException ("Invalid Guid format");  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 16; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_a |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 16; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_a |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset -= 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset = 15 * 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset = 15 * 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 32; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_b |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 32; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_b |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset -= 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	bytes [i] = ba [i];  	bytes [i + 8] = bb [i];  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	bytes [i] = ba [i];  	bytes [i + 8] = bb [i];  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,ToByteArray,The following statement contains a magic number: bytes [i + 8] = bb [i];  
Magic Number,Pathfinding.Util,Guid,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Utilities\DotNetReplacements.cs,GetHashCode,The following statement contains a magic number: return (int)(ab >> 32) ^ (int)ab;  
Magic Number,Pathfinding.Serialization,MatrixConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The following statement contains a magic number: if (arr.Length != 16) {  	Debug.LogError ("Number of elements in matrix was not 16 (got " + arr.Length + ")");  	return m;  }  
Magic Number,Pathfinding.Serialization,MatrixConverter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	m [i] = System.Convert.ToSingle (arr.GetValue (i));  
Magic Number,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeUserConnections,The following statement contains a magic number: if (bytes.Length <= 2)  	return;  
Magic Number,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeEditorSettings,The following statement contains a magic number: for (int i = 0; i < editors.Length; i++) {  	if (editors [i] == null)  		return;  	System.Text.StringBuilder output = GetStringBuilder ();  	//new System.Text.StringBuilder();  	JsonWriter writer = new JsonWriter (output' writerSettings);  	writer.Write (editors [i]);  	byte[] bytes = encoding.GetBytes (output.ToString ());  	//Less or equal to 2 bytes means that nothing was saved (file is "{}")  	if (bytes.Length <= 2)  		continue;  	AddChecksum (bytes);  	zip.AddEntry ("graph" + i + "_editor" + jsonExt' bytes);  }  
Magic Number,Pathfinding.Serialization,AstarSerializer,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeEditorSettings,The following statement contains a magic number: if (bytes.Length <= 2)  	continue;  
Missing Default,Pathfinding,GraphModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Misc\GraphModifier.cs,TriggerEvent,The following switch statement is missing a default case: switch (type) {  case EventType.PreScan:  	while (c != null) {  		c.OnPreScan ();  		c = c.next;  	}  	break;  case EventType.PostScan:  	while (c != null) {  		c.OnPostScan ();  		c = c.next;  	}  	break;  case EventType.LatePostScan:  	while (c != null) {  		c.OnLatePostScan ();  		c = c.next;  	}  	break;  case EventType.PreUpdate:  	while (c != null) {  		c.OnGraphsPreUpdate ();  		c = c.next;  	}  	break;  case EventType.PostUpdate:  	while (c != null) {  		c.OnGraphsPostUpdate ();  		c = c.next;  	}  	break;  case EventType.PostCacheLoad:  	while (c != null) {  		c.OnPostCacheLoad ();  		c = c.next;  	}  	break;  }  
Missing Default,Pathfinding,Path,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following switch statement is missing a default case: switch (heuristic) {  case Heuristic.Euclidean:  	return (uint)(((GetHTarget () - node.position).costMagnitude) * heuristicScale);  case Heuristic.Manhattan:  	Int3 p2 = node.position;  	return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale);  case Heuristic.DiagonalManhattan:  	Int3 p = GetHTarget () - node.position;  	p.x = System.Math.Abs (p.x);  	p.y = System.Math.Abs (p.y);  	p.z = System.Math.Abs (p.z);  	int diag = System.Math.Min (p.x' p.z);  	int diag2 = System.Math.Max (p.x' p.z);  	return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  }  
Missing Default,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,The following switch statement is missing a default case: switch (AstarPath.active.debugMode) {  case GraphDebugMode.Areas:  	c = AstarColor.GetAreaColor (node.Area);  	colSet = true;  	break;  case GraphDebugMode.Penalty:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.Penalty / (float)AstarPath.active.debugRoof);  	colSet = true;  	break;  case GraphDebugMode.Tags:  	c = AstarMath.IntToColor ((int)node.Tag' 0.5F);  	colSet = true;  	break;  /* Wasn't really usefull 				case GraphDebugMode.Position: 					float r = Mathf.PingPong (node.position.x/10000F'1F) + Mathf.PingPong (node.position.x/300000F'1F); 					float g = Mathf.PingPong (node.position.y/10000F'1F) + Mathf.PingPong (node.position.y/200000F'1F); 					float b = Mathf.PingPong (node.position.z/10000F'1F) + Mathf.PingPong (node.position.z/100000F'1F); 					 					 					c = new Color (r'g'b); 					break; 				*/}  
Missing Default,Pathfinding,NavGraph,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Base.cs,NodeColor,The following switch statement is missing a default case: switch (AstarPath.active.debugMode) {  case GraphDebugMode.G:  	//c = Mathfx.IntToColor (node.g'0.5F);  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.G / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.H:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.H / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.F:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.F / (float)AstarPath.active.debugRoof);  	break;  }  
Missing Default,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following switch statement is missing a default case: switch (brokenString [0]) {  case "v":  	vertices++;  	break;  case "vt":  	vt++;  	break;  case "vn":  	vn++;  	break;  case "f":  	face = face + brokenString.Length - 1;  	triangles = triangles + 3 * (brokenString.Length - 2);  	/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  }  
Missing Default,Pathfinding,ObjImporter,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following switch statement is missing a default case: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Missing Default,Pathfinding,SimpleSmoothModifier,C:\repos\pwypeanut_isometricdefense\Assets\Plugins\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,Apply,The following switch statement is missing a default case: switch (smoothType) {  case SmoothType.Simple:  	path = SmoothSimple (p.vectorPath);  	break;  case SmoothType.Bezier:  	path = SmoothBezier (p.vectorPath);  	break;  case SmoothType.OffsetSimple:  	path = SmoothOffsetSimple (p.vectorPath);  	break;  case SmoothType.CurvedNonuniform:  	path = CurvedNonuniform (p.vectorPath);  	break;  }  
