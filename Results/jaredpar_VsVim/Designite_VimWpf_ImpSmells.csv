Implementation smell,Namespace,Class,File,Method,Description
Long Method,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The method has 102 lines of code.
Complex Method,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,Cyclomatic complexity of the method is 13
Complex Method,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,Cyclomatic complexity of the method is 96
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusOther,Cyclomatic complexity of the method is 23
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusCommon,Cyclomatic complexity of the method is 45
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,ChangeEditKind,Cyclomatic complexity of the method is 16
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEvent,Cyclomatic complexity of the method is 25
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,CheckEnableCommandLineEdit,Cyclomatic complexity of the method is 16
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateVimBufferStateWithCommandText,Cyclomatic complexity of the method is 15
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginControl,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginControl.xaml.cs,UpdateCaretPosition,Cyclomatic complexity of the method is 15
Complex Method,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretDisplay,Cyclomatic complexity of the method is 28
Complex Method,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,Cyclomatic complexity of the method is 11
Complex Method,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,PreprocessMouseDown,Cyclomatic complexity of the method is 15
Complex Method,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,PreprocessMouseUp,Cyclomatic complexity of the method is 15
Long Parameter List,Vim.UI.Wpf,NativeMethods,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\NativeMethods.cs,ToUnicodeEx,The method has 7 parameters.
Long Parameter List,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,CommandMarginController,The method has 5 parameters.
Long Parameter List,Vim.UI.Wpf.Implementation.Misc,DisplayWindowBroker,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Misc\DisplayWindowBroker.cs,DisplayWindowBroker,The method has 5 parameters.
Long Parameter List,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,BlockCaret,The method has 6 parameters.
Long Parameter List,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,BlockCaret,The method has 6 parameters.
Long Identifier,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,VimHost,The length of the parameter editorOperationsFactoryService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginProvider,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginProvider.cs,CommandMarginProvider,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.Directory,DirectoryTaggerSourceFactory,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Directory\DirectoryTaggerSourceFactory.cs,DirectoryTaggerSourceFactory,The length of the parameter classificationTypeRegistryService is 33.
Long Identifier,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretFactoryService,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretFactoryService.cs,BlockCaretFactoryService,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.WordCompletion,WordCompletionSessionFactoryService,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\WordCompletion\WordCompletionSessionFactoryService.cs,WordCompletionSessionFactoryService,The length of the parameter intellisenseSessionStackMapService is 34.
Long Statement,Vim.UI.Wpf,Extensions,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Extensions.cs,GetForegroundBrush,The length of the statement  "	return GetBrush (dictionary' EditorFormatDefinition.ForegroundBrushId' EditorFormatDefinition.ForegroundColorId' defaultBrush); " is 127.
Long Statement,Vim.UI.Wpf,Extensions,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Extensions.cs,GetBackgroundBrush,The length of the statement  "	return GetBrush (dictionary' EditorFormatDefinition.BackgroundBrushId' EditorFormatDefinition.BackgroundColorId' defaultBrush); " is 127.
Long Statement,Vim.UI.Wpf,VimKeyProcessor,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimKeyProcessor.cs,TextInput,The length of the statement  "	VimTrace.TraceInfo ("VimKeyProcessor::TextInput Text={0} ControlText={1} SystemText={2}"' args.Text' args.ControlText' args.SystemText); " is 136.
Long Statement,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,CreateHiddenTextView,The length of the statement  "	return _textEditorFactoryService.CreateTextView (_textBufferFactoryService.CreateTextBuffer ()' _textEditorFactoryService.NoRoles); " is 131.
Long Statement,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,ShouldCreateVimBuffer,The length of the statement  "	if (textView.Roles.Contains (PredefinedTextViewRoles.Interactive) && !textView.Roles.Contains (PredefinedTextViewRoles.Document)) { " is 131.
Long Statement,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,The length of the statement  "			var pos = textViewLine.Start < textView.TextViewLines.FormattedSpan.Start && textViewLine.Height <= textView.ViewportHeight + roundOff ? ViewRelativePosition.Top : ViewRelativePosition.Bottom; " is 192.
Long Statement,Vim.UI.Wpf.Implementation.CharDisplay,CharDisplayTaggerSourceFactory,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\CharDisplayTaggerSourceFactory.cs,CreateTagger,The length of the statement  "	return EditorUtilsFactory.CreateTagger (textView.Properties' _key' () => CreateCharDisplayTaggerSource (textView)) as ITagger<T>; " is 129.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusCommon,The length of the statement  "		status = String.IsNullOrEmpty (oneTimeArgument) ? String.Empty : String.Format (Resources.NormalOneTimeCommandBanner' oneTimeArgument); " is 135.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusCommon,The length of the statement  "		status = String.IsNullOrEmpty (oneTimeArgument) ? Resources.VisualBlockBanner : String.Format (Resources.VisualBlockOneTimeCommandBanner' oneTimeArgument); " is 155.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusCommon,The length of the statement  "		status = String.IsNullOrEmpty (oneTimeArgument) ? Resources.VisualCharacterBanner : String.Format (Resources.VisualCharacterOneTimeCommandBanner' oneTimeArgument); " is 163.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusCommon,The length of the statement  "		status = String.IsNullOrEmpty (oneTimeArgument) ? Resources.VisualLineBanner : String.Format (Resources.VisualLineOneTimeCommandBanner' oneTimeArgument); " is 153.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,CalculateCommandLineEditKind,The length of the statement  "		return _vimBuffer.IncrementalSearch.CurrentSearchData.Kind.IsAnyForward ? EditKind.SearchForward : EditKind.SearchBackward; " is 123.
Long Statement,Vim.UI.Wpf.Implementation.Directory,DirectoryTaggerSourceFactory,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Directory\DirectoryTaggerSourceFactory.cs,GetClassifier,The length of the statement  "	return EditorUtilsFactory.CreateClassifier (textBuffer.Properties' s_key' () => new DirectoryTaggerSource (textBuffer' classificationType)); " is 140.
Long Statement,Vim.UI.Wpf.Implementation.Misc,DisplayWindowBrokerFactoryService,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Misc\DisplayWindowBroker.cs,GetDisplayWindowBroker,The length of the statement  "	return textView.Properties.GetOrCreateSingletonProperty (s_key' () => new DisplayWindowBroker (textView' _completionBroker' _signatureHelpBroker' _smartTagBroker' _quickInfoBroker)); " is 182.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CreateBlinkTimer,The length of the statement  "		var blinkTimer = new DispatcherTimer (caretBlinkTimeSpan' DispatcherPriority.Normal' protectedOperations.GetProtectedEventHandler (onCaretBlinkTimer)' Dispatcher.CurrentDispatcher); " is 181.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CreateBlinkTimer,The length of the statement  "		var blinkTimer = new DispatcherTimer (TimeSpan.FromSeconds (2)' DispatcherPriority.Normal' protectedOperations.GetProtectedEventHandler (onCaretBlinkTimer)' Dispatcher.CurrentDispatcher); " is 187.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CreateFormattedText,The length of the statement  "	return new FormattedText ("^"' CultureInfo.CurrentUICulture' FlowDirection.RightToLeft' textRunProperties.Typeface' textRunProperties.FontRenderingEmSize' Brushes.Black); " is 170.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,IsAdornmentStale,The length of the statement  "	if (caretData.Color != TryCalculateCaretColor () || caretData.CaretDisplay != _caretDisplay || caretData.CaretOpacity != _caretOpacity) { " is 137.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,IsAdornmentStale,The length of the statement  "	if (Math.Abs (size.Height - caretData.Size.Height) > epsilon || Math.Abs (size.Width - caretData.Size.Width) > epsilon) { " is 121.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,EnsureCaretDisplayed,The length of the statement  "		_adornmentLayer.AddAdornment (AdornmentPositioningBehavior.TextRelative' new SnapshotSpan (caretPoint' 0)' _tag' caretData.Image' OnBlockCaretAdornmentRemoved); " is 160.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretFactoryService,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretFactoryService.cs,CreateBlockCaret,The length of the statement  "	return new BlockCaret (textView' BlockCaretAdornmentLayerName' classificationFormaptMap' formatMap' _controlCharUtil' _protectedOperations); " is 140.
Long Statement,Vim.UI.Wpf.Implementation.Paste,PasteAdornment,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteAdornment.cs,Display,The length of the statement  "		_adornmentLayer.AddAdornment (AdornmentPositioningBehavior.TextRelative' new SnapshotSpan (caretPoint' 0)' _tag' control' (x' y) => _isAdornmentPresent = false); " is 161.
Long Statement,Vim.UI.Wpf.Implementation.Paste,PasteFactoryService,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteFactoryService.cs,VimBufferCreated,The length of the statement  "	var controller = new PasteController (vimBuffer' wpfTextView' _protectedOperations' _formatMapService.GetEditorFormatMap (wpfTextView)); " is 136.
Long Statement,Vim.UI.Wpf.Implementation.WordCompletion,WordCompletionSessionFactoryService,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\WordCompletion\WordCompletionSessionFactoryService.cs,CreateWordCompletionSession,The length of the statement  "		var wordCompletionSession = new WordCompletionSession (wordTrackingSpan' intellisenseSessionStack' completionSession' wordCompletionSet); " is 137.
Long Statement,Vim.UI.Wpf.Implementation.WordCompletion,WordCompletionSession,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\WordCompletion\WordCompletionSession.cs,SendCommand,The length of the statement  "	if (wordSpan.IsSome () && _wordCompletionSet.SelectionStatus != null && _wordCompletionSet.SelectionStatus.Completion != null) { " is 128.
Long Statement,Vim.UI.Wpf.Implementation.WordCompletion,WordCompletionSession,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\WordCompletion\WordCompletionSession.cs,MoveWithWrap,The length of the statement  "	var originalCompletion = _wordCompletionSet.SelectionStatus != null ? _wordCompletionSet.SelectionStatus.Completion : null; " is 123.
Long Statement,Vim.UI.Wpf.Implementation.WordCompletion,WordCompletionSession,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\WordCompletion\WordCompletionSession.cs,MoveWithWrap,The length of the statement  "	var currentCompletion = _wordCompletionSet.SelectionStatus != null ? _wordCompletionSet.SelectionStatus.Completion : null; " is 122.
Empty Catch Block,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureVisible,The method has an empty catch block.
Empty Catch Block,Vim.UI.Wpf.Implementation.WordCompletion,WordCompletionPresenterProvider,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\WordCompletion\WordCompletionPresenterProvider.cs,TryCreateIntellisensePresenter,The method has an empty catch block.
Magic Number,Vim.UI.Wpf,NativeMethods,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\NativeMethods.cs,HiWord,The following statement contains a magic number: return (number >> 16) & 0xffff;  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,CharDisplayTaggerSource,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\CharDisplayTaggerSource.cs,TryFindIndex,The following statement contains a magic number: do {  	mid = (min + max) / 2;  	current = _adornmentCache [mid].Position;  	if (current == position) {  		index = mid;  		return true;  	}  	if (position < current) {  		max = mid - 1;  	} else {  		min = mid + 1;  	}  } while (min <= max);  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,CharDisplayTaggerSource,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\CharDisplayTaggerSource.cs,TryFindIndex,The following statement contains a magic number: mid = (min + max) / 2;  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,IsRelevant,The following statement contains a magic number: return i <= 31;  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: if (i >= 9 && i <= 13) {  	text = null;  	return false;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: if (i >= 9 && i <= 13) {  	text = null;  	return false;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following statement contains a magic number: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: if (e.Changes.Count == 1 && command.Length > 0) {  	var change = e.Changes.First ();  	if (change.AddedLength == 1) {  		// If we are in a paste wait context then attempt to complete it by passing on the   		// typed char to _vimBuffer.  This will process it as the register  		var c = command [change.Offset];  		var keyInput = KeyInputUtil.CharToKeyInput (c);  		_vimBuffer.Process (keyInput);  		// Now we need to update the command line.  During edits the controller is responsible  		// for manually updating the command line state.  Also we have to keep the caret postion  		// correct  		var name = RegisterName.OfChar ('c');  		if (name.IsSome ()) {  			var toPaste = _vimBuffer.GetRegister (name.Value).StringValue;  			var builder = new StringBuilder ();  			builder.Append (command' 0' change.Offset);  			builder.Append (toPaste);  			builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  			_margin.CommandLineTextBox.Text = builder.ToString ();  			_margin.CommandLineTextBox.Select (change.Offset + toPaste.Length' 0);  		}  		return;  	}  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: if (e.Changes.Count == 1 && command.Length > 0) {  	var change = e.Changes.First ();  	if (change.AddedLength == 1) {  		// If we are in a paste wait context then attempt to complete it by passing on the   		// typed char to _vimBuffer.  This will process it as the register  		var c = command [change.Offset];  		var keyInput = KeyInputUtil.CharToKeyInput (c);  		_vimBuffer.Process (keyInput);  		// Now we need to update the command line.  During edits the controller is responsible  		// for manually updating the command line state.  Also we have to keep the caret postion  		// correct  		var name = RegisterName.OfChar ('c');  		if (name.IsSome ()) {  			var toPaste = _vimBuffer.GetRegister (name.Value).StringValue;  			var builder = new StringBuilder ();  			builder.Append (command' 0' change.Offset);  			builder.Append (toPaste);  			builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  			_margin.CommandLineTextBox.Text = builder.ToString ();  			_margin.CommandLineTextBox.Select (change.Offset + toPaste.Length' 0);  		}  		return;  	}  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: if (change.AddedLength == 1) {  	// If we are in a paste wait context then attempt to complete it by passing on the   	// typed char to _vimBuffer.  This will process it as the register  	var c = command [change.Offset];  	var keyInput = KeyInputUtil.CharToKeyInput (c);  	_vimBuffer.Process (keyInput);  	// Now we need to update the command line.  During edits the controller is responsible  	// for manually updating the command line state.  Also we have to keep the caret postion  	// correct  	var name = RegisterName.OfChar ('c');  	if (name.IsSome ()) {  		var toPaste = _vimBuffer.GetRegister (name.Value).StringValue;  		var builder = new StringBuilder ();  		builder.Append (command' 0' change.Offset);  		builder.Append (toPaste);  		builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  		_margin.CommandLineTextBox.Text = builder.ToString ();  		_margin.CommandLineTextBox.Select (change.Offset + toPaste.Length' 0);  	}  	return;  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: if (change.AddedLength == 1) {  	// If we are in a paste wait context then attempt to complete it by passing on the   	// typed char to _vimBuffer.  This will process it as the register  	var c = command [change.Offset];  	var keyInput = KeyInputUtil.CharToKeyInput (c);  	_vimBuffer.Process (keyInput);  	// Now we need to update the command line.  During edits the controller is responsible  	// for manually updating the command line state.  Also we have to keep the caret postion  	// correct  	var name = RegisterName.OfChar ('c');  	if (name.IsSome ()) {  		var toPaste = _vimBuffer.GetRegister (name.Value).StringValue;  		var builder = new StringBuilder ();  		builder.Append (command' 0' change.Offset);  		builder.Append (toPaste);  		builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  		_margin.CommandLineTextBox.Text = builder.ToString ();  		_margin.CommandLineTextBox.Select (change.Offset + toPaste.Length' 0);  	}  	return;  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: if (name.IsSome ()) {  	var toPaste = _vimBuffer.GetRegister (name.Value).StringValue;  	var builder = new StringBuilder ();  	builder.Append (command' 0' change.Offset);  	builder.Append (toPaste);  	builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  	_margin.CommandLineTextBox.Text = builder.ToString ();  	_margin.CommandLineTextBox.Select (change.Offset + toPaste.Length' 0);  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: if (name.IsSome ()) {  	var toPaste = _vimBuffer.GetRegister (name.Value).StringValue;  	var builder = new StringBuilder ();  	builder.Append (command' 0' change.Offset);  	builder.Append (toPaste);  	builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  	_margin.CommandLineTextBox.Text = builder.ToString ();  	_margin.CommandLineTextBox.Select (change.Offset + toPaste.Length' 0);  }  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,UpdateForPasteWait,The following statement contains a magic number: builder.Append (command' change.Offset + 2' command.Length - (change.Offset + 2));  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretOpacity,The following statement contains a magic number: if (value >= 0 && value <= 100) {  	var opacity = ((double)value / 100);  	_blockCaret.CaretOpacity = opacity;  }  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretOpacity,The following statement contains a magic number: if (value >= 0 && value <= 100) {  	var opacity = ((double)value / 100);  	_blockCaret.CaretOpacity = opacity;  }  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CreateBlinkTimer,The following statement contains a magic number: try {  	var blinkTimer = new DispatcherTimer (caretBlinkTimeSpan' DispatcherPriority.Normal' protectedOperations.GetProtectedEventHandler (onCaretBlinkTimer)' Dispatcher.CurrentDispatcher);  	blinkTimer.IsEnabled = caretBlinkTime != null;  	return blinkTimer;  } catch (ArgumentOutOfRangeException) {  	// Hit the bug ... just create a simple timer with a default interval.  	VimTrace.TraceError ("Error creating BlockCaret DispatcherTimer");  	var blinkTimer = new DispatcherTimer (TimeSpan.FromSeconds (2)' DispatcherPriority.Normal' protectedOperations.GetProtectedEventHandler (onCaretBlinkTimer)' Dispatcher.CurrentDispatcher);  	blinkTimer.IsEnabled = true;  	return blinkTimer;  }  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: switch (_caretDisplay) {  case CaretDisplay.Block:  	return Tuple.Create (new Rect (GetRealCaretVisualPoint ()' CalculateCaretSize ())' 0d);  case CaretDisplay.HalfBlock: {  	var size = CalculateCaretSize ();  	size = new Size (size.Width' size.Height / 2);  	var point = GetRealCaretVisualPoint ();  	point = new Point (point.X' point.Y + size.Height);  	return Tuple.Create (new Rect (point' size)' size.Height);  }  case CaretDisplay.QuarterBlock: {  	var size = CalculateCaretSize ();  	var quarter = size.Height / 4;  	size = new Size (size.Width' quarter);  	var point = GetRealCaretVisualPoint ();  	var offset = quarter * 3;  	point = new Point (point.X' point.Y + offset);  	return Tuple.Create (new Rect (point' size)' offset);  }  case CaretDisplay.Select: {  	var size = new Size (_textView.Caret.Width' _textView.Caret.Height);  	var point = GetRealCaretVisualPoint ();  	return Tuple.Create (new Rect (point' size)' 0d);  }  case CaretDisplay.Invisible:  case CaretDisplay.NormalCaret:  	return Tuple.Create (new Rect (GetRealCaretVisualPoint ()' new Size (0' 0))' 0d);  default:  	throw new InvalidOperationException ("Invalid enum value");  }  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: switch (_caretDisplay) {  case CaretDisplay.Block:  	return Tuple.Create (new Rect (GetRealCaretVisualPoint ()' CalculateCaretSize ())' 0d);  case CaretDisplay.HalfBlock: {  	var size = CalculateCaretSize ();  	size = new Size (size.Width' size.Height / 2);  	var point = GetRealCaretVisualPoint ();  	point = new Point (point.X' point.Y + size.Height);  	return Tuple.Create (new Rect (point' size)' size.Height);  }  case CaretDisplay.QuarterBlock: {  	var size = CalculateCaretSize ();  	var quarter = size.Height / 4;  	size = new Size (size.Width' quarter);  	var point = GetRealCaretVisualPoint ();  	var offset = quarter * 3;  	point = new Point (point.X' point.Y + offset);  	return Tuple.Create (new Rect (point' size)' offset);  }  case CaretDisplay.Select: {  	var size = new Size (_textView.Caret.Width' _textView.Caret.Height);  	var point = GetRealCaretVisualPoint ();  	return Tuple.Create (new Rect (point' size)' 0d);  }  case CaretDisplay.Invisible:  case CaretDisplay.NormalCaret:  	return Tuple.Create (new Rect (GetRealCaretVisualPoint ()' new Size (0' 0))' 0d);  default:  	throw new InvalidOperationException ("Invalid enum value");  }  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: switch (_caretDisplay) {  case CaretDisplay.Block:  	return Tuple.Create (new Rect (GetRealCaretVisualPoint ()' CalculateCaretSize ())' 0d);  case CaretDisplay.HalfBlock: {  	var size = CalculateCaretSize ();  	size = new Size (size.Width' size.Height / 2);  	var point = GetRealCaretVisualPoint ();  	point = new Point (point.X' point.Y + size.Height);  	return Tuple.Create (new Rect (point' size)' size.Height);  }  case CaretDisplay.QuarterBlock: {  	var size = CalculateCaretSize ();  	var quarter = size.Height / 4;  	size = new Size (size.Width' quarter);  	var point = GetRealCaretVisualPoint ();  	var offset = quarter * 3;  	point = new Point (point.X' point.Y + offset);  	return Tuple.Create (new Rect (point' size)' offset);  }  case CaretDisplay.Select: {  	var size = new Size (_textView.Caret.Width' _textView.Caret.Height);  	var point = GetRealCaretVisualPoint ();  	return Tuple.Create (new Rect (point' size)' 0d);  }  case CaretDisplay.Invisible:  case CaretDisplay.NormalCaret:  	return Tuple.Create (new Rect (GetRealCaretVisualPoint ()' new Size (0' 0))' 0d);  default:  	throw new InvalidOperationException ("Invalid enum value");  }  
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: size = new Size (size.Width' size.Height / 2);  
Magic Number,Vim.UI.Wpf.Implementation.Paste,PasteAdornment,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteAdornment.cs,CreateControl,The following statement contains a magic number: border.Opacity = 100;  
Missing Default,Vim.UI.Wpf,VimHost,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,The following switch statement is missing a default case: switch (textViewLine.VisibilityState) {  case VisibilityState.FullyVisible:  	// If the line is fully visible then no scrolling needs to occur  	break;  case VisibilityState.Hidden:  case VisibilityState.PartiallyVisible:  	{  		ViewRelativePosition? pos = null;  		if (textViewLine.Height <= textView.ViewportHeight + roundOff) {  			// The line fits into the view.  Figure out if it needs to be at the top   			// or the bottom  			pos = textViewLine.Top < textView.ViewportTop ? ViewRelativePosition.Top : ViewRelativePosition.Bottom;  		} else if (textViewLine.Bottom < textView.ViewportBottom) {  			// Line does not fit into view but we can use more space at the bottom   			// of the view  			pos = ViewRelativePosition.Bottom;  		} else if (textViewLine.Top > textView.ViewportTop) {  			pos = ViewRelativePosition.Top;  		}  		if (pos.HasValue) {  			textView.DisplayTextLineContainingBufferPosition (point' 0.0' pos.Value);  		}  	}  	break;  case VisibilityState.Unattached:  	{  		var pos = textViewLine.Start < textView.TextViewLines.FormattedSpan.Start && textViewLine.Height <= textView.ViewportHeight + roundOff ? ViewRelativePosition.Top : ViewRelativePosition.Bottom;  		textView.DisplayTextLineContainingBufferPosition (point' 0.0' pos);  	}  	break;  }  
Missing Default,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,TryGetDisplayText,The following switch statement is missing a default case: switch (i) {  case 0:  	text = "^@";  	break;  case 1:  	text = "^A";  	break;  case 2:  	text = "^B";  	break;  case 3:  	text = "^C";  	break;  case 4:  	text = "^D";  	break;  case 5:  	text = "^E";  	break;  case 6:  	text = "^F";  	break;  case 7:  	text = "^G";  	break;  case 8:  	text = "^H";  	break;  case 9:  	text = "^I";  	break;  case 10:  	text = "^J";  	break;  case 11:  	text = "^K";  	break;  case 12:  	text = "^L";  	break;  case 13:  	text = "^M";  	break;  case 14:  	text = "^N";  	break;  case 15:  	text = "^O";  	break;  case 16:  	text = "^P";  	break;  case 17:  	text = "^Q";  	break;  case 18:  	text = "^R";  	break;  case 19:  	text = "^S";  	break;  case 20:  	text = "^T";  	break;  case 21:  	text = "^U";  	break;  case 22:  	text = "^V";  	break;  case 23:  	text = "^W";  	break;  case 24:  	text = "^X";  	break;  case 25:  	text = "^Y";  	break;  case 26:  	text = "^Z";  	break;  case 27:  	text = "^[";  	break;  case 28:  	text = "^\\";  	break;  case 29:  	text = "^]";  	break;  case 30:  	text = "^^";  	break;  case 31:  	text = "^_";  	break;  }  
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEvent,The following switch statement is missing a default case: switch (e.Key) {  case Key.Escape:  	_vimBuffer.Process (KeyInputUtil.EscapeKey);  	ChangeEditKind (EditKind.None);  	e.Handled = true;  	break;  case Key.Return:  	ExecuteCommand (_margin.CommandLineTextBox.Text);  	e.Handled = true;  	break;  case Key.Up:  	_vimBuffer.Process (KeyInputUtil.VimKeyToKeyInput (VimKey.Up));  	e.Handled = true;  	break;  case Key.Down:  	_vimBuffer.Process (KeyInputUtil.VimKeyToKeyInput (VimKey.Down));  	e.Handled = true;  	break;  case Key.R:  	if (e.KeyboardDevice.Modifiers == ModifierKeys.Control) {  		// During edits we are responsible for handling the command line.  Need to   		// put a " into the box at the edit position  		var textBox = _margin.CommandLineTextBox;  		var text = textBox.Text;  		var builder = new StringBuilder ();  		var offset = textBox.SelectionStart;  		builder.Append (text' 0' offset);  		builder.Append ('"');  		builder.Append (text' offset' text.Length - offset);  		UpdateCommandLine (builder.ToString ());  		textBox.Select (offset' 0);  		// Now move the buffer into paste wait   		_vimBuffer.Process (KeyInputUtil.ApplyKeyModifiersToChar ('r'' VimKeyModifiers.Control));  	}  	break;  case Key.U:  	if (e.KeyboardDevice.Modifiers == ModifierKeys.Control) {  		var textBox = _margin.CommandLineTextBox;  		var text = textBox.Text.Substring (textBox.SelectionStart);  		textBox.Text = text;  		UpdateVimBufferStateWithCommandText (text);  	}  	break;  }  
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,CheckEnableCommandLineEdit,The following switch statement is missing a default case: switch (args.KeyInput.Key) {  case VimKey.Home:  	// Enable command line edition  	ChangeEditKind (commandLineEditKind);  	_margin.UpdateCaretPosition (EditPosition.Start);  	args.Handled = true;  	break;  case VimKey.Left:  	ChangeEditKind (commandLineEditKind);  	_margin.UpdateCaretPosition (EditPosition.BeforeLastCharacter);  	args.Handled = true;  	break;  case VimKey.Up:  case VimKey.Down:  	// User is navigation through history' move caret to the end of the entry  	_margin.UpdateCaretPosition (EditPosition.End);  	break;  }  
Missing Default,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretDisplay,The following switch statement is missing a default case: switch (_vimBuffer.ModeKind) {  case ModeKind.Normal:  	{  		var mode = _vimBuffer.NormalMode;  		if (mode.InReplace) {  			kind = CaretDisplay.QuarterBlock;  		} else if (mode.KeyRemapMode.IsOperatorPending) {  			kind = CaretDisplay.HalfBlock;  		} else {  			kind = CaretDisplay.Block;  		}  	}  	break;  case ModeKind.VisualBlock:  case ModeKind.VisualCharacter:  case ModeKind.VisualLine:  case ModeKind.SelectBlock:  case ModeKind.SelectCharacter:  case ModeKind.SelectLine:  	// In visual mode we change the caret based on what the selection mode  	// is  	kind = _globalSettings.IsSelectionInclusive ? CaretDisplay.Block : CaretDisplay.Select;  	break;  case ModeKind.Command:  case ModeKind.SubstituteConfirm:  	kind = CaretDisplay.Invisible;  	break;  case ModeKind.Insert:  case ModeKind.ExternalEdit:  	kind = CaretDisplay.NormalCaret;  	break;  case ModeKind.Disabled:  	kind = CaretDisplay.NormalCaret;  	break;  case ModeKind.Replace:  	kind = CaretDisplay.QuarterBlock;  	break;  }  
Missing Default,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,PreprocessMouseDown,The following switch statement is missing a default case: switch (e.ChangedButton) {  case MouseButton.Left:  	e.Handled = TryProcess (VimKey.LeftMouse);  	break;  case MouseButton.Middle:  	e.Handled = TryProcess (VimKey.MiddleMouse);  	break;  case MouseButton.Right:  	e.Handled = TryProcess (VimKey.RightMouse);  	break;  case MouseButton.XButton1:  	e.Handled = TryProcess (VimKey.X1Mouse);  	break;  case MouseButton.XButton2:  	e.Handled = TryProcess (VimKey.X2Mouse);  	break;  }  
Missing Default,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,F:\newReposMay17\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,PreprocessMouseUp,The following switch statement is missing a default case: switch (e.ChangedButton) {  case MouseButton.Left:  	e.Handled = TryProcess (VimKey.LeftRelease);  	break;  case MouseButton.Middle:  	e.Handled = TryProcess (VimKey.MiddleRelease);  	break;  case MouseButton.Right:  	e.Handled = TryProcess (VimKey.RightRelease);  	break;  case MouseButton.XButton1:  	e.Handled = TryProcess (VimKey.X1Release);  	break;  case MouseButton.XButton2:  	e.Handled = TryProcess (VimKey.X2Release);  	break;  }  
