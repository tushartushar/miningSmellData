Implementation smell,Namespace,Class,File,Method,Description
Long Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEvent,The method has 145 lines of code.
Complex Method,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,Cyclomatic complexity of the method is 8
Complex Method,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretSize,Cyclomatic complexity of the method is 9
Complex Method,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,EnsureCaretDisplayed,Cyclomatic complexity of the method is 9
Complex Method,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretDisplay,Cyclomatic complexity of the method is 10
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEvent,Cyclomatic complexity of the method is 33
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEventInPasteWait,Cyclomatic complexity of the method is 9
Complex Method,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetStatusCommon,Cyclomatic complexity of the method is 17
Complex Method,Vim.UI.Wpf.Implementation.ImeCoordinator,ImeCoordinator,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,OnSettingChanged,Cyclomatic complexity of the method is 9
Complex Method,Vim.UI.Wpf.Implementation.ImeCoordinator,InputModeState,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,GetState,Cyclomatic complexity of the method is 8
Complex Method,Vim.UI.Wpf.Implementation.ImeCoordinator,InputModeState,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,SetState,Cyclomatic complexity of the method is 12
Complex Method,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphTaggerSource,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphTaggerSource.cs,UpdateMark,Cyclomatic complexity of the method is 11
Complex Method,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,OnScrollTimer,Cyclomatic complexity of the method is 8
Long Parameter List,Vim.UI.Wpf,NativeMethods,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\NativeMethods.cs,ToUnicodeEx,The method has 7 parameters. Parameters: virtualKey' scanCode' keyState' buffer' bufferSize' flags' keyboardLayout
Long Parameter List,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,VimHost,The method has 5 parameters. Parameters: protectedOperations' textBufferFactoryService' textEditorFactoryService' textDocumentFactoryService' editorOperationsFactoryService
Long Parameter List,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,FindInFiles,The method has 5 parameters. Parameters: pattern' matchCase' filesOfType' flags' action
Long Parameter List,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,FindInFiles,The method has 5 parameters. Parameters: pattern' matchCase' filesOfType' flags' action
Long Parameter List,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,BlockCaret,The method has 6 parameters. Parameters: vimBufferData' classificationFormatMap' formatMap' layer' controlCharUtil' protectedOperations
Long Parameter List,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,BlockCaret,The method has 6 parameters. Parameters: vimBufferData' adornmentLayerName' classificationFormatMap' formatMap' controlCharUtil' protectedOperations
Long Parameter List,Vim.UI.Wpf.Implementation.BlockCaret,CaretData,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CaretData,The method has 9 parameters. Parameters: caretIndex' caretDisplay' caretOpacity' element' color' size' displayOffset' baselineOffset' caretCharacter
Long Parameter List,Vim.UI.Wpf.Implementation.CommandMargin,CommandMargin,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMargin.cs,CommandMargin,The method has 7 parameters. Parameters: parentVisualElement' buffer' editorFormatMap' classificationFormatMap' commonOperations' clipboardDevice' isFirstCommandMargin
Long Parameter List,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,CommandMarginController,The method has 8 parameters. Parameters: buffer' parentVisualElement' control' editorFormatMap' classificationFormatMap' commonOperations' clipboardDevice' isFirstCommandMargin
Long Parameter List,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginProvider,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginProvider.cs,CommandMarginProvider,The method has 5 parameters. Parameters: vim' editorFormatMapService' classificationFormatMapService' commonOperationsFactory' clipboardDevice
Long Parameter List,Vim.UI.Wpf.Implementation.Paste,PasteAdornment,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteAdornment.cs,PasteAdornment,The method has 5 parameters. Parameters: textView' adornmentLayer' protectedOperations' classificationFormatMap' editorFormatMap
Long Parameter List,Vim.UI.Wpf.Implementation.Paste,PasteController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteController.cs,PasteController,The method has 5 parameters. Parameters: vimBuffer' wpfTextView' protectedOperations' classificationFormatMap' editorFormatMap
Long Parameter List,Vim.UI.Wpf.Implementation.RelativeLineNumbers,RelativeLineNumbersMargin,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\RelativeLineNumbers\RelativeLineNumbersMargin.cs,RelativeLineNumbersMargin,The method has 5 parameters. Parameters: textView' formatTracker' localSettings' marginContainer' protectedOperations
Long Identifier,Vim.UI.Wpf,VimWpfConstants,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Constants.cs,,The length of the parameter BlockCaretFormatDefinitionName is 30.
Long Identifier,Vim.UI.Wpf,VimWpfConstants,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Constants.cs,,The length of the parameter PrimaryCaretFormatDefinitionName is 32.
Long Identifier,Vim.UI.Wpf,VimWpfConstants,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Constants.cs,,The length of the parameter SecondaryCaretFormatDefinitionName is 34.
Long Identifier,Vim.UI.Wpf,VimWpfConstants,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Constants.cs,,The length of the parameter ControlCharactersFormatDefinitionName is 37.
Long Identifier,Vim.UI.Wpf,VimWpfConstants,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Constants.cs,,The length of the parameter CommandMarginFormatDefinitionName is 33.
Long Identifier,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,VimHost,The length of the parameter editorOperationsFactoryService is 30.
Long Identifier,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,,The length of the parameter _editorOperationsFactoryService is 31.
Long Identifier,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretFactoryService,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretFactoryService.cs,BlockCaretFactoryService,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretFactoryService,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretFactoryService.cs,,The length of the parameter _classificationFormatMapService is 31.
Long Identifier,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretFactoryService,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretFactoryService.cs,,The length of the parameter _blockCaretAdornmentLayerDefinition is 35.
Long Identifier,Vim.UI.Wpf.Implementation.CharDisplay,CharDisplayTaggerSourceFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\CharDisplayTaggerSourceFactory.cs,CharDisplayTaggerSourceFactory,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.CharDisplay,CharDisplayTaggerSourceFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\CharDisplayTaggerSourceFactory.cs,,The length of the parameter _classificationFormatMapService is 31.
Long Identifier,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginProvider,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginProvider.cs,CommandMarginProvider,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginProvider,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginProvider.cs,,The length of the parameter _classificationFormatMapService is 31.
Long Identifier,Vim.UI.Wpf.Implementation.Directory,DirectoryContentType,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Directory\DirectoryContentType.cs,,The length of the parameter DirectoryContentTypeDefinition is 30.
Long Identifier,Vim.UI.Wpf.Implementation.Directory,DirectoryTaggerSourceFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Directory\DirectoryTaggerSourceFactory.cs,DirectoryTaggerSourceFactory,The length of the parameter classificationTypeRegistryService is 33.
Long Identifier,Vim.UI.Wpf.Implementation.Directory,DirectoryTaggerSourceFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Directory\DirectoryTaggerSourceFactory.cs,,The length of the parameter _classificationTypeRegistryService is 34.
Long Identifier,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphFactoryProvider,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphFactoryProvider.cs,MarkGlyphFactoryProvider,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphFactoryProvider,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphFactoryProvider.cs,,The length of the parameter _classificationFormatMapService is 31.
Long Identifier,Vim.UI.Wpf.Implementation.Paste,PasteFactoryService,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteFactoryService.cs,PasteFactoryService,The length of the parameter classificationFormatMapService is 30.
Long Identifier,Vim.UI.Wpf.Implementation.Paste,PasteFactoryService,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteFactoryService.cs,,The length of the parameter _classificationFormatMapService is 31.
Long Identifier,Vim.UI.Wpf.Implementation.Paste,PasteFactoryService,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteFactoryService.cs,,The length of the parameter _pasteAdornmentLayerDefinition is 30.
Long Statement,Vim.UI.Wpf,Extensions,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Extensions.cs,GetForegroundBrush,The length of the statement  "            return GetBrush(dictionary' EditorFormatDefinition.ForegroundBrushId' EditorFormatDefinition.ForegroundColorId' defaultBrush); " is 126.
Long Statement,Vim.UI.Wpf,Extensions,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Extensions.cs,GetBackgroundBrush,The length of the statement  "            return GetBrush(dictionary' EditorFormatDefinition.BackgroundBrushId' EditorFormatDefinition.BackgroundColorId' defaultBrush); " is 126.
Long Statement,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,The length of the statement  "                        var pos = textViewLine.Start < textView.TextViewLines.FormattedSpan.Start && textViewLine.Height <= textView.ViewportHeight + roundOff " is 134.
Long Statement,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CreateFormattedText,The length of the statement  "            return new FormattedText("A"' CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' textRunProperties.Typeface' textRunProperties.FontRenderingEmSize' Brushes.Black); " is 169.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginControl,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginControl.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/Vim.UI.Wpf;component/implementation/commandmargin/commandmargincontrol.xaml"' System.UriKind.Relative); " is 149.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,DeleteWordBeforeCursor,The length of the statement  "            var wordSpans = _vimBuffer.VimTextBuffer.WordUtil.GetWordSpansInText(WordKind.NormalWord' SearchPath.Backward' textBox.Text); " is 125.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEventInPasteWait,The length of the statement  "                        e.Handled = HandlePasteSpecial(KeyInputUtil.ApplyKeyModifiersToChar('w'' VimKeyModifiers.Control)' WordKind.NormalWord); " is 120.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandlePasteSpecial,The length of the statement  "            var currentWord = _vimBuffer.MotionUtil.GetMotion(Motion.NewInnerWord(wordKind)' new MotionArgument(MotionContext.AfterOperator)); " is 130.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginProvider,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginProvider.cs,CreateCommandMargin,The length of the statement  "            var commandMargin = new CommandMargin(wpfTextView.VisualElement' vimBuffer' editorFormatMap' classificationFormatMap' commonOperations' _clipboardDevice' _isFirstCommandMargin); " is 177.
Long Statement,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetVisualModeShowCommandText,The length of the statement  "                    // account for the selection possibly extending past the last printable character in the line to include some or all of a multi-character newline " is 145.
Complex Conditional,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,OnScrollTimer,The conditional expression  "_wpfTextView.IsClosed                  || !_wpfTextView.HasAggregateFocus                  || !_mouseCaptured                  || !_wpfTextView.VisualElement.IsMouseCaptured                  || _mouseDevice.LeftButton != MouseButtonState.Pressed"  is complex.
Complex Conditional,Vim.UI.Wpf.Implementation.RelativeLineNumbers,LineNumbersTracker,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\RelativeLineNumbers\LineNumbersTracker.cs,OnLayoutChanged,The conditional expression  "newOrReformatted || linesMoved || scroll || _bufferChanged || _heightChanged || _zoomChanged"  is complex.
Empty Catch Block,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureVisible,The method has an empty catch block.
Magic Number,Vim.UI.Wpf,NativeMethods,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\NativeMethods.cs,HiWord,The following statement contains a magic number: return (number >> 16) & 0xffff;
Magic Number,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,RunCommand,The following statement contains a magic number: var timeout = 30 * 1000;
Magic Number,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,RunCommand,The following statement contains a magic number: var timeout = 30 * 1000;
Magic Number,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,The following statement contains a magic number: const double roundOff = 0.01;
Magic Number,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLinePointVisible,The following statement contains a magic number: const double horizontalPadding = 2.0;
Magic Number,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLinePointVisible,The following statement contains a magic number: const double scrollbarPadding = 200.0;
Magic Number,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLinePointVisible,The following statement contains a magic number: var scroll = Math.Max(                  horizontalPadding'                  Math.Min(scrollbarPadding' textView.ViewportWidth / 4));
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: switch (_caretDisplay)              {                  case CaretDisplay.Block:                      break;                    case CaretDisplay.HalfBlock:                      size = new Size(size.Width' size.Height / 2);                      blockPoint = new Point(blockPoint.X' blockPoint.Y + size.Height);                      break;                    case CaretDisplay.QuarterBlock:                      size = new Size(size.Width' size.Height / 4);                      blockPoint = new Point(blockPoint.X' blockPoint.Y + 3 * size.Height);                      break;                    case CaretDisplay.Select:                      caretCharacter = null;                      var width = SnapToWholeDevicePixels(_textView.Caret.Width' ensurePositive: true);                      var height = _textView.Caret.Height;                        size = new Size(width' height);                      break;                    case CaretDisplay.Invisible:                  case CaretDisplay.NormalCaret:                      caretCharacter = null;                      size = new Size(0' 0);                      break;                    default:                      throw new InvalidOperationException("Invalid enum value");              }
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: switch (_caretDisplay)              {                  case CaretDisplay.Block:                      break;                    case CaretDisplay.HalfBlock:                      size = new Size(size.Width' size.Height / 2);                      blockPoint = new Point(blockPoint.X' blockPoint.Y + size.Height);                      break;                    case CaretDisplay.QuarterBlock:                      size = new Size(size.Width' size.Height / 4);                      blockPoint = new Point(blockPoint.X' blockPoint.Y + 3 * size.Height);                      break;                    case CaretDisplay.Select:                      caretCharacter = null;                      var width = SnapToWholeDevicePixels(_textView.Caret.Width' ensurePositive: true);                      var height = _textView.Caret.Height;                        size = new Size(width' height);                      break;                    case CaretDisplay.Invisible:                  case CaretDisplay.NormalCaret:                      caretCharacter = null;                      size = new Size(0' 0);                      break;                    default:                      throw new InvalidOperationException("Invalid enum value");              }
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,CalculateCaretRectAndDisplayOffset,The following statement contains a magic number: switch (_caretDisplay)              {                  case CaretDisplay.Block:                      break;                    case CaretDisplay.HalfBlock:                      size = new Size(size.Width' size.Height / 2);                      blockPoint = new Point(blockPoint.X' blockPoint.Y + size.Height);                      break;                    case CaretDisplay.QuarterBlock:                      size = new Size(size.Width' size.Height / 4);                      blockPoint = new Point(blockPoint.X' blockPoint.Y + 3 * size.Height);                      break;                    case CaretDisplay.Select:                      caretCharacter = null;                      var width = SnapToWholeDevicePixels(_textView.Caret.Width' ensurePositive: true);                      var height = _textView.Caret.Height;                        size = new Size(width' height);                      break;                    case CaretDisplay.Invisible:                  case CaretDisplay.NormalCaret:                      caretCharacter = null;                      size = new Size(0' 0);                      break;                    default:                      throw new InvalidOperationException("Invalid enum value");              }
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaret,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaret.cs,IsAdornmentStale,The following statement contains a magic number: var epsilon = 0.001;
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretOpacity,The following statement contains a magic number: var opacity = ((double)value / 100);
Magic Number,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretOpacity,The following statement contains a magic number: value >= 0 && value <= 100
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,CharDisplayTaggerSource,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\CharDisplayTaggerSource.cs,TryFindIndex,The following statement contains a magic number: mid = (min + max) / 2;
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,IsDisplayControlChar,The following statement contains a magic number: i == 9 || i == 10 || i == 13
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,IsDisplayControlChar,The following statement contains a magic number: i == 9 || i == 10 || i == 13
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,IsDisplayControlChar,The following statement contains a magic number: i == 9 || i == 10 || i == 13
Magic Number,Vim.UI.Wpf.Implementation.CharDisplay,ControlCharUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CharDisplay\ControlCharUtil.cs,IsDisplayControlChar,The following statement contains a magic number: return i >= 0 && i <= 31;
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginControl,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginControl.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.commandMarginControl = ((Vim.UI.Wpf.Implementation.CommandMargin.CommandMarginControl)(target));              return;              case 2:              this._commandLineInput = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this._showCommandText = ((System.Windows.Controls.TextBox)(target));              return;              }
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginControl,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginControl.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.commandMarginControl = ((Vim.UI.Wpf.Implementation.CommandMargin.CommandMarginControl)(target));              return;              case 2:              this._commandLineInput = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this._showCommandText = ((System.Windows.Controls.TextBox)(target));              return;              }
Magic Number,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,DeleteWordBeforeCursor,The following statement contains a magic number: caretIndex < 2
Magic Number,Vim.UI.Wpf.Implementation.ImeCoordinator,InputModeState,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,GetState,The following statement contains a magic number: switch (inputMode)                  {                      case InputMode.Command:                          if (_globalSettings.ImeCommand)                          {                              return GetState(InputMode.Insert);                          }                          else                          {                              return InputMethodState.Off;                          }                        case InputMode.Insert:                          if (_globalSettings.ImeInsert == 2)                          {                              return InputMethodState.On;                          }                          else                          {                              return InputMethodState.Off;                          }                        case InputMode.Search:                          if (_globalSettings.ImeSearch == -1)                          {                              return GetState(InputMode.Insert);                          }                          else                          {                              if (_globalSettings.ImeSearch == 2)                              {                                  return InputMethodState.On;                              }                              else                              {                                  return InputMethodState.Off;                              }                          }                        default:                          throw new ArgumentException(nameof(inputMode));                  }
Magic Number,Vim.UI.Wpf.Implementation.ImeCoordinator,InputModeState,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,GetState,The following statement contains a magic number: switch (inputMode)                  {                      case InputMode.Command:                          if (_globalSettings.ImeCommand)                          {                              return GetState(InputMode.Insert);                          }                          else                          {                              return InputMethodState.Off;                          }                        case InputMode.Insert:                          if (_globalSettings.ImeInsert == 2)                          {                              return InputMethodState.On;                          }                          else                          {                              return InputMethodState.Off;                          }                        case InputMode.Search:                          if (_globalSettings.ImeSearch == -1)                          {                              return GetState(InputMode.Insert);                          }                          else                          {                              if (_globalSettings.ImeSearch == 2)                              {                                  return InputMethodState.On;                              }                              else                              {                                  return InputMethodState.Off;                              }                          }                        default:                          throw new ArgumentException(nameof(inputMode));                  }
Magic Number,Vim.UI.Wpf.Implementation.ImeCoordinator,InputModeState,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,SetState,The following statement contains a magic number: switch (inputMode)                  {                      case InputMode.Command:                          if (_globalSettings.ImeCommand)                          {                              SetState(InputMode.Insert' state);                          }                          break;                        case InputMode.Insert:                          switch (state)                          {                              case InputMethodState.On:                                  _globalSettings.ImeInsert = 2;                                  break;                                case InputMethodState.Off:                                  _globalSettings.ImeInsert = 0;                                  break;                                case InputMethodState.DoNotCare:                                  break;                                default:                                  throw new ArgumentException(nameof(state));                          }                          break;                        case InputMode.Search:                          if (_globalSettings.ImeSearch == -1)                          {                              SetState(InputMode.Insert' state);                          }                          else                          {                              switch (state)                              {                                  case InputMethodState.On:                                      _globalSettings.ImeSearch = 2;                                      break;                                    case InputMethodState.Off:                                      _globalSettings.ImeSearch = 0;                                      break;                                    case InputMethodState.DoNotCare:                                      break;                                    default:                                      throw new ArgumentException(nameof(state));                              }                          }                          break;                        default:                          throw new ArgumentException(nameof(inputMode));                  }
Magic Number,Vim.UI.Wpf.Implementation.ImeCoordinator,InputModeState,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\ImeCoordinator\ImeCoordinator.cs,SetState,The following statement contains a magic number: switch (inputMode)                  {                      case InputMode.Command:                          if (_globalSettings.ImeCommand)                          {                              SetState(InputMode.Insert' state);                          }                          break;                        case InputMode.Insert:                          switch (state)                          {                              case InputMethodState.On:                                  _globalSettings.ImeInsert = 2;                                  break;                                case InputMethodState.Off:                                  _globalSettings.ImeInsert = 0;                                  break;                                case InputMethodState.DoNotCare:                                  break;                                default:                                  throw new ArgumentException(nameof(state));                          }                          break;                        case InputMode.Search:                          if (_globalSettings.ImeSearch == -1)                          {                              SetState(InputMode.Insert' state);                          }                          else                          {                              switch (state)                              {                                  case InputMethodState.On:                                      _globalSettings.ImeSearch = 2;                                      break;                                    case InputMethodState.Off:                                      _globalSettings.ImeSearch = 0;                                      break;                                    case InputMethodState.DoNotCare:                                      break;                                    default:                                      throw new ArgumentException(nameof(state));                              }                          }                          break;                        default:                          throw new ArgumentException(nameof(inputMode));                  }
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphFactory.cs,GenerateGlyph,The following statement contains a magic number: chars = chars.Substring(0' 3);
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphFactory.cs,GenerateGlyph,The following statement contains a magic number: chars.Length > 3
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphFactory.cs,GenerateGlyph,The following statement contains a magic number: fontSize = fontSize * 2 / chars.Length;
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphFactory,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphFactory.cs,GenerateGlyph,The following statement contains a magic number: chars.Length > 2
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphTaggerSource,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphTaggerSource.cs,ExpandHideMarksSetting,The following statement contains a magic number: var c2 = setting[i + 2];
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphTaggerSource,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphTaggerSource.cs,ExpandHideMarksSetting,The following statement contains a magic number: i += 3;
Magic Number,Vim.UI.Wpf.Implementation.MarkGlyph,MarkGlyphTaggerSource,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\MarkGlyph\MarkGlyphTaggerSource.cs,ExpandHideMarksSetting,The following statement contains a magic number: i + 2 < setting.Length && setting[i + 1] == '-'
Magic Number,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,VimMouseProcessor,The following statement contains a magic number: _scrollTimer = new DispatcherTimer(                  new TimeSpan(0' 0' 0' 0' 1000 / s_linesPerSecond)'                  DispatcherPriority.Normal'                  protectedOperations.GetProtectedEventHandler(OnScrollTimer)'                  Dispatcher.CurrentDispatcher);
Magic Number,Vim.UI.Wpf.Implementation.Paste,PasteAdornment,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Paste\PasteAdornment.cs,CreateControl,The following statement contains a magic number: var border = new Border              {                  Opacity = 100'                  Background = Brushes.White'                  Child = textBlock              };
Magic Number,Vim.UI.Wpf.Implementation.RelativeLineNumbers,LineNumberFormatTracker,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\RelativeLineNumbers\LineNumberFormatTracker.cs,UpdateFormat,The following statement contains a magic number: NumberWidth = Enumerable.Range(0' 10).Max(x => MakeTextLine(x).Width);
Missing Default,Vim.UI.Wpf,VimHost,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\VimHost.cs,EnsureLineVisible,The following switch statement is missing a default case: switch (textViewLine.VisibilityState)              {                  case VisibilityState.FullyVisible:                      // If the line is fully visible then no scrolling needs to occur                      break;                    case VisibilityState.Hidden:                  case VisibilityState.PartiallyVisible:                      {                          ViewRelativePosition? pos = null;                          if (textViewLine.Height <= textView.ViewportHeight + roundOff)                          {                              // The line fits into the view.  Figure out if it needs to be at the top                               // or the bottom                              pos = textViewLine.Top < textView.ViewportTop                                  ? ViewRelativePosition.Top                                  : ViewRelativePosition.Bottom;                          }                          else if (textViewLine.Bottom < textView.ViewportBottom)                          {                              // Line does not fit into view but we can use more space at the bottom                               // of the view                              pos = ViewRelativePosition.Bottom;                          }                          else if (textViewLine.Top > textView.ViewportTop)                          {                              pos = ViewRelativePosition.Top;                          }                            if (pos.HasValue)                          {                              textView.DisplayTextLineContainingBufferPosition(point' 0.0' pos.Value);                          }                      }                      break;                  case VisibilityState.Unattached:                      {                          var pos = textViewLine.Start < textView.TextViewLines.FormattedSpan.Start && textViewLine.Height <= textView.ViewportHeight + roundOff                                        ? ViewRelativePosition.Top                                        : ViewRelativePosition.Bottom;                          textView.DisplayTextLineContainingBufferPosition(point' 0.0' pos);                      }                      break;              }
Missing Default,Vim.UI.Wpf.Implementation.BlockCaret,BlockCaretController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\BlockCaret\BlockCaretController.cs,UpdateCaretDisplay,The following switch statement is missing a default case: switch (_vimBuffer.ModeKind)              {                  case ModeKind.Normal:                      {                          var mode = _vimBuffer.NormalMode;                          if (mode.InReplace)                          {                              kind = CaretDisplay.QuarterBlock;                          }                          else if (mode.KeyRemapMode.IsOperatorPending)                          {                              kind = CaretDisplay.HalfBlock;                          }                          else                          {                              kind = CaretDisplay.Block;                          }                      }                      break;                  case ModeKind.VisualBlock:                  case ModeKind.VisualCharacter:                  case ModeKind.VisualLine:                  case ModeKind.SelectBlock:                  case ModeKind.SelectCharacter:                  case ModeKind.SelectLine:                        // In visual mode we change the caret based on what the selection mode                      // is                      kind = _globalSettings.IsSelectionInclusive                         ? CaretDisplay.Block                         : CaretDisplay.Select;                      break;                  case ModeKind.Command:                  case ModeKind.SubstituteConfirm:                      kind = CaretDisplay.Invisible;                      break;                  case ModeKind.Insert:                      kind =_vimBuffer.Vim.VimHost.UseDefaultCaret                          ? CaretDisplay.NormalCaret                          : CaretDisplay.Select;                      break;                  case ModeKind.ExternalEdit:                      kind = CaretDisplay.NormalCaret;                      break;                  case ModeKind.Disabled:                      kind = CaretDisplay.NormalCaret;                      break;                  case ModeKind.Replace:                      kind = CaretDisplay.QuarterBlock;                      break;              }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginControl,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginControl.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.commandMarginControl = ((Vim.UI.Wpf.Implementation.CommandMargin.CommandMarginControl)(target));              return;              case 2:              this._commandLineInput = ((System.Windows.Controls.TextBox)(target));              return;              case 3:              this._showCommandText = ((System.Windows.Controls.TextBox)(target));              return;              }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleHistoryNavigation,The following switch statement is missing a default case: switch (_editKind)                  {                      case EditKind.Command:                          var command = _vimBuffer.CommandMode.EditableCommand;                          UpdateCommandLine(prefixChar.ToString() + command.Text' command.CaretPosition + 1);                          break;                        case EditKind.SearchForward:                      case EditKind.SearchBackward:                          UpdateCommandLine(prefixChar.ToString() + _vimBuffer.IncrementalSearch.CurrentSearchText);                          break;                  }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEvent,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Escape:                      _vimBuffer.Process(KeyInputUtil.EscapeKey);                      ChangeEditKind(EditKind.None);                      e.Handled = true;                      break;                  case Key.C:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          if (_margin.CommandLineTextBox.SelectionLength != 0)                          {                              // Copy if there is a selection.                              // Reported in issue #2338.                              _clipboardDevice.Text = _margin.CommandLineTextBox.SelectedText;                          }                          else                          {                              _vimBuffer.Process(KeyInputUtil.EscapeKey);                              ChangeEditKind(EditKind.None);                          }                          e.Handled = true;                      }                      break;                  case Key.Space:                      TryCompleteAbbreviation(KeyNotationUtil.StringToKeyInput(" "));                      break;                  case Key.Return:                      TryCompleteAbbreviation(KeyInputUtil.EnterKey);                      ExecuteCommand(_margin.CommandLineTextBox.Text);                      e.Handled = true;                      break;                  case Key.J:                  case Key.M:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          ExecuteCommand(_margin.CommandLineTextBox.Text);                          e.Handled = true;                      }                      break;                  case Key.Up:                      e.Handled = HandleHistoryNavigation(KeyInputUtil.VimKeyToKeyInput(VimKey.Up));                      break;                  case Key.Down:                      e.Handled = HandleHistoryNavigation(KeyInputUtil.VimKeyToKeyInput(VimKey.Down));                      break;                  case Key.Home:                      if ((e.KeyboardDevice.Modifiers & ModifierKeys.Shift) == 0)                      {                          _margin.UpdateCaretPosition(EditPosition.Start);                          e.Handled = true;                      }                      break;                  case Key.End:                      if ((e.KeyboardDevice.Modifiers & ModifierKeys.Shift) == 0)                      {                          _margin.UpdateCaretPosition(EditPosition.End);                          e.Handled = true;                      }                      break;                  case Key.Left:                      // Ignore left arrow if at start position                      e.Handled = _margin.IsCaretAtStart();                      break;                  case Key.Back:                      // Backspacing past the beginning aborts the command/search.                      if (_margin.CommandLineTextBox.Text.Length <= 1)                      {                          _vimBuffer.Process(KeyInputUtil.EscapeKey);                          ChangeEditKind(EditKind.None);                          e.Handled = true;                      }                      else if (_margin.CommandLineTextBox.CaretIndex == 1)                      {                          // don't let the caret get behind the initial character                          e.Handled = true;                      }                      break;                  case Key.Tab:                      InsertIntoCommandLine("\t"' putCaretAfter: true);                      var commandText = _margin.CommandLineTextBox.Text;                      UpdateVimBufferStateWithCommandText(commandText);                      e.Handled = true;                      break;                  case Key.R:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          // During edits we are responsible for handling the command line.  Need to                           // put a " into the box at the edit position                          _pasteWaitMemo.Set(_margin.CommandLineTextBox);                          InsertIntoCommandLine("\""' putCaretAfter: false);                            // Now move the buffer into paste wait                           _vimBuffer.Process(KeyInputUtil.ApplyKeyModifiersToChar('r'' VimKeyModifiers.Control));                          e.Handled = true;                      }                      break;                  case Key.U:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          var textBox = _margin.CommandLineTextBox;                          if(textBox.SelectionStart > 1)                          {                              var text = textBox.Text.Substring(textBox.SelectionStart);                              textBox.Text = text;                                                            UpdateVimBufferStateWithCommandText(text);                              textBox.Select(1' 0);                          }                          e.Handled = true;                      }                      break;                  case Key.W:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          DeleteWordBeforeCursor();                          e.Handled = true;                      }                      break;                  case Key.P:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          e.Handled = HandleHistoryNavigation(KeyInputUtil.ApplyKeyModifiersToChar('p'' VimKeyModifiers.Control));                      }                      break;                  case Key.N:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          e.Handled = HandleHistoryNavigation(KeyInputUtil.ApplyKeyModifiersToChar('n'' VimKeyModifiers.Control));                      }                      break;                  case Key.D6:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          ToggleLanguage();                          e.Handled = true;                      }                      break;              }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleCharEvent,The following switch statement is missing a default case: switch (textChar)                  {                      case (char)0x1B: // <C-[>                          _vimBuffer.Process(KeyInputUtil.EscapeKey);                          ChangeEditKind(EditKind.None);                          e.Handled = true;                          break;                      case (char)0x1D: // <C-]>                          _vimBuffer.Process(KeyNotationUtil.StringToKeyInput("<C-]>"));                          ChangeEditKind(EditKind.None);                          e.Handled = true;                          break;                      case (char)0x1E: // <C-^>                          ToggleLanguage();                          e.Handled = true;                          break;                  }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,CheckEnableCommandLineEdit,The following switch statement is missing a default case: switch (args.KeyInput.Key)              {                  case VimKey.Home:                      // Enable command line edition                      ChangeEditKind(commandLineEditKind);                      _margin.UpdateCaretPosition(EditPosition.Start);                      args.Handled = true;                      break;                  case VimKey.Left:                      ChangeEditKind(commandLineEditKind);                      _margin.UpdateCaretPosition(EditPosition.BeforeLastCharacter);                      args.Handled = true;                      break;                  case VimKey.Up:                  case VimKey.Down:                      // User is navigation through history' move caret to the end of the entry                      _margin.UpdateCaretPosition(EditPosition.End);                      break;              }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginController,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginController.cs,HandleKeyEventInPasteWait,The following switch statement is missing a default case: switch (e.Key)              {                 case Key.R:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          e.Handled = true; // remain in paste-wait state                      }                     break;                  case Key.A:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          e.Handled = HandlePasteSpecial(KeyInputUtil.ApplyKeyModifiersToChar('a'' VimKeyModifiers.Control)' WordKind.BigWord);                      }                      break;                  case Key.W:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          e.Handled = HandlePasteSpecial(KeyInputUtil.ApplyKeyModifiersToChar('w'' VimKeyModifiers.Control)' WordKind.NormalWord);                      }                      break;                  case Key.J:                  case Key.M:                      if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)                      {                          CancelPasteWait();                          e.Handled = true;                      }                      break;                  case Key.Escape:                  case Key.Enter:                  case Key.Left:                  case Key.Right:                  case Key.Back:                  case Key.Delete:                      CancelPasteWait();                      e.Handled = true;                      break;              }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetShowCommandText,The following switch statement is missing a default case: switch (vimBuffer.ModeKind)              {                  case ModeKind.Normal:                      return GetNormalModeShowCommandText(vimBuffer);                  case ModeKind.SelectBlock:                      return GetVisualModeShowCommandText(vimBuffer' vimBuffer.VisualBlockMode);                  case ModeKind.SelectCharacter:                      return GetVisualModeShowCommandText(vimBuffer' vimBuffer.VisualCharacterMode);                  case ModeKind.SelectLine:                      return GetVisualModeShowCommandText(vimBuffer' vimBuffer.VisualLineMode);                  case ModeKind.VisualCharacter:                  case ModeKind.VisualBlock:                  case ModeKind.VisualLine:                      return GetVisualModeShowCommandText(vimBuffer' (IVisualMode) vimBuffer.Mode);              }
Missing Default,Vim.UI.Wpf.Implementation.CommandMargin,CommandMarginUtil,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\CommandMargin\CommandMarginUtil.cs,GetVisualModeShowCommandText,The following switch statement is missing a default case: switch (visualSpan.VisualKind.VisualModeKind)              {                  case ModeKind.VisualLine:                      return visualSpan.LineRange.Count.ToString();                  case ModeKind.VisualCharacter:                      if (visualSpan.LineRange.Count > 1)                      {                          return visualSpan.LineRange.Count.ToString();                      }                                var charSpan = visualSpan.Spans.First();                      // account for the selection possibly extending past the last printable character in the line to include some or all of a multi-character newline                      var line = charSpan.Snapshot.GetLineFromPosition(charSpan.Start);                      if (charSpan.End.Position > line.End)                      {                          return (line.End - charSpan.Start + 1).ToString();                      }                        return charSpan.Length.ToString();                  case ModeKind.VisualBlock:                      return $"{visualSpan.LineRange.Count}x{visualSpan.Spans.Max(x => x.Length)}";              }
Missing Default,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,PreprocessMouseDown,The following switch statement is missing a default case: switch (e.ChangedButton)              {                  case MouseButton.Left:                      e.Handled = TryProcess(VimKey.LeftMouse' e.ClickCount);                      if (e.Handled)                      {                          CaptureMouse();                      }                      break;                  case MouseButton.Middle:                      e.Handled = TryProcess(VimKey.MiddleMouse' e.ClickCount);                      break;                  case MouseButton.Right:                      e.Handled = TryProcess(VimKey.RightMouse' e.ClickCount);                      break;                  case MouseButton.XButton1:                      e.Handled = TryProcess(VimKey.X1Mouse' e.ClickCount);                      break;                  case MouseButton.XButton2:                      e.Handled = TryProcess(VimKey.X2Mouse' e.ClickCount);                      break;              }
Missing Default,Vim.UI.Wpf.Implementation.Mouse,VimMouseProcessor,D:\research\architectureSmells\repos\jaredpar_VsVim\Src\VimWpf\Implementation\Mouse\VimMouseProcessor.cs,PreprocessMouseUp,The following switch statement is missing a default case: switch (e.ChangedButton)              {                  case MouseButton.Left:                      e.Handled = TryProcess(VimKey.LeftRelease);                      CheckReleaseMouseCapture();                      break;                  case MouseButton.Middle:                      e.Handled = TryProcess(VimKey.MiddleRelease);                      break;                  case MouseButton.Right:                      e.Handled = TryProcess(VimKey.RightRelease);                      break;                  case MouseButton.XButton1:                      e.Handled = TryProcess(VimKey.X1Release);                      break;                  case MouseButton.XButton2:                      e.Handled = TryProcess(VimKey.X2Release);                      break;              }
