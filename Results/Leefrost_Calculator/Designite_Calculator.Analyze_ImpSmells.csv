Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Calculator.Analyze.Expression,InputMathExpressionItem,C:\repos\Leefrost_Calculator\Calculator.Analyze\Expression\InputMathExpressionItem.cs,InputMathExpressionItem,Cyclomatic complexity of the method is 11
Complex Method,Calculator.Analyze.Expression,RpnExpressionItem,C:\repos\Leefrost_Calculator\Calculator.Analyze\Expression\RpnExpression.cs,RpnExpressionItem,Cyclomatic complexity of the method is 10
Complex Method,Calculator.Analyze.Expression,InputMathExpression,C:\repos\Leefrost_Calculator\Calculator.Analyze\Expression\InputMathExpression.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Calculator.Analyze.Helpers,OperationSequenceItem,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequenceItem.cs,OperationSequenceItem,Cyclomatic complexity of the method is 9
Complex Method,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushPartitionSymbol,Cyclomatic complexity of the method is 18
Complex Method,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushOperation,Cyclomatic complexity of the method is 13
Complex Method,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushComplexOperatorNonFirstSignature,Cyclomatic complexity of the method is 9
Complex Method,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,Cyclomatic complexity of the method is 20
Complex Method,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,Cyclomatic complexity of the method is 18
Complex Method,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,IsRpmExpression,Cyclomatic complexity of the method is 10
Complex Method,Calculator.Analyze.Tools,RpnExpressionSimplificator,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\RpnExpressionSimplificator.cs,OptimazeExpression,Cyclomatic complexity of the method is 15
Complex Method,Calculator.Analyze.Tools,Parser,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\Parser.cs,ParseInput,Cyclomatic complexity of the method is 24
Long Statement,Calculator.Analyze.Expression,RpnExpressionItem,C:\repos\Leefrost_Calculator\Calculator.Analyze\Expression\RpnExpression.cs,ToString,The length of the statement  "	return String.Format ("{0} {1}"' ItemKind' ItemKind == RpmExpressionItemKind.Constant ? Constant.ToString (CultureInfo.InvariantCulture) : ItemKind == RpmExpressionItemKind.Operation ? OperationName : VaribleName); " is 214.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushPartitionSymbol,The length of the statement  "		_stack.Add (new OperationSequenceItem (OperationSequenceItemKind.Partition' InputMathPartitionSymbolKind.OpenBrace' pos)); " is 122.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushPartitionSymbol,The length of the statement  "			if ((_stack [j].OperationSequenceItemKind == OperationSequenceItemKind.Partition) && (_stack [j].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) { " is 171.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushPartitionSymbol,The length of the statement  "			if ((_stack [_stack.Count - 1].OperationSequenceItemKind == OperationSequenceItemKind.Operation) && (_registered.GetOperationByName (_stack [_stack.Count - 1].OperationName).KindOfOperation == OperationKind.Function)) { " is 219.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushPartitionSymbol,The length of the statement  "			if ((_stack [j].OperationSequenceItemKind == OperationSequenceItemKind.Partition) && (_stack [j].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) { " is 171.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushUnaryOperator,The length of the statement  "	PushOperation (operation' new OperationSequenceItem (OperationSequenceItemKind.Operation' operation.OperationName' pos)' pos); " is 126.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushBinaryOperator,The length of the statement  "	PushOperation (operation' new OperationSequenceItem (OperationSequenceItemKind.Operation' operation.OperationName' pos)' pos); " is 126.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,PushComplexOperatorNonFirstSignature,The length of the statement  "		if (_stack [j].OperationSequenceItemKind == OperationSequenceItemKind.PartialSignature && _stack [j].PartialSignature.OperationName == operation.OperationName && _stack [j].PartialSignature.SignatureNumber == pathNumber - 1) { " is 226.
Long Statement,Calculator.Analyze.Helpers,OperationSequence,C:\repos\Leefrost_Calculator\Calculator.Analyze\Helpers\OperationSequence.cs,Flush,The length of the statement  "			_resList.Add (new RpnExpressionItem (RpmExpressionItemKind.Operation' _stack [element].OperationName' _stack [element].Position)); " is 130.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "			throw new InvalidOperationException (String.Format ("Could not load '{0}' configuration resource from assembly."' documentPath)); " is 129.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "		XmlNodeList prioritiesNodeList = document.SelectNodes ("main:operations/main:priorities/main:priority"' namespaceManager); " is 122.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "			OperationPriority priorityAssociation = (priorityNode.Attributes ["association"].Value == "left") ? OperationPriority.LeftAssociated : OperationPriority.RightAssociated; " is 169.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "		XmlNodeList operationsNodeList = document.SelectNodes ("main:operations/main:operations/main:operation"' namespaceManager); " is 123.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "			OperationKind operationKind = (operationNode.Attributes ["kind"].Value == "operator") ? OperationKind.Operator : OperationKind.Function; " is 136.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "				signaturesOrderedList.Add (new SerializedSignature (signatureNode.Attributes ["value"].Value' Int32.Parse (signatureNode.Attributes ["number"].Value))); " is 152.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "				_opreationList.Add (new MathOperation (operationName' OperationKind.Operator' operationPriority' operationSignatures' operationOperandsCount' operationCalculator)); " is 164.
Long Statement,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The length of the statement  "				_opreationList.Add (new MathOperation (operationName' OperationKind.Function' operationSignatures' operationOperandsCount' operationCalculator)); " is 145.
Long Statement,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The length of the statement  "			_operationSequence.PushPartitionSymbol (preparedExpressionItem.InputMathPartitionSymbolKind' preparedExpressionItem.Position); " is 126.
Long Statement,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The length of the statement  "						if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) { " is 225.
Long Statement,Calculator.Analyze.Tools,RpnExpressionSimplificator,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\RpnExpressionSimplificator.cs,OptimazeExpression,The length of the statement  "				optimizedExpression.Add (new RpnExpressionItem (RpmExpressionItemKind.Constant' operation.CalculatorFunction.Compture (arguments)' item.Position)); " is 147.
Long Statement,Calculator.Analyze.Tools,Parser,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\Parser.cs,ParseInput,The length of the statement  "						getInputMath = new InputMathExpressionItem (InputMathExpressionItemKind.Signature' input.Substring (i' lens [j])' i + 1); " is 121.
Long Statement,Calculator.Analyze.Tools,Parser,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\Parser.cs,CheckFor2Operators,The length of the statement  "		if (now.ItemKind == InputMathExpressionItemKind.Signature && item [i + 1].ItemKind == InputMathExpressionItemKind.Signature) { " is 126.
Complex Conditional,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The conditional expression  "(item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)"  is complex.
Magic Number,Calculator.Analyze.Expression,RpnExpression,C:\repos\Leefrost_Calculator\Calculator.Analyze\Expression\RpnExpression.cs,RpnExpression,The following statement contains a magic number: if (items.Count > 30) {  	throw new BasicError<WrongTotalOperatorsAndNumbersArgs> (new WrongTotalOperatorsAndNumbersArgs ());  }  
Magic Number,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The following statement contains a magic number: using (Stream stream = assembly.GetManifestResourceStream (assemblyName.Name + "." + documentPath)) {  	if (stream == null)  		throw new InvalidOperationException (String.Format ("Could not load '{0}' configuration resource from assembly."' documentPath));  	//  	var document = new XmlDocument ();  	document.Load (stream);  	// Validating schema  	XmlSchema schema;  	using (Stream streamSchema = assembly.GetManifestResourceStream (assemblyName.Name + "." + schemaPath)) {  		if (streamSchema == null)  			throw new InvalidOperationException ("Could not load schema resource from assembly.");  		schema = XmlSchema.Read (streamSchema' ValidationSchema);  	}  	document.Schemas.Add (schema);  	document.Validate (DocumentValidation);  	var namespaceManager = new XmlNamespaceManager (document.NameTable);  	namespaceManager.AddNamespace ("main"' schema.TargetNamespace);  	XmlNodeList prioritiesNodeList = document.SelectNodes ("main:operations/main:priorities/main:priority"' namespaceManager);  	if (prioritiesNodeList == null)  		throw new InvalidOperationException ("Could not load priorities from configuration.");  	//  	foreach (XmlNode priorityNode in prioritiesNodeList) {  		int priorityValue = Convert.ToInt32 (priorityNode.Attributes ["value"].Value);  		OperationPriority priorityAssociation = (priorityNode.Attributes ["association"].Value == "left") ? OperationPriority.LeftAssociated : OperationPriority.RightAssociated;  		_priorityDictionary.Add (priorityValue' priorityAssociation);  	}  	XmlNodeList operationsNodeList = document.SelectNodes ("main:operations/main:operations/main:operation"' namespaceManager);  	if (operationsNodeList == null)  		throw new InvalidOperationException ("Could not load operations from configuration.");  	//  	foreach (XmlNode operationNode in operationsNodeList) {  		string operationName = operationNode.Attributes ["name"].Value;  		int operationOperandsCount = Convert.ToInt32 (operationNode.Attributes ["operands"].Value);  		OperationKind operationKind = (operationNode.Attributes ["kind"].Value == "operator") ? OperationKind.Operator : OperationKind.Function;  		int operationPriority;  		if (operationKind == OperationKind.Operator)  			operationPriority = Convert.ToInt32 (operationNode.Attributes ["priority"].Value);  		else  			operationPriority = 0;  		//  		var signaturesOrderedList = new List<SerializedSignature> ();  		XmlNode signaturesNode = operationNode ["signatures"];  		if (signaturesNode == null)  			throw new InvalidOperationException ("No signatures found during parsing operation.");  		foreach (XmlNode signatureNode in signaturesNode.ChildNodes) {  			signaturesOrderedList.Add (new SerializedSignature (signatureNode.Attributes ["value"].Value' Int32.Parse (signatureNode.Attributes ["number"].Value)));  		}  		signaturesOrderedList.Sort (SerializedSignature.Compare);  		var operationSignatures = new string[signaturesOrderedList.Count];  		for (int i = 0; i < signaturesOrderedList.Count; i++)  			operationSignatures [i] = signaturesOrderedList [i].Signature;  		//  		XmlNode calculatorNode = operationNode ["calculator"];  		if (calculatorNode == null)  			throw new InvalidOperationException ("No calculator specified.");  		string calculatorType = calculatorNode.Attributes ["type"].Value;  		if (String.IsNullOrEmpty (calculatorType))  			throw new InvalidOperationException ("Empty calculator type string.");  		string[] calculatorTypeParts = calculatorType.Split (''');  		if (calculatorTypeParts.Length != 2)  			throw new InvalidOperationException ("Invalid type declarations syntax.");  		string calculatorTypeName = calculatorTypeParts [0];  		string calculatorAssemblyName = calculatorTypeParts [1];  		//  		Assembly calculatorAssembly = Assembly.Load (calculatorAssemblyName);  		var operationCalculator = (IOperationCalculatorFunction)calculatorAssembly.CreateInstance (calculatorTypeName' false);  		//  		if (operationKind == OperationKind.Operator)  			_opreationList.Add (new MathOperation (operationName' OperationKind.Operator' operationPriority' operationSignatures' operationOperandsCount' operationCalculator));  		else {  			_opreationList.Add (new MathOperation (operationName' OperationKind.Function' operationSignatures' operationOperandsCount' operationCalculator));  		}  	}  }  
Magic Number,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The following statement contains a magic number: foreach (XmlNode operationNode in operationsNodeList) {  	string operationName = operationNode.Attributes ["name"].Value;  	int operationOperandsCount = Convert.ToInt32 (operationNode.Attributes ["operands"].Value);  	OperationKind operationKind = (operationNode.Attributes ["kind"].Value == "operator") ? OperationKind.Operator : OperationKind.Function;  	int operationPriority;  	if (operationKind == OperationKind.Operator)  		operationPriority = Convert.ToInt32 (operationNode.Attributes ["priority"].Value);  	else  		operationPriority = 0;  	//  	var signaturesOrderedList = new List<SerializedSignature> ();  	XmlNode signaturesNode = operationNode ["signatures"];  	if (signaturesNode == null)  		throw new InvalidOperationException ("No signatures found during parsing operation.");  	foreach (XmlNode signatureNode in signaturesNode.ChildNodes) {  		signaturesOrderedList.Add (new SerializedSignature (signatureNode.Attributes ["value"].Value' Int32.Parse (signatureNode.Attributes ["number"].Value)));  	}  	signaturesOrderedList.Sort (SerializedSignature.Compare);  	var operationSignatures = new string[signaturesOrderedList.Count];  	for (int i = 0; i < signaturesOrderedList.Count; i++)  		operationSignatures [i] = signaturesOrderedList [i].Signature;  	//  	XmlNode calculatorNode = operationNode ["calculator"];  	if (calculatorNode == null)  		throw new InvalidOperationException ("No calculator specified.");  	string calculatorType = calculatorNode.Attributes ["type"].Value;  	if (String.IsNullOrEmpty (calculatorType))  		throw new InvalidOperationException ("Empty calculator type string.");  	string[] calculatorTypeParts = calculatorType.Split (''');  	if (calculatorTypeParts.Length != 2)  		throw new InvalidOperationException ("Invalid type declarations syntax.");  	string calculatorTypeName = calculatorTypeParts [0];  	string calculatorAssemblyName = calculatorTypeParts [1];  	//  	Assembly calculatorAssembly = Assembly.Load (calculatorAssemblyName);  	var operationCalculator = (IOperationCalculatorFunction)calculatorAssembly.CreateInstance (calculatorTypeName' false);  	//  	if (operationKind == OperationKind.Operator)  		_opreationList.Add (new MathOperation (operationName' OperationKind.Operator' operationPriority' operationSignatures' operationOperandsCount' operationCalculator));  	else {  		_opreationList.Add (new MathOperation (operationName' OperationKind.Function' operationSignatures' operationOperandsCount' operationCalculator));  	}  }  
Magic Number,Calculator.Analyze,RegisteredOperation,C:\repos\Leefrost_Calculator\Calculator.Analyze\RegisteredOperation.cs,InitializeFromConfigurationXml,The following statement contains a magic number: if (calculatorTypeParts.Length != 2)  	throw new InvalidOperationException ("Invalid type declarations syntax.");  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: for (var item = 0; item < expression.Items.Count; item++) {  	var preparedExpressionItem = expression.Items [item];  	// constant and varibles can be add into result without preparation  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Constant) {  		_operationSequence.PushConstantValue (preparedExpressionItem.Constant' preparedExpressionItem.Position);  	}  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Varible) {  		_operationSequence.PushVaribleItem (preparedExpressionItem.Name' preparedExpressionItem.Position);  	}  	//Partition symbols send into result where result sequence will use it  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.PartitionSymbol) {  		_operationSequence.PushPartitionSymbol (preparedExpressionItem.InputMathPartitionSymbolKind' preparedExpressionItem.Position);  	}  	//Operation signatures must be prepared to solving equation  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Signature) {  		var operations = new List<MathOperation> (_registered.GetOperationUsingSignature (preparedExpressionItem.Signature));  		operations.Sort (ComparebyOperandCount);  		foreach (var operation in operations) {  			//  			if (operation.KindOfOperation == OperationKind.Operator) {  				//todo operation excretion while solving  				//if operation has 1 operand  				if (operation.CountOfOperand == 1) {  					if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  						_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  						break;  					}  				}  				// operation with 2 operand - + * /  				if (operation.CountOfOperand == 2) {  					_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  					break;  				}  				//more  				if (operation.CountOfOperand > 2) {  					var partNumber = 0;  					for (var k = 0; k < operation.OperationSignature.Length; k++) {  						if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  							partNumber = k + 1;  							break;  						}  					}  					if (partNumber == 1) {  						_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  						break;  					}  					_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  					break;  				}  			}  			// such as sin or cos  			if (operation.KindOfOperation == OperationKind.Function) {  				_operationSequence.PushFunction (operation' preparedExpressionItem.Position);  				break;  			}  		}  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: for (var item = 0; item < expression.Items.Count; item++) {  	var preparedExpressionItem = expression.Items [item];  	// constant and varibles can be add into result without preparation  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Constant) {  		_operationSequence.PushConstantValue (preparedExpressionItem.Constant' preparedExpressionItem.Position);  	}  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Varible) {  		_operationSequence.PushVaribleItem (preparedExpressionItem.Name' preparedExpressionItem.Position);  	}  	//Partition symbols send into result where result sequence will use it  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.PartitionSymbol) {  		_operationSequence.PushPartitionSymbol (preparedExpressionItem.InputMathPartitionSymbolKind' preparedExpressionItem.Position);  	}  	//Operation signatures must be prepared to solving equation  	if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Signature) {  		var operations = new List<MathOperation> (_registered.GetOperationUsingSignature (preparedExpressionItem.Signature));  		operations.Sort (ComparebyOperandCount);  		foreach (var operation in operations) {  			//  			if (operation.KindOfOperation == OperationKind.Operator) {  				//todo operation excretion while solving  				//if operation has 1 operand  				if (operation.CountOfOperand == 1) {  					if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  						_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  						break;  					}  				}  				// operation with 2 operand - + * /  				if (operation.CountOfOperand == 2) {  					_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  					break;  				}  				//more  				if (operation.CountOfOperand > 2) {  					var partNumber = 0;  					for (var k = 0; k < operation.OperationSignature.Length; k++) {  						if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  							partNumber = k + 1;  							break;  						}  					}  					if (partNumber == 1) {  						_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  						break;  					}  					_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  					break;  				}  			}  			// such as sin or cos  			if (operation.KindOfOperation == OperationKind.Function) {  				_operationSequence.PushFunction (operation' preparedExpressionItem.Position);  				break;  			}  		}  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Signature) {  	var operations = new List<MathOperation> (_registered.GetOperationUsingSignature (preparedExpressionItem.Signature));  	operations.Sort (ComparebyOperandCount);  	foreach (var operation in operations) {  		//  		if (operation.KindOfOperation == OperationKind.Operator) {  			//todo operation excretion while solving  			//if operation has 1 operand  			if (operation.CountOfOperand == 1) {  				if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  					_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  					break;  				}  			}  			// operation with 2 operand - + * /  			if (operation.CountOfOperand == 2) {  				_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  				break;  			}  			//more  			if (operation.CountOfOperand > 2) {  				var partNumber = 0;  				for (var k = 0; k < operation.OperationSignature.Length; k++) {  					if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  						partNumber = k + 1;  						break;  					}  				}  				if (partNumber == 1) {  					_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  					break;  				}  				_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  				break;  			}  		}  		// such as sin or cos  		if (operation.KindOfOperation == OperationKind.Function) {  			_operationSequence.PushFunction (operation' preparedExpressionItem.Position);  			break;  		}  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: if (preparedExpressionItem.ItemKind == InputMathExpressionItemKind.Signature) {  	var operations = new List<MathOperation> (_registered.GetOperationUsingSignature (preparedExpressionItem.Signature));  	operations.Sort (ComparebyOperandCount);  	foreach (var operation in operations) {  		//  		if (operation.KindOfOperation == OperationKind.Operator) {  			//todo operation excretion while solving  			//if operation has 1 operand  			if (operation.CountOfOperand == 1) {  				if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  					_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  					break;  				}  			}  			// operation with 2 operand - + * /  			if (operation.CountOfOperand == 2) {  				_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  				break;  			}  			//more  			if (operation.CountOfOperand > 2) {  				var partNumber = 0;  				for (var k = 0; k < operation.OperationSignature.Length; k++) {  					if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  						partNumber = k + 1;  						break;  					}  				}  				if (partNumber == 1) {  					_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  					break;  				}  				_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  				break;  			}  		}  		// such as sin or cos  		if (operation.KindOfOperation == OperationKind.Function) {  			_operationSequence.PushFunction (operation' preparedExpressionItem.Position);  			break;  		}  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: foreach (var operation in operations) {  	//  	if (operation.KindOfOperation == OperationKind.Operator) {  		//todo operation excretion while solving  		//if operation has 1 operand  		if (operation.CountOfOperand == 1) {  			if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  				_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  				break;  			}  		}  		// operation with 2 operand - + * /  		if (operation.CountOfOperand == 2) {  			_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  			break;  		}  		//more  		if (operation.CountOfOperand > 2) {  			var partNumber = 0;  			for (var k = 0; k < operation.OperationSignature.Length; k++) {  				if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  					partNumber = k + 1;  					break;  				}  			}  			if (partNumber == 1) {  				_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  				break;  			}  			_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  			break;  		}  	}  	// such as sin or cos  	if (operation.KindOfOperation == OperationKind.Function) {  		_operationSequence.PushFunction (operation' preparedExpressionItem.Position);  		break;  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: foreach (var operation in operations) {  	//  	if (operation.KindOfOperation == OperationKind.Operator) {  		//todo operation excretion while solving  		//if operation has 1 operand  		if (operation.CountOfOperand == 1) {  			if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  				_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  				break;  			}  		}  		// operation with 2 operand - + * /  		if (operation.CountOfOperand == 2) {  			_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  			break;  		}  		//more  		if (operation.CountOfOperand > 2) {  			var partNumber = 0;  			for (var k = 0; k < operation.OperationSignature.Length; k++) {  				if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  					partNumber = k + 1;  					break;  				}  			}  			if (partNumber == 1) {  				_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  				break;  			}  			_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  			break;  		}  	}  	// such as sin or cos  	if (operation.KindOfOperation == OperationKind.Function) {  		_operationSequence.PushFunction (operation' preparedExpressionItem.Position);  		break;  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: if (operation.KindOfOperation == OperationKind.Operator) {  	//todo operation excretion while solving  	//if operation has 1 operand  	if (operation.CountOfOperand == 1) {  		if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  			_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  			break;  		}  	}  	// operation with 2 operand - + * /  	if (operation.CountOfOperand == 2) {  		_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  		break;  	}  	//more  	if (operation.CountOfOperand > 2) {  		var partNumber = 0;  		for (var k = 0; k < operation.OperationSignature.Length; k++) {  			if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  				partNumber = k + 1;  				break;  			}  		}  		if (partNumber == 1) {  			_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  			break;  		}  		_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  		break;  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: if (operation.KindOfOperation == OperationKind.Operator) {  	//todo operation excretion while solving  	//if operation has 1 operand  	if (operation.CountOfOperand == 1) {  		if ((item == 0) || (item > 0) && (expression.Items [item - 1].ItemKind == InputMathExpressionItemKind.PartitionSymbol) && (expression.Items [item - 1].InputMathPartitionSymbolKind == InputMathPartitionSymbolKind.OpenBrace)) {  			_operationSequence.PushUnaryOperator (operation' preparedExpressionItem.Position);  			break;  		}  	}  	// operation with 2 operand - + * /  	if (operation.CountOfOperand == 2) {  		_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  		break;  	}  	//more  	if (operation.CountOfOperand > 2) {  		var partNumber = 0;  		for (var k = 0; k < operation.OperationSignature.Length; k++) {  			if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  				partNumber = k + 1;  				break;  			}  		}  		if (partNumber == 1) {  			_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  			break;  		}  		_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  		break;  	}  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: if (operation.CountOfOperand == 2) {  	_operationSequence.PushBinaryOperator (operation' preparedExpressionItem.Position);  	break;  }  
Magic Number,Calculator.Analyze.Tools,MathExpressionToRpnConverter,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\MathExpressionToRpnConverter.cs,ConvertToRpn,The following statement contains a magic number: if (operation.CountOfOperand > 2) {  	var partNumber = 0;  	for (var k = 0; k < operation.OperationSignature.Length; k++) {  		if (operation.OperationSignature [k] == preparedExpressionItem.Signature) {  			partNumber = k + 1;  			break;  		}  	}  	if (partNumber == 1) {  		_operationSequence.PushComplexOperatorFirstSignature (operation' preparedExpressionItem.Position);  		break;  	}  	_operationSequence.PushComplexOperatorNonFirstSignature (operation' partNumber' preparedExpressionItem.Position);  	break;  }  
Magic Number,Calculator.Analyze.Tools,Parser,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\Parser.cs,ParseInput,The following statement contains a magic number: if (input.Length > 65536) {  	throw new BasicError<TooLongExpressionArgs> (new TooLongExpressionArgs ());  }  
Missing Default,Calculator.Analyze.Tools,Parser,C:\repos\Leefrost_Calculator\Calculator.Analyze\Tools\Parser.cs,ParseInput,The following switch statement is missing a default case: switch (input [i]) {  case '(': {  	delimiterKind = InputMathPartitionSymbolKind.OpenBrace;  	break;  }  case ')': {  	delimiterKind = InputMathPartitionSymbolKind.CloseBrace;  	break;  }  case ''': {  	delimiterKind = InputMathPartitionSymbolKind.Another;  	break;  }  }  
