Implementation smell,Namespace,Class,File,Method,Description
Long Method,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The method has 100 lines of code.
Long Method,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The method has 176 lines of code.
Complex Method,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,Cyclomatic complexity of the method is 24
Complex Method,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCache,Cyclomatic complexity of the method is 8
Complex Method,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,NewTick,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,NewTick,Cyclomatic complexity of the method is 9
Complex Method,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,Cyclomatic complexity of the method is 9
Complex Method,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,Cyclomatic complexity of the method is 42
Complex Method,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,ContractToSecurityFullName,Cyclomatic complexity of the method is 8
Complex Method,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,newPoint,Cyclomatic complexity of the method is 12
Complex Method,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,Cyclomatic complexity of the method is 37
Complex Method,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Adjust,Cyclomatic complexity of the method is 11
Complex Method,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,TickArchiver,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickArchiver.cs,newTick,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,TickWatcher,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickWatcher.cs,newTick,Cyclomatic complexity of the method is 12
Complex Method,TradingBase,TickWatcher,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickWatcher.cs,_bw_DoWork,Cyclomatic complexity of the method is 11
Complex Method,TradingBase,EnumDescConverter,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\EnumDescConverter.cs,GetEnumValue,Cyclomatic complexity of the method is 8
Complex Method,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,Cyclomatic complexity of the method is 12
Complex Method,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,Adjust,Cyclomatic complexity of the method is 9
Complex Method,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,GmailAccount,Cyclomatic complexity of the method is 8
Long Parameter List,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,Bar,The method has 9 parameters.
Long Parameter List,TradingBase,BarIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarIntervalData.cs,NewPoint,The method has 5 parameters.
Long Parameter List,TradingBase,BarRequest,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarRequest.cs,BarRequest,The method has 7 parameters.
Long Parameter List,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,NewPoint,The method has 5 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updatePortfolio,The method has 8 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The method has 6 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The method has 7 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The method has 10 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickEFP,The method has 9 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickOptionComputation,The method has 10 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,accountSummary,The method has 5 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,orderStatus,The method has 10 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,realtimeBar,The method has 9 parameters.
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,scannerData,The method has 7 parameters.
Long Parameter List,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Order,The method has 6 parameters.
Long Parameter List,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Order,The method has 9 parameters.
Long Parameter List,TradingBase,MarketOrderFlat,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,MarketOrderFlat,The method has 5 parameters.
Long Parameter List,TradingBase,StopLimitOrder,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,StopLimitOrder,The method has 5 parameters.
Long Parameter List,TradingBase,TrailingStopLimitOrder,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,TrailingStopLimitOrder,The method has 5 parameters.
Long Parameter List,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Position,The method has 5 parameters.
Long Parameter List,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,NewTrade,The method has 5 parameters.
Long Parameter List,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Trade,The method has 5 parameters.
Long Parameter List,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionProfit,The method has 5 parameters.
Long Parameter List,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionStop,The method has 5 parameters.
Long Parameter List,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,Log,The method has 5 parameters.
Long Parameter List,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,OffsetInfo,The method has 6 parameters.
Long Statement,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The length of the statement  "	if ((first.FullSymbol != second.FullSymbol) || (first.OrderSide != second.OrderSide) || !first.IsLimit || !second.IsLimit) " is 122.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,Play,The length of the statement  "			Debug ("optimize " + id + " finished.  Used: " + value + " -> " + OptimizeDecisionsName + ": " + rv + " trades: " + trades.Count + " SimsRemaining: " + OptimizeRemain); " is 168.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,ChangeValue,The length of the statement  "		Debug ("error setting parameter " + OptimizeName + " on strategy: " + s.FullName + " to: " + v + " err: " + ex.Message + ex.StackTrace); " is 136.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,GetResult,The length of the statement  "		Debug ("error getting result from OptimizeDecision name: " + OptimizeDecisionsName + " err: " + ex.Message + ex.StackTrace); " is 124.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,DeepClone,The length of the statement  "		System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bf = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter (); " is 138.
Long Statement,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,GetBar,The length of the statement  "	b = new Bar (opens [index]' highs [index]' lows [index]' closes [index]' vols [index]' dates [index]' orders [index]' symbol' intervallength); " is 142.
Long Statement,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestMarketData,The length of the statement  "		var task = Task.Factory.StartNew (() => GetQuoteLoop (cancellationtoken)' cancellationtoken' TaskCreationOptions.LongRunning' TaskScheduler.Default).ContinueWith (antecendent =>  { " is 180.
Long Statement,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The length of the statement  "				//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time " is 128.
Long Statement,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The length of the statement  "	_ibSocket.reqHistoricalData (_historicalBarRequests.Count - 1' contract' enddatetimestring' durationstring' barSize' "TRADES"' useReguarTradingHour' 1); " is 152.
Long Statement,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,openOrder,The length of the statement  "	o.LimitPrice = ((order.OrderType == "LMT") || (order.OrderType == "TRAIL LIMIT") || (order.OrderType == "STP LMT")) ? (decimal)order.LmtPrice : 0m; " is 147.
Long Statement,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The length of the statement  "	Bar bar = new Bar ((decimal)open' (decimal)high' (decimal)low' (decimal)close' volume' ndate' ntime' _historicalBarRequests [reqId].FullSymbol' _historicalBarRequests [reqId].Interval); " is 185.
Long Statement,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,newPoint,The length of the statement  "		D (symbol + " enforcing trail with: " + flat.ToString () + " esize: " + esize [symbol] + " count: " + firecount [symbol]); " is 122.
Long Statement,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,Adjust,The length of the statement  "			v (fill.FullSymbol + " trail partial fill: " + fill.ToString () + " e: " + esize [fill.FullSymbol] + " != a: " + asize); " is 120.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The length of the statement  "					PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2")); " is 127.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The length of the statement  "			SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3); " is 187.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The length of the statement  "				SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3); " is 143.
Long Statement,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The length of the statement  "	if (decimal.TryParse (r [3]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d)) " is 126.
Long Statement,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The length of the statement  "	if (decimal.TryParse (r [5]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d)) " is 126.
Long Statement,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The length of the statement  "	if (decimal.TryParse (r [7]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d)) " is 126.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,ClosePT,The length of the statement  "		throw new Exception ("Invalid position provided. (existing:" + existing.ToString () + " adjustment:" + adjust.ToString ()); " is 123.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,ClosePL,The length of the statement  "	int closedsize = Math.Abs (adjust.TradeSize) > existing.UnsignedSize ? existing.UnsignedSize : Math.Abs (adjust.TradeSize); " is 123.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionProfit,The length of the statement  "	int size = percent == 0 ? 0 : (!normalizesize ? (int)(p.FlatSize * percent) : Calc.Norm2Min (p.FlatSize * percent' MINSIZE)); " is 125.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionStop,The length of the statement  "	int size = percent == 0 ? 0 : (!normalizesize ? (int)(p.FlatSize * percent) : Calc.Norm2Min (p.FlatSize * percent' MINSIZE)); " is 125.
Long Statement,TradingBase,EnumDescConverter,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\EnumDescConverter.cs,GetEnumDescription,The length of the statement  "	DescriptionAttribute[] attributes = (DescriptionAttribute[])fi.GetCustomAttributes (typeof(DescriptionAttribute)' false); " is 121.
Long Statement,TradingBase,EnumDescConverter,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\EnumDescConverter.cs,GetEnumValue,The length of the statement  "		DescriptionAttribute[] attributes = (DescriptionAttribute[])fi.GetCustomAttributes (typeof(DescriptionAttribute)' false); " is 121.
Long Statement,TradingBase,EnumDescConverter,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\EnumDescConverter.cs,GetEnumValue,The length of the statement  "	throw new InvalidCastException (string.Concat ("The received value "' description' " was unrecognized as an "' value.Name' " enum value.")); " is 140.
Long Statement,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,ToString,The length of the statement  "	return string.Format ("p{0}/{1:p0} s{2}/{3:p0}"' ProfitDist.ToString ("N" + decimals.ToString ())' ProfitPercent' StopDist.ToString ("N" + decimals.ToString ())' StopPercent); " is 175.
Long Statement,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,Serialize,The length of the statement  "	string m = string.Format ("{0}'{1}'{2}'{3}'{4}'{5}"' oi.ProfitDist' oi.StopDist' oi.ProfitPercent' oi.StopPercent' oi.NormalizeSize' oi.MinimumLotSize); " is 152.
Long Statement,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The length of the statement  "	if ((updatestop && off.hasStop && !CancelOnce) || (updatestop && off.hasStop && CancelOnce && !off.StopcancelPending)) { " is 120.
Long Statement,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The length of the statement  "	if ((updateprofit && off.hasProfit && AllowSimulatenousCancels) || (updateprofit && off.hasProfit && AllowSimulatenousCancels && !sentcancel)) { " is 144.
Long Statement,TradingBase,OversellProtector,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OversellProtector.cs,sendorder,The length of the statement  "		debug (o.FullSymbol + " oversell detected on pos: " + size + " order adjustment: " + osize + "->" + size + " " + o.ToString ()); " is 128.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,SecurityFromFileName,The length of the statement  "		string ds = System.Text.RegularExpressions.Regex.Match (filename' "([0-9]{8})[.]"' System.Text.RegularExpressions.RegexOptions.IgnoreCase).Result ("$1"); " is 153.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,DateFromFileName,The length of the statement  "		string ds = System.Text.RegularExpressions.Regex.Match (filename' "([0-9]{8})[.]"' System.Text.RegularExpressions.RegexOptions.IgnoreCase).Result ("$1"); " is 153.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,isTickFile,The length of the statement  "	return System.Text.RegularExpressions.Regex.IsMatch (path' "TXT"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 122.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,isStrategyFile,The length of the statement  "	return System.Text.RegularExpressions.Regex.IsMatch (path' "DLL"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 122.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,loadFile,The length of the statement  "	System.IO.FileStream fs = new System.IO.FileStream (filename' System.IO.FileMode.Open' System.IO.FileAccess.Read' System.IO.FileShare.ReadWrite); " is 145.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IsStrategyDLL,The length of the statement  "	return System.Text.RegularExpressions.Regex.IsMatch (path' "DLL"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 122.
Complex Conditional,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The conditional expression  "(first.FullSymbol != second.FullSymbol) || (first.OrderSide != second.OrderSide) || !first.IsLimit || !second.IsLimit"  is complex.
Complex Conditional,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The conditional expression  "(first.OrderSide && (first.LimitPrice > second.LimitPrice)) || // if first is better' use it  (!first.OrderSide && (first.LimitPrice < second.LimitPrice))"  is complex.
Complex Conditional,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The conditional expression  "(first.OrderSide && (first.LimitPrice < second.LimitPrice)) || // if second is better' use it  (!first.OrderSide && (first.LimitPrice > second.LimitPrice))"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Fill,The conditional expression  "(IsLimit && OrderSide && (p <= LimitPrice)) // buy limit  || (IsLimit && !OrderSide && (p >= LimitPrice)) // sell limit  || (IsStop && OrderSide && (p >= StopPrice)) // buy stop  || (IsStop && !OrderSide && (p <= StopPrice)) // sell stop  || IsMarket"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,FillHighLiquidityEOD,The conditional expression  "(IsLimit && OrderSide && (p <= LimitPrice)) // buy limit  || (IsLimit && !OrderSide && (p >= LimitPrice))"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,FillHighLiquidityEOD,The conditional expression  "(IsStop && OrderSide && (p >= StopPrice)) // buy stop  || (IsStop && !OrderSide && (p <= StopPrice))"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Fill,The conditional expression  "(IsLimit && OrderSide && (o.LimitPrice <= LimitPrice)) // buy limit cross  || (IsLimit && !OrderSide && (o.LimitPrice >= LimitPrice)) // sell limit cross  || (IsStop && OrderSide && (o.LimitPrice >= StopPrice)) // buy stop  || (IsStop && !OrderSide && (o.LimitPrice <= StopPrice)) // sell stop  || IsMarket"  is complex.
Complex Conditional,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,newPoint,The conditional expression  "(refp == 0) || (_pt [symbol].isLong && (refp < p)) || (_pt [symbol].isShort && (refp > p))"  is complex.
Complex Conditional,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,newPoint,The conditional expression  "!_pendingfill [idx] && (trail.StopDist != 0) && trailtest && (MaxFireCount > firecount [symbol])"  is complex.
Complex Conditional,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Adjust,The conditional expression  "(pos.isLong && this.isLong) || (!pos.isLong && !this.isLong)"  is complex.
Complex Conditional,TradingBase,TickWatcher,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickWatcher.cs,_bw_DoWork,The conditional expression  "!alltrading && !sentmissingfirstticks && (_starttime != 0) && (_lasttime > _starttime)"  is complex.
Complex Conditional,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The conditional expression  "(updatestop && off.hasStop && !CancelOnce) || (updatestop && off.hasStop && CancelOnce && !off.StopcancelPending)"  is complex.
Complex Conditional,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The conditional expression  "(updateprofit && off.hasProfit && AllowSimulatenousCancels) || (updateprofit && off.hasProfit && AllowSimulatenousCancels && !sentcancel)"  is complex.
Complex Conditional,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The conditional expression  "(!off.hasProfit && AllowSimulatenousOrders) || (!off.hasProfit && !AllowSimulatenousOrders && !sentorder)"  is complex.
Virtual Method Call from Constructor,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,BacktestEngine,The constructor "BacktestEngine" calls a virtual method "Reset".
Empty Catch Block,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,UnbindStrategy,The method has an empty catch block.
Empty Catch Block,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,AddOrder,The method has an empty catch block.
Empty Catch Block,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,TickArchiver,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickArchiver.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,TickArchiver,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickArchiver.cs,newTick,The method has an empty catch block.
Empty Catch Block,TradingBase,ConnectionTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConnectionTracker.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,setfile,The method has an empty catch block.
Empty Catch Block,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,GotDebug,The method has an empty catch block.
Empty Catch Block,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,Stop,The method has an empty catch block.
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: if (t.FullSymbol.Contains ("STK")) {  	t.BidSize *= 100;  	t.AskSize *= 100;  	t.TradeSize *= 100;  }  
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: if (t.FullSymbol.Contains ("STK")) {  	t.BidSize *= 100;  	t.AskSize *= 100;  	t.TradeSize *= 100;  }  
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: if (t.FullSymbol.Contains ("STK")) {  	t.BidSize *= 100;  	t.AskSize *= 100;  	t.TradeSize *= 100;  }  
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: t.BidSize *= 100;  
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: t.AskSize *= 100;  
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: t.TradeSize *= 100;  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: for (int idx = 0; idx < accts.Length; idx++) {  	Account a = accts [idx];  	// if account has requested no executions' skip it  	if (!a.Execute)  		continue;  	// make sure we have a record for this account  	if (!_mastertrades.ContainsKey (a.ID))  		_mastertrades.Add (a.ID' new List<Trade> ());  	// track orders being removed and trades that need notification  	List<int> notifytrade = new List<int> ();  	List<int> remove = new List<int> ();  	// go through each order in the account  	for (int i = 0; i < _masterorders [a].Count; i++) {  		Order o = _masterorders [a] [i];  		//make sure tick is for the right stock  		if (tick.FullSymbol != o.FullSymbol)  			continue;  		bool filled = false;  		if (UseHighLiquidityFillsEOD) {  			Order oi = (Order)o;  			filled = oi.FillHighLiquidityEOD (tick' _usebidaskfill' false);  		}  		else if (o.TIF <= TimeInForce.GTC) {  			filled = o.Fill (tick' _usebidaskfill' false);  			// fill our trade  		}  		else if (o.TIF == TimeInForce.OPG) {  			// if it's already opened' we missed our shot  			if (_hasopened.Contains (o.FullSymbol))  				continue;  			// otherwise make sure it's really the opening  			//if (tick.Exchange == OPGEX)  			{  				// it's the opening tick' so fill it as an opg  				filled = o.Fill (tick' _usebidaskfill' true);  				// mark this symbol as already being open  				_hasopened.Add (tick.FullSymbol);  			}  		}  		// other orders fill normally' except MOC orders which are at 4:00PM  		else if (o.TIF == TimeInForce.MOC) {  			if (tick.Time >= 160000)  				filled = o.Fill (tick' _usebidaskfill' false);  			// fill our trade  		}  		else  			filled = o.Fill (tick' _usebidaskfill' false);  		// fill our trade  		if (filled) {  			// get copy of trade for recording  			Trade trade = new Trade ((Trade)o);  			// remove filled size from size available in trade  			if (_adjustincomingticksize) {  				if (_usebidaskfill) {  					if (o.Side)  						tick.AskSize -= trade.UnsignedSize;  					else  						tick.BidSize -= trade.UnsignedSize;  				}  				else  					tick.TradeSize -= trade.UnsignedSize;  			}  			// if trade represents entire requested order' mark order for removal  			if (trade.UnsignedSize == o.UnsignedSize)  				remove.Add (i);  			else  				// otherwise reflect order's remaining size  				o.OrderSize = (o.UnsignedSize - trade.UnsignedSize) * (o.OrderSide ? 1 : -1);  			// record trade  			_mastertrades [a.ID].Add (trade);  			// mark it for notification  			notifytrade.Add (_mastertrades [a.ID].Count - 1);  			// count the trade  			filledorders++;  		}  	}  	int rmcount = remove.Count;  	// remove the filled orders  	for (int i = remove.Count - 1; i >= 0; i--)  		_masterorders [a].RemoveAt (remove [i]);  	// unmark filled orders as pending  	_pendingorders -= rmcount;  	if (_pendingorders < 0)  		_pendingorders = 0;  	// notify subscribers of trade  	if (a.Notify)  		for (int tradeidx = 0; tradeidx < notifytrade.Count; tradeidx++)  			OnGotFill (_mastertrades [a.ID] [notifytrade [tradeidx]]);  }  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: for (int i = 0; i < _masterorders [a].Count; i++) {  	Order o = _masterorders [a] [i];  	//make sure tick is for the right stock  	if (tick.FullSymbol != o.FullSymbol)  		continue;  	bool filled = false;  	if (UseHighLiquidityFillsEOD) {  		Order oi = (Order)o;  		filled = oi.FillHighLiquidityEOD (tick' _usebidaskfill' false);  	}  	else if (o.TIF <= TimeInForce.GTC) {  		filled = o.Fill (tick' _usebidaskfill' false);  		// fill our trade  	}  	else if (o.TIF == TimeInForce.OPG) {  		// if it's already opened' we missed our shot  		if (_hasopened.Contains (o.FullSymbol))  			continue;  		// otherwise make sure it's really the opening  		//if (tick.Exchange == OPGEX)  		{  			// it's the opening tick' so fill it as an opg  			filled = o.Fill (tick' _usebidaskfill' true);  			// mark this symbol as already being open  			_hasopened.Add (tick.FullSymbol);  		}  	}  	// other orders fill normally' except MOC orders which are at 4:00PM  	else if (o.TIF == TimeInForce.MOC) {  		if (tick.Time >= 160000)  			filled = o.Fill (tick' _usebidaskfill' false);  		// fill our trade  	}  	else  		filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  	if (filled) {  		// get copy of trade for recording  		Trade trade = new Trade ((Trade)o);  		// remove filled size from size available in trade  		if (_adjustincomingticksize) {  			if (_usebidaskfill) {  				if (o.Side)  					tick.AskSize -= trade.UnsignedSize;  				else  					tick.BidSize -= trade.UnsignedSize;  			}  			else  				tick.TradeSize -= trade.UnsignedSize;  		}  		// if trade represents entire requested order' mark order for removal  		if (trade.UnsignedSize == o.UnsignedSize)  			remove.Add (i);  		else  			// otherwise reflect order's remaining size  			o.OrderSize = (o.UnsignedSize - trade.UnsignedSize) * (o.OrderSide ? 1 : -1);  		// record trade  		_mastertrades [a.ID].Add (trade);  		// mark it for notification  		notifytrade.Add (_mastertrades [a.ID].Count - 1);  		// count the trade  		filledorders++;  	}  }  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: if (UseHighLiquidityFillsEOD) {  	Order oi = (Order)o;  	filled = oi.FillHighLiquidityEOD (tick' _usebidaskfill' false);  }  else if (o.TIF <= TimeInForce.GTC) {  	filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  }  else if (o.TIF == TimeInForce.OPG) {  	// if it's already opened' we missed our shot  	if (_hasopened.Contains (o.FullSymbol))  		continue;  	// otherwise make sure it's really the opening  	//if (tick.Exchange == OPGEX)  	{  		// it's the opening tick' so fill it as an opg  		filled = o.Fill (tick' _usebidaskfill' true);  		// mark this symbol as already being open  		_hasopened.Add (tick.FullSymbol);  	}  }  // other orders fill normally' except MOC orders which are at 4:00PM  else if (o.TIF == TimeInForce.MOC) {  	if (tick.Time >= 160000)  		filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  }  else  	filled = o.Fill (tick' _usebidaskfill' false);  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: if (o.TIF <= TimeInForce.GTC) {  	filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  }  else if (o.TIF == TimeInForce.OPG) {  	// if it's already opened' we missed our shot  	if (_hasopened.Contains (o.FullSymbol))  		continue;  	// otherwise make sure it's really the opening  	//if (tick.Exchange == OPGEX)  	{  		// it's the opening tick' so fill it as an opg  		filled = o.Fill (tick' _usebidaskfill' true);  		// mark this symbol as already being open  		_hasopened.Add (tick.FullSymbol);  	}  }  // other orders fill normally' except MOC orders which are at 4:00PM  else if (o.TIF == TimeInForce.MOC) {  	if (tick.Time >= 160000)  		filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  }  else  	filled = o.Fill (tick' _usebidaskfill' false);  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: if (o.TIF == TimeInForce.OPG) {  	// if it's already opened' we missed our shot  	if (_hasopened.Contains (o.FullSymbol))  		continue;  	// otherwise make sure it's really the opening  	//if (tick.Exchange == OPGEX)  	{  		// it's the opening tick' so fill it as an opg  		filled = o.Fill (tick' _usebidaskfill' true);  		// mark this symbol as already being open  		_hasopened.Add (tick.FullSymbol);  	}  }  // other orders fill normally' except MOC orders which are at 4:00PM  else if (o.TIF == TimeInForce.MOC) {  	if (tick.Time >= 160000)  		filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  }  else  	filled = o.Fill (tick' _usebidaskfill' false);  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: if (o.TIF == TimeInForce.MOC) {  	if (tick.Time >= 160000)  		filled = o.Fill (tick' _usebidaskfill' false);  	// fill our trade  }  else  	filled = o.Fill (tick' _usebidaskfill' false);  
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: if (tick.Time >= 160000)  	filled = o.Fill (tick' _usebidaskfill' false);  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: for (int i = 0; i < Workers.Count; i++) {  	// for some reason background worker is slow exiting' recreate  	if (Workers [i].IsBusy) {  		DebugWithTime (Workers [i].Name + " worker#" + i + " is busy' waiting till free...");  		// retry  		while (Workers [i].IsBusy) {  			System.Threading.Thread.Sleep (10);  		}  		DebugWithTime (Workers [i].Name + " is no longer busy.");  		System.Threading.Thread.Sleep (10);  	}  	Workers [i].RunWorkerAsync (readahead);  	Debug (Workers [i].Name + " worker# " + i + " now is working.");  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: for (int i = 0; i < Workers.Count; i++) {  	// for some reason background worker is slow exiting' recreate  	if (Workers [i].IsBusy) {  		DebugWithTime (Workers [i].Name + " worker#" + i + " is busy' waiting till free...");  		// retry  		while (Workers [i].IsBusy) {  			System.Threading.Thread.Sleep (10);  		}  		DebugWithTime (Workers [i].Name + " is no longer busy.");  		System.Threading.Thread.Sleep (10);  	}  	Workers [i].RunWorkerAsync (readahead);  	Debug (Workers [i].Name + " worker# " + i + " now is working.");  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: if (Workers [i].IsBusy) {  	DebugWithTime (Workers [i].Name + " worker#" + i + " is busy' waiting till free...");  	// retry  	while (Workers [i].IsBusy) {  		System.Threading.Thread.Sleep (10);  	}  	DebugWithTime (Workers [i].Name + " is no longer busy.");  	System.Threading.Thread.Sleep (10);  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: if (Workers [i].IsBusy) {  	DebugWithTime (Workers [i].Name + " worker#" + i + " is busy' waiting till free...");  	// retry  	while (Workers [i].IsBusy) {  		System.Threading.Thread.Sleep (10);  	}  	DebugWithTime (Workers [i].Name + " is no longer busy.");  	System.Threading.Thread.Sleep (10);  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: while (Workers [i].IsBusy) {  	System.Threading.Thread.Sleep (10);  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: System.Threading.Thread.Sleep (10);  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: System.Threading.Thread.Sleep (10);  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCache,The following statement contains a magic number: while (simrunning) {  	// get next times of ticks in cache  	long[] times = nexttimes ();  	// copy our master index list into a temporary for sorting  	Buffer.BlockCopy (idx' 0' cidx' 0' idx.Length * 4);  	// sort loaded instruments by time  	Array.Sort (times' cidx);  	int nextidx = 0;  	// get next time from all instruments we have loaded  	while ((nextidx < times.Length) && (times [nextidx] == -1))  		nextidx++;  	// test to see if ticks left in simulation  	bool ticksleft = (nextidx < times.Length);  	bool simtimeleft = ticksleft && (times [nextidx] <= endsim);  	simrunning = ticksleft && simtimeleft;  	// if no ticks left or we exceeded simulation time' quit  	if (!simrunning) {  		if (!ticksleft)  			DebugWithTime ("No ticks left.");  		if (!simtimeleft)  			DebugWithTime ("Hit end of simulation.");  		break;  	}  	// get next tick  	Tick k = Workers [cidx [nextidx]].NextTick ();  	// time check  	orderok &= k.Datetime >= lasttime;  	if (orderok != lastorderok) {  		DebugWithTime ("tick out of order: " + k.FullSymbol + " w/" + k.Datetime + " behind: " + lasttime);  		lastorderok = orderok;  	}  	// update time  	lasttime = k.Datetime;  	// notify tick  	OnGotTick (k);  	// count tick  	_tickcount++;  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCache,The following statement contains a magic number: Buffer.BlockCopy (idx' 0' cidx' 0' idx.Length * 4);  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCacheSingleCore,The following statement contains a magic number: while (simrunning) {  	// get next ticks  	FillCacheSingleCore (1);  	// get next times of ticks in cache  	long[] times = nexttimes ();  	// copy our master index list into a temporary for sorting  	Buffer.BlockCopy (idx' 0' cidx' 0' idx.Length * 4);  	// sort loaded instruments by time  	Array.Sort (times' cidx);  	int nextidx = 0;  	// get next time from all instruments we have loaded  	while ((nextidx < times.Length) && (times [nextidx] == -1))  		nextidx++;  	// test to see if ticks left in simulation  	simrunning = (nextidx < times.Length) && (times [nextidx] <= endsim);  	// if no ticks left or we exceeded simulation time' quit  	if (!simrunning)  		break;  	// get next tick  	Tick k = Workers [cidx [nextidx]].NextTick ();  	// notify tick  	OnGotTick (k);  	// count tick  	_tickcount++;  }  
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCacheSingleCore,The following statement contains a magic number: Buffer.BlockCopy (idx' 0' cidx' 0' idx.Length * 4);  
Magic Number,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,progress,The following statement contains a magic number: if (pct > 100)  	pct = 100;  
Magic Number,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,progress,The following statement contains a magic number: if (pct > 100)  	pct = 100;  
Magic Number,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,progress,The following statement contains a magic number: pct = 100;  
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,Bar,The following statement contains a magic number: Interval = 300;  
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add (Tick.NewTrade (bar.FullSymbol' bar.Date' bar.BarStartTime' bar.Open' (int)((double)bar.Volume / 4)));  
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add (Tick.NewTrade (bar.FullSymbol' bar.Date' bar.BarStartTime' bar.High' (int)((double)bar.Volume / 4)));  
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add (Tick.NewTrade (bar.FullSymbol' bar.Date' bar.BarStartTime' bar.Low' (int)((double)bar.Volume / 4)));  
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add (Tick.NewTrade (bar.FullSymbol' bar.Date' bar.BarStartTime' bar.Close' (int)((double)bar.Volume / 4)));  
Magic Number,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,GetBarId,The following statement contains a magic number: bcount += (long)date * 100000;  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try {  	using (WebClient client = new WebClient ()) {  		string google;  		if (br.Interval != 86400) {  			google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		else// for oneday' today is empty  		 {  			google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  		}  		string[] symbol = br.FullSymbol.Split (' ');  		System.IO.Stream data = client.OpenRead (google + symbol [0]);  		System.IO.StreamReader read = new System.IO.StreamReader (data);  		string[] lines = new string[] {  			read.ReadToEnd ()  		};  		string[] lines2 = lines [0].Split ('\n');  		// get time zone adjustment  		// In line 6' GOOG has time zone offset = -240 which is new york time;   		//      while SPX has time zone offset = -300' which is chicago time.  		// The following find the additional offset relative to local time.  		/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  		// skip the first 7 lines: header  		int nlines = 0;  		// count of lines  		string[] entries;  		DateTime dstart = DateTime.Now;  		// just for initialization  		DateTime dt = DateTime.Now;  		foreach (string line in history) {  			if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  			 {  				entries = line.Split (''');  				if (nlines == 0) {  					// http://www.epochconverter.com/  					dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  					double secs = double.Parse (entries [0].Remove (0' 1));  					// remove character 'a'  					dt = dt.AddSeconds (secs);  					// GMT to EST  					// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  					dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  					dstart = dt;  				}  				else {  					dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  				}  				nlines++;  				// write line to database  				Bar bar = new Bar ();  				bar.Interval = 1;  				// 1 sec  				bar.FullSymbol = br.FullSymbol;  				bar.Open = decimal.Parse (entries [4]);  				bar.Date = Util.ToIntDate (dstart);  				bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  				bar.High = decimal.Parse (entries [2]);  				bar.Low = decimal.Parse (entries [3]);  				bar.Close = decimal.Parse (entries [1]);  				bar.Volume = long.Parse (entries [5]);  				if (GotHistoricalBarDelegate != null)  					GotHistoricalBarDelegate (bar);  			}  		}  	}  }  catch (Exception e) {  	Debug ("Error in requesting historical data from Google client.");  	Debug (e.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: using (WebClient client = new WebClient ()) {  	string google;  	if (br.Interval != 86400) {  		google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	else// for oneday' today is empty  	 {  		google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  	}  	string[] symbol = br.FullSymbol.Split (' ');  	System.IO.Stream data = client.OpenRead (google + symbol [0]);  	System.IO.StreamReader read = new System.IO.StreamReader (data);  	string[] lines = new string[] {  		read.ReadToEnd ()  	};  	string[] lines2 = lines [0].Split ('\n');  	// get time zone adjustment  	// In line 6' GOOG has time zone offset = -240 which is new york time;   	//      while SPX has time zone offset = -300' which is chicago time.  	// The following find the additional offset relative to local time.  	/*                     int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                     string stime = lines[6];                     int itime;                     bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                     int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                     */IEnumerable<string> history = lines2.Skip (7);  	// skip the first 7 lines: header  	int nlines = 0;  	// count of lines  	string[] entries;  	DateTime dstart = DateTime.Now;  	// just for initialization  	DateTime dt = DateTime.Now;  	foreach (string line in history) {  		if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  		 {  			entries = line.Split (''');  			if (nlines == 0) {  				// http://www.epochconverter.com/  				dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  				double secs = double.Parse (entries [0].Remove (0' 1));  				// remove character 'a'  				dt = dt.AddSeconds (secs);  				// GMT to EST  				// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  				dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  				dstart = dt;  			}  			else {  				dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  			}  			nlines++;  			// write line to database  			Bar bar = new Bar ();  			bar.Interval = 1;  			// 1 sec  			bar.FullSymbol = br.FullSymbol;  			bar.Open = decimal.Parse (entries [4]);  			bar.Date = Util.ToIntDate (dstart);  			bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  			bar.High = decimal.Parse (entries [2]);  			bar.Low = decimal.Parse (entries [3]);  			bar.Close = decimal.Parse (entries [1]);  			bar.Volume = long.Parse (entries [5]);  			if (GotHistoricalBarDelegate != null)  				GotHistoricalBarDelegate (bar);  		}  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (br.Interval != 86400) {  	google = @"https://www.google.com/finance/getprices?i=" + br.Interval.ToString () + @"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";  }  else// for oneday' today is empty   {  	google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: foreach (string line in history) {  	if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  	 {  		entries = line.Split (''');  		if (nlines == 0) {  			// http://www.epochconverter.com/  			dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  			double secs = double.Parse (entries [0].Remove (0' 1));  			// remove character 'a'  			dt = dt.AddSeconds (secs);  			// GMT to EST  			// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  			dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  			dstart = dt;  		}  		else {  			dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  		}  		nlines++;  		// write line to database  		Bar bar = new Bar ();  		bar.Interval = 1;  		// 1 sec  		bar.FullSymbol = br.FullSymbol;  		bar.Open = decimal.Parse (entries [4]);  		bar.Date = Util.ToIntDate (dstart);  		bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  		bar.High = decimal.Parse (entries [2]);  		bar.Low = decimal.Parse (entries [3]);  		bar.Close = decimal.Parse (entries [1]);  		bar.Volume = long.Parse (entries [5]);  		if (GotHistoricalBarDelegate != null)  			GotHistoricalBarDelegate (bar);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: foreach (string line in history) {  	if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  	 {  		entries = line.Split (''');  		if (nlines == 0) {  			// http://www.epochconverter.com/  			dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  			double secs = double.Parse (entries [0].Remove (0' 1));  			// remove character 'a'  			dt = dt.AddSeconds (secs);  			// GMT to EST  			// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  			dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  			dstart = dt;  		}  		else {  			dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  		}  		nlines++;  		// write line to database  		Bar bar = new Bar ();  		bar.Interval = 1;  		// 1 sec  		bar.FullSymbol = br.FullSymbol;  		bar.Open = decimal.Parse (entries [4]);  		bar.Date = Util.ToIntDate (dstart);  		bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  		bar.High = decimal.Parse (entries [2]);  		bar.Low = decimal.Parse (entries [3]);  		bar.Close = decimal.Parse (entries [1]);  		bar.Volume = long.Parse (entries [5]);  		if (GotHistoricalBarDelegate != null)  			GotHistoricalBarDelegate (bar);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: foreach (string line in history) {  	if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  	 {  		entries = line.Split (''');  		if (nlines == 0) {  			// http://www.epochconverter.com/  			dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  			double secs = double.Parse (entries [0].Remove (0' 1));  			// remove character 'a'  			dt = dt.AddSeconds (secs);  			// GMT to EST  			// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  			dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  			dstart = dt;  		}  		else {  			dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  		}  		nlines++;  		// write line to database  		Bar bar = new Bar ();  		bar.Interval = 1;  		// 1 sec  		bar.FullSymbol = br.FullSymbol;  		bar.Open = decimal.Parse (entries [4]);  		bar.Date = Util.ToIntDate (dstart);  		bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  		bar.High = decimal.Parse (entries [2]);  		bar.Low = decimal.Parse (entries [3]);  		bar.Close = decimal.Parse (entries [1]);  		bar.Volume = long.Parse (entries [5]);  		if (GotHistoricalBarDelegate != null)  			GotHistoricalBarDelegate (bar);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: foreach (string line in history) {  	if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  	 {  		entries = line.Split (''');  		if (nlines == 0) {  			// http://www.epochconverter.com/  			dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  			double secs = double.Parse (entries [0].Remove (0' 1));  			// remove character 'a'  			dt = dt.AddSeconds (secs);  			// GMT to EST  			// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  			dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  			dstart = dt;  		}  		else {  			dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  		}  		nlines++;  		// write line to database  		Bar bar = new Bar ();  		bar.Interval = 1;  		// 1 sec  		bar.FullSymbol = br.FullSymbol;  		bar.Open = decimal.Parse (entries [4]);  		bar.Date = Util.ToIntDate (dstart);  		bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  		bar.High = decimal.Parse (entries [2]);  		bar.Low = decimal.Parse (entries [3]);  		bar.Close = decimal.Parse (entries [1]);  		bar.Volume = long.Parse (entries [5]);  		if (GotHistoricalBarDelegate != null)  			GotHistoricalBarDelegate (bar);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: foreach (string line in history) {  	if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line  	 {  		entries = line.Split (''');  		if (nlines == 0) {  			// http://www.epochconverter.com/  			dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  			double secs = double.Parse (entries [0].Remove (0' 1));  			// remove character 'a'  			dt = dt.AddSeconds (secs);  			// GMT to EST  			// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  			dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  			dstart = dt;  		}  		else {  			dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  		}  		nlines++;  		// write line to database  		Bar bar = new Bar ();  		bar.Interval = 1;  		// 1 sec  		bar.FullSymbol = br.FullSymbol;  		bar.Open = decimal.Parse (entries [4]);  		bar.Date = Util.ToIntDate (dstart);  		bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  		bar.High = decimal.Parse (entries [2]);  		bar.Low = decimal.Parse (entries [3]);  		bar.Close = decimal.Parse (entries [1]);  		bar.Volume = long.Parse (entries [5]);  		if (GotHistoricalBarDelegate != null)  			GotHistoricalBarDelegate (bar);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line   {  	entries = line.Split (''');  	if (nlines == 0) {  		// http://www.epochconverter.com/  		dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  		double secs = double.Parse (entries [0].Remove (0' 1));  		// remove character 'a'  		dt = dt.AddSeconds (secs);  		// GMT to EST  		// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  		dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  		dstart = dt;  	}  	else {  		dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  	}  	nlines++;  	// write line to database  	Bar bar = new Bar ();  	bar.Interval = 1;  	// 1 sec  	bar.FullSymbol = br.FullSymbol;  	bar.Open = decimal.Parse (entries [4]);  	bar.Date = Util.ToIntDate (dstart);  	bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  	bar.High = decimal.Parse (entries [2]);  	bar.Low = decimal.Parse (entries [3]);  	bar.Close = decimal.Parse (entries [1]);  	bar.Volume = long.Parse (entries [5]);  	if (GotHistoricalBarDelegate != null)  		GotHistoricalBarDelegate (bar);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line   {  	entries = line.Split (''');  	if (nlines == 0) {  		// http://www.epochconverter.com/  		dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  		double secs = double.Parse (entries [0].Remove (0' 1));  		// remove character 'a'  		dt = dt.AddSeconds (secs);  		// GMT to EST  		// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  		dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  		dstart = dt;  	}  	else {  		dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  	}  	nlines++;  	// write line to database  	Bar bar = new Bar ();  	bar.Interval = 1;  	// 1 sec  	bar.FullSymbol = br.FullSymbol;  	bar.Open = decimal.Parse (entries [4]);  	bar.Date = Util.ToIntDate (dstart);  	bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  	bar.High = decimal.Parse (entries [2]);  	bar.Low = decimal.Parse (entries [3]);  	bar.Close = decimal.Parse (entries [1]);  	bar.Volume = long.Parse (entries [5]);  	if (GotHistoricalBarDelegate != null)  		GotHistoricalBarDelegate (bar);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line   {  	entries = line.Split (''');  	if (nlines == 0) {  		// http://www.epochconverter.com/  		dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  		double secs = double.Parse (entries [0].Remove (0' 1));  		// remove character 'a'  		dt = dt.AddSeconds (secs);  		// GMT to EST  		// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  		dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  		dstart = dt;  	}  	else {  		dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  	}  	nlines++;  	// write line to database  	Bar bar = new Bar ();  	bar.Interval = 1;  	// 1 sec  	bar.FullSymbol = br.FullSymbol;  	bar.Open = decimal.Parse (entries [4]);  	bar.Date = Util.ToIntDate (dstart);  	bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  	bar.High = decimal.Parse (entries [2]);  	bar.Low = decimal.Parse (entries [3]);  	bar.Close = decimal.Parse (entries [1]);  	bar.Volume = long.Parse (entries [5]);  	if (GotHistoricalBarDelegate != null)  		GotHistoricalBarDelegate (bar);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line   {  	entries = line.Split (''');  	if (nlines == 0) {  		// http://www.epochconverter.com/  		dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  		double secs = double.Parse (entries [0].Remove (0' 1));  		// remove character 'a'  		dt = dt.AddSeconds (secs);  		// GMT to EST  		// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  		dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  		dstart = dt;  	}  	else {  		dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  	}  	nlines++;  	// write line to database  	Bar bar = new Bar ();  	bar.Interval = 1;  	// 1 sec  	bar.FullSymbol = br.FullSymbol;  	bar.Open = decimal.Parse (entries [4]);  	bar.Date = Util.ToIntDate (dstart);  	bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  	bar.High = decimal.Parse (entries [2]);  	bar.Low = decimal.Parse (entries [3]);  	bar.Close = decimal.Parse (entries [1]);  	bar.Volume = long.Parse (entries [5]);  	if (GotHistoricalBarDelegate != null)  		GotHistoricalBarDelegate (bar);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (!string.IsNullOrEmpty (line))// skip empty lines' i.e.' the last line   {  	entries = line.Split (''');  	if (nlines == 0) {  		// http://www.epochconverter.com/  		dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  		double secs = double.Parse (entries [0].Remove (0' 1));  		// remove character 'a'  		dt = dt.AddSeconds (secs);  		// GMT to EST  		// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  		dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  		dstart = dt;  	}  	else {  		dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  	}  	nlines++;  	// write line to database  	Bar bar = new Bar ();  	bar.Interval = 1;  	// 1 sec  	bar.FullSymbol = br.FullSymbol;  	bar.Open = decimal.Parse (entries [4]);  	bar.Date = Util.ToIntDate (dstart);  	bar.BarOrderInADay = bar.GetOrder (Util.ToIntTime (dstart));  	bar.High = decimal.Parse (entries [2]);  	bar.Low = decimal.Parse (entries [3]);  	bar.Close = decimal.Parse (entries [1]);  	bar.Volume = long.Parse (entries [5]);  	if (GotHistoricalBarDelegate != null)  		GotHistoricalBarDelegate (bar);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: if (nlines == 0) {  	// http://www.epochconverter.com/  	dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  	double secs = double.Parse (entries [0].Remove (0' 1));  	// remove character 'a'  	dt = dt.AddSeconds (secs);  	// GMT to EST  	// dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));  	dt = TimeZoneInfo.ConvertTimeFromUtc (dt' TimeZoneInfo.Local);  	dstart = dt;  }  else {  	dstart = dt.AddSeconds (Int32.Parse (entries [0]) * br.Interval);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: dt = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: bar.Open = decimal.Parse (entries [4]);  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: bar.High = decimal.Parse (entries [2]);  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: bar.Low = decimal.Parse (entries [3]);  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: bar.Volume = long.Parse (entries [5]);  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true) {  	if (token.IsCancellationRequested) {  		break;  	}  	try {  		// Create a request for the URL.   		HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  		// If required by the server' set the credentials.  		grequest.Credentials = CredentialCache.DefaultCredentials;  		// Get the response.  		HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  		// Display the status.  		// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  		// Get the stream containing content returned by the server.  		Stream gdatastream = gresponse.GetResponseStream ();  		// Open the stream using a StreamReader for easy access.  		StreamReader greader = new StreamReader (gdatastream);  		// Read the content.  		string quotestr = greader.ReadToEnd ();  		// Display the content.  		// Console.WriteLine(quotestr);  		quotestr = quotestr.Replace ("//"' "");  		// Clean up the streams and the response.  		greader.Close ();  		gdatastream.Close ();  		gresponse.Close ();  		var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  		DateTime ct = DateTime.Now;  		int i = 0;  		// quote has the same order as that in securities; use this logic to retrieve symbol directly  		foreach (var sec in SecurityFullNameToGoogleSymbol) {  			Tick k = new Tick ();  			// it should create a new tick. Otherwise it overrides.  			k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  			k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  			//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  			//dt = dt.ToLocalTime();  			//k.Date = Util.ToIntDate(dt);  			//k.Time = Util.ToIntTime(dt);  			k.FullSymbol = sec.Key;  			k.TradePrice = Convert.ToDecimal (quote [i].l);  			k.TradeSize = Convert.ToInt32 (quote [i++].s);  			k.TradeSize = 1000;  			// overwrite. It seems that google hasn't provided size yet.  			SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  			if (k.IsValid) {  				if (GotTickDelegate != null)  					GotTickDelegate (k);  			}  		}  	}  	catch (Exception ex) {  		Debug ("GoogleClient error: " + ex.Message);  	}  	// Sleep 30 seconds  	// Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));  	System.Threading.Thread.Sleep (new TimeSpan (0' 0' 0' 0' RefreshInterval));  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true) {  	if (token.IsCancellationRequested) {  		break;  	}  	try {  		// Create a request for the URL.   		HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  		// If required by the server' set the credentials.  		grequest.Credentials = CredentialCache.DefaultCredentials;  		// Get the response.  		HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  		// Display the status.  		// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  		// Get the stream containing content returned by the server.  		Stream gdatastream = gresponse.GetResponseStream ();  		// Open the stream using a StreamReader for easy access.  		StreamReader greader = new StreamReader (gdatastream);  		// Read the content.  		string quotestr = greader.ReadToEnd ();  		// Display the content.  		// Console.WriteLine(quotestr);  		quotestr = quotestr.Replace ("//"' "");  		// Clean up the streams and the response.  		greader.Close ();  		gdatastream.Close ();  		gresponse.Close ();  		var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  		DateTime ct = DateTime.Now;  		int i = 0;  		// quote has the same order as that in securities; use this logic to retrieve symbol directly  		foreach (var sec in SecurityFullNameToGoogleSymbol) {  			Tick k = new Tick ();  			// it should create a new tick. Otherwise it overrides.  			k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  			k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  			//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  			//dt = dt.ToLocalTime();  			//k.Date = Util.ToIntDate(dt);  			//k.Time = Util.ToIntTime(dt);  			k.FullSymbol = sec.Key;  			k.TradePrice = Convert.ToDecimal (quote [i].l);  			k.TradeSize = Convert.ToInt32 (quote [i++].s);  			k.TradeSize = 1000;  			// overwrite. It seems that google hasn't provided size yet.  			SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  			if (k.IsValid) {  				if (GotTickDelegate != null)  					GotTickDelegate (k);  			}  		}  	}  	catch (Exception ex) {  		Debug ("GoogleClient error: " + ex.Message);  	}  	// Sleep 30 seconds  	// Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));  	System.Threading.Thread.Sleep (new TimeSpan (0' 0' 0' 0' RefreshInterval));  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true) {  	if (token.IsCancellationRequested) {  		break;  	}  	try {  		// Create a request for the URL.   		HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  		// If required by the server' set the credentials.  		grequest.Credentials = CredentialCache.DefaultCredentials;  		// Get the response.  		HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  		// Display the status.  		// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  		// Get the stream containing content returned by the server.  		Stream gdatastream = gresponse.GetResponseStream ();  		// Open the stream using a StreamReader for easy access.  		StreamReader greader = new StreamReader (gdatastream);  		// Read the content.  		string quotestr = greader.ReadToEnd ();  		// Display the content.  		// Console.WriteLine(quotestr);  		quotestr = quotestr.Replace ("//"' "");  		// Clean up the streams and the response.  		greader.Close ();  		gdatastream.Close ();  		gresponse.Close ();  		var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  		DateTime ct = DateTime.Now;  		int i = 0;  		// quote has the same order as that in securities; use this logic to retrieve symbol directly  		foreach (var sec in SecurityFullNameToGoogleSymbol) {  			Tick k = new Tick ();  			// it should create a new tick. Otherwise it overrides.  			k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  			k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  			//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  			//dt = dt.ToLocalTime();  			//k.Date = Util.ToIntDate(dt);  			//k.Time = Util.ToIntTime(dt);  			k.FullSymbol = sec.Key;  			k.TradePrice = Convert.ToDecimal (quote [i].l);  			k.TradeSize = Convert.ToInt32 (quote [i++].s);  			k.TradeSize = 1000;  			// overwrite. It seems that google hasn't provided size yet.  			SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  			if (k.IsValid) {  				if (GotTickDelegate != null)  					GotTickDelegate (k);  			}  		}  	}  	catch (Exception ex) {  		Debug ("GoogleClient error: " + ex.Message);  	}  	// Sleep 30 seconds  	// Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));  	System.Threading.Thread.Sleep (new TimeSpan (0' 0' 0' 0' RefreshInterval));  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true) {  	if (token.IsCancellationRequested) {  		break;  	}  	try {  		// Create a request for the URL.   		HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  		// If required by the server' set the credentials.  		grequest.Credentials = CredentialCache.DefaultCredentials;  		// Get the response.  		HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  		// Display the status.  		// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  		// Get the stream containing content returned by the server.  		Stream gdatastream = gresponse.GetResponseStream ();  		// Open the stream using a StreamReader for easy access.  		StreamReader greader = new StreamReader (gdatastream);  		// Read the content.  		string quotestr = greader.ReadToEnd ();  		// Display the content.  		// Console.WriteLine(quotestr);  		quotestr = quotestr.Replace ("//"' "");  		// Clean up the streams and the response.  		greader.Close ();  		gdatastream.Close ();  		gresponse.Close ();  		var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  		DateTime ct = DateTime.Now;  		int i = 0;  		// quote has the same order as that in securities; use this logic to retrieve symbol directly  		foreach (var sec in SecurityFullNameToGoogleSymbol) {  			Tick k = new Tick ();  			// it should create a new tick. Otherwise it overrides.  			k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  			k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  			//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  			//dt = dt.ToLocalTime();  			//k.Date = Util.ToIntDate(dt);  			//k.Time = Util.ToIntTime(dt);  			k.FullSymbol = sec.Key;  			k.TradePrice = Convert.ToDecimal (quote [i].l);  			k.TradeSize = Convert.ToInt32 (quote [i++].s);  			k.TradeSize = 1000;  			// overwrite. It seems that google hasn't provided size yet.  			SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  			if (k.IsValid) {  				if (GotTickDelegate != null)  					GotTickDelegate (k);  			}  		}  	}  	catch (Exception ex) {  		Debug ("GoogleClient error: " + ex.Message);  	}  	// Sleep 30 seconds  	// Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));  	System.Threading.Thread.Sleep (new TimeSpan (0' 0' 0' 0' RefreshInterval));  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true) {  	if (token.IsCancellationRequested) {  		break;  	}  	try {  		// Create a request for the URL.   		HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  		// If required by the server' set the credentials.  		grequest.Credentials = CredentialCache.DefaultCredentials;  		// Get the response.  		HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  		// Display the status.  		// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  		// Get the stream containing content returned by the server.  		Stream gdatastream = gresponse.GetResponseStream ();  		// Open the stream using a StreamReader for easy access.  		StreamReader greader = new StreamReader (gdatastream);  		// Read the content.  		string quotestr = greader.ReadToEnd ();  		// Display the content.  		// Console.WriteLine(quotestr);  		quotestr = quotestr.Replace ("//"' "");  		// Clean up the streams and the response.  		greader.Close ();  		gdatastream.Close ();  		gresponse.Close ();  		var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  		DateTime ct = DateTime.Now;  		int i = 0;  		// quote has the same order as that in securities; use this logic to retrieve symbol directly  		foreach (var sec in SecurityFullNameToGoogleSymbol) {  			Tick k = new Tick ();  			// it should create a new tick. Otherwise it overrides.  			k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  			k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  			//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  			//dt = dt.ToLocalTime();  			//k.Date = Util.ToIntDate(dt);  			//k.Time = Util.ToIntTime(dt);  			k.FullSymbol = sec.Key;  			k.TradePrice = Convert.ToDecimal (quote [i].l);  			k.TradeSize = Convert.ToInt32 (quote [i++].s);  			k.TradeSize = 1000;  			// overwrite. It seems that google hasn't provided size yet.  			SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  			if (k.IsValid) {  				if (GotTickDelegate != null)  					GotTickDelegate (k);  			}  		}  	}  	catch (Exception ex) {  		Debug ("GoogleClient error: " + ex.Message);  	}  	// Sleep 30 seconds  	// Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));  	System.Threading.Thread.Sleep (new TimeSpan (0' 0' 0' 0' RefreshInterval));  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: try {  	// Create a request for the URL.   	HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  	// If required by the server' set the credentials.  	grequest.Credentials = CredentialCache.DefaultCredentials;  	// Get the response.  	HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  	// Display the status.  	// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  	// Get the stream containing content returned by the server.  	Stream gdatastream = gresponse.GetResponseStream ();  	// Open the stream using a StreamReader for easy access.  	StreamReader greader = new StreamReader (gdatastream);  	// Read the content.  	string quotestr = greader.ReadToEnd ();  	// Display the content.  	// Console.WriteLine(quotestr);  	quotestr = quotestr.Replace ("//"' "");  	// Clean up the streams and the response.  	greader.Close ();  	gdatastream.Close ();  	gresponse.Close ();  	var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  	DateTime ct = DateTime.Now;  	int i = 0;  	// quote has the same order as that in securities; use this logic to retrieve symbol directly  	foreach (var sec in SecurityFullNameToGoogleSymbol) {  		Tick k = new Tick ();  		// it should create a new tick. Otherwise it overrides.  		k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  		k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  		//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  		//dt = dt.ToLocalTime();  		//k.Date = Util.ToIntDate(dt);  		//k.Time = Util.ToIntTime(dt);  		k.FullSymbol = sec.Key;  		k.TradePrice = Convert.ToDecimal (quote [i].l);  		k.TradeSize = Convert.ToInt32 (quote [i++].s);  		k.TradeSize = 1000;  		// overwrite. It seems that google hasn't provided size yet.  		SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  		if (k.IsValid) {  			if (GotTickDelegate != null)  				GotTickDelegate (k);  		}  	}  }  catch (Exception ex) {  	Debug ("GoogleClient error: " + ex.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: try {  	// Create a request for the URL.   	HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  	// If required by the server' set the credentials.  	grequest.Credentials = CredentialCache.DefaultCredentials;  	// Get the response.  	HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  	// Display the status.  	// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  	// Get the stream containing content returned by the server.  	Stream gdatastream = gresponse.GetResponseStream ();  	// Open the stream using a StreamReader for easy access.  	StreamReader greader = new StreamReader (gdatastream);  	// Read the content.  	string quotestr = greader.ReadToEnd ();  	// Display the content.  	// Console.WriteLine(quotestr);  	quotestr = quotestr.Replace ("//"' "");  	// Clean up the streams and the response.  	greader.Close ();  	gdatastream.Close ();  	gresponse.Close ();  	var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  	DateTime ct = DateTime.Now;  	int i = 0;  	// quote has the same order as that in securities; use this logic to retrieve symbol directly  	foreach (var sec in SecurityFullNameToGoogleSymbol) {  		Tick k = new Tick ();  		// it should create a new tick. Otherwise it overrides.  		k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  		k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  		//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  		//dt = dt.ToLocalTime();  		//k.Date = Util.ToIntDate(dt);  		//k.Time = Util.ToIntTime(dt);  		k.FullSymbol = sec.Key;  		k.TradePrice = Convert.ToDecimal (quote [i].l);  		k.TradeSize = Convert.ToInt32 (quote [i++].s);  		k.TradeSize = 1000;  		// overwrite. It seems that google hasn't provided size yet.  		SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  		if (k.IsValid) {  			if (GotTickDelegate != null)  				GotTickDelegate (k);  		}  	}  }  catch (Exception ex) {  	Debug ("GoogleClient error: " + ex.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: try {  	// Create a request for the URL.   	HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  	// If required by the server' set the credentials.  	grequest.Credentials = CredentialCache.DefaultCredentials;  	// Get the response.  	HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  	// Display the status.  	// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  	// Get the stream containing content returned by the server.  	Stream gdatastream = gresponse.GetResponseStream ();  	// Open the stream using a StreamReader for easy access.  	StreamReader greader = new StreamReader (gdatastream);  	// Read the content.  	string quotestr = greader.ReadToEnd ();  	// Display the content.  	// Console.WriteLine(quotestr);  	quotestr = quotestr.Replace ("//"' "");  	// Clean up the streams and the response.  	greader.Close ();  	gdatastream.Close ();  	gresponse.Close ();  	var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  	DateTime ct = DateTime.Now;  	int i = 0;  	// quote has the same order as that in securities; use this logic to retrieve symbol directly  	foreach (var sec in SecurityFullNameToGoogleSymbol) {  		Tick k = new Tick ();  		// it should create a new tick. Otherwise it overrides.  		k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  		k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  		//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  		//dt = dt.ToLocalTime();  		//k.Date = Util.ToIntDate(dt);  		//k.Time = Util.ToIntTime(dt);  		k.FullSymbol = sec.Key;  		k.TradePrice = Convert.ToDecimal (quote [i].l);  		k.TradeSize = Convert.ToInt32 (quote [i++].s);  		k.TradeSize = 1000;  		// overwrite. It seems that google hasn't provided size yet.  		SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  		if (k.IsValid) {  			if (GotTickDelegate != null)  				GotTickDelegate (k);  		}  	}  }  catch (Exception ex) {  	Debug ("GoogleClient error: " + ex.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: try {  	// Create a request for the URL.   	HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  	// If required by the server' set the credentials.  	grequest.Credentials = CredentialCache.DefaultCredentials;  	// Get the response.  	HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  	// Display the status.  	// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  	// Get the stream containing content returned by the server.  	Stream gdatastream = gresponse.GetResponseStream ();  	// Open the stream using a StreamReader for easy access.  	StreamReader greader = new StreamReader (gdatastream);  	// Read the content.  	string quotestr = greader.ReadToEnd ();  	// Display the content.  	// Console.WriteLine(quotestr);  	quotestr = quotestr.Replace ("//"' "");  	// Clean up the streams and the response.  	greader.Close ();  	gdatastream.Close ();  	gresponse.Close ();  	var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  	DateTime ct = DateTime.Now;  	int i = 0;  	// quote has the same order as that in securities; use this logic to retrieve symbol directly  	foreach (var sec in SecurityFullNameToGoogleSymbol) {  		Tick k = new Tick ();  		// it should create a new tick. Otherwise it overrides.  		k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  		k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  		//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  		//dt = dt.ToLocalTime();  		//k.Date = Util.ToIntDate(dt);  		//k.Time = Util.ToIntTime(dt);  		k.FullSymbol = sec.Key;  		k.TradePrice = Convert.ToDecimal (quote [i].l);  		k.TradeSize = Convert.ToInt32 (quote [i++].s);  		k.TradeSize = 1000;  		// overwrite. It seems that google hasn't provided size yet.  		SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  		if (k.IsValid) {  			if (GotTickDelegate != null)  				GotTickDelegate (k);  		}  	}  }  catch (Exception ex) {  	Debug ("GoogleClient error: " + ex.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: try {  	// Create a request for the URL.   	HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create (query);  	// If required by the server' set the credentials.  	grequest.Credentials = CredentialCache.DefaultCredentials;  	// Get the response.  	HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse ();  	// Display the status.  	// Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);  	// Get the stream containing content returned by the server.  	Stream gdatastream = gresponse.GetResponseStream ();  	// Open the stream using a StreamReader for easy access.  	StreamReader greader = new StreamReader (gdatastream);  	// Read the content.  	string quotestr = greader.ReadToEnd ();  	// Display the content.  	// Console.WriteLine(quotestr);  	quotestr = quotestr.Replace ("//"' "");  	// Clean up the streams and the response.  	greader.Close ();  	gdatastream.Close ();  	gresponse.Close ();  	var quote = JsonConvert.DeserializeObject<List<RealTimeData>> (quotestr);  	DateTime ct = DateTime.Now;  	int i = 0;  	// quote has the same order as that in securities; use this logic to retrieve symbol directly  	foreach (var sec in SecurityFullNameToGoogleSymbol) {  		Tick k = new Tick ();  		// it should create a new tick. Otherwise it overrides.  		k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  		k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  		//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  		//dt = dt.ToLocalTime();  		//k.Date = Util.ToIntDate(dt);  		//k.Time = Util.ToIntTime(dt);  		k.FullSymbol = sec.Key;  		k.TradePrice = Convert.ToDecimal (quote [i].l);  		k.TradeSize = Convert.ToInt32 (quote [i++].s);  		k.TradeSize = 1000;  		// overwrite. It seems that google hasn't provided size yet.  		SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  		if (k.IsValid) {  			if (GotTickDelegate != null)  				GotTickDelegate (k);  		}  	}  }  catch (Exception ex) {  	Debug ("GoogleClient error: " + ex.Message);  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: foreach (var sec in SecurityFullNameToGoogleSymbol) {  	Tick k = new Tick ();  	// it should create a new tick. Otherwise it overrides.  	k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  	k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  	//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  	//dt = dt.ToLocalTime();  	//k.Date = Util.ToIntDate(dt);  	//k.Time = Util.ToIntTime(dt);  	k.FullSymbol = sec.Key;  	k.TradePrice = Convert.ToDecimal (quote [i].l);  	k.TradeSize = Convert.ToInt32 (quote [i++].s);  	k.TradeSize = 1000;  	// overwrite. It seems that google hasn't provided size yet.  	SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  	if (k.IsValid) {  		if (GotTickDelegate != null)  			GotTickDelegate (k);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: foreach (var sec in SecurityFullNameToGoogleSymbol) {  	Tick k = new Tick ();  	// it should create a new tick. Otherwise it overrides.  	k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  	k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  	//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  	//dt = dt.ToLocalTime();  	//k.Date = Util.ToIntDate(dt);  	//k.Time = Util.ToIntTime(dt);  	k.FullSymbol = sec.Key;  	k.TradePrice = Convert.ToDecimal (quote [i].l);  	k.TradeSize = Convert.ToInt32 (quote [i++].s);  	k.TradeSize = 1000;  	// overwrite. It seems that google hasn't provided size yet.  	SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  	if (k.IsValid) {  		if (GotTickDelegate != null)  			GotTickDelegate (k);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: foreach (var sec in SecurityFullNameToGoogleSymbol) {  	Tick k = new Tick ();  	// it should create a new tick. Otherwise it overrides.  	k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  	k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  	//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  	//dt = dt.ToLocalTime();  	//k.Date = Util.ToIntDate(dt);  	//k.Time = Util.ToIntTime(dt);  	k.FullSymbol = sec.Key;  	k.TradePrice = Convert.ToDecimal (quote [i].l);  	k.TradeSize = Convert.ToInt32 (quote [i++].s);  	k.TradeSize = 1000;  	// overwrite. It seems that google hasn't provided size yet.  	SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  	if (k.IsValid) {  		if (GotTickDelegate != null)  			GotTickDelegate (k);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: foreach (var sec in SecurityFullNameToGoogleSymbol) {  	Tick k = new Tick ();  	// it should create a new tick. Otherwise it overrides.  	k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  	k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  	//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  	//dt = dt.ToLocalTime();  	//k.Date = Util.ToIntDate(dt);  	//k.Time = Util.ToIntTime(dt);  	k.FullSymbol = sec.Key;  	k.TradePrice = Convert.ToDecimal (quote [i].l);  	k.TradeSize = Convert.ToInt32 (quote [i++].s);  	k.TradeSize = 1000;  	// overwrite. It seems that google hasn't provided size yet.  	SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  	if (k.IsValid) {  		if (GotTickDelegate != null)  			GotTickDelegate (k);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: foreach (var sec in SecurityFullNameToGoogleSymbol) {  	Tick k = new Tick ();  	// it should create a new tick. Otherwise it overrides.  	k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  	k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  	//DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time  	//dt = dt.ToLocalTime();  	//k.Date = Util.ToIntDate(dt);  	//k.Time = Util.ToIntTime(dt);  	k.FullSymbol = sec.Key;  	k.TradePrice = Convert.ToDecimal (quote [i].l);  	k.TradeSize = Convert.ToInt32 (quote [i++].s);  	k.TradeSize = 1000;  	// overwrite. It seems that google hasn't provided size yet.  	SecurityFullNameToLastPrice [sec.Key] = k.TradePrice;  	if (k.IsValid) {  		if (GotTickDelegate != null)  			GotTickDelegate (k);  	}  }  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: k.TradeSize = 1000;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,Connect,The following statement contains a magic number: _ibSocket.setServerLogLevel (5);  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval) {  case 1:  	barSize = "1 secs";  	// not 1 sec  	break;  case 5:  	barSize = "5 secs";  	break;  case 15:  	barSize = "15 secs";  	break;  case 30:  	barSize = "30 secs";  	break;  case 60:  	barSize = "1 min";  	break;  case 120:  	barSize = "2 mins";  	break;  case 180:  	barSize = "3 mins";  	break;  case 300:  	barSize = "5 mins";  	break;  case 900:  	barSize = "15 mins";  	break;  case 1800:  	barSize = "30 mins";  	break;  case 3600:  	barSize = "1 hour";  	break;  case 86400:  	barSize = "1 day";  	break;  default:  	throw new ArgumentOutOfRangeException ("Invalid barsize/interval.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddDays (-1)) {  	durationstring = duration.TotalSeconds.ToString () + " S";  }  // Request is greater than 1 day and less than 7 days -> Request in days  else if (startdatetime > enddatetime.AddDays (-7)) {  	durationstring = duration.TotalDays.ToString () + " D";  }  // Request is greater than 7 days and less than 1 month -> Request in weeks  else if (startdatetime > enddatetime.AddMonths (-1)) {  	int numberOfWeeksToRequest = (int)Math.Ceiling (duration.TotalDays / 7.0);  	durationstring = numberOfWeeksToRequest.ToString () + " W";  }  else {  	throw new ArgumentOutOfRangeException ("Period cannot be bigger than 52 weeks.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddDays (-1)) {  	durationstring = duration.TotalSeconds.ToString () + " S";  }  // Request is greater than 1 day and less than 7 days -> Request in days  else if (startdatetime > enddatetime.AddDays (-7)) {  	durationstring = duration.TotalDays.ToString () + " D";  }  // Request is greater than 7 days and less than 1 month -> Request in weeks  else if (startdatetime > enddatetime.AddMonths (-1)) {  	int numberOfWeeksToRequest = (int)Math.Ceiling (duration.TotalDays / 7.0);  	durationstring = numberOfWeeksToRequest.ToString () + " W";  }  else {  	throw new ArgumentOutOfRangeException ("Period cannot be bigger than 52 weeks.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddDays (-7)) {  	durationstring = duration.TotalDays.ToString () + " D";  }  // Request is greater than 7 days and less than 1 month -> Request in weeks  else if (startdatetime > enddatetime.AddMonths (-1)) {  	int numberOfWeeksToRequest = (int)Math.Ceiling (duration.TotalDays / 7.0);  	durationstring = numberOfWeeksToRequest.ToString () + " W";  }  else {  	throw new ArgumentOutOfRangeException ("Period cannot be bigger than 52 weeks.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddDays (-7)) {  	durationstring = duration.TotalDays.ToString () + " D";  }  // Request is greater than 7 days and less than 1 month -> Request in weeks  else if (startdatetime > enddatetime.AddMonths (-1)) {  	int numberOfWeeksToRequest = (int)Math.Ceiling (duration.TotalDays / 7.0);  	durationstring = numberOfWeeksToRequest.ToString () + " W";  }  else {  	throw new ArgumentOutOfRangeException ("Period cannot be bigger than 52 weeks.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddMonths (-1)) {  	int numberOfWeeksToRequest = (int)Math.Ceiling (duration.TotalDays / 7.0);  	durationstring = numberOfWeeksToRequest.ToString () + " W";  }  else {  	throw new ArgumentOutOfRangeException ("Period cannot be bigger than 52 weeks.");  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,error,The following statement contains a magic number: if (errorCode == 202)// Order Cancelled   {  	try {  		OnGotOrderCancel (_iborderIdToOrderInfo [id].StrategyOrderId);  	}  	catch {  		OnDebug ("A non-exist order to be cancelled.");  	}  }  else {  	string str = "requestId = " + id + "; Error code = " + errorCode + "; Error Message = " + errorMsg;  	OnDebug (str);  }  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeDate = dt.Year * 10000 + dt.Month * 100 + dt.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeDate = dt.Year * 10000 + dt.Month * 100 + dt.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeTime = dt.Hour * 10000 + dt.Minute * 100 + dt.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeTime = dt.Hour * 10000 + dt.Minute * 100 + dt.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,GetMultiplier,The following statement contains a magic number: if (symbol == "ES")  	multiplier = 50;  
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,GetMultiplier,The following statement contains a magic number: multiplier = 50;  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.Id = Convert.ToInt64 (rec [2]);  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.Account = rec [3];  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.FullSymbol = rec [4];  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.OrderSize = Convert.ToInt32 (rec [5]);  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.LimitPrice = Convert.ToDecimal (rec [6]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.StopPrice = Convert.ToDecimal (rec [7]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.TrailPrice = Convert.ToDecimal (rec [8]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.Currency = rec [9];  
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: Enum.TryParse<TimeInForce> (rec [10]' out tif);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	_fills.Clear ();  	_fills.AddRange (trades);  	List<decimal> moneyinuse = new List<decimal> ();  	// money in use  	List<decimal> tradepnl = new List<decimal> ();  	List<int> days = new List<int> ();  	// hostorical trading days when the trades happened  	Dictionary<string' int> tradecount = new Dictionary<string' int> ();  	// symbol --> trade count  	List<decimal> negret = new List<decimal> (_fills.Count);  	int consecWinners = 0;  	int consecLosers = 0;  	List<long> exitscounted = new List<long> ();  	decimal winpl = 0;  	decimal losepl = 0;  	foreach (Trade trade in _fills) {  		if (tradecount.ContainsKey (trade.FullSymbol))  			tradecount [trade.FullSymbol]++;  		else  			tradecount.Add (trade.FullSymbol' 1);  		if (!days.Contains (trade.TradeDate))  			days.Add (trade.TradeDate);  		int usizebefore = 0;  		decimal closedpnlfromthistrade = 0;  		if (_positions.ContainsKey (trade.FullSymbol)) {  			usizebefore = _positions [trade.FullSymbol].UnsignedSize;  			closedpnlfromthistrade = _positions [trade.FullSymbol].Adjust (trade);  			// closed pnl  		}  		else {  			// add the trade to position  			_positions.Add (trade.FullSymbol' new Position (trade));  			usizebefore = 0;  			closedpnlfromthistrade = 0;  		}  		bool isroundturn = (usizebefore != 0) && (_positions [trade.FullSymbol].UnsignedSize == 0);  		// end at exact 0  		bool isclosing = _positions [trade.FullSymbol].UnsignedSize < usizebefore;  		// calculate MIU and store on array  		decimal miu = Calc.Sum (Calc.MoneyInUse (_positions));  		if (miu != 0)  			moneyinuse.Add (miu);  		// if we closed something' update return  		if (isclosing) {  			// get p&l for portfolio  			decimal pl = Calc.Sum (Calc.AbsoluteReturn (_positions));  			// with one param' AbsoluteReturn returns closed pnl  			// count return  			tradepnl.Add (pl);  			// get pct return for portfolio  			decimal pctret = moneyinuse [moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse [moneyinuse.Count - 1];  			// if it is below our zero' count it as negative return  			if (pctret < 0)  				negret.Add (pl);  		}  		if (isroundturn)// # of RoundTurns = RoundWinners + RoundLosers  		 {  			RoundTurns++;  			if (closedpnlfromthistrade >= 0)  				RoundWinners++;  			else if (closedpnlfromthistrade < 0)  				RoundLosers++;  		}  		Trades++;  		SharesTraded += Math.Abs (trade.TradeSize);  		Commissions += CalculateIBCommissions (trade);  		GrossPL += closedpnlfromthistrade;  		if ((closedpnlfromthistrade > 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellWins++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyWins++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Winners++;  			consecWinners++;  			consecLosers = 0;  		}  		else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains (trade.Id)) {  			if (trade.Side) {  				SellLosers++;  				SellPL += closedpnlfromthistrade;  			}  			else {  				BuyLosers++;  				BuyPL += closedpnlfromthistrade;  			}  			if (trade.Id != 0)  				exitscounted.Add (trade.Id);  			Losers++;  			consecLosers++;  			consecWinners = 0;  		}  		if (closedpnlfromthistrade > 0)  			winpl += closedpnlfromthistrade;  		else if (closedpnlfromthistrade < 0)  			losepl += closedpnlfromthistrade;  		if (consecWinners > ConsecWin)  			ConsecWin = consecWinners;  		if (consecLosers > ConsecLose)  			ConsecLose = consecLosers;  		if ((_positions [trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0))  			Flats++;  		if (closedpnlfromthistrade > MaxWin)  			MaxWin = closedpnlfromthistrade;  		if (closedpnlfromthistrade < MaxLoss)  			MaxLoss = closedpnlfromthistrade;  		if (_positions [trade.FullSymbol].OpenPL > MaxOpenWin)  			MaxOpenWin = _positions [trade.FullSymbol].OpenPL;  		if (_positions [trade.FullSymbol].OpenPL < MaxOpenLoss)  			MaxOpenLoss = _positions [trade.FullSymbol].OpenPL;  	}  	// end of loop over trades  	if (Trades != 0) {  		AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  		AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  		AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  		MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  		MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  		MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  		MaxDD = Calc.MaxDDPct (_fills);  		SymbolCount = _positions.Count;  		DaysTraded = days.Count;  		GrossPerDay = Math.Round (GrossPL / days.Count' 2);  		GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  		if (PerSymbol) {  			foreach (KeyValuePair<string' Position> item in _positions) {  				PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  			}  		}  	}  	else {  		MoneyInUse = 0;  		MaxPL = 0;  		MinPL = 0;  		MaxDD = 0;  		GrossPerDay = 0;  		GrossPerSymbol = 0;  	}  	// ratio measures  	try {  		SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  	}  	catch (Exception ex) {  		Debug ("sharpe error: " + ex.Message);  	}  	try {  		if (tradepnl.Count == 0)  			SortinoRatio = 0;  		else if (negret.Count == 1)  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  			SortinoRatio = 0;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MaxValue;  		else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  			SortinoRatio = 0;  		//SortinoRatio = decimal.MinValue;  		else  			SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  	}  	catch (Exception ex) {  		Debug ("sortino error: " + ex.Message);  	}  }  catch (Exception ex) {  	Debug ("error in generating performance report" + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (Trades != 0) {  	AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  	AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  	AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  	MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  	MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  	MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  	MaxDD = Calc.MaxDDPct (_fills);  	SymbolCount = _positions.Count;  	DaysTraded = days.Count;  	GrossPerDay = Math.Round (GrossPL / days.Count' 2);  	GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  	if (PerSymbol) {  		foreach (KeyValuePair<string' Position> item in _positions) {  			PerSymbolStats.Add (item.Value.FullSymbol' tradecount [item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString ("C2"));  		}  	}  }  else {  	MoneyInUse = 0;  	MaxPL = 0;  	MinPL = 0;  	MaxDD = 0;  	GrossPerDay = 0;  	GrossPerSymbol = 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: AvgPerTrade = Math.Round ((losepl + winpl) / Trades' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: AvgLoser = Losers == 0 ? 0 : Math.Round (losepl / Losers' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: AvgWin = Winners == 0 ? 0 : Math.Round (winpl / Winners' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: MoneyInUse = Math.Round (Calc.Max (moneyinuse.ToArray ())' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: MaxPL = Math.Round (Calc.Max (tradepnl.ToArray ())' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: MinPL = Math.Round (Calc.Min (tradepnl.ToArray ())' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: GrossPerDay = Math.Round (GrossPL / days.Count' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: GrossPerSymbol = Math.Round (GrossPL / _positions.Count' 2);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  }  catch (Exception ex) {  	Debug ("sharpe error: " + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  }  catch (Exception ex) {  	Debug ("sharpe error: " + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  }  catch (Exception ex) {  	Debug ("sharpe error: " + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round (Calc.SharpeRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (tradepnl.ToArray ())' (RiskFreeRate * MoneyInUse * DaysTraded / 252))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try {  	if (tradepnl.Count == 0)  		SortinoRatio = 0;  	else if (negret.Count == 1)  		SortinoRatio = 0;  	else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  		SortinoRatio = 0;  	else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  		SortinoRatio = 0;  	//SortinoRatio = decimal.MaxValue;  	else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  		SortinoRatio = 0;  	//SortinoRatio = decimal.MinValue;  	else  		SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  }  catch (Exception ex) {  	Debug ("sortino error: " + ex.Message);  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (tradepnl.Count == 0)  	SortinoRatio = 0;  else if (negret.Count == 1)  	SortinoRatio = 0;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  	SortinoRatio = 0;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MaxValue;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MinValue;  else  	SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if (negret.Count == 1)  	SortinoRatio = 0;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  	SortinoRatio = 0;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MaxValue;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MinValue;  else  	SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] == 0))  	SortinoRatio = 0;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MaxValue;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MinValue;  else  	SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] > 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MaxValue;  else if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MinValue;  else  	SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: if ((negret.Count == 0) && (tradepnl [tradepnl.Count - 1] < 0))  	SortinoRatio = 0;  //SortinoRatio = decimal.MinValue;  else  	SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: SortinoRatio = Math.Round (Calc.SortinoRatio (tradepnl [tradepnl.Count - 1]' Calc.StdDev (negret.ToArray ())' (RiskFreeRate * MoneyInUse))' 3);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains ("STK")) {  	return (decimal)Math.Max (0.005 * Math.Abs (t.TradeSize)' 1);  }  else if (t.FullSymbol.Contains ("FUT")) {  	return 2.01m * Math.Abs (t.TradeSize);  }  else if (t.FullSymbol.Contains ("OPT")) {  	return Math.Max (0.70m * Math.Abs (t.TradeSize)' 1);  }  else if (t.FullSymbol.Contains ("CASH")) {  	return Math.Max (0.000002m * (t.TradePrice * t.TradeSize)' 2);  }  else {  	return 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains ("STK")) {  	return (decimal)Math.Max (0.005 * Math.Abs (t.TradeSize)' 1);  }  else if (t.FullSymbol.Contains ("FUT")) {  	return 2.01m * Math.Abs (t.TradeSize);  }  else if (t.FullSymbol.Contains ("OPT")) {  	return Math.Max (0.70m * Math.Abs (t.TradeSize)' 1);  }  else if (t.FullSymbol.Contains ("CASH")) {  	return Math.Max (0.000002m * (t.TradePrice * t.TradeSize)' 2);  }  else {  	return 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: return (decimal)Math.Max (0.005 * Math.Abs (t.TradeSize)' 1);  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains ("FUT")) {  	return 2.01m * Math.Abs (t.TradeSize);  }  else if (t.FullSymbol.Contains ("OPT")) {  	return Math.Max (0.70m * Math.Abs (t.TradeSize)' 1);  }  else if (t.FullSymbol.Contains ("CASH")) {  	return Math.Max (0.000002m * (t.TradePrice * t.TradeSize)' 2);  }  else {  	return 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains ("OPT")) {  	return Math.Max (0.70m * Math.Abs (t.TradeSize)' 1);  }  else if (t.FullSymbol.Contains ("CASH")) {  	return Math.Max (0.000002m * (t.TradePrice * t.TradeSize)' 2);  }  else {  	return 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains ("CASH")) {  	return Math.Max (0.000002m * (t.TradePrice * t.TradeSize)' 2);  }  else {  	return 0;  }  
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: return Math.Max (0.000002m * (t.TradePrice * t.TradeSize)' 2);  
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: _exchange = str [2];  
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: if (str.Length > 3 && str [3] != "")  	_multiplier = Int32.Parse (str [3]);  
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: if (str.Length > 3 && str [3] != "")  	_multiplier = Int32.Parse (str [3]);  
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: if (str.Length > 3 && str [3] != "")  	_multiplier = Int32.Parse (str [3]);  
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: _multiplier = Int32.Parse (str [3]);  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse (r [2]' out i))  	t.Time = i;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (decimal.TryParse (r [3]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d))  	t.TradePrice = d;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse (r [4]' out i))  	t.TradeSize = i;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (decimal.TryParse (r [5]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d))  	t.BidPrice = d;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse (r [6]' out i))  	t.BidSize = i;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (decimal.TryParse (r [7]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d))  	t.AskPrice = d;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse (r [8]' out i))  	t.AskSize = i;  
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse (r [9]' out i))  	t.Depth = i;  
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: if (ts.Length < 14)  	throw new Exception ("Invalid trade");  
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradeDate = Convert.ToInt32 (ts [2]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradeTime = Convert.ToInt32 (ts [3]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.FullSymbol = ts [4];  
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradeSize = Convert.ToInt32 (ts [5]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradePrice = Convert.ToDecimal (ts [6]' System.Globalization.CultureInfo.InvariantCulture);  
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: Port = 7496;  
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: TickQueueCapacity = 50000;  
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: TickSampleTime = 10;  
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: DailyOrderCapacity = 500;  
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: DecimalPlace = 2;  
Magic Number,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,ToString,The following statement contains a magic number: return ToString (2);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntDate,The following statement contains a magic number: return (dt.Year * 10000) + (dt.Month * 100) + dt.Day;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntDate,The following statement contains a magic number: return (dt.Year * 10000) + (dt.Month * 100) + dt.Day;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return (dt.Hour * 10000) + (dt.Minute * 100) + (dt.Second);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return (dt.Hour * 10000) + (dt.Minute * 100) + (dt.Second);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return hour * 10000 + min * 100 + sec;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return hour * 10000 + min * 100 + sec;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (sec > 59) {  	sec -= 60;  	min++;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (sec > 59) {  	sec -= 60;  	min++;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: sec -= 60;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (min > 59) {  	hour++;  	min -= 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (min > 59) {  	hour++;  	min -= 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: min -= 60;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0) {  	int ym = (date % 10000);  	year = (int)((date - ym) / 10000);  	int mm = ym % 100;  	month = (int)((ym - mm) / 100);  	day = mm;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0) {  	int ym = (date % 10000);  	year = (int)((date - ym) / 10000);  	int mm = ym % 100;  	month = (int)((ym - mm) / 100);  	day = mm;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0) {  	int ym = (date % 10000);  	year = (int)((date - ym) / 10000);  	int mm = ym % 100;  	month = (int)((ym - mm) / 100);  	day = mm;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0) {  	int ym = (date % 10000);  	year = (int)((date - ym) / 10000);  	int mm = ym % 100;  	month = (int)((ym - mm) / 100);  	day = mm;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: year = (int)((date - ym) / 10000);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: month = (int)((ym - mm) / 100);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: return h1 * 3600 + m1 * 60 + s1;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: return h1 * 3600 + m1 * 60 + s1;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (s1 >= 60) {  	m1 += (int)(s1 / 60);  	s1 = s1 % 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (s1 >= 60) {  	m1 += (int)(s1 / 60);  	s1 = s1 % 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (s1 >= 60) {  	m1 += (int)(s1 / 60);  	s1 = s1 % 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: m1 += (int)(s1 / 60);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: s1 = s1 % 60;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (m1 >= 60) {  	h1 += (int)(m1 / 60);  	m1 = m1 % 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (m1 >= 60) {  	h1 += (int)(m1 / 60);  	m1 = m1 % 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (m1 >= 60) {  	h1 += (int)(m1 / 60);  	m1 = m1 % 60;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: h1 += (int)(m1 / 60);  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: m1 = m1 % 60;  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,Sendemail,The following statement contains a magic number: try {  	// Send mail  	// gmail = ConfigurationManager.AppSettings["gmailacct"];  	// pwd = ConfigurationManager.AppSettings["gmailpwd"];  	string emailfrom' pwd' emailto;  	emailfrom = EmailFrom;  	emailto = EmailTo;  	pwd = EmailPass;  	MailMessage mail = new MailMessage ();  	mail.From = new MailAddress (emailfrom);  	string[] toaddr = emailto.Split (';');  	foreach (string s in toaddr)  		mail.To.Add (s);  	mail.Subject = subject;  	mail.Body = body;  	mail.IsBodyHtml = useHTML;  	if (!string.IsNullOrEmpty (attachfilepathname)) {  		System.Net.Mail.Attachment attachment;  		attachment = new System.Net.Mail.Attachment (attachfilepathname);  		mail.Attachments.Add (attachment);  	}  	SmtpClient smtpServer = new SmtpClient ("smtp.gmail.com");  	smtpServer.Port = 587;  	smtpServer.Credentials = new System.Net.NetworkCredential (emailfrom' pwd);  	smtpServer.EnableSsl = true;  	smtpServer.Send (mail);  }  catch (Exception) {  	throw;  }  
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,Sendemail,The following statement contains a magic number: smtpServer.Port = 587;  
