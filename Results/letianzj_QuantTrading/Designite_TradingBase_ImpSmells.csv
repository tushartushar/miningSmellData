Implementation smell,Namespace,Class,File,Method,Description
Long Method,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The method has 103 lines of code.
Long Method,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The method has 186 lines of code.
Long Method,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The method has 104 lines of code.
Complex Method,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,Cyclomatic complexity of the method is 18
Complex Method,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,NewTick,Cyclomatic complexity of the method is 12
Complex Method,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,NewTick,Cyclomatic complexity of the method is 9
Complex Method,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,openOrder,Cyclomatic complexity of the method is 8
Complex Method,TradingBase,OrderBook,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\OrderBook.cs,GotTick,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,Cyclomatic complexity of the method is 25
Complex Method,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Adjust,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,TickWatcher,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickWatcher.cs,newTick,Cyclomatic complexity of the method is 12
Complex Method,TradingBase,TickWatcher,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickWatcher.cs,_bw_DoWork,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,EnumDescConverter,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\EnumDescConverter.cs,GetEnumValue,Cyclomatic complexity of the method is 10
Complex Method,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,Cyclomatic complexity of the method is 14
Complex Method,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,Adjust,Cyclomatic complexity of the method is 8
Long Parameter List,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,Bar,The method has 9 parameters. Parameters: o' h' l' c' v' date' order' fullsymbol' interval
Long Parameter List,TradingBase,BarIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarIntervalData.cs,NewPoint,The method has 5 parameters. Parameters: symbol' p' time' date' size
Long Parameter List,TradingBase,BarRequest,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarRequest.cs,BarRequest,The method has 7 parameters. Parameters: fullsymbol' interval' startdate' starttime' enddate' endtime' client
Long Parameter List,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,NewPoint,The method has 5 parameters. Parameters: symbol' p' time' date' size
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updatePortfolio,The method has 8 parameters. Parameters: contract' position' marketPrice' marketValue' averageCost' unrealisedPNL' realisedPNL' accountName
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The method has 6 parameters. Parameters: tickerId' position' operation' side' price' size
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The method has 7 parameters. Parameters: tickerId' position' marketMaker' operation' side' price' size
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The method has 10 parameters. Parameters: reqId' date' open' high' low' close' volume' count' WAP' hasGaps
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickEFP,The method has 9 parameters. Parameters: tickerId' tickType' basisPoints' formattedBasisPoints' impliedFuture' holdDays' futureExpiry' dividendImpact' dividendsToExpiry
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickOptionComputation,The method has 10 parameters. Parameters: tickerId' field' impliedVolatility' delta' optPrice' pvDividend' gamma' vega' theta' undPrice
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,accountSummary,The method has 5 parameters. Parameters: reqId' account' tag' value' currency
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,orderStatus,The method has 10 parameters. Parameters: orderId' status' filled' remaining' avgFillPrice' permId' parentId' lastFillPrice' clientId' whyHeld
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,realtimeBar,The method has 9 parameters. Parameters: reqId' time' open' high' low' close' volume' WAP' count
Long Parameter List,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,scannerData,The method has 7 parameters. Parameters: reqId' rank' contractDetails' distance' benchmark' projection' legsStr
Long Parameter List,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Order,The method has 6 parameters. Parameters: symbol' size' id' p' s' t
Long Parameter List,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Order,The method has 9 parameters. Parameters: symbol' size' id' p' s' t' date' time' tif
Long Parameter List,TradingBase,MarketOrderFlat,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,MarketOrderFlat,The method has 5 parameters. Parameters: p' percent' normalizeSize' MinimumLotSize' id
Long Parameter List,TradingBase,StopLimitOrder,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,StopLimitOrder,The method has 5 parameters. Parameters: sym' size' price' stop' orderid
Long Parameter List,TradingBase,TrailingStopLimitOrder,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,TrailingStopLimitOrder,The method has 5 parameters. Parameters: sym' size' limit' trailing' orderid
Long Parameter List,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Position,The method has 5 parameters. Parameters: symbol' price' size' closedpl' account
Long Parameter List,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,NewTrade,The method has 5 parameters. Parameters: fullsym' date' time' trade' size
Long Parameter List,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Trade,The method has 5 parameters. Parameters: fullname' fillprice' fillsize' filldate' filltime
Long Parameter List,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionProfit,The method has 5 parameters. Parameters: p' offset' percent' normalizesize' MINSIZE
Long Parameter List,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionStop,The method has 5 parameters. Parameters: p' offset' percent' normalizesize' MINSIZE
Long Parameter List,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,Log,The method has 5 parameters. Parameters: path' logname' dateinlogname' appendtolog' timestamps
Long Parameter List,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,OffsetInfo,The method has 6 parameters. Parameters: profitdist' stopdist' profitpercent' stoppercent' NormalizeSize' MinSize
Long Identifier,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,,The length of the parameter SecurityFullNameToGoogleSymbol is 30.
Long Statement,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The length of the statement  "            if ((first.FullSymbol != second.FullSymbol) || (first.OrderSide != second.OrderSide) || !first.IsLimit || !second.IsLimit) " is 122.
Long Statement,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,CancelOrder,The length of the statement  "                        OnGotOrderCancelBroadcast(orderlist[i].FullSymbol' orderlist[i].OrderSide' orderid); //send cancel notifcation to any subscribers " is 129.
Long Statement,TradingBase,simworker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,simworker_DoWork,The length of the statement  "                // while simulation hasn't been canceled' we still have historical ticks to read and we haven't read too many' cache a tick " is 123.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,Play,The length of the statement  "                    Debug("optimize " + id + " finished.  Used: " + value + " -> " + OptimizeDecisionsName + ": " + rv + " trades: " + trades.Count + " SimsRemaining: " + OptimizeRemain); " is 167.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,ChangeValue,The length of the statement  "                Debug("error setting parameter " + OptimizeName + " on strategy: " + s.FullName + " to: " + v + " err: " + ex.Message + ex.StackTrace); " is 135.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,GetResult,The length of the statement  "                Debug("error getting result from OptimizeDecision name: " + OptimizeDecisionsName + " err: " + ex.Message + ex.StackTrace); " is 123.
Long Statement,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,DeepClone,The length of the statement  "                System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bf = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter(); " is 137.
Long Statement,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,GetBar,The length of the statement  "            b = new Bar(opens[index]' highs[index]' lows[index]' closes[index]' vols[index]' dates[index]' orders[index]' symbol' intervallength); " is 134.
Long Statement,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestMarketData,The length of the statement  "                var task = Task.Factory.StartNew(() => GetQuoteLoop(cancellationtoken)' cancellationtoken' TaskCreationOptions.LongRunning' TaskScheduler.Default) " is 146.
Long Statement,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The length of the statement  "                        //DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time " is 128.
Long Statement,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The length of the statement  "            DateTime dt = DateTime.ParseExact(execution.Time' "yyyyMMdd  HH:mm:ss"' CultureInfo.InvariantCulture);       // Two blanks " is 122.
Long Statement,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,openOrder,The length of the statement  "            o.LimitPrice = ((order.OrderType == "LMT") || (order.OrderType == "TRAIL LIMIT") || (order.OrderType == "STP LMT")) ? (decimal)order.LmtPrice : 0m; " is 147.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The length of the statement  "                            PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2")); " is 124.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The length of the statement  "                    SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3); " is 180.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The length of the statement  "                        SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3); " is 138.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,FillGrid,The length of the statement  "                table.Rows.Add(new string[] { fi.Name' (format != null) ? string.Format(format' fi.GetValue(this)) : fi.GetValue(this).ToString() }); " is 133.
Long Statement,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,FillGrid,The length of the statement  "                table.Rows.Add(new string[] { pi.Name' (format != null) ? string.Format(format' pi.GetValue(this' null)) : pi.GetValue(this' null).ToString() }); " is 145.
Long Statement,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Adjust,The length of the statement  "            if ((_fullsymbol!="") && (this._fullsymbol != pos._fullsymbol)) throw new Exception("Failed because adjustment symbol did not match position symbol"); " is 150.
Long Statement,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Adjust,The length of the statement  "            if (!pos.isValid) throw new Exception("Invalid position adjustment' existing:" + this.ToString() + " adjustment:" + pos.ToString()); " is 132.
Long Statement,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The length of the statement  "            if (decimal.TryParse(r[3]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d)) " is 124.
Long Statement,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The length of the statement  "            if (decimal.TryParse(r[5]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d)) " is 124.
Long Statement,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The length of the statement  "            if (decimal.TryParse(r[7]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d)) " is 124.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,ClosePT,The length of the statement  "                throw new Exception("Invalid position provided. (existing:" + existing.ToString() + " adjustment:" + adjust.ToString()); " is 120.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,ClosePL,The length of the statement  "            int closedsize = Math.Abs(adjust.TradeSize) > existing.UnsignedSize ? existing.UnsignedSize : Math.Abs(adjust.TradeSize); " is 121.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionProfit,The length of the statement  "            int size = percent == 0 ? 0 : (!normalizesize ? (int)(p.FlatSize * percent) : Calc.Norm2Min(p.FlatSize * percent' MINSIZE)); " is 124.
Long Statement,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,PositionStop,The length of the statement  "            int size = percent == 0 ? 0 : (!normalizesize ? (int)(p.FlatSize * percent) : Calc.Norm2Min(p.FlatSize * percent' MINSIZE)); " is 124.
Long Statement,TradingBase,EnumDescConverter,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\EnumDescConverter.cs,GetEnumValue,The length of the statement  "            throw new InvalidCastException(string.Concat("The received value "' description' " was unrecognized as an "' value.Name' " enum value.")); " is 138.
Long Statement,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,ToString,The length of the statement  "            return string.Format("p{0}/{1:p0} s{2}/{3:p0}"' ProfitDist.ToString("N" + decimals.ToString())' ProfitPercent' StopDist.ToString("N" + decimals.ToString())' StopPercent); " is 170.
Long Statement,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,Serialize,The length of the statement  "                string.Format("{0}'{1}'{2}'{3}'{4}'{5}"' oi.ProfitDist' oi.StopDist' oi.ProfitPercent' oi.StopPercent' oi.NormalizeSize' oi.MinimumLotSize); " is 140.
Long Statement,TradingBase,OversellProtector,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OversellProtector.cs,sendorder,The length of the statement  "                debug(o.FullSymbol + " oversell detected on pos: "+size+" order adjustment: " + osize + "->" + size + " " + o.ToString()); " is 122.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,SecurityFromFileName,The length of the statement  "                string ds = System.Text.RegularExpressions.Regex.Match(filename' "([0-9]{8})[.]"' System.Text.RegularExpressions.RegexOptions.IgnoreCase).Result("$1"); " is 151.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,DateFromFileName,The length of the statement  "                string ds = System.Text.RegularExpressions.Regex.Match(filename' "([0-9]{8})[.]"' System.Text.RegularExpressions.RegexOptions.IgnoreCase).Result("$1"); " is 151.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,isTickFile,The length of the statement  "            return System.Text.RegularExpressions.Regex.IsMatch(path' "TXT"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 121.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,isStrategyFile,The length of the statement  "            return System.Text.RegularExpressions.Regex.IsMatch(path' "DLL"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 121.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,loadFile,The length of the statement  "            System.IO.FileStream fs = new System.IO.FileStream(filename' System.IO.FileMode.Open' System.IO.FileAccess.Read' System.IO.FileShare.ReadWrite); " is 144.
Long Statement,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IsStrategyDLL,The length of the statement  "            return System.Text.RegularExpressions.Regex.IsMatch(path' "DLL"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 121.
Complex Conditional,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The conditional expression  "(first.FullSymbol != second.FullSymbol) || (first.OrderSide != second.OrderSide) || !first.IsLimit || !second.IsLimit"  is complex.
Complex Conditional,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The conditional expression  "(first.OrderSide && (first.LimitPrice > second.LimitPrice)) || // if first is better' use it                  (!first.OrderSide && (first.LimitPrice < second.LimitPrice))"  is complex.
Complex Conditional,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,BestBidOrOffer,The conditional expression  "(first.OrderSide && (first.LimitPrice < second.LimitPrice)) || // if second is better' use it                  (!first.OrderSide && (first.LimitPrice > second.LimitPrice))"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Fill,The conditional expression  "(IsLimit && OrderSide && (p <= LimitPrice)) // buy limit                  || (IsLimit && !OrderSide && (p >= LimitPrice))// sell limit                  || (IsStop && OrderSide && (p >= StopPrice)) // buy stop                  || (IsStop && !OrderSide && (p <= StopPrice)) // sell stop                  || IsMarket"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,FillHighLiquidityEOD,The conditional expression  "(IsLimit && OrderSide && (p <= LimitPrice)) // buy limit               || (IsLimit && !OrderSide && (p >= LimitPrice))"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,FillHighLiquidityEOD,The conditional expression  "(IsStop && OrderSide && (p >= StopPrice)) // buy stop                    || (IsStop && !OrderSide && (p <= StopPrice))"  is complex.
Complex Conditional,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Fill,The conditional expression  "(IsLimit && OrderSide && (o.LimitPrice <= LimitPrice)) // buy limit cross                  || (IsLimit && !OrderSide && (o.LimitPrice >= LimitPrice))// sell limit cross                  || (IsStop && OrderSide && (o.LimitPrice >= StopPrice)) // buy stop                  || (IsStop && !OrderSide && (o.LimitPrice <= StopPrice)) // sell stop                  || IsMarket"  is complex.
Complex Conditional,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,newPoint,The conditional expression  "(refp == 0)                  || (_pt[symbol].isLong && (refp < p))                  || (_pt[symbol].isShort && (refp > p))"  is complex.
Complex Conditional,TradingBase,TrailTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\TrailTracker.cs,newPoint,The conditional expression  "!_pendingfill[idx] && (trail.StopDist != 0) && trailtest && (MaxFireCount > firecount[symbol])"  is complex.
Complex Conditional,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Adjust,The conditional expression  "(pos.isLong && this.isLong) || (!pos.isLong && !this.isLong)"  is complex.
Complex Conditional,TradingBase,TickWatcher,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickWatcher.cs,_bw_DoWork,The conditional expression  "!alltrading && !sentmissingfirstticks                      && (_starttime != 0) && (_lasttime > _starttime)"  is complex.
Complex Conditional,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The conditional expression  "(updatestop && off.hasStop && !CancelOnce)                  || (updatestop && off.hasStop && CancelOnce && !off.StopcancelPending)"  is complex.
Complex Conditional,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The conditional expression  "(updateprofit && off.hasProfit && AllowSimulatenousCancels) ||                  (updateprofit && off.hasProfit && AllowSimulatenousCancels && !sentcancel)"  is complex.
Complex Conditional,TradingBase,OffsetTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetTracker.cs,doupdate,The conditional expression  "(!off.hasProfit && AllowSimulatenousOrders) || (!off.hasProfit && !AllowSimulatenousOrders && !sentorder)"  is complex.
Virtual Method Call from Constructor,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,BacktestEngine,The constructor "BacktestEngine" calls a virtual method "Reset".
Empty Catch Block,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,UnbindStrategy,The method has an empty catch block.
Empty Catch Block,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,AddOrder,The method has an empty catch block.
Empty Catch Block,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,TickArchiver,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickArchiver.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,TickArchiver,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\TickArchiver.cs,newTick,The method has an empty catch block.
Empty Catch Block,TradingBase,ConnectionTracker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConnectionTracker.cs,Stop,The method has an empty catch block.
Empty Catch Block,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,setfile,The method has an empty catch block.
Empty Catch Block,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,GotDebug,The method has an empty catch block.
Empty Catch Block,TradingBase,Log,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Log.cs,Stop,The method has an empty catch block.
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,Play,The following statement contains a magic number: int time = (int)(_histsim.NextTickTime % 100000);
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,Play,The following statement contains a magic number: long date = (_histsim.NextTickTime / 100000) * 100000;
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,Play,The following statement contains a magic number: long date = (_histsim.NextTickTime / 100000) * 100000;
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: if (t.FullSymbol.Contains("STK"))              {                  t.BidSize *= 100;                  t.AskSize *= 100;                  t.TradeSize *= 100;              }
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: if (t.FullSymbol.Contains("STK"))              {                  t.BidSize *= 100;                  t.AskSize *= 100;                  t.TradeSize *= 100;              }
Magic Number,TradingBase,BacktestEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\BacktestEngine.cs,_histsim_GotTick,The following statement contains a magic number: if (t.FullSymbol.Contains("STK"))              {                  t.BidSize *= 100;                  t.AskSize *= 100;                  t.TradeSize *= 100;              }
Magic Number,TradingBase,Broker,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\Broker.cs,Execute,The following statement contains a magic number: for (int idx = 0; idx < accts.Length; idx++)              {                   Account a = accts[idx];                  // if account has requested no executions' skip it                  if (!a.Execute) continue;                  // make sure we have a record for this account                  if (!_mastertrades.ContainsKey(a.ID))                      _mastertrades.Add(a.ID' new List<Trade>());                  // track orders being removed and trades that need notification                  List<int> notifytrade = new List<int>();                  List<int> remove = new List<int>();                  // go through each order in the account                  for (int i = 0; i < _masterorders[a].Count; i++)                  {                      Order o = _masterorders[a][i];                      //make sure tick is for the right stock                      if (tick.FullSymbol != o.FullSymbol)                          continue;                      bool filled = false;                      if (UseHighLiquidityFillsEOD)                      {                          Order oi = (Order)o;                          filled = oi.FillHighLiquidityEOD(tick' _usebidaskfill' false);                      }                      else if (o.TIF <= TimeInForce.GTC)                      {                          filled = o.Fill(tick' _usebidaskfill' false); // fill our trade                      }                      else if (o.TIF == TimeInForce.OPG)                      {                          // if it's already opened' we missed our shot                          if (_hasopened.Contains(o.FullSymbol))                              continue;                          // otherwise make sure it's really the opening                          //if (tick.Exchange == OPGEX)                          {                              // it's the opening tick' so fill it as an opg                              filled = o.Fill(tick' _usebidaskfill' true);                              // mark this symbol as already being open                              _hasopened.Add(tick.FullSymbol);                          }                        }                      // other orders fill normally' except MOC orders which are at 4:00PM                      else if (o.TIF == TimeInForce.MOC)                      {                          if (tick.Time >= 160000)                              filled = o.Fill(tick' _usebidaskfill' false); // fill our trade                      }                      else                          filled = o.Fill(tick' _usebidaskfill' false); // fill our trade                        if (filled)                      {                          // get copy of trade for recording                          Trade trade = new Trade((Trade)o);                                                    // remove filled size from size available in trade                          if (_adjustincomingticksize)                          {                              if (_usebidaskfill)                              {                                  if (o.Side)                                      tick.AskSize -= trade.UnsignedSize;                                  else                                      tick.BidSize -= trade.UnsignedSize;                              }                              else                                  tick.TradeSize -= trade.UnsignedSize;                          }                                                    // if trade represents entire requested order' mark order for removal                          if (trade.UnsignedSize == o.UnsignedSize)                              remove.Add(i);                          else // otherwise reflect order's remaining size                              o.OrderSize = (o.UnsignedSize - trade.UnsignedSize) * (o.OrderSide ? 1 : -1);                            // record trade                          _mastertrades[a.ID].Add(trade);                          // mark it for notification                          notifytrade.Add(_mastertrades[a.ID].Count - 1);                          // count the trade                          filledorders++;                      }                  }                  int rmcount = remove.Count;                  // remove the filled orders                  for (int i = remove.Count - 1; i >= 0; i--)                      _masterorders[a].RemoveAt(remove[i]);                  // unmark filled orders as pending                  _pendingorders -= rmcount;                  if (_pendingorders < 0) _pendingorders = 0;                  // notify subscribers of trade                  if (a.Notify)                      for (int tradeidx = 0; tradeidx < notifytrade.Count; tradeidx++)                          OnGotFill(_mastertrades[a.ID][notifytrade[tradeidx]]);                }
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: for (int i = 0; i < Workers.Count; i++)              {                  // for some reason background worker is slow exiting' recreate                  if (Workers[i].IsBusy)                  {                      DebugWithTime(Workers[i].Name + " worker#" + i + " is busy' waiting till free...");                      // retry                      while (Workers[i].IsBusy)                      {                          System.Threading.Thread.Sleep(10);                      }                      DebugWithTime(Workers[i].Name + " is no longer busy.");                      System.Threading.Thread.Sleep(10);                  }                  Workers[i].RunWorkerAsync(readahead);                  Debug(Workers[i].Name + " worker# " + i + " now is working.");                }
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FillCache,The following statement contains a magic number: for (int i = 0; i < Workers.Count; i++)              {                  // for some reason background worker is slow exiting' recreate                  if (Workers[i].IsBusy)                  {                      DebugWithTime(Workers[i].Name + " worker#" + i + " is busy' waiting till free...");                      // retry                      while (Workers[i].IsBusy)                      {                          System.Threading.Thread.Sleep(10);                      }                      DebugWithTime(Workers[i].Name + " is no longer busy.");                      System.Threading.Thread.Sleep(10);                  }                  Workers[i].RunWorkerAsync(readahead);                  Debug(Workers[i].Name + " worker# " + i + " now is working.");                }
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCache,The following statement contains a magic number: while (simrunning)              {                  // get next times of ticks in cache                  long[] times = nexttimes();                  // copy our master index list into a temporary for sorting                  Buffer.BlockCopy(idx' 0' cidx' 0' idx.Length * 4);                  // sort loaded instruments by time                  Array.Sort(times' cidx);                  int nextidx = 0;                  // get next time from all instruments we have loaded                  while ((nextidx < times.Length) && (times[nextidx] == -1))                      nextidx++;                  // test to see if ticks left in simulation                  bool ticksleft = (nextidx < times.Length);                  bool simtimeleft = ticksleft && (times[nextidx] <= endsim);                  simrunning = ticksleft && simtimeleft;                  // if no ticks left or we exceeded simulation time' quit                  if (!simrunning)                  {                      if (!ticksleft)                          DebugWithTime("No ticks left.");                      if (!simtimeleft)                          DebugWithTime("Hit end of simulation.");                        break;                  }                  // get next tick                  Tick k = Workers[cidx[nextidx]].NextTick();                  // time check                  orderok &= k.Datetime >= lasttime;                  if (orderok != lastorderok)                  {                      DebugWithTime("tick out of order: " + k.FullSymbol + " w/" + k.Datetime + " behind: " + lasttime);                      lastorderok = orderok;                  }                  // update time                  lasttime = k.Datetime;                  // notify tick                  OnGotTick(k);                  // count tick                  _tickcount++;              }
Magic Number,TradingBase,MultiSim,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\MultiSim.cs,FlushCacheSingleCore,The following statement contains a magic number: while (simrunning)              {                  // get next ticks                  FillCacheSingleCore(1);                  // get next times of ticks in cache                  long[] times = nexttimes();                  // copy our master index list into a temporary for sorting                  Buffer.BlockCopy(idx' 0' cidx' 0' idx.Length * 4);                  // sort loaded instruments by time                  Array.Sort(times' cidx);                  int nextidx = 0;                  // get next time from all instruments we have loaded                  while ((nextidx < times.Length) && (times[nextidx] == -1))                      nextidx++;                  // test to see if ticks left in simulation                  simrunning = (nextidx < times.Length) && (times[nextidx] <= endsim);                  // if no ticks left or we exceeded simulation time' quit                  if (!simrunning)                      break;                  // get next tick                  Tick k = Workers[cidx[nextidx]].NextTick();                  // notify tick                  OnGotTick(k);                  // count tick                  _tickcount++;              }
Magic Number,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,progress,The following statement contains a magic number: int pct = (int)(((double)cur * 100) / max);
Magic Number,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,progress,The following statement contains a magic number: if (pct > 100)                  pct = 100;
Magic Number,TradingBase,OptimizeEngine,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Backtest\OptimizeEngine.cs,progress,The following statement contains a magic number: if (pct > 100)                  pct = 100;
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,Bar,The following statement contains a magic number: Interval = 300;
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add(Tick.NewTrade(bar.FullSymbol' bar.Date' bar.BarStartTime' bar.Open'                  (int)((double)bar.Volume / 4)));
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add(Tick.NewTrade(bar.FullSymbol' bar.Date' bar.BarStartTime' bar.High'                  (int)((double)bar.Volume / 4)));
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add(Tick.NewTrade(bar.FullSymbol' bar.Date' bar.BarStartTime' bar.Low'                  (int)((double)bar.Volume / 4)));
Magic Number,TradingBase,Bar,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\Bar.cs,ToTick,The following statement contains a magic number: list.Add(Tick.NewTrade(bar.FullSymbol' bar.Date' bar.BarStartTime' bar.Close'                  (int)((double)bar.Volume / 4)));
Magic Number,TradingBase,BarTimeIntervalData,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Bar\BarTimeIntervalData.cs,GetBarId,The following statement contains a magic number: bcount += (long)date * 100000;
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,RequestHistoricalData,The following statement contains a magic number: try              {                  using (WebClient client = new WebClient())                  {                      string google;                      if (br.Interval != 86400)                      {                         google = @"https://www.google.com/finance/getprices?i="+br.Interval.ToString()+@"&p=1d&f=d'o'h'l'c'v&df=cpct&q=";                      }                      else   // for oneday' today is empty                      {                          google = @"https://www.google.com/finance/getprices?i=86400&p=2d&f=d'o'h'l'c'v&df=cpct&q=";                      }                        string[] symbol = br.FullSymbol.Split(' ');                        System.IO.Stream data = client.OpenRead(google + symbol[0]);                      System.IO.StreamReader read = new System.IO.StreamReader(data);                        string[] lines = new string[] { read.ReadToEnd() };                      string[] lines2 = lines[0].Split('\n');                        // get time zone adjustment                      // In line 6' GOOG has time zone offset = -240 which is new york time;                       //      while SPX has time zone offset = -300' which is chicago time.                      // The following find the additional offset relative to local time.                      /*                      int localtimezonediffinminutes = (int)Util.GetUtcOffset(DateTime.Today).TotalMinutes;       // negative offset                      string stime = lines[6];                      int itime;                      bool btime = Int32.TryParse(stime.Substring(stime.IndexOf('=') + 1)' out itime);        // negative offset                      int additionaloffset = localtimezonediffinminutes - itime;          // (-240) - (-300) = 60 mins                      */                        IEnumerable<string> history = lines2.Skip(7);        // skip the first 7 lines: header                        int nlines = 0;                  // count of lines                      string[] entries;                      DateTime dstart = DateTime.Now;        // just for initialization                      DateTime dt = DateTime.Now;                        foreach (string line in history)                      {                          if (!string.IsNullOrEmpty(line))                 // skip empty lines' i.e.' the last line                          {                              entries = line.Split(''');                                if (nlines == 0)                              {                                  // http://www.epochconverter.com/                                  dt = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);                                  double secs = double.Parse(entries[0].Remove(0' 1));        // remove character 'a'                                  dt = dt.AddSeconds(secs);                                   // GMT to EST                                  // dstart = TimeZoneInfo.ConvertTimeFromUtc(dt1' TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time"));                                  dt = TimeZoneInfo.ConvertTimeFromUtc(dt' TimeZoneInfo.Local);                                  dstart = dt;                              }                              else                              {                                  dstart = dt.AddSeconds(Int32.Parse(entries[0])*br.Interval);                              }                                                            nlines++;                              // write line to database                              Bar bar = new Bar();                              bar.Interval = 1;       // 1 sec                                bar.FullSymbol = br.FullSymbol;                                bar.Open = decimal.Parse(entries[4]);                              bar.Date = Util.ToIntDate(dstart);                              bar.BarOrderInADay = bar.GetOrder(Util.ToIntTime(dstart));                              bar.High = decimal.Parse(entries[2]);                              bar.Low = decimal.Parse(entries[3]);                              bar.Close = decimal.Parse(entries[1]);                              bar.Volume = long.Parse(entries[5]);                                if (GotHistoricalBarDelegate != null)                                  GotHistoricalBarDelegate(bar);                          }                      }                  }              }              catch (Exception e)              {                  Debug("Error in requesting historical data from Google client.");                  Debug(e.Message);              }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true)              {                  if (token.IsCancellationRequested)                  {                      break;                  }                                      try                  {                      // Create a request for the URL.                       HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create(query);                      // If required by the server' set the credentials.                      grequest.Credentials = CredentialCache.DefaultCredentials;                      // Get the response.                      HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse();                      // Display the status.                      // Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);                      // Get the stream containing content returned by the server.                      Stream gdatastream = gresponse.GetResponseStream();                      // Open the stream using a StreamReader for easy access.                      StreamReader greader = new StreamReader(gdatastream);                        // Read the content.                      string quotestr = greader.ReadToEnd();                        // Display the content.                      // Console.WriteLine(quotestr);                      quotestr = quotestr.Replace("//"' "");                      // Clean up the streams and the response.                      greader.Close();                      gdatastream.Close();                      gresponse.Close();                        var quote = JsonConvert.DeserializeObject<List<RealTimeData>>(quotestr);                                                      DateTime ct = DateTime.Now;                      int i = 0;                      // quote has the same order as that in securities; use this logic to retrieve symbol directly                      foreach (var sec in SecurityFullNameToGoogleSymbol)                      {                          Tick k = new Tick();        // it should create a new tick. Otherwise it overrides.                          k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;                          k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;                          //DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time                          //dt = dt.ToLocalTime();                          //k.Date = Util.ToIntDate(dt);                          //k.Time = Util.ToIntTime(dt);                            k.FullSymbol = sec.Key;                            k.TradePrice = Convert.ToDecimal(quote[i].l);                          k.TradeSize = Convert.ToInt32(quote[i++].s);                          k.TradeSize = 1000;           // overwrite. It seems that google hasn't provided size yet.                          SecurityFullNameToLastPrice[sec.Key] = k.TradePrice;                            if (k.IsValid)                          {                              if (GotTickDelegate != null)                                  GotTickDelegate(k);                          }                      }                  }                  catch (Exception ex)                  {                      Debug("GoogleClient error: " + ex.Message);                  }                    // Sleep 30 seconds                  // Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));                  System.Threading.Thread.Sleep(new TimeSpan(0' 0' 0' 0' RefreshInterval));                                }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true)              {                  if (token.IsCancellationRequested)                  {                      break;                  }                                      try                  {                      // Create a request for the URL.                       HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create(query);                      // If required by the server' set the credentials.                      grequest.Credentials = CredentialCache.DefaultCredentials;                      // Get the response.                      HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse();                      // Display the status.                      // Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);                      // Get the stream containing content returned by the server.                      Stream gdatastream = gresponse.GetResponseStream();                      // Open the stream using a StreamReader for easy access.                      StreamReader greader = new StreamReader(gdatastream);                        // Read the content.                      string quotestr = greader.ReadToEnd();                        // Display the content.                      // Console.WriteLine(quotestr);                      quotestr = quotestr.Replace("//"' "");                      // Clean up the streams and the response.                      greader.Close();                      gdatastream.Close();                      gresponse.Close();                        var quote = JsonConvert.DeserializeObject<List<RealTimeData>>(quotestr);                                                      DateTime ct = DateTime.Now;                      int i = 0;                      // quote has the same order as that in securities; use this logic to retrieve symbol directly                      foreach (var sec in SecurityFullNameToGoogleSymbol)                      {                          Tick k = new Tick();        // it should create a new tick. Otherwise it overrides.                          k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;                          k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;                          //DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time                          //dt = dt.ToLocalTime();                          //k.Date = Util.ToIntDate(dt);                          //k.Time = Util.ToIntTime(dt);                            k.FullSymbol = sec.Key;                            k.TradePrice = Convert.ToDecimal(quote[i].l);                          k.TradeSize = Convert.ToInt32(quote[i++].s);                          k.TradeSize = 1000;           // overwrite. It seems that google hasn't provided size yet.                          SecurityFullNameToLastPrice[sec.Key] = k.TradePrice;                            if (k.IsValid)                          {                              if (GotTickDelegate != null)                                  GotTickDelegate(k);                          }                      }                  }                  catch (Exception ex)                  {                      Debug("GoogleClient error: " + ex.Message);                  }                    // Sleep 30 seconds                  // Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));                  System.Threading.Thread.Sleep(new TimeSpan(0' 0' 0' 0' RefreshInterval));                                }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true)              {                  if (token.IsCancellationRequested)                  {                      break;                  }                                      try                  {                      // Create a request for the URL.                       HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create(query);                      // If required by the server' set the credentials.                      grequest.Credentials = CredentialCache.DefaultCredentials;                      // Get the response.                      HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse();                      // Display the status.                      // Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);                      // Get the stream containing content returned by the server.                      Stream gdatastream = gresponse.GetResponseStream();                      // Open the stream using a StreamReader for easy access.                      StreamReader greader = new StreamReader(gdatastream);                        // Read the content.                      string quotestr = greader.ReadToEnd();                        // Display the content.                      // Console.WriteLine(quotestr);                      quotestr = quotestr.Replace("//"' "");                      // Clean up the streams and the response.                      greader.Close();                      gdatastream.Close();                      gresponse.Close();                        var quote = JsonConvert.DeserializeObject<List<RealTimeData>>(quotestr);                                                      DateTime ct = DateTime.Now;                      int i = 0;                      // quote has the same order as that in securities; use this logic to retrieve symbol directly                      foreach (var sec in SecurityFullNameToGoogleSymbol)                      {                          Tick k = new Tick();        // it should create a new tick. Otherwise it overrides.                          k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;                          k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;                          //DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time                          //dt = dt.ToLocalTime();                          //k.Date = Util.ToIntDate(dt);                          //k.Time = Util.ToIntTime(dt);                            k.FullSymbol = sec.Key;                            k.TradePrice = Convert.ToDecimal(quote[i].l);                          k.TradeSize = Convert.ToInt32(quote[i++].s);                          k.TradeSize = 1000;           // overwrite. It seems that google hasn't provided size yet.                          SecurityFullNameToLastPrice[sec.Key] = k.TradePrice;                            if (k.IsValid)                          {                              if (GotTickDelegate != null)                                  GotTickDelegate(k);                          }                      }                  }                  catch (Exception ex)                  {                      Debug("GoogleClient error: " + ex.Message);                  }                    // Sleep 30 seconds                  // Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));                  System.Threading.Thread.Sleep(new TimeSpan(0' 0' 0' 0' RefreshInterval));                                }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true)              {                  if (token.IsCancellationRequested)                  {                      break;                  }                                      try                  {                      // Create a request for the URL.                       HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create(query);                      // If required by the server' set the credentials.                      grequest.Credentials = CredentialCache.DefaultCredentials;                      // Get the response.                      HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse();                      // Display the status.                      // Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);                      // Get the stream containing content returned by the server.                      Stream gdatastream = gresponse.GetResponseStream();                      // Open the stream using a StreamReader for easy access.                      StreamReader greader = new StreamReader(gdatastream);                        // Read the content.                      string quotestr = greader.ReadToEnd();                        // Display the content.                      // Console.WriteLine(quotestr);                      quotestr = quotestr.Replace("//"' "");                      // Clean up the streams and the response.                      greader.Close();                      gdatastream.Close();                      gresponse.Close();                        var quote = JsonConvert.DeserializeObject<List<RealTimeData>>(quotestr);                                                      DateTime ct = DateTime.Now;                      int i = 0;                      // quote has the same order as that in securities; use this logic to retrieve symbol directly                      foreach (var sec in SecurityFullNameToGoogleSymbol)                      {                          Tick k = new Tick();        // it should create a new tick. Otherwise it overrides.                          k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;                          k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;                          //DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time                          //dt = dt.ToLocalTime();                          //k.Date = Util.ToIntDate(dt);                          //k.Time = Util.ToIntTime(dt);                            k.FullSymbol = sec.Key;                            k.TradePrice = Convert.ToDecimal(quote[i].l);                          k.TradeSize = Convert.ToInt32(quote[i++].s);                          k.TradeSize = 1000;           // overwrite. It seems that google hasn't provided size yet.                          SecurityFullNameToLastPrice[sec.Key] = k.TradePrice;                            if (k.IsValid)                          {                              if (GotTickDelegate != null)                                  GotTickDelegate(k);                          }                      }                  }                  catch (Exception ex)                  {                      Debug("GoogleClient error: " + ex.Message);                  }                    // Sleep 30 seconds                  // Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));                  System.Threading.Thread.Sleep(new TimeSpan(0' 0' 0' 0' RefreshInterval));                                }
Magic Number,TradingBase,GoogleClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\GoogleClient.cs,GetQuoteLoop,The following statement contains a magic number: while (true)              {                  if (token.IsCancellationRequested)                  {                      break;                  }                                      try                  {                      // Create a request for the URL.                       HttpWebRequest grequest = (HttpWebRequest)WebRequest.Create(query);                      // If required by the server' set the credentials.                      grequest.Credentials = CredentialCache.DefaultCredentials;                      // Get the response.                      HttpWebResponse gresponse = (HttpWebResponse)grequest.GetResponse();                      // Display the status.                      // Console.WriteLine(((HttpWebResponse)gresponse).StatusDescription);                      // Get the stream containing content returned by the server.                      Stream gdatastream = gresponse.GetResponseStream();                      // Open the stream using a StreamReader for easy access.                      StreamReader greader = new StreamReader(gdatastream);                        // Read the content.                      string quotestr = greader.ReadToEnd();                        // Display the content.                      // Console.WriteLine(quotestr);                      quotestr = quotestr.Replace("//"' "");                      // Clean up the streams and the response.                      greader.Close();                      gdatastream.Close();                      gresponse.Close();                        var quote = JsonConvert.DeserializeObject<List<RealTimeData>>(quotestr);                                                      DateTime ct = DateTime.Now;                      int i = 0;                      // quote has the same order as that in securities; use this logic to retrieve symbol directly                      foreach (var sec in SecurityFullNameToGoogleSymbol)                      {                          Tick k = new Tick();        // it should create a new tick. Otherwise it overrides.                          k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;                          k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;                          //DateTime dt = DateTime.SpecifyKind(DateTime.Parse(quote[0].lt_dts)' DateTimeKind.Utc);      // Z shouldn't refer to local time                          //dt = dt.ToLocalTime();                          //k.Date = Util.ToIntDate(dt);                          //k.Time = Util.ToIntTime(dt);                            k.FullSymbol = sec.Key;                            k.TradePrice = Convert.ToDecimal(quote[i].l);                          k.TradeSize = Convert.ToInt32(quote[i++].s);                          k.TradeSize = 1000;           // overwrite. It seems that google hasn't provided size yet.                          SecurityFullNameToLastPrice[sec.Key] = k.TradePrice;                            if (k.IsValid)                          {                              if (GotTickDelegate != null)                                  GotTickDelegate(k);                          }                      }                  }                  catch (Exception ex)                  {                      Debug("GoogleClient error: " + ex.Message);                  }                    // Sleep 30 seconds                  // Console.WriteLine("Time .... " + Util.ToIntTime(DateTime.Now));                  System.Threading.Thread.Sleep(new TimeSpan(0' 0' 0' 0' RefreshInterval));                                }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,Connect,The following statement contains a magic number: _ibSocket.setServerLogLevel(5);
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: switch (br.Interval)              {                  case 1:                      barSize = "1 secs";             // not 1 sec                      break;                  case 5:                      barSize = "5 secs";                      break;                  case 15:                      barSize = "15 secs";                      break;                  case 30:                      barSize = "30 secs";                      break;                  case 60:                      barSize = "1 min";                      break;                  case 120:                      barSize = "2 mins";                      break;                  case 180:                      barSize = "3 mins";                      break;                  case 300:                      barSize = "5 mins";                      break;                  case 900:                      barSize = "15 mins";                      break;                  case 1800:                      barSize = "30 mins";                      break;                  case 3600:                      barSize = "1 hour";                      break;                  case 86400:                      barSize = "1 day";                      break;                  default:                      throw new ArgumentOutOfRangeException("Invalid barsize/interval.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddDays(-1))              {                  durationstring = duration.TotalSeconds.ToString() + " S";              }              // Request is greater than 1 day and less than 7 days -> Request in days              else if (startdatetime > enddatetime.AddDays(-7))              {                  durationstring = duration.TotalDays.ToString() + " D";              }              // Request is greater than 7 days and less than 1 month -> Request in weeks              else if (startdatetime > enddatetime.AddMonths(-1))              {                  int numberOfWeeksToRequest = (int)Math.Ceiling(duration.TotalDays / 7.0);                  durationstring = numberOfWeeksToRequest.ToString() + " W";              }              else              {                  throw new ArgumentOutOfRangeException("Period cannot be bigger than 52 weeks.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,RequestHistoricalData,The following statement contains a magic number: if (startdatetime > enddatetime.AddDays(-1))              {                  durationstring = duration.TotalSeconds.ToString() + " S";              }              // Request is greater than 1 day and less than 7 days -> Request in days              else if (startdatetime > enddatetime.AddDays(-7))              {                  durationstring = duration.TotalDays.ToString() + " D";              }              // Request is greater than 7 days and less than 1 month -> Request in weeks              else if (startdatetime > enddatetime.AddMonths(-1))              {                  int numberOfWeeksToRequest = (int)Math.Ceiling(duration.TotalDays / 7.0);                  durationstring = numberOfWeeksToRequest.ToString() + " W";              }              else              {                  throw new ArgumentOutOfRangeException("Period cannot be bigger than 52 weeks.");              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,error,The following statement contains a magic number: if (errorCode == 202)           // Order Cancelled              {                  try                  {                      OnGotOrderCancel(_iborderIdToOrderInfo[id].StrategyOrderId);                  }                  catch                  {                      OnDebug("A non-exist order to be cancelled.");                  }              }              else              {                  string str = "requestId = " + id                      + "; Error code = " + errorCode                      + "; Error Message = " + errorMsg;                  OnDebug(str);              }
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeDate = dt.Year * 10000 + dt.Month * 100 + dt.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeDate = dt.Year * 10000 + dt.Month * 100 + dt.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeTime = dt.Hour * 10000 + dt.Minute * 100 + dt.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,execDetails,The following statement contains a magic number: trade.TradeTime = dt.Hour * 10000 + dt.Minute * 100 + dt.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickPrice,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,tickSize,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepth,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Date = ct.Year * 10000 + ct.Month * 100 + ct.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,updateMktDepthL2,The following statement contains a magic number: k.Time = ct.Hour * 10000 + ct.Minute * 100 + ct.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The following statement contains a magic number: int ndate = dt.Year * 10000 + dt.Month * 100 + dt.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The following statement contains a magic number: int ndate = dt.Year * 10000 + dt.Month * 100 + dt.Day;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The following statement contains a magic number: int ntime = dt.Hour * 10000 + dt.Minute * 100 + dt.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,historicalData,The following statement contains a magic number: int ntime = dt.Hour * 10000 + dt.Minute * 100 + dt.Second;
Magic Number,TradingBase,IBClient,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Brokers\IBClient.cs,GetMultiplier,The following statement contains a magic number: if (symbol == "ES") multiplier = 50;
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.Id = Convert.ToInt64(rec[2]);
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.Account = rec[3];
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.FullSymbol = rec[4];
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.OrderSize = Convert.ToInt32(rec[5]);
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.LimitPrice = Convert.ToDecimal(rec[6]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.StopPrice = Convert.ToDecimal(rec[7]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.TrailPrice = Convert.ToDecimal(rec[8]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: o.Currency = rec[9];
Magic Number,TradingBase,Order,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Order.cs,Deserialize,The following statement contains a magic number: Enum.TryParse<TimeInForce>(rec[10]' out tif);
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,GenerateReports,The following statement contains a magic number: try              {                  _fills.Clear();                  _fills.AddRange(trades);                    List<decimal> moneyinuse = new List<decimal>();                   // money in use                  List<decimal> tradepnl = new List<decimal>();                  List<int> days = new List<int>();                           // hostorical trading days when the trades happened                  Dictionary<string' int> tradecount = new Dictionary<string' int>();         // symbol --> trade count                  List<decimal> negret = new List<decimal>(_fills.Count);                    int consecWinners = 0;                  int consecLosers = 0;                  List<long> exitscounted = new List<long>();                  decimal winpl = 0;                  decimal losepl = 0;                                    foreach (Trade trade in _fills)                  {                      if (tradecount.ContainsKey(trade.FullSymbol))                          tradecount[trade.FullSymbol]++;                      else                          tradecount.Add(trade.FullSymbol' 1);                        if (!days.Contains(trade.TradeDate))                          days.Add(trade.TradeDate);                        int usizebefore = 0;                      decimal closedpnlfromthistrade = 0;                      if (_positions.ContainsKey(trade.FullSymbol))                      {                          usizebefore = _positions[trade.FullSymbol].UnsignedSize;                          closedpnlfromthistrade = _positions[trade.FullSymbol].Adjust(trade);                           // closed pnl                        }                      else                      {                          // add the trade to position                          _positions.Add(trade.FullSymbol' new Position(trade));                          usizebefore = 0;                          closedpnlfromthistrade = 0;                      }                                                 bool isroundturn = (usizebefore != 0) && (_positions[trade.FullSymbol].UnsignedSize == 0);      // end at exact 0                        bool isclosing = _positions[trade.FullSymbol].UnsignedSize < usizebefore;                                            // calculate MIU and store on array                      decimal miu = Calc.Sum(Calc.MoneyInUse(_positions));                      if (miu != 0)                          moneyinuse.Add(miu);                      // if we closed something' update return                      if (isclosing)                      {                          // get p&l for portfolio                          decimal pl = Calc.Sum(Calc.AbsoluteReturn(_positions));         // with one param' AbsoluteReturn returns closed pnl                          // count return                          tradepnl.Add(pl);                          // get pct return for portfolio                          decimal pctret = moneyinuse[moneyinuse.Count - 1] == 0 ? 0 : pl / moneyinuse[moneyinuse.Count - 1];                          // if it is below our zero' count it as negative return                          if (pctret < 0)                              negret.Add(pl);                      }                      if (isroundturn)            // # of RoundTurns = RoundWinners + RoundLosers                      {                          RoundTurns++;                          if (closedpnlfromthistrade >= 0)                              RoundWinners++;                          else if (closedpnlfromthistrade < 0)                              RoundLosers++;                        }                        Trades++;                      SharesTraded += Math.Abs(trade.TradeSize);                      Commissions += CalculateIBCommissions(trade);                      GrossPL += closedpnlfromthistrade;                            if ((closedpnlfromthistrade > 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellWins++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyWins++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Winners++;                          consecWinners++;                          consecLosers = 0;                      }                      else if ((closedpnlfromthistrade < 0) && !exitscounted.Contains(trade.Id))                      {                          if (trade.Side)                          {                              SellLosers++;                              SellPL += closedpnlfromthistrade;                          }                          else                          {                              BuyLosers++;                              BuyPL += closedpnlfromthistrade;                          }                          if (trade.Id != 0)                              exitscounted.Add(trade.Id);                          Losers++;                          consecLosers++;                          consecWinners = 0;                      }                      if (closedpnlfromthistrade > 0)                          winpl += closedpnlfromthistrade;                      else if (closedpnlfromthistrade < 0)                          losepl += closedpnlfromthistrade;                        if (consecWinners > ConsecWin) ConsecWin = consecWinners;                      if (consecLosers > ConsecLose) ConsecLose = consecLosers;                      if ((_positions[trade.FullSymbol].Size == 0) && (closedpnlfromthistrade == 0)) Flats++;                      if (closedpnlfromthistrade > MaxWin) MaxWin = closedpnlfromthistrade;                      if (closedpnlfromthistrade < MaxLoss) MaxLoss = closedpnlfromthistrade;                      if (_positions[trade.FullSymbol].OpenPL > MaxOpenWin) MaxOpenWin = _positions[trade.FullSymbol].OpenPL;                      if (_positions[trade.FullSymbol].OpenPL < MaxOpenLoss) MaxOpenLoss = _positions[trade.FullSymbol].OpenPL;                    }   // end of loop over trades                    if (Trades != 0)                  {                      AvgPerTrade = Math.Round((losepl + winpl) / Trades' 2);                      AvgLoser = Losers == 0 ? 0 : Math.Round(losepl / Losers' 2);                      AvgWin = Winners == 0 ? 0 : Math.Round(winpl / Winners' 2);                      MoneyInUse = Math.Round(Calc.Max(moneyinuse.ToArray())' 2);                      MaxPL = Math.Round(Calc.Max(tradepnl.ToArray())' 2);                      MinPL = Math.Round(Calc.Min(tradepnl.ToArray())' 2);                      MaxDD = Calc.MaxDDPct(_fills);                      SymbolCount = _positions.Count;                      DaysTraded = days.Count;                      GrossPerDay = Math.Round(GrossPL / days.Count' 2);                      GrossPerSymbol = Math.Round(GrossPL / _positions.Count' 2);                      if (PerSymbol)                      {                          foreach (KeyValuePair<string' Position> item in _positions)                          {                              PerSymbolStats.Add(item.Value.FullSymbol' tradecount[item.Value.FullSymbol] + " for " + item.Value.ClosedPL.ToString("C2"));                          }                      }                  }                  else                  {                      MoneyInUse = 0;                      MaxPL = 0;                      MinPL = 0;                      MaxDD = 0;                      GrossPerDay = 0;                      GrossPerSymbol = 0;                  }                    // ratio measures                  try                  {                      SharpeRatio = tradepnl.Count < 2 ? 0 : Math.Round(Calc.SharpeRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(tradepnl.ToArray())' (RiskFreeRate * MoneyInUse * DaysTraded/252))' 3);                  }                  catch (Exception ex)                  {                      Debug("sharpe error: " + ex.Message);                  }                    try                  {                      if (tradepnl.Count == 0)                          SortinoRatio = 0;                      else if (negret.Count == 1)                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] == 0))                          SortinoRatio = 0;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] > 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MaxValue;                      else if ((negret.Count == 0) && (tradepnl[tradepnl.Count - 1] < 0))                          SortinoRatio = 0;                      //SortinoRatio = decimal.MinValue;                      else                          SortinoRatio = Math.Round(Calc.SortinoRatio(tradepnl[tradepnl.Count - 1]' Calc.StdDev(negret.ToArray())' (RiskFreeRate * MoneyInUse))' 3);                  }                  catch (Exception ex)                  {                      Debug("sortino error: " + ex.Message);                  }              }              catch (Exception ex)              {                  Debug("error in generating performance report" + ex.Message);              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains("STK"))              {                  return (decimal)Math.Max(0.005 * Math.Abs(t.TradeSize)' 1);              }              else if (t.FullSymbol.Contains("FUT"))              {                  return 2.01m * Math.Abs(t.TradeSize);              }              else if (t.FullSymbol.Contains("OPT"))              {                  return Math.Max(0.70m * Math.Abs(t.TradeSize)' 1);              }              else if (t.FullSymbol.Contains("CASH"))              {                  return Math.Max(0.000002m * (t.TradePrice * t.TradeSize)' 2);              }              else              {                  return 0;              }
Magic Number,TradingBase,PerformanceEvaluator,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\PerformanceAnalysis\PerformanceEvaluator.cs,CalculateIBCommissions,The following statement contains a magic number: if (t.FullSymbol.Contains("STK"))              {                  return (decimal)Math.Max(0.005 * Math.Abs(t.TradeSize)' 1);              }              else if (t.FullSymbol.Contains("FUT"))              {                  return 2.01m * Math.Abs(t.TradeSize);              }              else if (t.FullSymbol.Contains("OPT"))              {                  return Math.Max(0.70m * Math.Abs(t.TradeSize)' 1);              }              else if (t.FullSymbol.Contains("CASH"))              {                  return Math.Max(0.000002m * (t.TradePrice * t.TradeSize)' 2);              }              else              {                  return 0;              }
Magic Number,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Deserialize,The following statement contains a magic number: int size = Convert.ToInt32(r[2]);
Magic Number,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Deserialize,The following statement contains a magic number: decimal cpl = Convert.ToDecimal(r[4]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Position,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Position.cs,Deserialize,The following statement contains a magic number: string act = r[5];
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: _exchange = str[2];
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: if (str.Length > 3 && str[3] != "")                  _multiplier = Int32.Parse(str[3]);
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: if (str.Length > 3 && str[3] != "")                  _multiplier = Int32.Parse(str[3]);
Magic Number,TradingBase,Security,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Security\Security.cs,Security,The following statement contains a magic number: if (str.Length > 3 && str[3] != "")                  _multiplier = Int32.Parse(str[3]);
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse(r[2]' out i))                  t.Time = i;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (decimal.TryParse(r[3]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d))                  t.TradePrice = d;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse(r[4]' out i))                  t.TradeSize = i;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (decimal.TryParse(r[5]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d))                  t.BidPrice = d;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse(r[6]' out i))                  t.BidSize = i;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (decimal.TryParse(r[7]' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out d))                  t.AskPrice = d;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse(r[8]' out i))                  t.AskSize = i;
Magic Number,TradingBase,Tick,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Tick\Tick.cs,Deserialize,The following statement contains a magic number: if (int.TryParse(r[9]' out i))                  t.Depth = i;
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: if (ts.Length < 14) throw new Exception("Invalid trade");
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradeDate = Convert.ToInt32(ts[2]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradeTime = Convert.ToInt32(ts[3]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.FullSymbol = ts[4];
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradeSize = Convert.ToInt32(ts[5]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Trade,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Order\Trade.cs,Deserialize,The following statement contains a magic number: t.TradePrice = Convert.ToDecimal(ts[6]' System.Globalization.CultureInfo.InvariantCulture);
Magic Number,TradingBase,Calc,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Calc.cs,StdDev,The following statement contains a magic number: decimal stdev = (decimal)Math.Pow((double)tmp' .5);
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: Port = 7496;
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: TickQueueCapacity = 50000;
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: TickSampleTime = 10;
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: DailyOrderCapacity = 500;
Magic Number,TradingBase,ConfigManager,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\ConfigManager.cs,ConfigManager,The following statement contains a magic number: DecimalPlace = 2;
Magic Number,TradingBase,OffsetInfo,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\OffsetInfo.cs,ToString,The following statement contains a magic number: return ToString(2);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntDate,The following statement contains a magic number: return (dt.Year * 10000) + (dt.Month * 100) + dt.Day;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntDate,The following statement contains a magic number: return (dt.Year * 10000) + (dt.Month * 100) + dt.Day;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return (dt.Hour * 10000) + (dt.Minute * 100) + (dt.Second);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return (dt.Hour * 10000) + (dt.Minute * 100) + (dt.Second);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return hour * 10000 + min * 100 + sec;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToIntTime,The following statement contains a magic number: return hour * 10000 + min * 100 + sec;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: int sec = time % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: int hm = time % 10000;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: int hour = (int)((time - hm) / 10000);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: int min = (time - (hour * 10000)) / 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: int min = (time - (hour * 10000)) / 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (sec > 59) { sec -= 60; min++; }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (sec > 59) { sec -= 60; min++; }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (min > 59) { hour++; min -= 60; }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (min > 59) { hour++; min -= 60; }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0)              {                  int ym = (date % 10000);                  year = (int)((date - ym) / 10000);                  int mm = ym % 100;                  month = (int)((ym - mm) / 100);                  day = mm;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0)              {                  int ym = (date % 10000);                  year = (int)((date - ym) / 10000);                  int mm = ym % 100;                  month = (int)((ym - mm) / 100);                  day = mm;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0)              {                  int ym = (date % 10000);                  year = (int)((date - ym) / 10000);                  int mm = ym % 100;                  month = (int)((ym - mm) / 100);                  day = mm;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,ToDateTime,The following statement contains a magic number: if (date != 0)              {                  int ym = (date % 10000);                  year = (int)((date - ym) / 10000);                  int mm = ym % 100;                  month = (int)((ym - mm) / 100);                  day = mm;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: int s1 = time % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: int m1 = ((time - s1) / 100) % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: int m1 = ((time - s1) / 100) % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: int h1 = (int)((time - (m1 * 100) - s1) / 10000);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: int h1 = (int)((time - (m1 * 100) - s1) / 10000);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: return h1 * 3600 + m1 * 60 + s1;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeToIntTimeSpan,The following statement contains a magic number: return h1 * 3600 + m1 * 60 + s1;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int s1 = firsttime % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int m1 = ((firsttime - s1) / 100) % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int m1 = ((firsttime - s1) / 100) % 100;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int h1 = (int)((firsttime - m1 * 100 - s1) / 10000);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int h1 = (int)((firsttime - m1 * 100 - s1) / 10000);
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (s1 >= 60)              {                  m1 += (int)(s1 / 60);                  s1 = s1 % 60;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (s1 >= 60)              {                  m1 += (int)(s1 / 60);                  s1 = s1 % 60;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (s1 >= 60)              {                  m1 += (int)(s1 / 60);                  s1 = s1 % 60;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (m1 >= 60)              {                  h1 += (int)(m1 / 60);                  m1 = m1 % 60;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (m1 >= 60)              {                  h1 += (int)(m1 / 60);                  m1 = m1 % 60;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: if (m1 >= 60)              {                  h1 += (int)(m1 / 60);                  m1 = m1 % 60;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int sum = h1 * 10000 + m1 * 100 + s1;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,IntTimeAdd,The following statement contains a magic number: int sum = h1 * 10000 + m1 * 100 + s1;
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,Sendemail,The following statement contains a magic number: try              {                  // Send mail                  // gmail = ConfigurationManager.AppSettings["gmailacct"];                  // pwd = ConfigurationManager.AppSettings["gmailpwd"];                  string emailfrom' pwd' emailto;                  emailfrom = EmailFrom;                  emailto = EmailTo;                  pwd = EmailPass;                    MailMessage mail = new MailMessage();                  mail.From = new MailAddress(emailfrom);                  string[] toaddr = emailto.Split(';');                  foreach(string s in toaddr)                      mail.To.Add(s);                  mail.Subject = subject;                  mail.Body = body;                  mail.IsBodyHtml = useHTML;                    if (!string.IsNullOrEmpty(attachfilepathname))                  {                      System.Net.Mail.Attachment attachment;                      attachment = new System.Net.Mail.Attachment(attachfilepathname);                      mail.Attachments.Add(attachment);                  }                    SmtpClient smtpServer = new SmtpClient("smtp.gmail.com");                  smtpServer.Port = 587;                  smtpServer.Credentials = new System.Net.NetworkCredential(emailfrom' pwd);                  smtpServer.EnableSsl = true;                    smtpServer.Send(mail);              }              catch (Exception)              {                  throw;              }
Magic Number,TradingBase,Util,C:\repos\letianzj_QuantTrading\Source\TradingBase\TradingBase\Util\Util.cs,GmailAccount,The following statement contains a magic number: string[] ret = new string[2];
