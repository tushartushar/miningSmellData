Implementation smell,Namespace,Class,File,Method,Description
Long Identifier,BrockAllen.IdentityReboot,AdaptivePasswordHasher,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\PasswordHasher\AdaptivePasswordHasher.cs,,The length of the parameter PasswordHashingIterationCountSeparator is 38.
Long Statement,BrockAllen.IdentityReboot,StoredTwoFactorCodeProvider<TUser;TKey>,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\TwoFactorAuth\StoredTwoFactorCodeProvider.cs,GenerateAsync,The length of the statement  "            if (twoFactAuthManager == null) throw new InvalidOperationException(Messages.IUserManagerSupportsTwoFactorAuthStoreNotImplemented); " is 131.
Long Statement,BrockAllen.IdentityReboot,StoredTwoFactorCodeProvider<TUser;TKey>,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\TwoFactorAuth\StoredTwoFactorCodeProvider.cs,ValidateAsync,The length of the statement  "            if (twoFactAuthManager == null) throw new InvalidOperationException(Messages.IUserManagerSupportsTwoFactorAuthStoreNotImplemented); " is 131.
Long Statement,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,Hash,The length of the statement  "                    throw new InvalidOperationException();//String.Format(CultureInfo.InvariantCulture' HelpersResources.Crypto_NotSupportedHashAlg' algorithm)); " is 141.
Magic Number,BrockAllen.IdentityReboot,AdaptivePasswordHasher,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\PasswordHasher\AdaptivePasswordHasher.cs,VerifyHashedPassword,The following statement contains a magic number: if (!String.IsNullOrWhiteSpace(hashedPassword))              {                  if (hashedPassword.Contains(PasswordHashingIterationCountSeparator))                  {                      var parts = hashedPassword.Split(PasswordHashingIterationCountSeparator);                      if (parts.Length != 2) return PasswordVerificationResult.Failed;                        int count = DecodeIterations(parts[0]);                      if (count <= 0) return PasswordVerificationResult.Failed;                        hashedPassword = parts[1];                        if (VerifyHashedPasswordInternal(hashedPassword' providedPassword' count))                      {                          if (GetIterationCount() != count)                          {                              return PasswordVerificationResult.SuccessRehashNeeded;                          }                          else                          {                              return PasswordVerificationResult.Success;                          }                      }                  }                  else if (Crypto.VerifyHashedPassword(hashedPassword' providedPassword))                  {                      return PasswordVerificationResult.SuccessRehashNeeded;                  }              }
Magic Number,BrockAllen.IdentityReboot,AdaptivePasswordHasher,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\PasswordHasher\AdaptivePasswordHasher.cs,GetIterationsFromYear,The following statement contains a magic number: if (year > StartYear)              {                  var diff = (year - StartYear) / 2;                  var mul = (int)Math.Pow(2' diff);                  int count = StartCount * mul;                  // if we go negative' then we wrapped (expected in year ~2044).                   // Int32.Max is best we can do at this point                  if (count < 0) count = Int32.MaxValue;                  return count;              }
Magic Number,BrockAllen.IdentityReboot,AdaptivePasswordHasher,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\PasswordHasher\AdaptivePasswordHasher.cs,GetIterationsFromYear,The following statement contains a magic number: if (year > StartYear)              {                  var diff = (year - StartYear) / 2;                  var mul = (int)Math.Pow(2' diff);                  int count = StartCount * mul;                  // if we go negative' then we wrapped (expected in year ~2044).                   // Int32.Max is best we can do at this point                  if (count < 0) count = Int32.MaxValue;                  return count;              }
Magic Number,BrockAllen.IdentityReboot,StoredTwoFactorCodeProvider<TUser;TKey>,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\TwoFactorAuth\StoredTwoFactorCodeProvider.cs,GenerateAsync,The following statement contains a magic number: var mod = (int)Math.Pow(10' Digits);
Magic Number,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,BinaryToHex,The following statement contains a magic number: char[] hex = new char[data.Length * 2];
Magic Number,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,BinaryToHex,The following statement contains a magic number: for (int iter = 0; iter < data.Length; iter++)              {                  byte hexChar = ((byte)(data[iter] >> 4));                  hex[iter * 2] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);                  hexChar = ((byte)(data[iter] & 0xF));                  hex[(iter * 2) + 1] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);              }
Magic Number,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,BinaryToHex,The following statement contains a magic number: for (int iter = 0; iter < data.Length; iter++)              {                  byte hexChar = ((byte)(data[iter] >> 4));                  hex[iter * 2] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);                  hexChar = ((byte)(data[iter] & 0xF));                  hex[(iter * 2) + 1] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);              }
Magic Number,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,BinaryToHex,The following statement contains a magic number: for (int iter = 0; iter < data.Length; iter++)              {                  byte hexChar = ((byte)(data[iter] >> 4));                  hex[iter * 2] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);                  hexChar = ((byte)(data[iter] & 0xF));                  hex[(iter * 2) + 1] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);              }
Magic Number,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,BinaryToHex,The following statement contains a magic number: for (int iter = 0; iter < data.Length; iter++)              {                  byte hexChar = ((byte)(data[iter] >> 4));                  hex[iter * 2] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);                  hexChar = ((byte)(data[iter] & 0xF));                  hex[(iter * 2) + 1] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);              }
Magic Number,BrockAllen.IdentityReboot.Internal,Crypto,C:\repos\brockallen_BrockAllen.IdentityReboot\source\BrockAllen.IdentityReboot\System.Web.Helpers.Crypto.cs,BinaryToHex,The following statement contains a magic number: for (int iter = 0; iter < data.Length; iter++)              {                  byte hexChar = ((byte)(data[iter] >> 4));                  hex[iter * 2] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);                  hexChar = ((byte)(data[iter] & 0xF));                  hex[(iter * 2) + 1] = (char)(hexChar > 9 ? hexChar + 0x37 : hexChar + 0x30);              }
