Implementation smell,Namespace,Class,File,Method,Description
Long Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The method has 114 lines of code.
Long Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The method has 107 lines of code.
Long Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The method has 141 lines of code.
Long Method,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The method has 132 lines of code.
Long Method,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildSoftMask,The method has 106 lines of code.
Long Method,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The method has 126 lines of code.
Long Method,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildSoftMask,The method has 106 lines of code.
Long Method,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildSoftMask,The method has 106 lines of code.
Complex Method,PdfSharp.Xps.Parsing,XpsParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Parsing\XpsParser.FixedDocument.cs,ParseFixedDocument,Cyclomatic complexity of the method is 27
Complex Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphsInternal,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,Cyclomatic complexity of the method is 18
Complex Method,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,RenderPage,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Xps,XpsRenderer,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsRenderer.cs,RenderPage_Test01,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,Cyclomatic complexity of the method is 8
Long Parameter List,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShading2,The method has 5 parameters.
Long Parameter List,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The method has 5 parameters.
Long Parameter List,PdfSharp.Xps.XpsModel,Matrix,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Matrix.cs,Matrix,The method has 6 parameters.
Long Statement,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The length of the statement  "		WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0)); " is 150.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The length of the statement  "		shadingCount = Convert.ToInt32 (Math.Max (boundingBox.width / (2 * brush.RadiusX)' boundingBox.height / (2 * brush.RadiusY)) + 1); " is 130.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The length of the statement  "		PdfShading shading = BuildShading2 (brush' scaleX' scaleY' idx' brush.SpreadMethod == SpreadMethod.Reflect && idx % 2 == 1 ? funcReflected : funcRegular); " is 154.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The length of the statement  "	writer.WriteLiteral (PdfEncoders.ToString (brush.GradientStops [brush.GradientStops.Count - 1].Color' PdfColorMode.Rgb) + " rg 1 i\n"); " is 135.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShading,The length of the statement  "	shading.Elements [PdfShading.Keys.Coords] = new PdfLiteral ("[{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###}]"' x0' y0' r0' x1' y1' r1); " is 149.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShading2,The length of the statement  "	shading.Elements [PdfShading.Keys.Coords] = new PdfLiteral ("[{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###}]"' x0' y0' r0' x1' y1' r1); " is 149.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildForm,The length of the statement  "	PdfTransparencyGroupAttributes tgPrimaryForm = Context.PdfDocument.Internals.CreateIndirectObject<PdfTransparencyGroupAttributes> (); " is 133.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildSoftMask,The length of the statement  "	PdfTransparencyGroupAttributes tgAttributes = Context.PdfDocument.Internals.CreateIndirectObject<PdfTransparencyGroupAttributes> (); " is 132.
Long Statement,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingForSoftMask,The length of the statement  "	////shading.Elements.SetValue(PdfShading.Keys.Coords' new PdfLiteral("[{0:0.####} {1:0.####} {2:0.####} {3:0.####}]"' x1' y1' x2' y2)); " is 135.
Long Statement,PdfSharp.Xps.Rendering,XFormBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\XFormBuilder.cs,FromImageBrush,The length of the statement  "	// XRect box = new XRect(brush.Viewbox.X * 0.75' brush.Viewbox.Y * 0.75' brush.Viewbox.Width * 0.75' brush.Viewbox.Height * 0.75); " is 130.
Long Statement,PdfSharp.Xps.Rendering,XFormBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\XFormBuilder.cs,FromVisualBrush,The length of the statement  "	// XRect box = new XRect(brush.Viewbox.X * 0.75' brush.Viewbox.Y * 0.75' brush.Viewbox.Width * 0.75' brush.Viewbox.Height * 0.75); " is 130.
Long Statement,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShading,The length of the statement  "	shading.Elements [PdfShading.Keys.Coords] = new PdfLiteral ("[{0:0.####} {1:0.####} {2:0.####} {3:0.####}]"' x1' y1' x2' y2); " is 125.
Long Statement,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildForm,The length of the statement  "	PdfTransparencyGroupAttributes tgPrimaryForm = Context.PdfDocument.Internals.CreateIndirectObject<PdfTransparencyGroupAttributes> (); " is 133.
Long Statement,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildSoftMask,The length of the statement  "	PdfTransparencyGroupAttributes tgAttributes = Context.PdfDocument.Internals.CreateIndirectObject<PdfTransparencyGroupAttributes> (); " is 132.
Long Statement,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildSoftMask,The length of the statement  "	PdfTransparencyGroupAttributes tgAttributes = Context.PdfDocument.Internals.CreateIndirectObject<PdfTransparencyGroupAttributes> (); " is 132.
Long Statement,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingForSoftMask,The length of the statement  "	shading.Elements.SetValue (PdfShading.Keys.Coords' new PdfLiteral ("[{0:0.####} {1:0.####} {2:0.####} {3:0.####}]"' x1' y1' x2' y2)); " is 133.
Long Statement,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingForSoftMask,The length of the statement  "	////shading.Elements.SetValue(PdfShading.Keys.Coords' new PdfLiteral("[{0:0.####} {1:0.####} {2:0.####} {3:0.####}]"' x1' y1' x2' y2)); " is 135.
Long Statement,PdfSharp.Xps.Rendering,PdfGraphicsState,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfGraphicsState-ImageBrush.cs,RealizeImageBrush,The length of the statement  "	//xform = new XForm(this.writer.Owner' new XRect(brush.Viewbox.X * 3 / 4' brush.Viewbox.Y * 3 / 4' brush.Viewbox.Width * 3 / 4' brush.Viewbox.Height * 3 / 4)); " is 159.
Long Statement,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildPattern,The length of the statement  "		matrix.Prepend (new XMatrix (brush.Transform.Matrix.m11' brush.Transform.Matrix.m12' brush.Transform.Matrix.m21' brush.Transform.Matrix.m22' brush.Transform.Matrix.offsetX' brush.Transform.Matrix.offsetY)); " is 206.
Long Statement,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildForm,The length of the statement  "	// XRect box = new XRect(brush.Viewbox.X * 0.75' brush.Viewbox.Y * 0.75' brush.Viewbox.Width * 0.75' brush.Viewbox.Height * 0.75); " is 130.
Long Statement,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildPattern,The length of the statement  "		matrix.Prepend (new XMatrix (brush.Transform.Matrix.m11' brush.Transform.Matrix.m12' brush.Transform.Matrix.m21' brush.Transform.Matrix.m22' brush.Transform.Matrix.offsetX' brush.Transform.Matrix.offsetY)); " is 206.
Long Statement,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildForm,The length of the statement  "	var box = new PdfRectangle (brush.Viewbox.X' brush.Viewbox.Y + brush.Viewbox.Height - 1' brush.Viewbox.X + brush.Viewbox.Width - 1' brush.Viewbox.Y); " is 149.
Long Statement,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildForm,The length of the statement  "		writer.WriteLiteral ("1 1 1 rg 0 0 m {0:0.###} 0 l {0:0.###} {1:0.###} l 0 {1:0.###} l h s\n"' brush.Viewbox.Width' brush.Viewbox.Height); " is 138.
Long Statement,PdfSharp.Xps.Rendering,WpfUtils,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\WpfUtils.cs,FlattenSegment,The length of the statement  "		QuadraticBezierSegment qbseg = new QuadraticBezierSegment (new Point (seg.Points [idx].X' seg.Points [idx].Y)' new Point (seg.Points [idx + 1].X' seg.Points [idx + 1].Y)' seg.IsStroked); " is 186.
Long Statement,PdfSharp.Xps.Rendering,WpfUtils,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\WpfUtils.cs,FlattenSegment,The length of the statement  "	ArcSegment aseg = new ArcSegment (new Point (seg.Point.X' seg.Point.Y)' new Size (seg.Size.Width' seg.Size.Height)' seg.RotationAngle' seg.IsLargeArc' (SweepDirection)seg.SweepDirection' seg.IsStroked); " is 202.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,RenderPage,The length of the statement  "						string xmlPath = IOPath.Combine (IOPath.GetDirectoryName (this.xpsDocument.Path)' IOPath.GetFileNameWithoutExtension (this.xpsDocument.Path)) + ".xml"; " is 151.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The length of the statement  "			System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read); " is 126.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,SaveXpsPageToBitmap,The length of the statement  "	System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFileName' System.IO.FileAccess.Read); " is 136.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,SaveXpsPageToBitmap,The length of the statement  "		RenderTargetBitmap renderTarget = new RenderTargetBitmap ((int)docPage.Size.Width' (int)docPage.Size.Height' 96' // WPF (Avalon) units are 96dpi based     " is 150.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,SaveXpsPageToBitmap,The length of the statement  "		FileStream pageOutStream = new FileStream (xpsFileName + ".Page" + pageNum + ".bmp"' FileMode.Create' FileAccess.Write); " is 120.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,BitmapSourceFromPage,The length of the statement  "	RenderTargetBitmap renderTarget = new RenderTargetBitmap ((int)pixelWidth' (int)pixelHeight' resolution' resolution' PixelFormats.Default); " is 139.
Long Statement,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,BitmapSourceFromPage,The length of the statement  "	////FileStream pageOutStream = new FileStream(xpsFileName + ".Page" + pageNum + ".bmp"' FileMode.Create' FileAccess.Write); " is 123.
Long Statement,PdfSharp.Xps,XpsRenderer,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsRenderer.cs,RenderPage_Test01,The length of the statement  "				string xmlPath = IOPath.Combine (IOPath.GetDirectoryName (xpsFilename)' IOPath.GetFileNameWithoutExtension (xpsFilename)) + ".xml"; " is 131.
Long Statement,PdfSharp.Xps,XpsRenderer,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsRenderer.cs,RenderPage_Test01,The length of the statement  "		#            string xmlPath = IOPath.Combine(IOPath.GetDirectoryName(xpsFilename)' IOPath.GetFileNameWithoutExtension(xpsFilename)) + ".xml";" is 141.
Long Statement,PdfSharp.Xps,XpsRenderer,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsRenderer.cs,GetPartAsString,The length of the statement  "			          string xmlPath = IOPath.Combine(IOPath.GetDirectoryName(xpsFilename)' IOPath.GetFileNameWithoutExtension(xpsFilename)) + ".xml";" is 128.
Long Statement,PdfSharp.Xps.XpsModel,ArcSegment,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\ArcSegment.cs,GetBoundingBox,The length of the statement  "	System.Windows.Media.ArcSegment arc = new System.Windows.Media.ArcSegment (new System.Windows.Point (Point.X' Point.Y)' new System.Windows.Size (Size.Width' Size.Height)' RotationAngle' IsLargeArc' (System.Windows.Media.SweepDirection)SweepDirection' IsStroked); " is 262.
Long Statement,PdfSharp.Xps.XpsModel,XpsDocument,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\XpsDocument.cs,GetPartAsBytes,The length of the statement  "		//target = PackUriHelper.ResolvePartUri(package.t.GetRelationship Uri("/documents2/3/Pages"' UriKind.RelativeOrAbsolute)' target); " is 130.
Long Statement,PdfSharp.Xps.XpsModel,Point,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Point.cs,ParsePoints,The length of the statement  "		Point point = new Point (ParserHelper.ParseDouble (tokenizer.GetCurrentToken ())' ParserHelper.ParseDouble (tokenizer.NextTokenRequired ())); " is 141.
Long Statement,PdfSharp,PSXSR,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp\PSXSR.cs,InvalidValue,The length of the statement  "	return Format ("{0} is not a valid value for {1}. {1} should be greater than or equal to {2} and less than or equal to {3}."' val' name' min' max); " is 147.
Empty Catch Block,PdfSharp.Xps,XpsRenderer,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsRenderer.cs,RenderPage_Test01,The method has an empty catch block.
Magic Number,PdfSharp.Xps.Rendering,PatternOrShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\BuilderBase.cs,CanOptimizeForTwoColors,The following statement contains a magic number: return gradients.Count == 2 && gradients [0].Offset == 0 && gradients [1].Offset == 1;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: if (boldSimulation) {  	boldSimulation = true;  	// draw black stroke if it is not a solid color brush  	XColor color = XColor.FromArgb (0' 0' 0);  	if (glyphs.Fill is SolidColorBrush) {  		SolidColorBrush brush = glyphs.Fill as SolidColorBrush;  		color = brush.Color;  	}  	WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  	WriteLiteral ("{0:0.###} w\n"' emSize / 50);  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: if (boldSimulation) {  	boldSimulation = true;  	// draw black stroke if it is not a solid color brush  	XColor color = XColor.FromArgb (0' 0' 0);  	if (glyphs.Fill is SolidColorBrush) {  		SolidColorBrush brush = glyphs.Fill as SolidColorBrush;  		color = brush.Color;  	}  	WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  	WriteLiteral ("{0:0.###} w\n"' emSize / 50);  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: if (boldSimulation) {  	boldSimulation = true;  	// draw black stroke if it is not a solid color brush  	XColor color = XColor.FromArgb (0' 0' 0);  	if (glyphs.Fill is SolidColorBrush) {  		SolidColorBrush brush = glyphs.Fill as SolidColorBrush;  		color = brush.Color;  	}  	WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  	WriteLiteral ("{0:0.###} w\n"' emSize / 50);  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: if (boldSimulation) {  	boldSimulation = true;  	// draw black stroke if it is not a solid color brush  	XColor color = XColor.FromArgb (0' 0' 0);  	if (glyphs.Fill is SolidColorBrush) {  		SolidColorBrush brush = glyphs.Fill as SolidColorBrush;  		color = brush.Color;  	}  	WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  	WriteLiteral ("{0:0.###} w\n"' emSize / 50);  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: WriteLiteral (String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}  RG\n"' color.R / 255.0' color.G / 255.0' color.B / 255.0));  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: WriteLiteral ("{0:0.###} w\n"' emSize / 50);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: if ((glyphs.StyleSimulations & StyleSimulations.ItalicSimulation) == StyleSimulations.ItalicSimulation) {  	textMatrix.SkewPrepend (-20' 0);  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: textMatrix.SkewPrepend (-20' 0);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: if (glyphs.IsSideways) {  	textMatrix.RotateAtPrepend (-90' new XPoint (x' y));  	XPoint pos = new XPoint (x' y);  	AdjustTextMatrix (ref pos);  	//WriteTextTransform(textMatrix);  	WriteLiteral ("{0} Tj\n"' text);  }  else {  	#if true  	//if (glyphs.BidiLevel % 2 == 1)  	//  WriteLiteral("-1 Tc\n");  	if (!textMatrix.IsIdentity)  		WriteTextTransform (textMatrix);  	WriteGlyphsInternal (glyphs' null);  	#else  	        XPoint pos = new XPoint(x' y);         AdjustTextMatrix(ref pos);         WriteLiteral("{0:0.} {1:0.} Td {2} Tj\n"' pos.x' pos.y' text);         //PdfEncoders.ToStringLiteral(s' PdfStringEncoding.RawEncoding' null)); #endif  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs,The following statement contains a magic number: textMatrix.RotateAtPrepend (-90' new XPoint (x' y));  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: if (mustRender) {  	outputText.Append ('>');  	WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  		width = mapping.AdvanceWidth * 10;  	pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  	// reset values  	accumulatedWidth = 0;  	outputGlyphCount = 0;  	outputText.Length = 0;  	mustRender = false;  }  else// deferred rendering   {  	// accumulate width  	Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  	accumulatedWidth += width;  	outputGlyphCount++;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: if (mustRender) {  	outputText.Append ('>');  	WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  		width = mapping.AdvanceWidth * 10;  	pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  	// reset values  	accumulatedWidth = 0;  	outputGlyphCount = 0;  	outputText.Length = 0;  	mustRender = false;  }  else// deferred rendering   {  	// accumulate width  	Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  	accumulatedWidth += width;  	outputGlyphCount++;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: if (mustRender) {  	outputText.Append ('>');  	WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  		width = mapping.AdvanceWidth * 10;  	pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  	// reset values  	accumulatedWidth = 0;  	outputGlyphCount = 0;  	outputText.Length = 0;  	mustRender = false;  }  else// deferred rendering   {  	// accumulate width  	Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  	accumulatedWidth += width;  	outputGlyphCount++;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  	width = mapping.AdvanceWidth * 10;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: width = mapping.AdvanceWidth * 10;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_DistanceOnly,The following statement contains a magic number: width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: do {  	GlyphIndices.GlyphMapping clusterMapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx < glyphCount)  		clusterMapping = indices [glyphIdx];  	for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  		GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  		if (glyphIdx + clusterGlyphIdx < glyphCount)  			mapping = indices [glyphIdx + clusterGlyphIdx];  		Debug.Assert (mustRender == false);  		// Determine whether to render accumulated glyphs  		if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  			//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  			//  width = mapping.AdvanceWidth * 10;  			//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  			pos = new XPoint (accumulatedWidth' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		mustRender = mapping.HasAdvanceWidth;  		//mustRender = true;  		// Adjust former uOffset  		if (uOffset != 0) {  			pos.x -= uOffset;  			uOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former uOffset  		if (mapping.HasUOffset) {  			uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  			pos.x += uOffset;  			mustRender = true;  			hasOffset = true;  		}  		// Adjust former vOffset  		if (vOffset != 0) {  			pos.y += vOffset;  			vOffset = 0;  			mustRender = true;  		}  		// Adjust position by current former vOffset  		if (mapping.HasVOffset) {  			vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  			pos.y -= vOffset;  			mustRender = true;  			hasOffset = true;  		}  		// get index of current glyph  		if (mapping.HasGlyphIndex)  			glyphIndex = mapping.GlyphIndex;  		else  			glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  		// add glyph index to the fonts 'used glyph table'  		realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  		#if true  		if (outputGlyphCount == 0)  			outputText.Append ('<');  		outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  		#else  		          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  		// At the end of the glyph run we must always render  		if (!mustRender)  			mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  			&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  		// is it the last glyph index  		//mustRender = true;  		if (mustRender) {  			outputText.Append ('>');  			WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  				width = mapping.AdvanceWidth * 10;  			pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  			// reset values  			accumulatedWidth = 0;  			outputGlyphCount = 0;  			outputText.Length = 0;  			mustRender = false;  		}  		else// deferred rendering  		 {  			// accumulate width  			Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  			double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  			width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  			accumulatedWidth += width;  			outputGlyphCount++;  		}  	}  	codeIdx += clusterMapping.ClusterCodeUnitCount;  	glyphIdx += clusterMapping.ClusterGlyphCount;  	if (codeIdx >= codeCount && glyphIdx >= glyphCount)  		stop = true;  }  while (!stop);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: for (int clusterGlyphIdx = 0; clusterGlyphIdx < clusterMapping.ClusterGlyphCount; clusterGlyphIdx++) {  	GlyphIndices.GlyphMapping mapping = new GlyphIndices.GlyphMapping (42);  	if (glyphIdx + clusterGlyphIdx < glyphCount)  		mapping = indices [glyphIdx + clusterGlyphIdx];  	Debug.Assert (mustRender == false);  	// Determine whether to render accumulated glyphs  	if (outputGlyphCount > 0 && (hasOffset || mapping.HasAdvanceWidthOrOffset)) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		//double width = descriptor.GlyphIndexToPdfWidth(glyphIndex);  		//if (!PdfSharp.Internal.DoubleUtil.IsNaN(mapping.AdvanceWidth))  		//  width = mapping.AdvanceWidth * 10;  		//pos = new XPoint(accumulatedWidth + width / 1000 * glyphs.FontRenderingEmSize' 0);  		pos = new XPoint (accumulatedWidth' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	mustRender = mapping.HasAdvanceWidth;  	//mustRender = true;  	// Adjust former uOffset  	if (uOffset != 0) {  		pos.x -= uOffset;  		uOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former uOffset  	if (mapping.HasUOffset) {  		uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  		pos.x += uOffset;  		mustRender = true;  		hasOffset = true;  	}  	// Adjust former vOffset  	if (vOffset != 0) {  		pos.y += vOffset;  		vOffset = 0;  		mustRender = true;  	}  	// Adjust position by current former vOffset  	if (mapping.HasVOffset) {  		vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  		pos.y -= vOffset;  		mustRender = true;  		hasOffset = true;  	}  	// get index of current glyph  	if (mapping.HasGlyphIndex)  		glyphIndex = mapping.GlyphIndex;  	else  		glyphIndex = descriptor.CharCodeToGlyphIndex (unicodeString [codeIdx]);  	// add glyph index to the fonts 'used glyph table'  	realizedFont.AddGlyphIndices (new string ((char)glyphIndex' 1));  	#if true  	if (outputGlyphCount == 0)  		outputText.Append ('<');  	outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  	#else  	          byte[] bytes = new byte[2] { (byte)(glyphIndex >> 8)' (byte)glyphIndex };           bytes = PdfEncoders.FormatStringLiteral(bytes' true' false' true' null);           string output = PdfEncoders.RawEncoding.GetString(bytes); #endif  	// At the end of the glyph run we must always render  	if (!mustRender)  		mustRender = codeIdx + clusterMapping.ClusterCodeUnitCount >= codeCount // is it the last code unit cluster  		&& glyphIdx + clusterGlyphIdx + 1 >= glyphCount;  	// is it the last glyph index  	//mustRender = true;  	if (mustRender) {  		outputText.Append ('>');  		WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  			width = mapping.AdvanceWidth * 10;  		pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  		// reset values  		accumulatedWidth = 0;  		outputGlyphCount = 0;  		outputText.Length = 0;  		mustRender = false;  	}  	else// deferred rendering  	 {  		// accumulate width  		Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  		double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  		width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  		accumulatedWidth += width;  		outputGlyphCount++;  	}  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: if (mapping.HasUOffset) {  	uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  	pos.x += uOffset;  	mustRender = true;  	hasOffset = true;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: uOffset = mapping.UOffset * glyphs.FontRenderingEmSize / 100;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: if (mapping.HasVOffset) {  	vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  	pos.y -= vOffset;  	mustRender = true;  	hasOffset = true;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: vOffset = mapping.VOffset * glyphs.FontRenderingEmSize / 100;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: outputText.AppendFormat ("{0:X2}{1:X2}"' (byte)(glyphIndex >> 8)' (byte)glyphIndex);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: if (mustRender) {  	outputText.Append ('>');  	WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  		width = mapping.AdvanceWidth * 10;  	pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  	// reset values  	accumulatedWidth = 0;  	outputGlyphCount = 0;  	outputText.Length = 0;  	mustRender = false;  }  else// deferred rendering   {  	// accumulate width  	Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  	accumulatedWidth += width;  	outputGlyphCount++;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: if (mustRender) {  	outputText.Append ('>');  	WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  		width = mapping.AdvanceWidth * 10;  	pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  	// reset values  	accumulatedWidth = 0;  	outputGlyphCount = 0;  	outputText.Length = 0;  	mustRender = false;  }  else// deferred rendering   {  	// accumulate width  	Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  	accumulatedWidth += width;  	outputGlyphCount++;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: if (mustRender) {  	outputText.Append ('>');  	WriteLiteral ("{0:0.####} {1:0.####} Td {2}Tj\n"' pos.x' pos.y' outputText.ToString ());  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  		width = mapping.AdvanceWidth * 10;  	pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  	// reset values  	accumulatedWidth = 0;  	outputGlyphCount = 0;  	outputText.Length = 0;  	mustRender = false;  }  else// deferred rendering   {  	// accumulate width  	Debug.Assert (DoubleUtil.IsNaN (mapping.AdvanceWidth));  	double width = descriptor.GlyphIndexToPdfWidth (glyphIndex);  	width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  	accumulatedWidth += width;  	outputGlyphCount++;  }  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: if (!PdfSharp.Internal.DoubleUtil.IsNaN (mapping.AdvanceWidth))  	width = mapping.AdvanceWidth * 10;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: width = mapping.AdvanceWidth * 10;  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: pos = new XPoint (accumulatedWidth + width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize' 0);  
Magic Number,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphs_ClusterMapping,The following statement contains a magic number: width = width * boldSimulationFactor / 1000 * glyphs.FontRenderingEmSize;  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: pattern.Elements.SetInteger (PdfTilingPattern.Keys.TilingType' 3);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: if (brush.SpreadMethod != SpreadMethod.Pad) {  	// TODO: Calculate number of required shadings  	shadingCount = Convert.ToInt32 (Math.Max (boundingBox.width / (2 * brush.RadiusX)' boundingBox.height / (2 * brush.RadiusY)) + 1);  	// HACK: Rule of thumb' better than nothing  	shadingCount *= 2;  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: if (brush.SpreadMethod != SpreadMethod.Pad) {  	// TODO: Calculate number of required shadings  	shadingCount = Convert.ToInt32 (Math.Max (boundingBox.width / (2 * brush.RadiusX)' boundingBox.height / (2 * brush.RadiusY)) + 1);  	// HACK: Rule of thumb' better than nothing  	shadingCount *= 2;  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: if (brush.SpreadMethod != SpreadMethod.Pad) {  	// TODO: Calculate number of required shadings  	shadingCount = Convert.ToInt32 (Math.Max (boundingBox.width / (2 * brush.RadiusX)' boundingBox.height / (2 * brush.RadiusY)) + 1);  	// HACK: Rule of thumb' better than nothing  	shadingCount *= 2;  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: shadingCount = Convert.ToInt32 (Math.Max (boundingBox.width / (2 * brush.RadiusX)' boundingBox.height / (2 * brush.RadiusY)) + 1);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: shadingCount = Convert.ToInt32 (Math.Max (boundingBox.width / (2 * brush.RadiusX)' boundingBox.height / (2 * brush.RadiusY)) + 1);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: shadingCount *= 2;  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildPattern,The following statement contains a magic number: for (int idx = 0; idx < shadingCount; idx++) {  	PdfShading shading = BuildShading2 (brush' scaleX' scaleY' idx' brush.SpreadMethod == SpreadMethod.Reflect && idx % 2 == 1 ? funcReflected : funcRegular);  	shadings [idx] = shading;  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShading,The following statement contains a magic number: shading.Elements.SetInteger (PdfShading.Keys.ShadingType' 3);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShading2,The following statement contains a magic number: shading.Elements.SetInteger (PdfShading.Keys.ShadingType' 3);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildForm,The following statement contains a magic number: pdfForm.Elements.SetRectangle (PdfFormXObject.Keys.BBox' new PdfRectangle (0' 640' 480' 0));  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildForm,The following statement contains a magic number: pdfForm.Elements.SetRectangle (PdfFormXObject.Keys.BBox' new PdfRectangle (0' 640' 480' 0));  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingForSoftMask,The following statement contains a magic number: shading.Elements.SetInteger (PdfShading.Keys.ShadingType' 2);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: Debug.Assert (count >= 2);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (CanOptimizeForTwoColors (gradients)) {  	funcReverse = null;  	// Build a Type 3 function with an array of 2 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append (reverse ? "1 0" : "0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  else {  	#if true  	funcReverse = BuildShadingFunction3 (gradients' softMask' colorMode);  	Context.PdfDocument.Internals.AddObject (funcReverse);  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/Encode"] = new PdfLiteral ("[1 0]");  	func.Elements ["/Bounds"] = new PdfLiteral ("[]");  	func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	PdfArray fnarray0 = new PdfArray ();  	fnarray0.Elements.Add (funcReverse);  	func.Elements ["/Functions"] = fnarray0;  	#else  	        //        // Build a Type 3 function with an array of n-1 Type 2 functions          PdfDictionary fn1 = new PdfDictionary();           func.Elements["/FunctionType"] = new PdfInteger(3);  // Type 3 - Stitching Function         func.Elements["/Domain"] = new PdfLiteral("[0 1]");         func.Elements["/Encode"] = new PdfLiteral("[1 0]");         func.Elements["/Bounds"] = new PdfLiteral("[]");         func.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");         PdfArray fnarray0 = new PdfArray();         fnarray0.Elements.Add(fn1);         func.Elements["/Functions"] = fnarray0;              fn1.Elements["/FunctionType"] = new PdfInteger(3);  // Type 3 - Stitching Function         fn1.Elements["/Domain"] = new PdfLiteral("[0 1]");         fn1.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");         PdfArray fnarray = new PdfArray();         fn1.Elements["/Functions"] = fnarray;          StringBuilder bounds = new StringBuilder("[");         StringBuilder encode = new StringBuilder("[");          for (int idx = 1; idx < count; idx++)         {           PdfDictionary fn2 = new PdfDictionary();           fn2.Elements["/FunctionType"] = new PdfInteger(2);           Color clr0 = gradients[idx - 1].Color;           Color clr1 = gradients[idx].Color;           if (softMask)           {             fn2.Elements["/C0"] = new PdfLiteral("[" + PdfEncoders.ToString(clr0.ScA) + "]");             fn2.Elements["/C1"] = new PdfLiteral("[" + PdfEncoders.ToString(clr1.ScA) + "]");             fn2.Elements["/Range"] = new PdfLiteral("[0 1]");           }           else           {             fn2.Elements["/C0"] = new PdfLiteral("[" + PdfEncoders.ToString(clr0' colorMode) + "]");             fn2.Elements["/C1"] = new PdfLiteral("[" + PdfEncoders.ToString(clr1' colorMode) + "]");             fn2.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");           }           fn2.Elements["/Domain"] = new PdfLiteral("[0 1]");           fn2.Elements["/N"] = new PdfInteger(1);           //this.renderer.Owner.Internals.AddObject(fn2);           //fnarray.Elements.Add(fn2.Reference);           fnarray.Elements.Add(fn2);           if (idx > 1)           {             bounds.Append(' ');             encode.Append(' ');           }           if (idx < count - 1)             bounds.Append(PdfEncoders.ToString(gradients[idx].Offset));           encode.Append("0 1");         }         bounds.Append(']');         encode.Append(']');         fn1.Elements["/Bounds"] = new PdfLiteral(bounds.ToString());         fn1.Elements["/Encode"] = new PdfLiteral(encode.ToString()); #endif  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (CanOptimizeForTwoColors (gradients)) {  	funcReverse = null;  	// Build a Type 3 function with an array of 2 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append (reverse ? "1 0" : "0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  else {  	#if true  	funcReverse = BuildShadingFunction3 (gradients' softMask' colorMode);  	Context.PdfDocument.Internals.AddObject (funcReverse);  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/Encode"] = new PdfLiteral ("[1 0]");  	func.Elements ["/Bounds"] = new PdfLiteral ("[]");  	func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	PdfArray fnarray0 = new PdfArray ();  	fnarray0.Elements.Add (funcReverse);  	func.Elements ["/Functions"] = fnarray0;  	#else  	        //        // Build a Type 3 function with an array of n-1 Type 2 functions          PdfDictionary fn1 = new PdfDictionary();           func.Elements["/FunctionType"] = new PdfInteger(3);  // Type 3 - Stitching Function         func.Elements["/Domain"] = new PdfLiteral("[0 1]");         func.Elements["/Encode"] = new PdfLiteral("[1 0]");         func.Elements["/Bounds"] = new PdfLiteral("[]");         func.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");         PdfArray fnarray0 = new PdfArray();         fnarray0.Elements.Add(fn1);         func.Elements["/Functions"] = fnarray0;              fn1.Elements["/FunctionType"] = new PdfInteger(3);  // Type 3 - Stitching Function         fn1.Elements["/Domain"] = new PdfLiteral("[0 1]");         fn1.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");         PdfArray fnarray = new PdfArray();         fn1.Elements["/Functions"] = fnarray;          StringBuilder bounds = new StringBuilder("[");         StringBuilder encode = new StringBuilder("[");          for (int idx = 1; idx < count; idx++)         {           PdfDictionary fn2 = new PdfDictionary();           fn2.Elements["/FunctionType"] = new PdfInteger(2);           Color clr0 = gradients[idx - 1].Color;           Color clr1 = gradients[idx].Color;           if (softMask)           {             fn2.Elements["/C0"] = new PdfLiteral("[" + PdfEncoders.ToString(clr0.ScA) + "]");             fn2.Elements["/C1"] = new PdfLiteral("[" + PdfEncoders.ToString(clr1.ScA) + "]");             fn2.Elements["/Range"] = new PdfLiteral("[0 1]");           }           else           {             fn2.Elements["/C0"] = new PdfLiteral("[" + PdfEncoders.ToString(clr0' colorMode) + "]");             fn2.Elements["/C1"] = new PdfLiteral("[" + PdfEncoders.ToString(clr1' colorMode) + "]");             fn2.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");           }           fn2.Elements["/Domain"] = new PdfLiteral("[0 1]");           fn2.Elements["/N"] = new PdfInteger(1);           //this.renderer.Owner.Internals.AddObject(fn2);           //fnarray.Elements.Add(fn2.Reference);           fnarray.Elements.Add(fn2);           if (idx > 1)           {             bounds.Append(' ');             encode.Append(' ');           }           if (idx < count - 1)             bounds.Append(PdfEncoders.ToString(gradients[idx].Offset));           encode.Append("0 1");         }         bounds.Append(']');         encode.Append(']');         fn1.Elements["/Bounds"] = new PdfLiteral(bounds.ToString());         fn1.Elements["/Encode"] = new PdfLiteral(encode.ToString()); #endif  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (CanOptimizeForTwoColors (gradients)) {  	funcReverse = null;  	// Build a Type 3 function with an array of 2 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append (reverse ? "1 0" : "0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  else {  	#if true  	funcReverse = BuildShadingFunction3 (gradients' softMask' colorMode);  	Context.PdfDocument.Internals.AddObject (funcReverse);  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/Encode"] = new PdfLiteral ("[1 0]");  	func.Elements ["/Bounds"] = new PdfLiteral ("[]");  	func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	PdfArray fnarray0 = new PdfArray ();  	fnarray0.Elements.Add (funcReverse);  	func.Elements ["/Functions"] = fnarray0;  	#else  	        //        // Build a Type 3 function with an array of n-1 Type 2 functions          PdfDictionary fn1 = new PdfDictionary();           func.Elements["/FunctionType"] = new PdfInteger(3);  // Type 3 - Stitching Function         func.Elements["/Domain"] = new PdfLiteral("[0 1]");         func.Elements["/Encode"] = new PdfLiteral("[1 0]");         func.Elements["/Bounds"] = new PdfLiteral("[]");         func.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");         PdfArray fnarray0 = new PdfArray();         fnarray0.Elements.Add(fn1);         func.Elements["/Functions"] = fnarray0;              fn1.Elements["/FunctionType"] = new PdfInteger(3);  // Type 3 - Stitching Function         fn1.Elements["/Domain"] = new PdfLiteral("[0 1]");         fn1.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");         PdfArray fnarray = new PdfArray();         fn1.Elements["/Functions"] = fnarray;          StringBuilder bounds = new StringBuilder("[");         StringBuilder encode = new StringBuilder("[");          for (int idx = 1; idx < count; idx++)         {           PdfDictionary fn2 = new PdfDictionary();           fn2.Elements["/FunctionType"] = new PdfInteger(2);           Color clr0 = gradients[idx - 1].Color;           Color clr1 = gradients[idx].Color;           if (softMask)           {             fn2.Elements["/C0"] = new PdfLiteral("[" + PdfEncoders.ToString(clr0.ScA) + "]");             fn2.Elements["/C1"] = new PdfLiteral("[" + PdfEncoders.ToString(clr1.ScA) + "]");             fn2.Elements["/Range"] = new PdfLiteral("[0 1]");           }           else           {             fn2.Elements["/C0"] = new PdfLiteral("[" + PdfEncoders.ToString(clr0' colorMode) + "]");             fn2.Elements["/C1"] = new PdfLiteral("[" + PdfEncoders.ToString(clr1' colorMode) + "]");             fn2.Elements["/Range"] = new PdfLiteral("[0 1 0 1 0 1]");           }           fn2.Elements["/Domain"] = new PdfLiteral("[0 1]");           fn2.Elements["/N"] = new PdfInteger(1);           //this.renderer.Owner.Internals.AddObject(fn2);           //fnarray.Elements.Add(fn2.Reference);           fnarray.Elements.Add(fn2);           if (idx > 1)           {             bounds.Append(' ');             encode.Append(' ');           }           if (idx < count - 1)             bounds.Append(PdfEncoders.ToString(gradients[idx].Offset));           encode.Append("0 1");         }         bounds.Append(']');         encode.Append(']');         fn1.Elements["/Bounds"] = new PdfLiteral(bounds.ToString());         fn1.Elements["/Encode"] = new PdfLiteral(encode.ToString()); #endif  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: func.Elements ["/FunctionType"] = new PdfInteger (3);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: for (int idx = 1; idx < count; idx++) {  	PdfDictionary fn2 = new PdfDictionary ();  	fn2.Elements ["/FunctionType"] = new PdfInteger (2);  	Color clr0 = gradients [idx - 1].Color;  	Color clr1 = gradients [idx].Color;  	if (softMask) {  		fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	fn2.Elements ["/N"] = new PdfInteger (1);  	fnarray.Elements.Add (fn2);  	if (idx > 1) {  		bounds.Append (' ');  		encode.Append (' ');  	}  	if (idx < count - 1)  		bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  	encode.Append (reverse ? "1 0" : "0 1");  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: fn2.Elements ["/FunctionType"] = new PdfInteger (2);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: func.Elements ["/FunctionType"] = new PdfInteger (3);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction3,The following statement contains a magic number: Debug.Assert (count >= 2);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction3,The following statement contains a magic number: fn1.Elements ["/FunctionType"] = new PdfInteger (3);  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction3,The following statement contains a magic number: for (int idx = 1; idx < count; idx++) {  	PdfDictionary fn2 = new PdfDictionary ();  	fn2.Elements ["/FunctionType"] = new PdfInteger (2);  	Color clr0 = gradients [idx - 1].Color;  	Color clr1 = gradients [idx].Color;  	if (softMask) {  		fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	fn2.Elements ["/N"] = new PdfInteger (1);  	fnarray.Elements.Add (fn2);  	if (idx > 1) {  		bounds.Append (' ');  		encode.Append (' ');  	}  	if (idx < count - 1)  		bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  	encode.Append ("0 1");  }  
Magic Number,PdfSharp.Xps.Rendering,RadialShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\RadialShadingBuilder.cs,BuildShadingFunction3,The following statement contains a magic number: fn2.Elements ["/FunctionType"] = new PdfInteger (2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShading,The following statement contains a magic number: shading.Elements.SetInteger (PdfShading.Keys.ShadingType' 2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingPattern,The following statement contains a magic number: pattern.Elements.SetInteger (PdfShadingPattern.Keys.PatternType' 2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildForm,The following statement contains a magic number: pdfForm.Elements.SetRectangle (PdfFormXObject.Keys.BBox' new PdfRectangle (0' 640' 480' 0));  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildForm,The following statement contains a magic number: pdfForm.Elements.SetRectangle (PdfFormXObject.Keys.BBox' new PdfRectangle (0' 640' 480' 0));  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingForSoftMask,The following statement contains a magic number: shading.Elements.SetInteger (PdfShading.Keys.ShadingType' 2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingForSoftMask,The following statement contains a magic number: shading.Elements.SetInteger (PdfShading.Keys.ShadingType' 2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: Debug.Assert (count >= 2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (count == 2 && gradients [0].Offset == 0 && gradients [1].Offset == 1) {  	// Build a Type 2 function  	func.Elements ["/FunctionType"] = new PdfInteger (2);  	// Type 2 - Exponential Interpolation Function  	Color clr0 = gradients [0].Color;  	Color clr1 = gradients [1].Color;  	if (softMask) {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/N"] = new PdfInteger (1);  	// be linear  }  else {  	// Build a Type 3 function with an array of n-1 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		//this.renderer.Owner.Internals.AddObject(fn2);  		//fnarray.Elements.Add(fn2.Reference);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append ("0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (count == 2 && gradients [0].Offset == 0 && gradients [1].Offset == 1) {  	// Build a Type 2 function  	func.Elements ["/FunctionType"] = new PdfInteger (2);  	// Type 2 - Exponential Interpolation Function  	Color clr0 = gradients [0].Color;  	Color clr1 = gradients [1].Color;  	if (softMask) {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/N"] = new PdfInteger (1);  	// be linear  }  else {  	// Build a Type 3 function with an array of n-1 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		//this.renderer.Owner.Internals.AddObject(fn2);  		//fnarray.Elements.Add(fn2.Reference);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append ("0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (count == 2 && gradients [0].Offset == 0 && gradients [1].Offset == 1) {  	// Build a Type 2 function  	func.Elements ["/FunctionType"] = new PdfInteger (2);  	// Type 2 - Exponential Interpolation Function  	Color clr0 = gradients [0].Color;  	Color clr1 = gradients [1].Color;  	if (softMask) {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/N"] = new PdfInteger (1);  	// be linear  }  else {  	// Build a Type 3 function with an array of n-1 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		//this.renderer.Owner.Internals.AddObject(fn2);  		//fnarray.Elements.Add(fn2.Reference);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append ("0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: if (count == 2 && gradients [0].Offset == 0 && gradients [1].Offset == 1) {  	// Build a Type 2 function  	func.Elements ["/FunctionType"] = new PdfInteger (2);  	// Type 2 - Exponential Interpolation Function  	Color clr0 = gradients [0].Color;  	Color clr1 = gradients [1].Color;  	if (softMask) {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		func.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		func.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		func.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	func.Elements ["/N"] = new PdfInteger (1);  	// be linear  }  else {  	// Build a Type 3 function with an array of n-1 Type 2 functions  	func.Elements ["/FunctionType"] = new PdfInteger (3);  	// Type 3 - Stitching Function  	func.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	PdfArray fnarray = new PdfArray ();  	func.Elements ["/Functions"] = fnarray;  	StringBuilder bounds = new StringBuilder ("[");  	StringBuilder encode = new StringBuilder ("[");  	for (int idx = 1; idx < count; idx++) {  		PdfDictionary fn2 = new PdfDictionary ();  		fn2.Elements ["/FunctionType"] = new PdfInteger (2);  		Color clr0 = gradients [idx - 1].Color;  		Color clr1 = gradients [idx].Color;  		if (softMask) {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  		}  		else {  			fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  			fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  			fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  		}  		fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  		fn2.Elements ["/N"] = new PdfInteger (1);  		//this.renderer.Owner.Internals.AddObject(fn2);  		//fnarray.Elements.Add(fn2.Reference);  		fnarray.Elements.Add (fn2);  		if (idx > 1) {  			bounds.Append (' ');  			encode.Append (' ');  		}  		if (idx < count - 1)  			bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  		encode.Append ("0 1");  	}  	bounds.Append (']');  	encode.Append (']');  	func.Elements ["/Bounds"] = new PdfLiteral (bounds.ToString ());  	func.Elements ["/Encode"] = new PdfLiteral (encode.ToString ());  }  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: func.Elements ["/FunctionType"] = new PdfInteger (2);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: func.Elements ["/FunctionType"] = new PdfInteger (3);  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: for (int idx = 1; idx < count; idx++) {  	PdfDictionary fn2 = new PdfDictionary ();  	fn2.Elements ["/FunctionType"] = new PdfInteger (2);  	Color clr0 = gradients [idx - 1].Color;  	Color clr1 = gradients [idx].Color;  	if (softMask) {  		fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0.ScA) + "]");  		fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1.ScA) + "]");  		fn2.Elements ["/Range"] = new PdfLiteral ("[0 1]");  	}  	else {  		fn2.Elements ["/C0"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr0' colorMode) + "]");  		fn2.Elements ["/C1"] = new PdfLiteral ("[" + PdfEncoders.ToString (clr1' colorMode) + "]");  		fn2.Elements ["/Range"] = new PdfLiteral ("[0 1 0 1 0 1]");  	}  	fn2.Elements ["/Domain"] = new PdfLiteral ("[0 1]");  	fn2.Elements ["/N"] = new PdfInteger (1);  	//this.renderer.Owner.Internals.AddObject(fn2);  	//fnarray.Elements.Add(fn2.Reference);  	fnarray.Elements.Add (fn2);  	if (idx > 1) {  		bounds.Append (' ');  		encode.Append (' ');  	}  	if (idx < count - 1)  		bounds.Append (PdfEncoders.ToString (gradients [idx].Offset));  	encode.Append ("0 1");  }  
Magic Number,PdfSharp.Xps.Rendering,LinearShadingBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\LinearShadingBuilder.cs,BuildShadingFunction,The following statement contains a magic number: fn2.Elements ["/FunctionType"] = new PdfInteger (2);  
Magic Number,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildPattern,The following statement contains a magic number: pattern.Elements.SetInteger (PdfTilingPattern.Keys.TilingType' 3);  
Magic Number,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildPattern,The following statement contains a magic number: pattern.Elements.SetInteger (PdfTilingPattern.Keys.TilingType' 3);  
Magic Number,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildForm,The following statement contains a magic number: pdfForm.DpiX = 96;  
Magic Number,PdfSharp.Xps.Rendering,TilingPatternBuilder,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\TilingPatternBuilder.cs,BuildForm,The following statement contains a magic number: pdfForm.DpiY = 96;  
Magic Number,PdfSharp.Xps.Rendering,Utils,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\Utils.cs,AlphaToGray,The following statement contains a magic number: return Color.FromArgb (255' color.A' color.A' color.A);  
Magic Number,PdfSharp.Xps.Rendering,WpfUtils,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\WpfUtils.cs,FlattenSegment,The following statement contains a magic number: for (int idx = 0; idx < count - 1; idx += 2) {  	QuadraticBezierSegment qbseg = new QuadraticBezierSegment (new Point (seg.Points [idx].X' seg.Points [idx].Y)' new Point (seg.Points [idx + 1].X' seg.Points [idx + 1].Y)' seg.IsStroked);  	fig.Segments.Add (qbseg);  }  
Magic Number,PdfSharp.Xps.Rendering,WpfUtils,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\WpfUtils.cs,FlattenSegment,The following statement contains a magic number: idx += 2
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: foreach (FixedPage page in fixedDocument.Pages) {  	if (page == null)  		continue;  	Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  	PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  	renderer.RenderPage (pdfPage' page);  	pageIndex++;  	#if DEBUG  	// stop at page...  	if (pageIndex == 50)  		break;  	#endif  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (pageIndex == 50)  	break;  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: try {  	xpsDocument = XpsDocument.Open (xpsFilename);  	FixedDocument fixedDocument = xpsDocument.GetDocument ();  	PdfDocument pdfDocument = new PdfDocument ();  	PdfRenderer renderer = new PdfRenderer ();  	int pageIndex = 0;  	foreach (FixedPage page in fixedDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  		renderer.RenderPage (pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	pdfDocument.Save (pdfFilename);  	xpsDocument.Close ();  	xpsDocument = null;  	if (createComparisonDocument) {  		System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  		System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  		if (docSeq == null)  			throw new InvalidOperationException ("docSeq");  		XPdfForm form = XPdfForm.FromFile (pdfFilename);  		PdfDocument pdfComparisonDocument = new PdfDocument ();  		pageIndex = 0;  		foreach (PdfPage page in pdfDocument.Pages) {  			if (page == null)  				continue;  			Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  			PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  			double width = page.Width;  			double height = page.Height;  			pdfPage.Width = page.Width * 2;  			pdfPage.Height = page.Height;  			DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  			//byte[] png = PngFromPage(docPage' 96);  			BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  			XImage image = XImage.FromBitmapSource (bmsource);  			XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  			form.PageIndex = pageIndex;  			gfx.DrawImage (form' 0' 0' width' height);  			gfx.DrawImage (image' width' 0' width' height);  			//renderer.RenderPage(pdfPage' page);  			pageIndex++;  			#if DEBUG  			// stop at page...  			if (pageIndex == 50)  				break;  			#endif  		}  		string pdfComparisonFilename = pdfFilename;  		if (IOPath.HasExtension (pdfComparisonFilename))  			pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  		pdfComparisonFilename += "-comparison.pdf";  		pdfComparisonDocument.ViewerPreferences.FitWindow = true;  		//pdfComparisonDocument.PageMode = PdfPageMode.  		pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  		pdfComparisonDocument.Save (pdfComparisonFilename);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	if (xpsDocument != null)  		xpsDocument.Close ();  	throw;  }  finally {  	if (xpsDocument != null)  		xpsDocument.Close ();  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: try {  	xpsDocument = XpsDocument.Open (xpsFilename);  	FixedDocument fixedDocument = xpsDocument.GetDocument ();  	PdfDocument pdfDocument = new PdfDocument ();  	PdfRenderer renderer = new PdfRenderer ();  	int pageIndex = 0;  	foreach (FixedPage page in fixedDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  		renderer.RenderPage (pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	pdfDocument.Save (pdfFilename);  	xpsDocument.Close ();  	xpsDocument = null;  	if (createComparisonDocument) {  		System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  		System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  		if (docSeq == null)  			throw new InvalidOperationException ("docSeq");  		XPdfForm form = XPdfForm.FromFile (pdfFilename);  		PdfDocument pdfComparisonDocument = new PdfDocument ();  		pageIndex = 0;  		foreach (PdfPage page in pdfDocument.Pages) {  			if (page == null)  				continue;  			Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  			PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  			double width = page.Width;  			double height = page.Height;  			pdfPage.Width = page.Width * 2;  			pdfPage.Height = page.Height;  			DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  			//byte[] png = PngFromPage(docPage' 96);  			BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  			XImage image = XImage.FromBitmapSource (bmsource);  			XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  			form.PageIndex = pageIndex;  			gfx.DrawImage (form' 0' 0' width' height);  			gfx.DrawImage (image' width' 0' width' height);  			//renderer.RenderPage(pdfPage' page);  			pageIndex++;  			#if DEBUG  			// stop at page...  			if (pageIndex == 50)  				break;  			#endif  		}  		string pdfComparisonFilename = pdfFilename;  		if (IOPath.HasExtension (pdfComparisonFilename))  			pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  		pdfComparisonFilename += "-comparison.pdf";  		pdfComparisonDocument.ViewerPreferences.FitWindow = true;  		//pdfComparisonDocument.PageMode = PdfPageMode.  		pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  		pdfComparisonDocument.Save (pdfComparisonFilename);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	if (xpsDocument != null)  		xpsDocument.Close ();  	throw;  }  finally {  	if (xpsDocument != null)  		xpsDocument.Close ();  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: try {  	xpsDocument = XpsDocument.Open (xpsFilename);  	FixedDocument fixedDocument = xpsDocument.GetDocument ();  	PdfDocument pdfDocument = new PdfDocument ();  	PdfRenderer renderer = new PdfRenderer ();  	int pageIndex = 0;  	foreach (FixedPage page in fixedDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  		renderer.RenderPage (pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	pdfDocument.Save (pdfFilename);  	xpsDocument.Close ();  	xpsDocument = null;  	if (createComparisonDocument) {  		System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  		System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  		if (docSeq == null)  			throw new InvalidOperationException ("docSeq");  		XPdfForm form = XPdfForm.FromFile (pdfFilename);  		PdfDocument pdfComparisonDocument = new PdfDocument ();  		pageIndex = 0;  		foreach (PdfPage page in pdfDocument.Pages) {  			if (page == null)  				continue;  			Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  			PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  			double width = page.Width;  			double height = page.Height;  			pdfPage.Width = page.Width * 2;  			pdfPage.Height = page.Height;  			DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  			//byte[] png = PngFromPage(docPage' 96);  			BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  			XImage image = XImage.FromBitmapSource (bmsource);  			XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  			form.PageIndex = pageIndex;  			gfx.DrawImage (form' 0' 0' width' height);  			gfx.DrawImage (image' width' 0' width' height);  			//renderer.RenderPage(pdfPage' page);  			pageIndex++;  			#if DEBUG  			// stop at page...  			if (pageIndex == 50)  				break;  			#endif  		}  		string pdfComparisonFilename = pdfFilename;  		if (IOPath.HasExtension (pdfComparisonFilename))  			pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  		pdfComparisonFilename += "-comparison.pdf";  		pdfComparisonDocument.ViewerPreferences.FitWindow = true;  		//pdfComparisonDocument.PageMode = PdfPageMode.  		pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  		pdfComparisonDocument.Save (pdfComparisonFilename);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	if (xpsDocument != null)  		xpsDocument.Close ();  	throw;  }  finally {  	if (xpsDocument != null)  		xpsDocument.Close ();  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: try {  	xpsDocument = XpsDocument.Open (xpsFilename);  	FixedDocument fixedDocument = xpsDocument.GetDocument ();  	PdfDocument pdfDocument = new PdfDocument ();  	PdfRenderer renderer = new PdfRenderer ();  	int pageIndex = 0;  	foreach (FixedPage page in fixedDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  		renderer.RenderPage (pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	pdfDocument.Save (pdfFilename);  	xpsDocument.Close ();  	xpsDocument = null;  	if (createComparisonDocument) {  		System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  		System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  		if (docSeq == null)  			throw new InvalidOperationException ("docSeq");  		XPdfForm form = XPdfForm.FromFile (pdfFilename);  		PdfDocument pdfComparisonDocument = new PdfDocument ();  		pageIndex = 0;  		foreach (PdfPage page in pdfDocument.Pages) {  			if (page == null)  				continue;  			Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  			PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  			double width = page.Width;  			double height = page.Height;  			pdfPage.Width = page.Width * 2;  			pdfPage.Height = page.Height;  			DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  			//byte[] png = PngFromPage(docPage' 96);  			BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  			XImage image = XImage.FromBitmapSource (bmsource);  			XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  			form.PageIndex = pageIndex;  			gfx.DrawImage (form' 0' 0' width' height);  			gfx.DrawImage (image' width' 0' width' height);  			//renderer.RenderPage(pdfPage' page);  			pageIndex++;  			#if DEBUG  			// stop at page...  			if (pageIndex == 50)  				break;  			#endif  		}  		string pdfComparisonFilename = pdfFilename;  		if (IOPath.HasExtension (pdfComparisonFilename))  			pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  		pdfComparisonFilename += "-comparison.pdf";  		pdfComparisonDocument.ViewerPreferences.FitWindow = true;  		//pdfComparisonDocument.PageMode = PdfPageMode.  		pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  		pdfComparisonDocument.Save (pdfComparisonFilename);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	if (xpsDocument != null)  		xpsDocument.Close ();  	throw;  }  finally {  	if (xpsDocument != null)  		xpsDocument.Close ();  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: try {  	xpsDocument = XpsDocument.Open (xpsFilename);  	FixedDocument fixedDocument = xpsDocument.GetDocument ();  	PdfDocument pdfDocument = new PdfDocument ();  	PdfRenderer renderer = new PdfRenderer ();  	int pageIndex = 0;  	foreach (FixedPage page in fixedDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  		renderer.RenderPage (pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	pdfDocument.Save (pdfFilename);  	xpsDocument.Close ();  	xpsDocument = null;  	if (createComparisonDocument) {  		System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  		System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  		if (docSeq == null)  			throw new InvalidOperationException ("docSeq");  		XPdfForm form = XPdfForm.FromFile (pdfFilename);  		PdfDocument pdfComparisonDocument = new PdfDocument ();  		pageIndex = 0;  		foreach (PdfPage page in pdfDocument.Pages) {  			if (page == null)  				continue;  			Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  			PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  			double width = page.Width;  			double height = page.Height;  			pdfPage.Width = page.Width * 2;  			pdfPage.Height = page.Height;  			DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  			//byte[] png = PngFromPage(docPage' 96);  			BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  			XImage image = XImage.FromBitmapSource (bmsource);  			XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  			form.PageIndex = pageIndex;  			gfx.DrawImage (form' 0' 0' width' height);  			gfx.DrawImage (image' width' 0' width' height);  			//renderer.RenderPage(pdfPage' page);  			pageIndex++;  			#if DEBUG  			// stop at page...  			if (pageIndex == 50)  				break;  			#endif  		}  		string pdfComparisonFilename = pdfFilename;  		if (IOPath.HasExtension (pdfComparisonFilename))  			pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  		pdfComparisonFilename += "-comparison.pdf";  		pdfComparisonDocument.ViewerPreferences.FitWindow = true;  		//pdfComparisonDocument.PageMode = PdfPageMode.  		pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  		pdfComparisonDocument.Save (pdfComparisonFilename);  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.Message);  	if (xpsDocument != null)  		xpsDocument.Close ();  	throw;  }  finally {  	if (xpsDocument != null)  		xpsDocument.Close ();  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: foreach (FixedPage page in fixedDocument.Pages) {  	if (page == null)  		continue;  	Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  	PdfPage pdfPage = renderer.CreatePage (pdfDocument' page);  	renderer.RenderPage (pdfPage' page);  	pageIndex++;  	#if DEBUG  	// stop at page...  	if (pageIndex == 50)  		break;  	#endif  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (pageIndex == 50)  	break;  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (createComparisonDocument) {  	System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  	System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  	if (docSeq == null)  		throw new InvalidOperationException ("docSeq");  	XPdfForm form = XPdfForm.FromFile (pdfFilename);  	PdfDocument pdfComparisonDocument = new PdfDocument ();  	pageIndex = 0;  	foreach (PdfPage page in pdfDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  		double width = page.Width;  		double height = page.Height;  		pdfPage.Width = page.Width * 2;  		pdfPage.Height = page.Height;  		DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  		//byte[] png = PngFromPage(docPage' 96);  		BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  		XImage image = XImage.FromBitmapSource (bmsource);  		XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  		form.PageIndex = pageIndex;  		gfx.DrawImage (form' 0' 0' width' height);  		gfx.DrawImage (image' width' 0' width' height);  		//renderer.RenderPage(pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	string pdfComparisonFilename = pdfFilename;  	if (IOPath.HasExtension (pdfComparisonFilename))  		pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  	pdfComparisonFilename += "-comparison.pdf";  	pdfComparisonDocument.ViewerPreferences.FitWindow = true;  	//pdfComparisonDocument.PageMode = PdfPageMode.  	pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  	pdfComparisonDocument.Save (pdfComparisonFilename);  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (createComparisonDocument) {  	System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  	System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  	if (docSeq == null)  		throw new InvalidOperationException ("docSeq");  	XPdfForm form = XPdfForm.FromFile (pdfFilename);  	PdfDocument pdfComparisonDocument = new PdfDocument ();  	pageIndex = 0;  	foreach (PdfPage page in pdfDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  		double width = page.Width;  		double height = page.Height;  		pdfPage.Width = page.Width * 2;  		pdfPage.Height = page.Height;  		DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  		//byte[] png = PngFromPage(docPage' 96);  		BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  		XImage image = XImage.FromBitmapSource (bmsource);  		XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  		form.PageIndex = pageIndex;  		gfx.DrawImage (form' 0' 0' width' height);  		gfx.DrawImage (image' width' 0' width' height);  		//renderer.RenderPage(pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	string pdfComparisonFilename = pdfFilename;  	if (IOPath.HasExtension (pdfComparisonFilename))  		pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  	pdfComparisonFilename += "-comparison.pdf";  	pdfComparisonDocument.ViewerPreferences.FitWindow = true;  	//pdfComparisonDocument.PageMode = PdfPageMode.  	pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  	pdfComparisonDocument.Save (pdfComparisonFilename);  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (createComparisonDocument) {  	System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  	System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  	if (docSeq == null)  		throw new InvalidOperationException ("docSeq");  	XPdfForm form = XPdfForm.FromFile (pdfFilename);  	PdfDocument pdfComparisonDocument = new PdfDocument ();  	pageIndex = 0;  	foreach (PdfPage page in pdfDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  		double width = page.Width;  		double height = page.Height;  		pdfPage.Width = page.Width * 2;  		pdfPage.Height = page.Height;  		DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  		//byte[] png = PngFromPage(docPage' 96);  		BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  		XImage image = XImage.FromBitmapSource (bmsource);  		XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  		form.PageIndex = pageIndex;  		gfx.DrawImage (form' 0' 0' width' height);  		gfx.DrawImage (image' width' 0' width' height);  		//renderer.RenderPage(pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	string pdfComparisonFilename = pdfFilename;  	if (IOPath.HasExtension (pdfComparisonFilename))  		pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  	pdfComparisonFilename += "-comparison.pdf";  	pdfComparisonDocument.ViewerPreferences.FitWindow = true;  	//pdfComparisonDocument.PageMode = PdfPageMode.  	pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  	pdfComparisonDocument.Save (pdfComparisonFilename);  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (createComparisonDocument) {  	System.Windows.Xps.Packaging.XpsDocument xpsDoc = new System.Windows.Xps.Packaging.XpsDocument (xpsFilename' FileAccess.Read);  	System.Windows.Documents.FixedDocumentSequence docSeq = xpsDoc.GetFixedDocumentSequence ();  	if (docSeq == null)  		throw new InvalidOperationException ("docSeq");  	XPdfForm form = XPdfForm.FromFile (pdfFilename);  	PdfDocument pdfComparisonDocument = new PdfDocument ();  	pageIndex = 0;  	foreach (PdfPage page in pdfDocument.Pages) {  		if (page == null)  			continue;  		Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  		PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  		double width = page.Width;  		double height = page.Height;  		pdfPage.Width = page.Width * 2;  		pdfPage.Height = page.Height;  		DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  		//byte[] png = PngFromPage(docPage' 96);  		BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  		XImage image = XImage.FromBitmapSource (bmsource);  		XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  		form.PageIndex = pageIndex;  		gfx.DrawImage (form' 0' 0' width' height);  		gfx.DrawImage (image' width' 0' width' height);  		//renderer.RenderPage(pdfPage' page);  		pageIndex++;  		#if DEBUG  		// stop at page...  		if (pageIndex == 50)  			break;  		#endif  	}  	string pdfComparisonFilename = pdfFilename;  	if (IOPath.HasExtension (pdfComparisonFilename))  		pdfComparisonFilename = pdfComparisonFilename.Substring (0' pdfComparisonFilename.LastIndexOf ('.'));  	pdfComparisonFilename += "-comparison.pdf";  	pdfComparisonDocument.ViewerPreferences.FitWindow = true;  	//pdfComparisonDocument.PageMode = PdfPageMode.  	pdfComparisonDocument.PageLayout = PdfPageLayout.SinglePage;  	pdfComparisonDocument.Save (pdfComparisonFilename);  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: foreach (PdfPage page in pdfDocument.Pages) {  	if (page == null)  		continue;  	Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  	PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  	double width = page.Width;  	double height = page.Height;  	pdfPage.Width = page.Width * 2;  	pdfPage.Height = page.Height;  	DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  	//byte[] png = PngFromPage(docPage' 96);  	BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  	XImage image = XImage.FromBitmapSource (bmsource);  	XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  	form.PageIndex = pageIndex;  	gfx.DrawImage (form' 0' 0' width' height);  	gfx.DrawImage (image' width' 0' width' height);  	//renderer.RenderPage(pdfPage' page);  	pageIndex++;  	#if DEBUG  	// stop at page...  	if (pageIndex == 50)  		break;  	#endif  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: foreach (PdfPage page in pdfDocument.Pages) {  	if (page == null)  		continue;  	Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  	PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  	double width = page.Width;  	double height = page.Height;  	pdfPage.Width = page.Width * 2;  	pdfPage.Height = page.Height;  	DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  	//byte[] png = PngFromPage(docPage' 96);  	BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  	XImage image = XImage.FromBitmapSource (bmsource);  	XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  	form.PageIndex = pageIndex;  	gfx.DrawImage (form' 0' 0' width' height);  	gfx.DrawImage (image' width' 0' width' height);  	//renderer.RenderPage(pdfPage' page);  	pageIndex++;  	#if DEBUG  	// stop at page...  	if (pageIndex == 50)  		break;  	#endif  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: foreach (PdfPage page in pdfDocument.Pages) {  	if (page == null)  		continue;  	Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  	PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  	double width = page.Width;  	double height = page.Height;  	pdfPage.Width = page.Width * 2;  	pdfPage.Height = page.Height;  	DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  	//byte[] png = PngFromPage(docPage' 96);  	BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  	XImage image = XImage.FromBitmapSource (bmsource);  	XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  	form.PageIndex = pageIndex;  	gfx.DrawImage (form' 0' 0' width' height);  	gfx.DrawImage (image' width' 0' width' height);  	//renderer.RenderPage(pdfPage' page);  	pageIndex++;  	#if DEBUG  	// stop at page...  	if (pageIndex == 50)  		break;  	#endif  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: foreach (PdfPage page in pdfDocument.Pages) {  	if (page == null)  		continue;  	Debug.WriteLine (String.Format ("  doc={0}' page={1}"' docIndex' pageIndex));  	PdfPage pdfPage = /*renderer.CreatePage(pdfComparisonDocument' page);*/pdfComparisonDocument.AddPage ();  	double width = page.Width;  	double height = page.Height;  	pdfPage.Width = page.Width * 2;  	pdfPage.Height = page.Height;  	DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageIndex);  	//byte[] png = PngFromPage(docPage' 96);  	BitmapSource bmsource = BitmapSourceFromPage (docPage' 96 * 2);  	XImage image = XImage.FromBitmapSource (bmsource);  	XGraphics gfx = XGraphics.FromPdfPage (pdfPage);  	form.PageIndex = pageIndex;  	gfx.DrawImage (form' 0' 0' width' height);  	gfx.DrawImage (image' width' 0' width' height);  	//renderer.RenderPage(pdfPage' page);  	pageIndex++;  	#if DEBUG  	// stop at page...  	if (pageIndex == 50)  		break;  	#endif  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: pdfPage.Width = page.Width * 2;  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,Convert,The following statement contains a magic number: if (pageIndex == 50)  	break;  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,SaveXpsPageToBitmap,The following statement contains a magic number: for (int pageNum = 0; pageNum < docSeq.DocumentPaginator.PageCount; ++pageNum) {  	DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageNum);  	RenderTargetBitmap renderTarget = new RenderTargetBitmap ((int)docPage.Size.Width' (int)docPage.Size.Height' 96' // WPF (Avalon) units are 96dpi based      	96' System.Windows.Media.PixelFormats.Default);  	renderTarget.Render (docPage.Visual);  	BitmapEncoder encoder = new BmpBitmapEncoder ();  	// Choose type here ie: JpegBitmapEncoder' etc     	encoder.Frames.Add (BitmapFrame.Create (renderTarget));  	FileStream pageOutStream = new FileStream (xpsFileName + ".Page" + pageNum + ".bmp"' FileMode.Create' FileAccess.Write);  	encoder.Save (pageOutStream);  	pageOutStream.Close ();  }  
Magic Number,PdfSharp.Xps,XpsConverter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps\XpsConverter.cs,SaveXpsPageToBitmap,The following statement contains a magic number: for (int pageNum = 0; pageNum < docSeq.DocumentPaginator.PageCount; ++pageNum) {  	DocumentPage docPage = docSeq.DocumentPaginator.GetPage (pageNum);  	RenderTargetBitmap renderTarget = new RenderTargetBitmap ((int)docPage.Size.Width' (int)docPage.Size.Height' 96' // WPF (Avalon) units are 96dpi based      	96' System.Windows.Media.PixelFormats.Default);  	renderTarget.Render (docPage.Visual);  	BitmapEncoder encoder = new BmpBitmapEncoder ();  	// Choose type here ie: JpegBitmapEncoder' etc     	encoder.Frames.Add (BitmapFrame.Create (renderTarget));  	FileStream pageOutStream = new FileStream (xpsFileName + ".Page" + pageNum + ".bmp"' FileMode.Create' FileAccess.Write);  	encoder.Save (pageOutStream);  	pageOutStream.Close ();  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	if (length == 7) {  		clr.colorType = ColorType.scRGB;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = 0xFF;  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  	else if (length == 9) {  		clr.colorType = ColorType.scRGBwithAlpha;  		uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  		clr.A = (byte)((val >> 24) & 0xFF);  		clr.R = (byte)((val >> 16) & 0xFF);  		clr.G = (byte)((val >> 8) & 0xFF);  		clr.B = (byte)(val & 0xFF);  	}  }  else {  	// TODO  	if (value.StartsWith ("{StaticResource")) {  		DevHelper.NotImplemented ("Color StaticResource: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else if (value.StartsWith ("sc#")) {  		string[] xx = value.Substring (3).Split (''');  		if (xx.Length == 3) {  			clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		}  		else if (xx.Length == 4) {  			clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  			clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  			clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  			clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  		}  		else  			throw new NotImplementedException ("Color type format.");  	}  	else if (value.StartsWith ("ContextColor")) {  		DevHelper.NotImplemented ("Color profile: " + value);  		// HACK: just continue  		return Color.FromArgb (255' 0' 128' 0);  	}  	else  		throw new NotImplementedException ("Color type.");  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 7) {  	clr.colorType = ColorType.scRGB;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = 0xFF;  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  else if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.R = (byte)((val >> 16) & 0xFF);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.G = (byte)((val >> 8) & 0xFF);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (length == 9) {  	clr.colorType = ColorType.scRGBwithAlpha;  	uint val = UInt32.Parse (value.Substring (1)' NumberStyles.HexNumber);  	clr.A = (byte)((val >> 24) & 0xFF);  	clr.R = (byte)((val >> 16) & 0xFF);  	clr.G = (byte)((val >> 8) & 0xFF);  	clr.B = (byte)(val & 0xFF);  }  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.A = (byte)((val >> 24) & 0xFF);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.R = (byte)((val >> 16) & 0xFF);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.G = (byte)((val >> 8) & 0xFF);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("{StaticResource")) {  	DevHelper.NotImplemented ("Color StaticResource: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: return Color.FromArgb (255' 0' 128' 0);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: return Color.FromArgb (255' 0' 128' 0);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("sc#")) {  	string[] xx = value.Substring (3).Split (''');  	if (xx.Length == 3) {  		clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	}  	else if (xx.Length == 4) {  		clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  		clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  		clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  		clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  	}  	else  		throw new NotImplementedException ("Color type format.");  }  else if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 3) {  	clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  }  else if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 3) {  	clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  }  else if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 3) {  	clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  }  else if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 3) {  	clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  }  else if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 3) {  	clr.ScR = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  }  else if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.ScB = float.Parse (xx [2]' CultureInfo.InvariantCulture);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (xx.Length == 4) {  	clr.ScA = float.Parse (xx [0]' CultureInfo.InvariantCulture);  	clr.ScR = float.Parse (xx [1]' CultureInfo.InvariantCulture);  	clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  	clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  }  else  	throw new NotImplementedException ("Color type format.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.ScG = float.Parse (xx [2]' CultureInfo.InvariantCulture);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: clr.ScB = float.Parse (xx [3]' CultureInfo.InvariantCulture);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("ContextColor")) {  	DevHelper.NotImplemented ("Color profile: " + value);  	// HACK: just continue  	return Color.FromArgb (255' 0' 128' 0);  }  else  	throw new NotImplementedException ("Color type.");  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: return Color.FromArgb (255' 0' 128' 0);  
Magic Number,PdfSharp.Xps.XpsModel,Color,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\Color.cs,Parse,The following statement contains a magic number: return Color.FromArgb (255' 0' 128' 0);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 0) {  	if (!String.IsNullOrEmpty (commaSeparated [0])) {  		// Just split the numbers  		// (a:b)c  		// (a)c  		// c  		// (a:b)  - not possible  		// (a)  - not possible  		string[] tempStr = commaSeparated [0].Split (new char[] {  			'(''  			')''  			':'  		}' StringSplitOptions.RemoveEmptyEntries);  		// Last number is always the index  		mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  		// First and second (if available) are the code unit count and glyph count  		if (tempStr.Length > 1)  			mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  		if (tempStr.Length > 2)  			mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  	}  	if (commaSeparated.Length > 1 && !String.IsNullOrEmpty (commaSeparated [1]))  		mapping.AdvanceWidth = XpsParser.ParseDouble (commaSeparated [1]);  	if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  		mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  	if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  		mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (!String.IsNullOrEmpty (commaSeparated [0])) {  	// Just split the numbers  	// (a:b)c  	// (a)c  	// c  	// (a:b)  - not possible  	// (a)  - not possible  	string[] tempStr = commaSeparated [0].Split (new char[] {  		'(''  		')''  		':'  	}' StringSplitOptions.RemoveEmptyEntries);  	// Last number is always the index  	mapping.GlyphIndex = int.Parse (tempStr [tempStr.Length - 1]);  	// First and second (if available) are the code unit count and glyph count  	if (tempStr.Length > 1)  		mapping.ClusterCodeUnitCount = int.Parse (tempStr [0]);  	if (tempStr.Length > 2)  		mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  }  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (tempStr.Length > 2)  	mapping.ClusterGlyphCount = int.Parse (tempStr [1]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  	mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  	mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 2 && !String.IsNullOrEmpty (commaSeparated [2]))  	mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: mapping.UOffset = XpsParser.ParseDouble (commaSeparated [2]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  	mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  	mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: if (commaSeparated.Length > 3 && !String.IsNullOrEmpty (commaSeparated [3]))  	mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  
Magic Number,PdfSharp.Xps.XpsModel,GlyphIndicesParser,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GlyphIndices.cs,ParsePart,The following statement contains a magic number: mapping.VOffset = XpsParser.ParseDouble (commaSeparated [3]);  
Magic Number,PdfSharp.Xps.XpsModel,FixedPayload,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\FixedPayload.cs,GetFontData,The following statement contains a magic number: if (uriString.EndsWith ("odttf"' true' CultureInfo.InvariantCulture)) {  	Guid guid = new Guid (IOPath.GetFileNameWithoutExtension (uriString));  	byte[] bytes = guid.ToByteArray ();  	// See XPS 1.0 section 2.1.7.3 'Embedded Font Obfuscation'  	for (int idx = 0; idx < 32; idx++)  		fontData [idx] ^= bytes [odidx [idx]];  }  
Magic Number,PdfSharp.Xps.XpsModel,FixedPayload,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\FixedPayload.cs,GetFontData,The following statement contains a magic number: for (int idx = 0; idx < 32; idx++)  	fontData [idx] ^= bytes [odidx [idx]];  
Magic Number,PdfSharp.Xps.XpsModel,XpsDocument,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\XpsDocument.cs,GetPartAsXmlReader,The following statement contains a magic number: if (uriString.StartsWith ("/.."))  	uriString = uriString.Substring (3);  
Magic Number,PdfSharp.Xps.XpsModel,XpsDocument,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\XpsDocument.cs,GetPartAsXmlReader,The following statement contains a magic number: uriString = uriString.Substring (3);  
Magic Number,PdfSharp.Xps.XpsModel,GradientStopCollection,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GradientStopCollection.cs,GetAverageAlpha,The following statement contains a magic number: for (int idx = 0; idx < Count; idx++) {  	Color clr = this [idx].Color;  	result += clr.A / 255.0;  }  
Magic Number,PdfSharp.Xps.XpsModel,GradientStopCollection,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.XpsModel\GradientStopCollection.cs,GetAverageAlpha,The following statement contains a magic number: result += clr.A / 255.0;  
Missing Default,PdfSharp.Xps.Rendering,PdfContentWriter,C:\repos\homoluden_WPF2PDF\Libs\PDFSharp 1.31\PdfSharpXps\PdfSharp.Xps\PdfSharp.Xps.Rendering\PdfContentWriter-Glyphs.cs,WriteGlyphsInternal,The following switch statement is missing a default case: switch (complexity) {  case GlyphIndicesComplexity.None:  	break;  case GlyphIndicesComplexity.DistanceOnly:  	WriteGlyphs_DistanceOnly (glyphs);  	break;  case GlyphIndicesComplexity.GlyphIndicesAndDistanceOnly:  	break;  case GlyphIndicesComplexity.ClusterMapping:  	WriteGlyphs_ClusterMapping (glyphs);  	break;  }  
