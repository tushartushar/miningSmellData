Implementation smell,Namespace,Class,File,Method,Description
Long Method,MoonSharp.Interpreter.CoreLib,OsTimeModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\OsTimeModule.cs,StrFTime,The method has 115 lines of code.
Long Method,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The method has 131 lines of code.
Long Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ListenDebugger,The method has 101 lines of code.
Long Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Processing_Loop,The method has 273 lines of code.
Long Method,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,DynValueToObjectOfType,The method has 100 lines of code.
Long Method,MoonSharp.Interpreter.Interop,ReflectionSpecialName,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\ReflectionSpecialNames.cs,ReflectionSpecialName,The method has 128 lines of code.
Long Method,MoonSharp.Interpreter.Interop,StandardUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardUserDataDescriptor.cs,FillMemberList,The method has 101 lines of code.
Long Method,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The method has 292 lines of code.
Long Method,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The method has 132 lines of code.
Long Method,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadToken,The method has 112 lines of code.
Complex Method,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,scanformat,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ToggleBreakPoint,Cyclomatic complexity of the method is 13
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,GetBinaryMetamethod,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_ExecCall,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecEq,Cyclomatic complexity of the method is 8
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIndexSet,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIndex,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,FindSymbolByName,Cyclomatic complexity of the method is 10
Complex Method,MoonSharp.Interpreter.Execution.VM,Instruction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Instruction.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,MoonSharp.Interpreter.Execution.VM,Instruction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Instruction.cs,WriteBinary,Cyclomatic complexity of the method is 8
Complex Method,MoonSharp.Interpreter.Execution.VM,Instruction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Instruction.cs,ReadBinary,Cyclomatic complexity of the method is 8
Complex Method,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,CheckType,Cyclomatic complexity of the method is 10
Complex Method,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterCoreModules,Cyclomatic complexity of the method is 19
Complex Method,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,Index,Cyclomatic complexity of the method is 11
Complex Method,MoonSharp.Interpreter.Interop.Converters,ClrToScriptConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ClrToScriptConversions.cs,TryObjectToSimpleDynValue,Cyclomatic complexity of the method is 13
Complex Method,MoonSharp.Interpreter.Interop.Converters,ClrToScriptConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ClrToScriptConversions.cs,ObjectToDynValue,Cyclomatic complexity of the method is 12
Complex Method,MoonSharp.Interpreter.Interop.Converters,NumericConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\NumericConversions.cs,DoubleToType,Cyclomatic complexity of the method is 12
Complex Method,MoonSharp.Interpreter.Interop.Converters,NumericConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\NumericConversions.cs,TypeToDouble,Cyclomatic complexity of the method is 12
Complex Method,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,DynValueToObjectOfType,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CheckEventIsCompatible,Cyclomatic complexity of the method is 15
Complex Method,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,PerformOverloadedCall,Cyclomatic complexity of the method is 14
Complex Method,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,CalcScoreForOverload,Cyclomatic complexity of the method is 15
Complex Method,MoonSharp.Interpreter.Interop,StandardUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardUserDataDescriptor.cs,FillMemberList,Cyclomatic complexity of the method is 26
Complex Method,MoonSharp.Interpreter.Interop,MethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\MethodMemberDescriptor.cs,MethodMemberDescriptor,Cyclomatic complexity of the method is 9
Complex Method,MoonSharp.Interpreter.Interop,MethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\MethodMemberDescriptor.cs,CheckMethodIsCompatible,Cyclomatic complexity of the method is 10
Complex Method,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,IsPositive,Cyclomatic complexity of the method is 13
Complex Method,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ToUnsigned,Cyclomatic complexity of the method is 12
Complex Method,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ToInteger,Cyclomatic complexity of the method is 12
Complex Method,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,UnboxToLong,Cyclomatic complexity of the method is 12
Complex Method,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,Cyclomatic complexity of the method is 14
Complex Method,MoonSharp.Interpreter.Tree.Expressions,BinaryOperatorExpression,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Expressions\BinaryOperatorExpression.cs,CreateSubTree,Cyclomatic complexity of the method is 10
Long Parameter List,MoonSharp.Interpreter.CoreLib.IO,BinaryEncoding,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\IO\BinaryEncoding.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,MoonSharp.Interpreter.CoreLib.IO,BinaryEncoding,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\IO\BinaryEncoding.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,MoonSharp.Interpreter.Debugging,SourceRef,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Debugging\SourceRef.cs,SourceRef,The method has 6 parameters. Parameters: sourceIdx' from' to' fromline' toline' isStepStop
Long Parameter List,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_ExecCall,The method has 7 parameters. Parameters: argsCount' instructionPtr' handler' continuation' thisCall' debugText' unwindHandler
Long Parameter List,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_InvokeBinaryMetaMethod,The method has 5 parameters. Parameters: l' r' eventName' instructionPtr' extraPush
Long Parameter List,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_IndexSet,The method has 5 parameters. Parameters: stackofs' tupleidx' index' isNameIndex' isExpList
Long Parameter List,MoonSharp.Interpreter.Execution.VM,Instruction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Instruction.cs,ReadBinary,The method has 5 parameters. Parameters: chunkRef' rd' baseAddress' envTable' deserializedSymbols
Long Parameter List,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,BadArgumentUserData,The method has 5 parameters. Parameters: argNum' funcName' expected' got' allowNil
Long Parameter List,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,BadArgument,The method has 5 parameters. Parameters: argNum' funcName' expected' got' allowNil
Long Parameter List,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,BadArgument,The method has 5 parameters. Parameters: argNum' funcName' expected' got' allowNil
Long Parameter List,MoonSharp.Interpreter,AutoDescribingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\AutoDescribingUserDataDescriptor.cs,SetIndex,The method has 5 parameters. Parameters: script' obj' index' value' isDirectIndexing
Long Parameter List,MoonSharp.Interpreter,Table,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\Table.cs,PerformTableSet,The method has 6 parameters. Parameters: listIndex' key' keyDynValue' value' isNumber' appendKey
Long Parameter List,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterScriptFieldAsConst,The method has 5 parameters. Parameters: fi' o' table' t' name
Long Parameter List,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterScriptField,The method has 5 parameters. Parameters: fi' o' table' t' name
Long Parameter List,MoonSharp.Interpreter.Interop.BasicDescriptors,ParameterDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\ParameterDescriptor.cs,ParameterDescriptor,The method has 7 parameters. Parameters: name' type' hasDefaultValue' defaultValue' isOut' isRef' isVarArgs
Long Parameter List,MoonSharp.Interpreter.Interop.BasicDescriptors,ParameterDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\ParameterDescriptor.cs,ParameterDescriptor,The method has 8 parameters. Parameters: name' type' hasDefaultValue' defaultValue' isOut' isRef' isVarArgs' typeRestriction
Long Parameter List,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,SetIndex,The method has 5 parameters. Parameters: script' obj' index' value' isDirectIndexing
Long Parameter List,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,ExecuteIndexer,The method has 5 parameters. Parameters: mdesc' script' obj' index' value
Long Parameter List,MoonSharp.Interpreter.Interop,ProxyUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ProxyUserDataDescriptor.cs,SetIndex,The method has 5 parameters. Parameters: script' obj' index' value' isDirectIndexing
Long Parameter List,MoonSharp.Interpreter.Interop,FunctionMemberDescriptorBase,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\MemberDescriptors\FunctionMemberDescriptorBase.cs,BuildArgumentList,The method has 5 parameters. Parameters: script' obj' context' args' outParams
Long Parameter List,MoonSharp.Interpreter.Interop,StandardEnumUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardEnumUserDataDescriptor.cs,StandardEnumUserDataDescriptor,The method has 5 parameters. Parameters: enumType' friendlyName' names' values' underlyingType
Long Parameter List,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,DispatchEvent,The method has 17 parameters. Parameters: sender' o01' o02' o03' o04' o05' o06' o07' o08' o09' o10' o11' o12' o13' o14' o15' o16
Long Parameter List,MoonSharp.Interpreter.Interop,StandardGenericsUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardGenericsUserDataDescriptor.cs,SetIndex,The method has 5 parameters. Parameters: script' obj' index' value' isDirectIndexing
Long Parameter List,MoonSharp.Interpreter.Interop,IUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\IUserDataDescriptor.cs,SetIndex,The method has 5 parameters. Parameters: script' obj' index' value' isDirectIndexing
Long Parameter List,MoonSharp.Interpreter.Interop,CompositeUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\CompositeUserDataDescriptor.cs,SetIndex,The method has 5 parameters. Parameters: script' obj' index' value' isNameIndex
Long Parameter List,MoonSharp.Interpreter.IO,UndisposableStream,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\IO\UndisposableStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MoonSharp.Interpreter.IO,UndisposableStream,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\IO\UndisposableStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,FormatOct,The method has 7 parameters. Parameters: NativeFormat' Alternate' FieldLength' FieldPrecision' Left2Right' Padding' Value
Long Parameter List,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,FormatHex,The method has 7 parameters. Parameters: NativeFormat' Alternate' FieldLength' FieldPrecision' Left2Right' Padding' Value
Long Parameter List,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,FormatNumber,The method has 9 parameters. Parameters: NativeFormat' Alternate' FieldLength' FieldPrecision' Left2Right' PositiveSign' PositiveSpace' Padding' Value
Long Parameter List,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,PotentiallyDoubleCharOperator,The method has 5 parameters. Parameters: expectedSecondChar' singleCharToken' doubleCharToken' fromLine' fromCol
Long Parameter List,MoonSharp.Interpreter.Tree,Token,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Token.cs,Token,The method has 8 parameters. Parameters: type' sourceId' fromLine' fromCol' toLine' toCol' prevLine' prevCol
Long Identifier,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,,The length of the parameter WEIGHT_STRING_TO_STRINGBUILDER is 30.
Long Identifier,MoonSharp.Interpreter.Interop.UserDataRegistries,ExtensionMethodsRegistry,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\UserDataRegistries\ExtensionMethodsRegistry.cs,,The length of the parameter s_ExtensionMethodChangeVersion is 30.
Long Statement,MoonSharp.Interpreter.CoreLib,DynamicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\DynamicModule.cs,eval,The length of the statement  "						throw ScriptRuntimeException.BadArgument(0' "dynamic.eval"' "A userdata was passed' but was not a previously prepared expression."); " is 132.
Long Statement,MoonSharp.Interpreter.CoreLib,ErrorHandlingModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\ErrorHandlingModule.cs,SetErrorHandlerStrategy,The length of the statement  "							throw new ScriptRuntimeException("the function passed to {0} cannot be called directly by {0}. wrap in a script function instead."' funcName); " is 142.
Long Statement,MoonSharp.Interpreter.CoreLib,ErrorHandlingModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\ErrorHandlingModule.cs,SetErrorHandlerStrategy,The length of the statement  "						throw new ScriptRuntimeException("the function passed to {0} cannot be called directly by {0}. wrap in a script function instead."' funcName); " is 142.
Long Statement,MoonSharp.Interpreter.CoreLib,IoModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\IoModule.cs,close,The length of the statement  "			FileUserDataBase outp = args.AsUserData<FileUserDataBase>(0' "close"' true) ?? GetDefaultFile(executionContext' StandardFileType.StdOut); " is 137.
Long Statement,MoonSharp.Interpreter.CoreLib,IoModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\IoModule.cs,flush,The length of the statement  "			FileUserDataBase outp = args.AsUserData<FileUserDataBase>(0' "close"' true) ?? GetDefaultFile(executionContext' StandardFileType.StdOut); " is 137.
Long Statement,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,modf,The length of the statement  "			return DynValue.NewTuple(DynValue.NewNumber(Math.Floor(arg.Number))' DynValue.NewNumber(arg.Number - Math.Floor(arg.Number))); " is 126.
Long Statement,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,concat,The length of the statement  "					throw new ScriptRuntimeException("invalid value ({1}) at index {0} in table for 'concat'"' i' v.Type.ToLuaTypeString()); " is 120.
Long Statement,MoonSharp.Interpreter.Debugging,DebuggerAction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Debugging\DebuggerAction.cs,ToString,The length of the statement  "			if (Action == ActionType.ToggleBreakpoint || Action == ActionType.SetBreakpoint || Action == ActionType.ClearBreakpoint) " is 120.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Coroutine_Resume,The length of the statement  "				if (m_State != CoroutineState.NotStarted && m_State != CoroutineState.Suspended && m_State != CoroutineState.ForceSuspended) " is 124.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,EnterProcessor,The length of the statement  "				string msg = string.Format("Cannot enter the same MoonSharp processor from two different threads : {0} and {1}"' m_OwningThreadID' threadID); " is 141.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ListenDebugger,The length of the statement  "					if ((m_ExecutionStack.Count >= m_Debug.ExStackDepthAtStep) && (instr.SourceCodeRef == null || instr.SourceCodeRef == m_Debug.LastHlRef)) return; " is 144.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ListenDebugger,The length of the statement  "					if (instr.SourceCodeRef == null || instr.SourceCodeRef == m_Debug.LastHlRef || m_ExecutionStack.Count > m_Debug.ExStackDepthAtStep) return; " is 139.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ToggleBreakPoint,The length of the statement  "					//System.Diagnostics.Debug.WriteLine(string.Format("BRK: found {0} for {1} on distance {2}"' nearest' nearest.Type' minDistance)); " is 130.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Processing_Loop,The length of the statement  "						ex.DecoratedMessage = PerformMessageDecorationBeforeUnwind(c.ErrorHandlerBeforeUnwind' ex.DecoratedMessage' GetCurrentSourceRef(instructionPtr)); " is 145.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Processing_Loop,The length of the statement  "						DynValue handled = csi.ErrorHandler.Invoke(new ScriptExecutionContext(this' csi.ErrorHandler' GetCurrentSourceRef(instructionPtr))' cbargs); " is 140.
Long Statement,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_CheckForTailRequests,The length of the statement  "				return Internal_ExecCall(tcd.Args.Length' instructionPtr' tcd.ErrorHandler' tcd.Continuation' false' null' tcd.ErrorHandlerBeforeUnwind); " is 137.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_ThisCall,The length of the statement  "			AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.ThisCall' NumVal = argCount' Name = debugName }); " is 121.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Debug,The length of the statement  "			AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Debug' Name = str.Substring(0' Math.Min(32' str.Length)) }); " is 132.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Enter,The length of the statement  "			return AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Clean' NumVal = runtimeScopeBlock.From' NumVal2 = runtimeScopeBlock.ToInclusive }); " is 162.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Leave,The length of the statement  "			return AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Clean' NumVal = runtimeScopeBlock.From' NumVal2 = runtimeScopeBlock.To }); " is 153.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Exit,The length of the statement  "			return AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Clean' NumVal = runtimeScopeBlock.From' NumVal2 = runtimeScopeBlock.ToInclusive }); " is 162.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Clean,The length of the statement  "			return AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Clean' NumVal = runtimeScopeBlock.To + 1' NumVal2 = runtimeScopeBlock.ToInclusive }); " is 164.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Closure,The length of the statement  "			return AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Closure' SymbolList = symbols' NumVal = jmpnum }); " is 129.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Load,The length of the statement  "					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Index' Value = DynValue.NewString(sym.i_Name) }); " is 121.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Store,The length of the statement  "					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.IndexSet' Symbol = sym' NumVal = stackofs' NumVal2 = tupleidx' Value = DynValue.NewString(sym.i_Name) }); " is 177.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Store,The length of the statement  "					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.StoreLcl' Symbol = sym' NumVal = stackofs' NumVal2 = tupleidx }); " is 137.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Store,The length of the statement  "					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.StoreUpv' Symbol = sym' NumVal = stackofs' NumVal2 = tupleidx }); " is 137.
Long Statement,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_IndexSet,The length of the statement  "			return AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = o' NumVal = stackofs' NumVal2 = tupleidx' Value = index }); " is 131.
Long Statement,MoonSharp.Interpreter.Execution.VM,Instruction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Instruction.cs,ToString,The length of the statement  "			if ((this.OpCode == VM.OpCode.Meta) ||((usage & ((int)InstructionFieldUsage.NumValAsCodeAddress)) == (int)InstructionFieldUsage.NumValAsCodeAddress)) " is 149.
Long Statement,MoonSharp.Interpreter,Coroutine,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\Coroutine.cs,AsTypedEnumerable,The length of the statement  "				throw new InvalidOperationException("Only non-CLR coroutines can be resumed with this overload of the Resume method. Use the overload accepting a ScriptExecutionContext instead"); " is 179.
Long Statement,MoonSharp.Interpreter,Coroutine,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\Coroutine.cs,AsTypedEnumerable,The length of the statement  "			while (this.State == CoroutineState.NotStarted || this.State == CoroutineState.Suspended || this.State == CoroutineState.ForceSuspended) " is 136.
Long Statement,MoonSharp.Interpreter,Coroutine,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\Coroutine.cs,Resume,The length of the statement  "				throw new InvalidOperationException("Only non-CLR coroutines can be resumed with this overload of the Resume method. Use the overload accepting a ScriptExecutionContext instead"); " is 179.
Long Statement,MoonSharp.Interpreter,Coroutine,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\Coroutine.cs,Resume,The length of the statement  "				throw new InvalidOperationException("Only non-CLR coroutines can be resumed with this overload of the Resume method. Use the overload accepting a ScriptExecutionContext instead"); " is 179.
Long Statement,MoonSharp.Interpreter,ScriptPrivateResource_Extension,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\IScriptPrivateResource.cs,CheckScriptOwnership,The length of the statement  "				if (containingResource.OwnerScript != null && containingResource.OwnerScript != itemResource.OwnerScript && itemResource.OwnerScript != null) " is 141.
Long Statement,MoonSharp.Interpreter,UserData,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\UserData.cs,RegisterType,The length of the statement  "			return TypeDescriptorRegistry.RegisterType_Impl(customDescriptor.Type' InteropAccessMode.Default' null' customDescriptor); " is 122.
Long Statement,MoonSharp.Interpreter,UserData,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\UserData.cs,GetDescriptionOfRegisteredTypes,The length of the statement  "			var registeredTypesPairs = useHistoricalData ? TypeDescriptorRegistry.RegisteredTypesHistory : TypeDescriptorRegistry.RegisteredTypes; " is 134.
Long Statement,MoonSharp.Interpreter,UserData,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\UserData.cs,GetRegisteredTypes,The length of the statement  "			var registeredTypesPairs = useHistoricalData ? TypeDescriptorRegistry.RegisteredTypesHistory : TypeDescriptorRegistry.RegisteredTypes; " is 134.
Long Statement,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,CompareInvalidType,The length of the statement  "				return new ScriptRuntimeException("attempt to compare {0} with {1}"' l.Type.ToLuaTypeString()' r.Type.ToLuaTypeString()); " is 121.
Long Statement,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,ConvertObjectFailed,The length of the statement  "			return new ScriptRuntimeException("cannot convert a {0} to a clr type {1}"' t.ToString().ToLowerInvariant()' t2.FullName); " is 122.
Long Statement,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,UserDataArgumentTypeMismatch,The length of the statement  "			return new ScriptRuntimeException("cannot find a conversion from a MoonSharp {0} to a clr {1}"' t.ToString().ToLowerInvariant()' clrType.FullName); " is 147.
Long Statement,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,AccessInstanceMemberOnStatics,The length of the statement  "			return new ScriptRuntimeException("attempt to access instance member {0}.{1} from a static userdata"' typeDescr.Name' desc.Name); " is 129.
Long Statement,MoonSharp.Interpreter,CallbackArguments,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\CallbackArguments.cs,AsType,The length of the statement  "			return this[argNum].CheckType(funcName' type' argNum' allowNil ? TypeValidationFlags.AllowNil | TypeValidationFlags.AutoConvert : TypeValidationFlags.AutoConvert); " is 163.
Long Statement,MoonSharp.Interpreter,CallbackArguments,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\CallbackArguments.cs,AsUserData,The length of the statement  "			return this[argNum].CheckUserDataType<T>(funcName' argNum' allowNil ? TypeValidationFlags.AllowNil : TypeValidationFlags.None); " is 127.
Long Statement,MoonSharp.Interpreter,CallbackFunction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\CallbackFunction.cs,CheckCallbackSignature,The length of the statement  "				&& pi[1].ParameterType == typeof(CallbackArguments) && mi.ReturnType == typeof(DynValue) && (requirePublicVisibility || mi.IsPublic)); " is 134.
Long Statement,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,IsNilOrNan,The length of the statement  "			return (this.Type == DataType.Nil) || (this.Type == DataType.Void) || (this.Type == DataType.Number && double.IsNaN(this.Number)); " is 130.
Long Statement,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,ToObject,The length of the statement  "			return MoonSharp.Interpreter.Interop.Converters.ScriptToClrConversions.DynValueToObjectOfType(this' desiredType' null' false); " is 126.
Long Statement,MoonSharp.Interpreter,ScriptExecutionContext,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\ScriptExecutionContext.cs,PerformMessageDecorationBeforeUnwind,The length of the statement  "				exception.DecoratedMessage = m_Processor.PerformMessageDecorationBeforeUnwind(messageHandler' exception.Message' CallingLocation); " is 130.
Long Statement,MoonSharp.Interpreter,Script,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Script.cs,Dump,The length of the statement  "			m_MainProcessor.Dump(outStream' function.Function.EntryPointByteCodeLocation' upvaluesType == Closure.UpvaluesType.Environment); " is 128.
Long Statement,MoonSharp.Interpreter,Script,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Script.cs,LoadFile,The length of the statement  "					throw new InvalidCastException(string.Format("Unsupported return type from IScriptLoader.LoadFile : {0}"' code.GetType())); " is 123.
Long Statement,MoonSharp.Interpreter,Script,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Script.cs,Call,The length of the statement  "				return function.Callback.ClrCallback(this.CreateDynamicExecutionContext(function.Callback)' new CallbackArguments(args' false)); " is 128.
Long Statement,MoonSharp.Interpreter,Script,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Script.cs,GetBanner,The length of the statement  "			sb.AppendLine(string.Format("MoonSharp {0}{1} [{2}]"' subproduct' Script.VERSION' Script.GlobalOptions.Platform.GetPlatformName())); " is 132.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterModuleType,The length of the statement  "					MoonSharpModuleMethodAttribute attr = (MoonSharpModuleMethodAttribute)mi.GetCustomAttributes(typeof(MoonSharpModuleMethodAttribute)' false).First(); " is 148.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterModuleType,The length of the statement  "			foreach (FieldInfo fi in Framework.Do.GetFields(t).Where(_mi => _mi.IsStatic && _mi.GetCustomAttributes(typeof(MoonSharpModuleMethodAttribute)' false).ToArray().Length > 0)) " is 173.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterModuleType,The length of the statement  "				MoonSharpModuleMethodAttribute attr = (MoonSharpModuleMethodAttribute)fi.GetCustomAttributes(typeof(MoonSharpModuleMethodAttribute)' false).First(); " is 148.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterModuleType,The length of the statement  "			foreach (FieldInfo fi in Framework.Do.GetFields(t).Where(_mi => _mi.IsStatic && _mi.GetCustomAttributes(typeof(MoonSharpModuleConstantAttribute)' false).ToArray().Length > 0)) " is 175.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterModuleType,The length of the statement  "				MoonSharpModuleConstantAttribute attr = (MoonSharpModuleConstantAttribute)fi.GetCustomAttributes(typeof(MoonSharpModuleConstantAttribute)' false).First(); " is 154.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterScriptFieldAsConst,The length of the statement  "				throw new ArgumentException(string.Format("Field {0} does not have the right type - it must be string or double."' name)); " is 122.
Long Statement,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,CreateModuleNamespace,The length of the statement  "			MoonSharpModuleAttribute attr = (MoonSharpModuleAttribute)(Framework.Do.GetCustomAttributes(t' typeof(MoonSharpModuleAttribute)' false).First()); " is 145.
Long Statement,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,AddMemberTo,The length of the statement  "						throw new ArgumentException(string.Format("Multiple members named {0} are being added to type {1} and one or more of these members do not support overloads."' name' this.Type.FullName)); " is 186.
Long Statement,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,AddMemberTo,The length of the statement  "					throw new ArgumentException(string.Format("Multiple members named {0} are being added to type {1} and one or more of these members do not support overloads."' name' this.Type.FullName)); " is 186.
Long Statement,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,ExecuteIndexer,The length of the statement  "				throw new ScriptRuntimeException("a clr callback was expected in member {0}' while a {1} was found"' mdesc.Name' v.Type); " is 121.
Long Statement,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,TryDispatchLength,The length of the statement  "			if (lenprop != null && lenprop.CanRead() && !lenprop.CanExecute()) return lenprop.GetGetterCallbackAsDynValue(script' obj); " is 123.
Long Statement,MoonSharp.Interpreter.Interop.BasicDescriptors,DispatchingUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\DispatchingUserDataDescriptor.cs,TryDispatchLength,The length of the statement  "			if (countprop != null && countprop.CanRead() && !countprop.CanExecute()) return countprop.GetGetterCallbackAsDynValue(script' obj); " is 131.
Long Statement,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,DynValueToObject,The length of the statement  "			var converter = Script.GlobalOptions.CustomConverters.GetScriptToClrCustomConversion(value.Type' typeof(System.Object)); " is 120.
Long Statement,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,DynValueToObjectOfType,The length of the statement  "					else if (desiredType == typeof(Func<ScriptExecutionContext' CallbackArguments' DynValue>)) return value.Callback.ClrCallback; " is 125.
Long Statement,MoonSharp.Interpreter.Interop.Converters,TableConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\TableConversions.cs,ConvertTableToType,The length of the statement  "					return ConvertTableToDictionaryOfGenericType(t' Framework.Do.GetGenericArguments(t)[0]' Framework.Do.GetGenericArguments(t)[1]' table); " is 135.
Long Statement,MoonSharp.Interpreter.Interop.Converters,TableConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\TableConversions.cs,ConvertTableToArrayOfGenericType,The length of the statement  "			System.Collections.IList array = (System.Collections.IList)Activator.CreateInstance(arrayType' new object[] { lst.Count }); " is 123.
Long Statement,MoonSharp.Interpreter.Interop,DescriptorHelpers,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\DescriptorHelpers.cs,GetVisibilityFromAttributes,The length of the statement  "				throw new InvalidOperationException(string.Format("A member ('{0}') can't have discording MoonSharpHiddenAttribute and MoonSharpVisibleAttribute."' mi.Name)); " is 158.
Long Statement,MoonSharp.Interpreter.Interop,PropertyTableAssigner,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\PropertyTableAssigner.cs,AssignObject,The length of the statement  "				throw new ArgumentException(string.Format("Invalid type of object : got '{0}'' expected {1}"' obj.GetType().FullName' m_Type.FullName)); " is 136.
Long Statement,MoonSharp.Interpreter.Interop,DynValueMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\MemberDescriptors\DynValueMemberDescriptor.cs,PrepareForWiring,The length of the statement  "					t.Set("error"' DynValue.NewString(string.Format("Wiring of '{0}' value members not supported."' Value.Type.ToErrorTypeString()))); " is 130.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CheckEventIsCompatible,The length of the statement  "				if (throwException) throw new ArgumentException(string.Format("Event handler cannot have more than {0} parameters"' MAX_ARGS_IN_DELEGATE)); " is 139.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9)); " is 123.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10)); " is 133.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11)); " is 143.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12)); " is 153.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13)); " is 163.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14)); " is 173.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15)); " is 183.
Long Statement,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The length of the statement  "					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16)); " is 193.
Long Statement,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,PerformOverloadedCall,The length of the statement  "			bool extMethodCacheNotExpired = IgnoreExtensionMethods || (obj == null) || m_ExtensionMethodVersion == UserData.GetExtensionMethodsChangeVersion(); " is 147.
Long Statement,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,CalcScoreForOverload,The length of the statement  "				if ((parameterType == typeof(Script)) || (parameterType == typeof(ScriptExecutionContext)) || (parameterType == typeof(CallbackArguments))) " is 139.
Long Statement,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,CalcScoreForOverload,The length of the statement  "			System.Diagnostics.Debug.WriteLine(string.Format("[OVERLOAD] : Score {0} for method {1}"' totalScore' method.SortDiscriminant)); " is 128.
Long Statement,MoonSharp.Interpreter.Interop,FieldMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\FieldMemberDescriptor.cs,SetValue,The length of the statement  "				throw new ScriptRuntimeException("userdata field '{0}.{1}' cannot be written to."' this.FieldInfo.DeclaringType.Name' this.Name); " is 129.
Long Statement,MoonSharp.Interpreter.Interop,StandardUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardUserDataDescriptor.cs,FillMemberList,The length of the statement  "					if (Framework.Do.IsNestedPublic(nestedType) || Framework.Do.GetCustomAttributes(nestedType' typeof(MoonSharpUserDataAttribute)' true).Length > 0) " is 145.
Long Statement,MoonSharp.Interpreter.Interop,StandardUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardUserDataDescriptor.cs,PrepareForWiring,The length of the statement  "			if (AccessMode == InteropAccessMode.HideMembers || Framework.Do.GetAssembly(Type) == Framework.Do.GetAssembly(this.GetType())) " is 126.
Long Statement,MoonSharp.Interpreter.Interop,PropertyMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\PropertyMemberDescriptor.cs,GetValue,The length of the statement  "				throw new ScriptRuntimeException("userdata property '{0}.{1}' cannot be read from."' this.PropertyInfo.DeclaringType.Name' this.Name); " is 134.
Long Statement,MoonSharp.Interpreter.Interop,PropertyMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\PropertyMemberDescriptor.cs,SetValue,The length of the statement  "				throw new ScriptRuntimeException("userdata property '{0}.{1}' cannot be written to."' this.PropertyInfo.DeclaringType.Name' this.Name); " is 135.
Long Statement,MoonSharp.Interpreter.Interop.UserDataRegistries,TypeDescriptorRegistry,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\UserDataRegistries\TypeDescriptorRegistry.cs,RegisterProxyType_Impl,The length of the statement  "			return RegisterType_Impl(proxyFactory.TargetType' accessMode' friendlyName' new ProxyUserDataDescriptor(proxyFactory' proxyDescriptor' friendlyName)); " is 150.
Long Statement,MoonSharp.Interpreter.Execution,InstructionFieldUsage_Extensions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\InstructionFieldUsage.cs,GetFieldUsage,The length of the statement  "					return InstructionFieldUsage.Symbol | InstructionFieldUsage.Value | InstructionFieldUsage.NumVal | InstructionFieldUsage.NumVal2; " is 129.
Long Statement,MoonSharp.Interpreter.Execution,InstructionFieldUsage_Extensions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\InstructionFieldUsage.cs,GetFieldUsage,The length of the statement  "					return InstructionFieldUsage.NumVal | InstructionFieldUsage.NumVal2 | InstructionFieldUsage.Value | InstructionFieldUsage.Name; " is 127.
Long Statement,MoonSharp.Interpreter.Interop.LuaStateInterop,LuaBase,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\LuaBase.cs,ArgAsType,The length of the statement  "			return GetArgument(L' pos).CheckType(L.FunctionName' type' pos - 1' allowNil ? TypeValidationFlags.AllowNil | TypeValidationFlags.AutoConvert : TypeValidationFlags.AutoConvert); " is 177.
Long Statement,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The length of the statement  "								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}"; " is 148.
Long Statement,MoonSharp.Interpreter.Execution.Scopes,BuildTimeScopeBlock,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\Scopes\BuildTimeScopeBlock.cs,DefineLabel,The length of the statement  "				throw new SyntaxErrorException(label.NameToken' "label '{0}' already defined on line {1}"' label.Label' m_LocalLabels[label.Label].SourceRef.FromLine); " is 151.
Long Statement,MoonSharp.Interpreter.Loaders,UnityAssetsScriptLoader,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Loaders\UnityAssetsScriptLoader.cs,LoadFile,The length of the statement  "If you want scripts to be put in another directory or another way' use a custom instance of UnityAssetsScriptLoader or implement " is 128.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,IO_OpenFile,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,IO_GetStandardStream,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,IO_OS_GetTempFilename,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,OS_ExitFast,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,OS_FileExists,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,OS_FileDelete,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,OS_FileMove,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Platforms,LimitedPlatformAccessor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Platforms\LimitedPlatformAccessor.cs,OS_Execute,The length of the statement  "			throw new NotImplementedException("The current platform accessor does not support 'io' and 'os' operations. Provide your own implementation of platform to work around this limitation' if needed."); " is 197.
Long Statement,MoonSharp.Interpreter.Tree.Statements,AssignmentStatement,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Statements\AssignmentStatement.cs,CheckVar,The length of the statement  "				throw new SyntaxErrorException(lcontext.Lexer.Current' "unexpected symbol near '{0}' - not a l-value"' lcontext.Lexer.Current); " is 127.
Long Statement,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadToken,The length of the statement  "					throw new SyntaxErrorException(CreateToken(TokenType.Invalid' fromLine' fromCol)' "unexpected symbol near '{0}'"' CursorChar()) " is 127.
Long Statement,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadToken,The length of the statement  "					throw new SyntaxErrorException(CreateToken(TokenType.Invalid' fromLine' fromCol)' "unexpected symbol near '{0}'"' CursorChar()); " is 128.
Complex Conditional,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The conditional expression  "bb == 2 || bb == 8 || bb == 10 || bb == 16"  is complex.
Complex Conditional,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,LeaveProcessor,The conditional expression  "m_ExecutionNesting == 0 && m_Debug != null && m_Debug.DebuggerEnabled   				&& m_Debug.DebuggerAttached != null"  is complex.
Complex Conditional,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ListenDebugger,The conditional expression  "m_Debug.DebuggerAttached.IsPauseRequested() ||  				(instr.SourceCodeRef != null && instr.SourceCodeRef.Breakpoint && isOnDifferentRef)"  is complex.
Complex Conditional,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_ExecCall,The conditional expression  "(m_ExecutionStack.Count > this.m_Script.Options.TailCallOptimizationThreshold && m_ExecutionStack.Count > 1)  				|| (m_ValueStack.Count > this.m_Script.Options.TailCallOptimizationThreshold && m_ValueStack.Count > 1)"  is complex.
Complex Conditional,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_ExecCall,The conditional expression  "csi.ClrFunction == null && csi.Continuation == null && csi.ErrorHandler == null  							&& csi.ErrorHandlerBeforeUnwind == null && continuation == null && unwindHandler == null && handler == null"  is complex.
Complex Conditional,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecEq,The conditional expression  "(l.Type == DataType.Nil && r.Type == DataType.Void) || (l.Type == DataType.Void && r.Type == DataType.Nil)"  is complex.
Complex Conditional,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,Equals,The conditional expression  "(other.Type == DataType.Nil && this.Type == DataType.Void)  				|| (other.Type == DataType.Void && this.Type == DataType.Nil)"  is complex.
Complex Conditional,MoonSharp.Interpreter,Table,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\Table.cs,PerformTableSet,The conditional expression  "m_ContainsNilEntries && value.IsNotNil() && (prev.Value == null || prev.Value.IsNil())"  is complex.
Complex Conditional,MoonSharp.Interpreter.Interop.Converters,TableConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\TableConversions.cs,CanConvertTableToType,The conditional expression  "(generic == typeof(List<>))  					|| (generic == typeof(IList<>))  					 || (generic == typeof(ICollection<>))  					 || (generic == typeof(IEnumerable<>))"  is complex.
Complex Conditional,MoonSharp.Interpreter.Interop.Converters,TableConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\TableConversions.cs,ConvertTableToType,The conditional expression  "(generic == typeof(List<>))  					|| (generic == typeof(IList<>))  					 || (generic == typeof(ICollection<>))  					 || (generic == typeof(IEnumerable<>))"  is complex.
Complex Conditional,MoonSharp.Interpreter.Interop,PropertyTableAssigner,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\PropertyTableAssigner.cs,SetSubassignerForType,The conditional expression  "Framework.Do.IsAbstract(propertyType)   				|| Framework.Do.IsGenericType(propertyType)   				|| Framework.Do.IsInterface(propertyType)   				|| Framework.Do.IsValueType(propertyType)"  is complex.
Complex Conditional,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,TryCreateIfVisible,The conditional expression  "ei.GetVisibilityFromAttributes() ?? ((remm != null && remm.IsPublic) && (addm != null && addm.IsPublic))"  is complex.
Complex Conditional,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The conditional expression  "fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o'"  is complex.
Complex Conditional,MoonSharp.Interpreter.Tree.Expressions,BinaryOperatorExpression,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Expressions\BinaryOperatorExpression.cs,EvalComparison,The conditional expression  "(l.Type == DataType.Nil && r.Type == DataType.Void)  							|| (l.Type == DataType.Void && r.Type == DataType.Nil)"  is complex.
Complex Conditional,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadNumberToken,The conditional expression  "c == 'e' || c == 'E' || (isHex && (c == 'p' || c == 'P'))"  is complex.
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop.BasicDescriptors,ParameterDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\BasicDescriptors\ParameterDescriptor.cs,ParameterDescriptor,The constructor "ParameterDescriptor" calls a virtual method "IsDbNull".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,PropertyTableAssigner,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\PropertyTableAssigner.cs,PropertyTableAssigner,The constructor "PropertyTableAssigner" calls a virtual method "IsValueType".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,PropertyTableAssigner,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\PropertyTableAssigner.cs,PropertyTableAssigner,The constructor "PropertyTableAssigner" calls a virtual method "GetProperties".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,StandardEnumUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardEnumUserDataDescriptor.cs,StandardEnumUserDataDescriptor,The constructor "StandardEnumUserDataDescriptor" calls a virtual method "IsEnum".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,EventMemberDescriptor,The constructor "EventMemberDescriptor" calls a virtual method "GetAddMethod".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,EventMemberDescriptor,The constructor "EventMemberDescriptor" calls a virtual method "GetRemoveMethod".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,ValueTypeDefaultCtorMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\ValueTypeDefaultCtorMemberDescriptor.cs,ValueTypeDefaultCtorMemberDescriptor,The constructor "ValueTypeDefaultCtorMemberDescriptor" calls a virtual method "IsValueType".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,PropertyMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\PropertyMemberDescriptor.cs,PropertyMemberDescriptor,The constructor "PropertyMemberDescriptor" calls a virtual method "GetGetMethod".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Interop,PropertyMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\PropertyMemberDescriptor.cs,PropertyMemberDescriptor,The constructor "PropertyMemberDescriptor" calls a virtual method "GetSetMethod".
Virtual Method Call from Constructor,MoonSharp.Interpreter.Tree.Expressions,FunctionCallExpression,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Expressions\FunctionCallExpression.cs,FunctionCallExpression,The constructor "FunctionCallExpression" calls a virtual method "GetFriendlyDebugName".
Empty Catch Block,MoonSharp.Interpreter.CoreLib,OsTimeModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\OsTimeModule.cs,date,The method has an empty catch block.
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,collectgarbage,The following statement contains a magic number: if (mode == null || mode == "collect" || mode == "restart")  			{  #if PCL || ENABLE_DOTNET  				GC.Collect();  #else  				GC.Collect(2' GCCollectionMode.Forced);  #endif  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,BasicModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\BasicModule.cs,tonumber,The following statement contains a magic number: if (b.IsNil())  			{  				if (e.Type == DataType.Number)  					return e;    				if (e.Type != DataType.String)  					return DynValue.Nil;    				double d;  				if (double.TryParse(e.String' NumberStyles.Any' CultureInfo.InvariantCulture' out d))  				{  					return DynValue.NewNumber(d);  				}  				return DynValue.Nil;  			}  			else  			{                  //!COMPAT: tonumber supports only 2'8'10 or 16 as base                  //UPDATE: added support for 3-9 base numbers                  DynValue ee;    				if (args[0].Type != DataType.Number)  					ee = args.AsType(0' "tonumber"' DataType.String' false);  				else  					ee = DynValue.NewString(args[0].Number.ToString(CultureInfo.InvariantCulture)); ;    				int bb = (int)b.Number;    			    uint uiv = 0;                  if (bb == 2 || bb == 8 || bb == 10 || bb == 16)  			    {                      uiv = Convert.ToUInt32(ee.String.Trim()' bb);                  }  			    else if (bb < 10 && bb > 2) // Support for 3' 4' 5' 6' 7 and 9 based numbers  			    {  			        foreach (char digit in ee.String.Trim())  			        {  			            int value = digit - 48;  			            if (value < 0 || value >= bb)  			            {                              throw new ScriptRuntimeException("bad argument #1 to 'tonumber' (invalid character)");                          }                            uiv = (uint)(uiv * bb) + (uint)value;  			        }                  }  			    else  			    {                      throw new ScriptRuntimeException("bad argument #2 to 'tonumber' (base out of range)");                  }    				return DynValue.NewNumber(uiv);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,DebugModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\DebugModule.cs,setupvalue,The following statement contains a magic number: closure[index].Assign(args[2]);
Magic Number,MoonSharp.Interpreter.CoreLib,DebugModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\DebugModule.cs,upvaluejoin,The following statement contains a magic number: DynValue f2 = args.AsType(2' "upvaluejoin"' DataType.Function' false);
Magic Number,MoonSharp.Interpreter.CoreLib,DebugModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\DebugModule.cs,upvaluejoin,The following statement contains a magic number: int n2 = args.AsInt(3' "upvaluejoin") - 1;
Magic Number,MoonSharp.Interpreter.CoreLib,DebugModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\DebugModule.cs,upvaluejoin,The following statement contains a magic number: if (n2 < 0 || n2 >= c2.ClosureContext.Count)  				throw ScriptRuntimeException.BadArgument(3' "upvaluejoin"' "invalid upvalue index");
Magic Number,MoonSharp.Interpreter.CoreLib,DebugModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\DebugModule.cs,traceback,The following statement contains a magic number: if (vmessage.Type == DataType.Thread)  			{  				cor = vmessage.Coroutine;  				vmessage = args[1];  				vlevel = args[2];  				defaultSkip = 0.0;  			}
Magic Number,MoonSharp.Interpreter.CoreLib,IoModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\IoModule.cs,open,The following statement contains a magic number: DynValue vencoding = args.AsType(2' "open"' DataType.String' true);
Magic Number,MoonSharp.Interpreter.CoreLib,LoadModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\LoadModule.cs,load_impl,The following statement contains a magic number: try  			{  				Script S = executionContext.GetScript();  				DynValue ld = args[0];  				string script = "";    				if (ld.Type == DataType.Function)  				{  					while (true)  					{  						DynValue ret = executionContext.GetScript().Call(ld);  						if (ret.Type == DataType.String && ret.String.Length > 0)  							script += ret.String;  						else if (ret.IsNil())  							break;  						else  							return DynValue.NewTuple(DynValue.Nil' DynValue.NewString("reader function must return a string"));  					}  				}  				else if (ld.Type == DataType.String)  				{  					script = ld.String;  				}  				else  				{  					args.AsType(0' "load"' DataType.Function' false);  				}    				DynValue source = args.AsType(1' "load"' DataType.String' true);  				DynValue env = args.AsType(3' "load"' DataType.Table' true);    				DynValue fn = S.LoadString(script'  					!env.IsNil() ? env.Table : defaultEnv'  					!source.IsNil() ? source.String : "=(load)");    				return fn;  			}  			catch (SyntaxErrorException ex)  			{  				return DynValue.NewTuple(DynValue.Nil' DynValue.NewString(ex.DecoratedMessage ?? ex.Message));  			}
Magic Number,MoonSharp.Interpreter.CoreLib,LoadModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\LoadModule.cs,loadfile_impl,The following statement contains a magic number: try  			{  				Script S = executionContext.GetScript();  				DynValue filename = args.AsType(0' "loadfile"' DataType.String' false);  				DynValue env = args.AsType(2' "loadfile"' DataType.Table' true);    				DynValue fn = S.LoadFile(filename.String' env.IsNil() ? defaultEnv : env.Table);    				return fn;  			}  			catch (SyntaxErrorException ex)  			{  				return DynValue.NewTuple(DynValue.Nil' DynValue.NewString(ex.DecoratedMessage ?? ex.Message));  			}
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,ToUInt32,The following statement contains a magic number: d = Math.IEEERemainder(d' Math.Pow(2.0' 32.0));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,ToUInt32,The following statement contains a magic number: d = Math.IEEERemainder(d' Math.Pow(2.0' 32.0));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,ToInt32,The following statement contains a magic number: d = Math.IEEERemainder(d' Math.Pow(2.0' 32.0));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,ToInt32,The following statement contains a magic number: d = Math.IEEERemainder(d' Math.Pow(2.0' 32.0));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,NBitMask,The following statement contains a magic number: if (bits >= 32)  				return MASKS[31];
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,NBitMask,The following statement contains a magic number: if (bits >= 32)  				return MASKS[31];
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,extract,The following statement contains a magic number: DynValue v_width = args.AsType(2' "extract"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,extract,The following statement contains a magic number: ValidatePosWidth("extract"' 2' pos' width);
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,replace,The following statement contains a magic number: DynValue v_pos = args.AsType(2' "replace"' DataType.Number);
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,replace,The following statement contains a magic number: DynValue v_width = args.AsType(3' "replace"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,replace,The following statement contains a magic number: ValidatePosWidth("replace"' 3' pos' width);
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,ValidatePosWidth,The following statement contains a magic number: if (pos > 31 || (pos + width) > 31)  				throw new ScriptRuntimeException("trying to access non-existent bits");
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,ValidatePosWidth,The following statement contains a magic number: if (pos > 31 || (pos + width) > 31)  				throw new ScriptRuntimeException("trying to access non-existent bits");
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,lrotate,The following statement contains a magic number: int a = ((int)v_a.Number) % 32;
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,lrotate,The following statement contains a magic number: if (a < 0)  				v = (v >> (-a)) | (v << (32 + a));  			else  				v = (v << a) | (v >> (32 - a));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,lrotate,The following statement contains a magic number: if (a < 0)  				v = (v >> (-a)) | (v << (32 + a));  			else  				v = (v << a) | (v >> (32 - a));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,rrotate,The following statement contains a magic number: int a = ((int)v_a.Number) % 32;
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,rrotate,The following statement contains a magic number: if (a < 0)  				v = (v << (-a)) | (v >> (32 + a));  			else  				v = (v >> a) | (v << (32 - a));
Magic Number,MoonSharp.Interpreter.CoreLib,Bit32Module,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\Bit32Module.cs,rrotate,The following statement contains a magic number: if (a < 0)  				v = (v << (-a)) | (v >> (32 + a));  			else  				v = (v >> a) | (v << (32 - a));
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,deg,The following statement contains a magic number: return exec1(args' "deg"' d => d * 180.0 / Math.PI);
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,frexp,The following statement contains a magic number: int exponent = (int) ((bits >> 52) & 0x7ffL);
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,frexp,The following statement contains a magic number: if (exponent==0)  			{  				exponent++;  			}  			// Normal numbers; leave exponent as it is but add extra  			// bit to the front of the mantissa  			else  			{  				mantissa = mantissa | (1L<<52);  			}
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,frexp,The following statement contains a magic number: exponent -= 1075;
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,frexp,The following statement contains a magic number: while( m >= 1 )  			{  				m /= 2.0;  				e += 1.0;  			}
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,ldexp,The following statement contains a magic number: return exec2(args' "ldexp"' (d1' d2) => d1 * Math.Pow(2' d2));
Magic Number,MoonSharp.Interpreter.CoreLib,MathModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MathModule.cs,rad,The following statement contains a magic number: return exec1(args' "rad"' d => d * Math.PI / 180.0);
Magic Number,MoonSharp.Interpreter.CoreLib,MetaTableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\MetaTableModule.cs,rawset,The following statement contains a magic number: table.Table.Set(index' args[2]);
Magic Number,MoonSharp.Interpreter.CoreLib,OsTimeModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\OsTimeModule.cs,ParseTimeTable,The following statement contains a magic number: int hour = GetTimeTableField(t' "hour") ?? 12;
Magic Number,MoonSharp.Interpreter.CoreLib,OsTimeModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\OsTimeModule.cs,StrFTime,The following statement contains a magic number: for (int i = 0; i < format.Length; i++)  			{  				char c = format[i];    				if (c == '%')  				{  					if (isEscapeSequence)  					{  						sb.Append('%');  						isEscapeSequence = false;  					}  					else  						isEscapeSequence = true;    					continue;  				}    				if (!isEscapeSequence)  				{  					sb.Append(c);  					continue;  				}    				if (c == 'O' || c == 'E') continue; // no modifiers    				isEscapeSequence = false;    				if (STANDARD_PATTERNS.ContainsKey(c))  				{  					sb.Append(d.ToString(STANDARD_PATTERNS[c]));  				}  				else if (c == 'e')  				{  					string s = d.ToString("%d");  					if (s.Length < 2) s = " " + s;  					sb.Append(s);  				}  				else if (c == 'n')  				{  					sb.Append('\n');  				}  				else if (c == 't')  				{  					sb.Append('\t');  				}  				else if (c == 'C')  				{  					sb.Append((int)(d.Year / 100));  				}  				else if (c == 'j')  				{  					sb.Append(d.DayOfYear.ToString("000"));  				}  				else if (c == 'u')  				{  					int weekDay = (int)d.DayOfWeek;  					if (weekDay == 0)  						weekDay = 7;    					sb.Append(weekDay);  				}  				else if (c == 'w')  				{  					int weekDay = (int)d.DayOfWeek;  					sb.Append(weekDay);  				}  				else if (c == 'U')  				{  					// Week number with the first Sunday as the first day of week one (00-53)  					sb.Append("??");  				}  				else if (c == 'V')  				{  					// ISO 8601 week number (00-53)  					sb.Append("??");  				}  				else if (c == 'W')  				{  					// Week number with the first Monday as the first day of week one (00-53)  					sb.Append("??");  				}  				else  				{  					throw new ScriptRuntimeException("bad argument #1 to 'date' (invalid conversion specifier '{0}')"' format);  				}  			}
Magic Number,MoonSharp.Interpreter.CoreLib,OsTimeModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\OsTimeModule.cs,StrFTime,The following statement contains a magic number: for (int i = 0; i < format.Length; i++)  			{  				char c = format[i];    				if (c == '%')  				{  					if (isEscapeSequence)  					{  						sb.Append('%');  						isEscapeSequence = false;  					}  					else  						isEscapeSequence = true;    					continue;  				}    				if (!isEscapeSequence)  				{  					sb.Append(c);  					continue;  				}    				if (c == 'O' || c == 'E') continue; // no modifiers    				isEscapeSequence = false;    				if (STANDARD_PATTERNS.ContainsKey(c))  				{  					sb.Append(d.ToString(STANDARD_PATTERNS[c]));  				}  				else if (c == 'e')  				{  					string s = d.ToString("%d");  					if (s.Length < 2) s = " " + s;  					sb.Append(s);  				}  				else if (c == 'n')  				{  					sb.Append('\n');  				}  				else if (c == 't')  				{  					sb.Append('\t');  				}  				else if (c == 'C')  				{  					sb.Append((int)(d.Year / 100));  				}  				else if (c == 'j')  				{  					sb.Append(d.DayOfYear.ToString("000"));  				}  				else if (c == 'u')  				{  					int weekDay = (int)d.DayOfWeek;  					if (weekDay == 0)  						weekDay = 7;    					sb.Append(weekDay);  				}  				else if (c == 'w')  				{  					int weekDay = (int)d.DayOfWeek;  					sb.Append(weekDay);  				}  				else if (c == 'U')  				{  					// Week number with the first Sunday as the first day of week one (00-53)  					sb.Append("??");  				}  				else if (c == 'V')  				{  					// ISO 8601 week number (00-53)  					sb.Append("??");  				}  				else if (c == 'W')  				{  					// Week number with the first Monday as the first day of week one (00-53)  					sb.Append("??");  				}  				else  				{  					throw new ScriptRuntimeException("bad argument #1 to 'date' (invalid conversion specifier '{0}')"' format);  				}  			}
Magic Number,MoonSharp.Interpreter.CoreLib,OsTimeModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\OsTimeModule.cs,StrFTime,The following statement contains a magic number: for (int i = 0; i < format.Length; i++)  			{  				char c = format[i];    				if (c == '%')  				{  					if (isEscapeSequence)  					{  						sb.Append('%');  						isEscapeSequence = false;  					}  					else  						isEscapeSequence = true;    					continue;  				}    				if (!isEscapeSequence)  				{  					sb.Append(c);  					continue;  				}    				if (c == 'O' || c == 'E') continue; // no modifiers    				isEscapeSequence = false;    				if (STANDARD_PATTERNS.ContainsKey(c))  				{  					sb.Append(d.ToString(STANDARD_PATTERNS[c]));  				}  				else if (c == 'e')  				{  					string s = d.ToString("%d");  					if (s.Length < 2) s = " " + s;  					sb.Append(s);  				}  				else if (c == 'n')  				{  					sb.Append('\n');  				}  				else if (c == 't')  				{  					sb.Append('\t');  				}  				else if (c == 'C')  				{  					sb.Append((int)(d.Year / 100));  				}  				else if (c == 'j')  				{  					sb.Append(d.DayOfYear.ToString("000"));  				}  				else if (c == 'u')  				{  					int weekDay = (int)d.DayOfWeek;  					if (weekDay == 0)  						weekDay = 7;    					sb.Append(weekDay);  				}  				else if (c == 'w')  				{  					int weekDay = (int)d.DayOfWeek;  					sb.Append(weekDay);  				}  				else if (c == 'U')  				{  					// Week number with the first Sunday as the first day of week one (00-53)  					sb.Append("??");  				}  				else if (c == 'V')  				{  					// ISO 8601 week number (00-53)  					sb.Append("??");  				}  				else if (c == 'W')  				{  					// Week number with the first Monday as the first day of week one (00-53)  					sb.Append("??");  				}  				else  				{  					throw new ScriptRuntimeException("bad argument #1 to 'date' (invalid conversion specifier '{0}')"' format);  				}  			}
Magic Number,MoonSharp.Interpreter.CoreLib,StringModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringModule.cs,byte,The following statement contains a magic number: DynValue vj = args.AsType(2' "byte"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,StringModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringModule.cs,unicode,The following statement contains a magic number: DynValue vj = args.AsType(2' "unicode"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,StringModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringModule.cs,Unicode2Ascii,The following statement contains a magic number: if (i >= 0 && i < 255)  				return i;
Magic Number,MoonSharp.Interpreter.CoreLib,StringModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringModule.cs,rep,The following statement contains a magic number: DynValue arg_sep = args.AsType(2' "rep"' DataType.String' true);
Magic Number,MoonSharp.Interpreter.CoreLib,StringModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringModule.cs,sub,The following statement contains a magic number: DynValue arg_j = args.AsType(2' "sub"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,unpack,The following statement contains a magic number: DynValue vj = args.AsType(2' "unpack"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,insert,The following statement contains a magic number: DynValue vvalue = args[2];
Magic Number,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,insert,The following statement contains a magic number: if (args.Count > 3)  				throw new ScriptRuntimeException("wrong number of arguments to 'insert'");
Magic Number,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,remove,The following statement contains a magic number: if (args.Count > 2)  				throw new ScriptRuntimeException("wrong number of arguments to 'remove'");
Magic Number,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,concat,The following statement contains a magic number: DynValue vstart = args.AsType(2' "concat"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib,TableModule,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\TableModule.cs,concat,The following statement contains a magic number: DynValue vend = args.AsType(3' "concat"' DataType.Number' true);
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,matchbracketclass,The following statement contains a magic number: while ((p = p.next()) < ec)  			{  				if (p == L_ESC)  				{  					p = p.next();  					if (match_class((char)c' (char)(p[0])) != 0)  						return sig;  				}  				else if ((p[1] == '-') && (p + 2 < ec))  				{  					p += 2;  					if ((byte)((p[-2])) <= c && (c <= (byte)p[0]))  						return sig;  				}  				else if ((byte)(p[0]) == c) return sig;  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,matchbracketclass,The following statement contains a magic number: while ((p = p.next()) < ec)  			{  				if (p == L_ESC)  				{  					p = p.next();  					if (match_class((char)c' (char)(p[0])) != 0)  						return sig;  				}  				else if ((p[1] == '-') && (p + 2 < ec))  				{  					p += 2;  					if ((byte)((p[-2])) <= c && (c <= (byte)p[0]))  						return sig;  				}  				else if ((byte)(p[0]) == c) return sig;  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,matchbracketclass,The following statement contains a magic number: while ((p = p.next()) < ec)  			{  				if (p == L_ESC)  				{  					p = p.next();  					if (match_class((char)c' (char)(p[0])) != 0)  						return sig;  				}  				else if ((p[1] == '-') && (p + 2 < ec))  				{  					p += 2;  					if ((byte)((p[-2])) <= c && (c <= (byte)p[0]))  						return sig;  				}  				else if ((byte)(p[0]) == c) return sig;  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The following statement contains a magic number: init: /* using goto's to optimize tail recursion */  			switch (p[0])  			{  				case '(':  					{  /* start capture */  						if (p[1] == ')')  /* position capture? */  							return start_capture(ms' s' p + 2' CAP_POSITION);  						else  							return start_capture(ms' s' p + 1' CAP_UNFINISHED);  					}  				case ')':  					{  /* end capture */  						return end_capture(ms' s' p + 1);  					}  				case L_ESC:  					{  						switch (p[1])  						{  							case 'b':  								{  /* balanced string? */  									s = matchbalance(ms' s' p + 2);  									if (s == null) return null;  									p += 4; goto init;  /* else return match(ms' s' p+4); */  								}  							case 'f':  								{  /* frontier? */  									CharPtr ep; char previous;  									p += 2;  									if (p[0] != '[')  										LuaLError(ms.L' "missing " + LUA_QL("[") + " after " +  														   LUA_QL("%f") + " in pattern");  									ep = classend(ms' p);  /* points to what is next */  									previous = (s == ms.src_init) ? '\0' : s[-1];  									if ((matchbracketclass((byte)(previous)' p' ep - 1) != 0) ||  									   (matchbracketclass((byte)(s[0])' p' ep - 1) == 0)) return null;  									p = ep; goto init;  /* else return match(ms' s' ep); */  								}  							default:  								{  									if (isdigit((char)(p[1])))  									{  /* capture results (%0-%9)? */  										s = match_capture(ms' s' (byte)(p[1]));  										if (s == null) return null;  										p += 2; goto init;  /* else return match(ms' s' p+2) */  									}  									//ismeretlen hiba miatt lett ide átmásolva  									{  /* it is a pattern item */  										CharPtr ep = classend(ms' p);  /* points to what is next */  										int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  										switch (ep[0])  										{  											case '?':  												{  /* optional */  													CharPtr res;  													if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  														return res;  													p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  												}  											case '*':  												{  /* 0 or more repetitions */  													return max_expand(ms' s' p' ep);  												}  											case '+':  												{  /* 1 or more repetitions */  													return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  												}  											case '-':  												{  /* 0 or more repetitions (minimum) */  													return min_expand(ms' s' p' ep);  												}  											default:  												{  													if (m == 0) return null;  													s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  												}  										}  									}  									//goto dflt;  /* case default */  								}  						}  					}  				case '\0':  					{  /* end of pattern */  						return s;  /* match succeeded */  					}  				case '$':  					{  						if (p[1] == '\0')  /* is the `$' the last char in pattern? */  							return (s == ms.src_end) ? s : null;  /* check end of string */  						else goto dflt;  					}  				default:  				dflt:  					{  /* it is a pattern item */  						CharPtr ep = classend(ms' p);  /* points to what is next */  						int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  						switch (ep[0])  						{  							case '?':  								{  /* optional */  									CharPtr res;  									if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  										return res;  									p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  								}  							case '*':  								{  /* 0 or more repetitions */  									return max_expand(ms' s' p' ep);  								}  							case '+':  								{  /* 1 or more repetitions */  									return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  								}  							case '-':  								{  /* 0 or more repetitions (minimum) */  									return min_expand(ms' s' p' ep);  								}  							default:  								{  									if (m == 0) return null;  									s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  								}  						}  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The following statement contains a magic number: init: /* using goto's to optimize tail recursion */  			switch (p[0])  			{  				case '(':  					{  /* start capture */  						if (p[1] == ')')  /* position capture? */  							return start_capture(ms' s' p + 2' CAP_POSITION);  						else  							return start_capture(ms' s' p + 1' CAP_UNFINISHED);  					}  				case ')':  					{  /* end capture */  						return end_capture(ms' s' p + 1);  					}  				case L_ESC:  					{  						switch (p[1])  						{  							case 'b':  								{  /* balanced string? */  									s = matchbalance(ms' s' p + 2);  									if (s == null) return null;  									p += 4; goto init;  /* else return match(ms' s' p+4); */  								}  							case 'f':  								{  /* frontier? */  									CharPtr ep; char previous;  									p += 2;  									if (p[0] != '[')  										LuaLError(ms.L' "missing " + LUA_QL("[") + " after " +  														   LUA_QL("%f") + " in pattern");  									ep = classend(ms' p);  /* points to what is next */  									previous = (s == ms.src_init) ? '\0' : s[-1];  									if ((matchbracketclass((byte)(previous)' p' ep - 1) != 0) ||  									   (matchbracketclass((byte)(s[0])' p' ep - 1) == 0)) return null;  									p = ep; goto init;  /* else return match(ms' s' ep); */  								}  							default:  								{  									if (isdigit((char)(p[1])))  									{  /* capture results (%0-%9)? */  										s = match_capture(ms' s' (byte)(p[1]));  										if (s == null) return null;  										p += 2; goto init;  /* else return match(ms' s' p+2) */  									}  									//ismeretlen hiba miatt lett ide átmásolva  									{  /* it is a pattern item */  										CharPtr ep = classend(ms' p);  /* points to what is next */  										int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  										switch (ep[0])  										{  											case '?':  												{  /* optional */  													CharPtr res;  													if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  														return res;  													p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  												}  											case '*':  												{  /* 0 or more repetitions */  													return max_expand(ms' s' p' ep);  												}  											case '+':  												{  /* 1 or more repetitions */  													return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  												}  											case '-':  												{  /* 0 or more repetitions (minimum) */  													return min_expand(ms' s' p' ep);  												}  											default:  												{  													if (m == 0) return null;  													s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  												}  										}  									}  									//goto dflt;  /* case default */  								}  						}  					}  				case '\0':  					{  /* end of pattern */  						return s;  /* match succeeded */  					}  				case '$':  					{  						if (p[1] == '\0')  /* is the `$' the last char in pattern? */  							return (s == ms.src_end) ? s : null;  /* check end of string */  						else goto dflt;  					}  				default:  				dflt:  					{  /* it is a pattern item */  						CharPtr ep = classend(ms' p);  /* points to what is next */  						int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  						switch (ep[0])  						{  							case '?':  								{  /* optional */  									CharPtr res;  									if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  										return res;  									p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  								}  							case '*':  								{  /* 0 or more repetitions */  									return max_expand(ms' s' p' ep);  								}  							case '+':  								{  /* 1 or more repetitions */  									return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  								}  							case '-':  								{  /* 0 or more repetitions (minimum) */  									return min_expand(ms' s' p' ep);  								}  							default:  								{  									if (m == 0) return null;  									s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  								}  						}  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The following statement contains a magic number: init: /* using goto's to optimize tail recursion */  			switch (p[0])  			{  				case '(':  					{  /* start capture */  						if (p[1] == ')')  /* position capture? */  							return start_capture(ms' s' p + 2' CAP_POSITION);  						else  							return start_capture(ms' s' p + 1' CAP_UNFINISHED);  					}  				case ')':  					{  /* end capture */  						return end_capture(ms' s' p + 1);  					}  				case L_ESC:  					{  						switch (p[1])  						{  							case 'b':  								{  /* balanced string? */  									s = matchbalance(ms' s' p + 2);  									if (s == null) return null;  									p += 4; goto init;  /* else return match(ms' s' p+4); */  								}  							case 'f':  								{  /* frontier? */  									CharPtr ep; char previous;  									p += 2;  									if (p[0] != '[')  										LuaLError(ms.L' "missing " + LUA_QL("[") + " after " +  														   LUA_QL("%f") + " in pattern");  									ep = classend(ms' p);  /* points to what is next */  									previous = (s == ms.src_init) ? '\0' : s[-1];  									if ((matchbracketclass((byte)(previous)' p' ep - 1) != 0) ||  									   (matchbracketclass((byte)(s[0])' p' ep - 1) == 0)) return null;  									p = ep; goto init;  /* else return match(ms' s' ep); */  								}  							default:  								{  									if (isdigit((char)(p[1])))  									{  /* capture results (%0-%9)? */  										s = match_capture(ms' s' (byte)(p[1]));  										if (s == null) return null;  										p += 2; goto init;  /* else return match(ms' s' p+2) */  									}  									//ismeretlen hiba miatt lett ide átmásolva  									{  /* it is a pattern item */  										CharPtr ep = classend(ms' p);  /* points to what is next */  										int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  										switch (ep[0])  										{  											case '?':  												{  /* optional */  													CharPtr res;  													if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  														return res;  													p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  												}  											case '*':  												{  /* 0 or more repetitions */  													return max_expand(ms' s' p' ep);  												}  											case '+':  												{  /* 1 or more repetitions */  													return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  												}  											case '-':  												{  /* 0 or more repetitions (minimum) */  													return min_expand(ms' s' p' ep);  												}  											default:  												{  													if (m == 0) return null;  													s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  												}  										}  									}  									//goto dflt;  /* case default */  								}  						}  					}  				case '\0':  					{  /* end of pattern */  						return s;  /* match succeeded */  					}  				case '$':  					{  						if (p[1] == '\0')  /* is the `$' the last char in pattern? */  							return (s == ms.src_end) ? s : null;  /* check end of string */  						else goto dflt;  					}  				default:  				dflt:  					{  /* it is a pattern item */  						CharPtr ep = classend(ms' p);  /* points to what is next */  						int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  						switch (ep[0])  						{  							case '?':  								{  /* optional */  									CharPtr res;  									if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  										return res;  									p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  								}  							case '*':  								{  /* 0 or more repetitions */  									return max_expand(ms' s' p' ep);  								}  							case '+':  								{  /* 1 or more repetitions */  									return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  								}  							case '-':  								{  /* 0 or more repetitions (minimum) */  									return min_expand(ms' s' p' ep);  								}  							default:  								{  									if (m == 0) return null;  									s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  								}  						}  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The following statement contains a magic number: init: /* using goto's to optimize tail recursion */  			switch (p[0])  			{  				case '(':  					{  /* start capture */  						if (p[1] == ')')  /* position capture? */  							return start_capture(ms' s' p + 2' CAP_POSITION);  						else  							return start_capture(ms' s' p + 1' CAP_UNFINISHED);  					}  				case ')':  					{  /* end capture */  						return end_capture(ms' s' p + 1);  					}  				case L_ESC:  					{  						switch (p[1])  						{  							case 'b':  								{  /* balanced string? */  									s = matchbalance(ms' s' p + 2);  									if (s == null) return null;  									p += 4; goto init;  /* else return match(ms' s' p+4); */  								}  							case 'f':  								{  /* frontier? */  									CharPtr ep; char previous;  									p += 2;  									if (p[0] != '[')  										LuaLError(ms.L' "missing " + LUA_QL("[") + " after " +  														   LUA_QL("%f") + " in pattern");  									ep = classend(ms' p);  /* points to what is next */  									previous = (s == ms.src_init) ? '\0' : s[-1];  									if ((matchbracketclass((byte)(previous)' p' ep - 1) != 0) ||  									   (matchbracketclass((byte)(s[0])' p' ep - 1) == 0)) return null;  									p = ep; goto init;  /* else return match(ms' s' ep); */  								}  							default:  								{  									if (isdigit((char)(p[1])))  									{  /* capture results (%0-%9)? */  										s = match_capture(ms' s' (byte)(p[1]));  										if (s == null) return null;  										p += 2; goto init;  /* else return match(ms' s' p+2) */  									}  									//ismeretlen hiba miatt lett ide átmásolva  									{  /* it is a pattern item */  										CharPtr ep = classend(ms' p);  /* points to what is next */  										int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  										switch (ep[0])  										{  											case '?':  												{  /* optional */  													CharPtr res;  													if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  														return res;  													p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  												}  											case '*':  												{  /* 0 or more repetitions */  													return max_expand(ms' s' p' ep);  												}  											case '+':  												{  /* 1 or more repetitions */  													return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  												}  											case '-':  												{  /* 0 or more repetitions (minimum) */  													return min_expand(ms' s' p' ep);  												}  											default:  												{  													if (m == 0) return null;  													s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  												}  										}  									}  									//goto dflt;  /* case default */  								}  						}  					}  				case '\0':  					{  /* end of pattern */  						return s;  /* match succeeded */  					}  				case '$':  					{  						if (p[1] == '\0')  /* is the `$' the last char in pattern? */  							return (s == ms.src_end) ? s : null;  /* check end of string */  						else goto dflt;  					}  				default:  				dflt:  					{  /* it is a pattern item */  						CharPtr ep = classend(ms' p);  /* points to what is next */  						int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  						switch (ep[0])  						{  							case '?':  								{  /* optional */  									CharPtr res;  									if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  										return res;  									p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  								}  							case '*':  								{  /* 0 or more repetitions */  									return max_expand(ms' s' p' ep);  								}  							case '+':  								{  /* 1 or more repetitions */  									return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  								}  							case '-':  								{  /* 0 or more repetitions (minimum) */  									return min_expand(ms' s' p' ep);  								}  							default:  								{  									if (m == 0) return null;  									s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  								}  						}  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The following statement contains a magic number: init: /* using goto's to optimize tail recursion */  			switch (p[0])  			{  				case '(':  					{  /* start capture */  						if (p[1] == ')')  /* position capture? */  							return start_capture(ms' s' p + 2' CAP_POSITION);  						else  							return start_capture(ms' s' p + 1' CAP_UNFINISHED);  					}  				case ')':  					{  /* end capture */  						return end_capture(ms' s' p + 1);  					}  				case L_ESC:  					{  						switch (p[1])  						{  							case 'b':  								{  /* balanced string? */  									s = matchbalance(ms' s' p + 2);  									if (s == null) return null;  									p += 4; goto init;  /* else return match(ms' s' p+4); */  								}  							case 'f':  								{  /* frontier? */  									CharPtr ep; char previous;  									p += 2;  									if (p[0] != '[')  										LuaLError(ms.L' "missing " + LUA_QL("[") + " after " +  														   LUA_QL("%f") + " in pattern");  									ep = classend(ms' p);  /* points to what is next */  									previous = (s == ms.src_init) ? '\0' : s[-1];  									if ((matchbracketclass((byte)(previous)' p' ep - 1) != 0) ||  									   (matchbracketclass((byte)(s[0])' p' ep - 1) == 0)) return null;  									p = ep; goto init;  /* else return match(ms' s' ep); */  								}  							default:  								{  									if (isdigit((char)(p[1])))  									{  /* capture results (%0-%9)? */  										s = match_capture(ms' s' (byte)(p[1]));  										if (s == null) return null;  										p += 2; goto init;  /* else return match(ms' s' p+2) */  									}  									//ismeretlen hiba miatt lett ide átmásolva  									{  /* it is a pattern item */  										CharPtr ep = classend(ms' p);  /* points to what is next */  										int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  										switch (ep[0])  										{  											case '?':  												{  /* optional */  													CharPtr res;  													if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  														return res;  													p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  												}  											case '*':  												{  /* 0 or more repetitions */  													return max_expand(ms' s' p' ep);  												}  											case '+':  												{  /* 1 or more repetitions */  													return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  												}  											case '-':  												{  /* 0 or more repetitions (minimum) */  													return min_expand(ms' s' p' ep);  												}  											default:  												{  													if (m == 0) return null;  													s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  												}  										}  									}  									//goto dflt;  /* case default */  								}  						}  					}  				case '\0':  					{  /* end of pattern */  						return s;  /* match succeeded */  					}  				case '$':  					{  						if (p[1] == '\0')  /* is the `$' the last char in pattern? */  							return (s == ms.src_end) ? s : null;  /* check end of string */  						else goto dflt;  					}  				default:  				dflt:  					{  /* it is a pattern item */  						CharPtr ep = classend(ms' p);  /* points to what is next */  						int m = (s < ms.src_end) && (singlematch((byte)(s[0])' p' ep) != 0) ? 1 : 0;  						switch (ep[0])  						{  							case '?':  								{  /* optional */  									CharPtr res;  									if ((m != 0) && ((res = match(ms' s + 1' ep + 1)) != null))  										return res;  									p = ep + 1; goto init;  /* else return match(ms' s' ep+1); */  								}  							case '*':  								{  /* 0 or more repetitions */  									return max_expand(ms' s' p' ep);  								}  							case '+':  								{  /* 1 or more repetitions */  									return ((m != 0) ? max_expand(ms' s + 1' p' ep) : null);  								}  							case '-':  								{  /* 0 or more repetitions (minimum) */  									return min_expand(ms' s' p' ep);  								}  							default:  								{  									if (m == 0) return null;  									s = s.next(); p = ep; goto init;  /* else return match(ms' s+1' ep); */  								}  						}  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_find_aux,The following statement contains a magic number: CharPtr p = PatchPattern(LuaLCheckLString(L' 2' out l2));
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_find_aux,The following statement contains a magic number: ptrdiff_t init = posrelat(LuaLOptInteger(L' 3' 1)' l1) - 1;
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_find_aux,The following statement contains a magic number: if ((find != 0) && ((LuaToBoolean(L' 4) != 0) ||  /* explicit request? */  				strpbrk(p' SPECIALS) == null))  			{  /* or no special characters? */  				/* do a plain search */  				CharPtr s2 = lmemfind(s + init' (uint)(l1 - init)' p' (uint)(l2));  				if (s2 != null)  				{  					LuaPushInteger(L' s2 - s + 1);  					LuaPushInteger(L' (int)(s2 - s + l2));  					return 2;  				}  			}  			else  			{  				MatchState ms = new MatchState();  				int anchor = 0;  				if (p[0] == '^')  				{  					p = p.next();  					anchor = 1;  				}  				CharPtr s1 = s + init;  				ms.L = L;  				ms.matchdepth = MAXCCALLS;  				ms.src_init = s;  				ms.src_end = s + l1;  				do  				{  					CharPtr res;  					ms.level = 0;  					// LuaAssert(ms.matchdepth == MAXCCALLS);  					ms.matchdepth = MAXCCALLS;  					if ((res = match(ms' s1' p)) != null)  					{  						if (find != 0)  						{  							LuaPushInteger(L' s1 - s + 1);  /* start */  							LuaPushInteger(L' res - s);   /* end */  							return push_captures(ms' null' null) + 2;  						}  						else  							return push_captures(ms' s1' res);  					}  				} while (((s1 = s1.next()) <= ms.src_end) && (anchor == 0));  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_find_aux,The following statement contains a magic number: if ((find != 0) && ((LuaToBoolean(L' 4) != 0) ||  /* explicit request? */  				strpbrk(p' SPECIALS) == null))  			{  /* or no special characters? */  				/* do a plain search */  				CharPtr s2 = lmemfind(s + init' (uint)(l1 - init)' p' (uint)(l2));  				if (s2 != null)  				{  					LuaPushInteger(L' s2 - s + 1);  					LuaPushInteger(L' (int)(s2 - s + l2));  					return 2;  				}  			}  			else  			{  				MatchState ms = new MatchState();  				int anchor = 0;  				if (p[0] == '^')  				{  					p = p.next();  					anchor = 1;  				}  				CharPtr s1 = s + init;  				ms.L = L;  				ms.matchdepth = MAXCCALLS;  				ms.src_init = s;  				ms.src_end = s + l1;  				do  				{  					CharPtr res;  					ms.level = 0;  					// LuaAssert(ms.matchdepth == MAXCCALLS);  					ms.matchdepth = MAXCCALLS;  					if ((res = match(ms' s1' p)) != null)  					{  						if (find != 0)  						{  							LuaPushInteger(L' s1 - s + 1);  /* start */  							LuaPushInteger(L' res - s);   /* end */  							return push_captures(ms' null' null) + 2;  						}  						else  							return push_captures(ms' s1' res);  					}  				} while (((s1 = s1.next()) <= ms.src_end) && (anchor == 0));  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_find_aux,The following statement contains a magic number: if ((find != 0) && ((LuaToBoolean(L' 4) != 0) ||  /* explicit request? */  				strpbrk(p' SPECIALS) == null))  			{  /* or no special characters? */  				/* do a plain search */  				CharPtr s2 = lmemfind(s + init' (uint)(l1 - init)' p' (uint)(l2));  				if (s2 != null)  				{  					LuaPushInteger(L' s2 - s + 1);  					LuaPushInteger(L' (int)(s2 - s + l2));  					return 2;  				}  			}  			else  			{  				MatchState ms = new MatchState();  				int anchor = 0;  				if (p[0] == '^')  				{  					p = p.next();  					anchor = 1;  				}  				CharPtr s1 = s + init;  				ms.L = L;  				ms.matchdepth = MAXCCALLS;  				ms.src_init = s;  				ms.src_end = s + l1;  				do  				{  					CharPtr res;  					ms.level = 0;  					// LuaAssert(ms.matchdepth == MAXCCALLS);  					ms.matchdepth = MAXCCALLS;  					if ((res = match(ms' s1' p)) != null)  					{  						if (find != 0)  						{  							LuaPushInteger(L' s1 - s + 1);  /* start */  							LuaPushInteger(L' res - s);   /* end */  							return push_captures(ms' null' null) + 2;  						}  						else  							return push_captures(ms' s1' res);  					}  				} while (((s1 = s1.next()) <= ms.src_end) && (anchor == 0));  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_gmatch,The following statement contains a magic number: string p = PatchPattern(ArgAsType(L' 2' DataType.String' false).String);
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,add_s,The following statement contains a magic number: CharPtr news = LuaToLString(ms.L' 3' out l);
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,add_value,The following statement contains a magic number: switch (LuaType(L' 3))  			{  				case LUA_TNUMBER:  				case LUA_TSTRING:  					{  						add_s(ms' b' s' e);  						return;  					}  				// case LUA_TUSERDATA: /// +++ does this make sense ??  				case LUA_TFUNCTION:  					{  						int n;  						LuaPushValue(L' 3);  						n = push_captures(ms' s' e);  						LuaCall(L' n' 1);  						break;  					}  				case LUA_TTABLE:  					{  						push_onecapture(ms' 0' s' e);  						LuaGetTable(L' 3);  						break;  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,add_value,The following statement contains a magic number: switch (LuaType(L' 3))  			{  				case LUA_TNUMBER:  				case LUA_TSTRING:  					{  						add_s(ms' b' s' e);  						return;  					}  				// case LUA_TUSERDATA: /// +++ does this make sense ??  				case LUA_TFUNCTION:  					{  						int n;  						LuaPushValue(L' 3);  						n = push_captures(ms' s' e);  						LuaCall(L' n' 1);  						break;  					}  				case LUA_TTABLE:  					{  						push_onecapture(ms' 0' s' e);  						LuaGetTable(L' 3);  						break;  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,add_value,The following statement contains a magic number: switch (LuaType(L' 3))  			{  				case LUA_TNUMBER:  				case LUA_TSTRING:  					{  						add_s(ms' b' s' e);  						return;  					}  				// case LUA_TUSERDATA: /// +++ does this make sense ??  				case LUA_TFUNCTION:  					{  						int n;  						LuaPushValue(L' 3);  						n = push_captures(ms' s' e);  						LuaCall(L' n' 1);  						break;  					}  				case LUA_TTABLE:  					{  						push_onecapture(ms' 0' s' e);  						LuaGetTable(L' 3);  						break;  					}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_gsub,The following statement contains a magic number: CharPtr p = PatchPattern(LuaLCheckStringStr(L' 2));
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_gsub,The following statement contains a magic number: int tr = LuaType(L' 3);
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_gsub,The following statement contains a magic number: int max_s = LuaLOptInt(L' 4' (int)(srcl + 1));
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_gsub,The following statement contains a magic number: LuaLArgCheck(L' tr == LUA_TNUMBER || tr == LUA_TSTRING ||  							 tr == LUA_TFUNCTION || tr == LUA_TTABLE ||  							 tr == LUA_TUSERDATA' 3'  								"string/function/table expected");
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_gsub,The following statement contains a magic number: return 2;
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,addquoted,The following statement contains a magic number: while ((l--) != 0)  			{  				switch (s[0])  				{  					case '"':  					case '\\':  					case '\n':  						{  							LuaLAddChar(b' '\\');  							LuaLAddChar(b' s[0]);  							break;  						}  					case '\r':  						{  							LuaLAddLString(b' "\\r"' 2);  							break;  						}  					default:  						{  							if (s[0] < (char)16)  							{  								bool isfollowedbynum = false;    								if (l >= 1)  								{  									if (char.IsNumber(s[1]))  										isfollowedbynum = true;  								}    								if (isfollowedbynum)  									LuaLAddString(b' string.Format("\\{0:000}"' (int)s[0]));  								else  									LuaLAddString(b' string.Format("\\{0}"' (int)s[0]));  							}  							else  							{  								LuaLAddChar(b' s[0]);  							}  							break;  						}  				}  				s = s.next();  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,addquoted,The following statement contains a magic number: while ((l--) != 0)  			{  				switch (s[0])  				{  					case '"':  					case '\\':  					case '\n':  						{  							LuaLAddChar(b' '\\');  							LuaLAddChar(b' s[0]);  							break;  						}  					case '\r':  						{  							LuaLAddLString(b' "\\r"' 2);  							break;  						}  					default:  						{  							if (s[0] < (char)16)  							{  								bool isfollowedbynum = false;    								if (l >= 1)  								{  									if (char.IsNumber(s[1]))  										isfollowedbynum = true;  								}    								if (isfollowedbynum)  									LuaLAddString(b' string.Format("\\{0:000}"' (int)s[0]));  								else  									LuaLAddString(b' string.Format("\\{0}"' (int)s[0]));  							}  							else  							{  								LuaLAddChar(b' s[0]);  							}  							break;  						}  				}  				s = s.next();  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,addintlen,The following statement contains a magic number: form[l + (LUA_INTFRMLEN.Length + 1) - 2] = spec;
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_format,The following statement contains a magic number: while (strfrmt < strfrmt_end)  			{  				if (strfrmt[0] != L_ESC)  				{  					LuaLAddChar(b' strfrmt[0]);  					strfrmt = strfrmt.next();  				}  				else if (strfrmt[1] == L_ESC)  				{  					LuaLAddChar(b' strfrmt[0]);  /* %% */  					strfrmt = strfrmt + 2;  				}  				else  				{ /* format item */  					strfrmt = strfrmt.next();  					CharPtr form = new char[MAX_FORMAT];  /* to store the format (`%...') */  					CharPtr buff = new char[MAX_ITEM];  /* to store the formatted item */  					if (++arg > top)  						LuaLArgError(L' arg' "no value");  					strfrmt = scanformat(L' strfrmt' form);  					char ch = strfrmt[0];  					strfrmt = strfrmt.next();  					switch (ch)  					{  						case 'c':  							{  								sprintf(buff' form' (int)LuaLCheckNumber(L' arg));  								break;  							}  						case 'd':  						case 'i':  							{  								addintlen(form);  								sprintf(buff' form' (LUA_INTFRM_T)LuaLCheckNumber(L' arg));  								break;  							}  						case 'o':  						case 'u':  						case 'x':  						case 'X':  							{  								addintlen(form);  								sprintf(buff' form' (UNSIGNED_LUA_INTFRM_T)LuaLCheckNumber(L' arg));  								break;  							}  						case 'e':  						case 'E':  						case 'f':  						case 'g':  						case 'G':  							{  								sprintf(buff' form' (double)LuaLCheckNumber(L' arg));  								break;  							}  						case 'q':  							{  								addquoted(L' b' arg);  								continue;  /* skip the 'addsize' at the end */  							}  						case 's':  							{  								uint l;  								CharPtr s = LuaLCheckLString(L' arg' out l);  								if ((strchr(form' '.') == null) && l >= 100)  								{  									/* no precision and string is too long to be formatted;  									   keep original string */  									LuaPushValue(L' arg);  									LuaLAddValue(b);  									continue;  /* skip the `addsize' at the end */  								}  								else  								{  									sprintf(buff' form' s);  									break;  								}  							}  						default:  							{  /* also treat cases `pnLlh' */  								return LuaLError(L' "invalid option " + LUA_QL("%" + ch) + " to " +  													 LUA_QL("format")' strfrmt[-1]);  							}  					}  					LuaLAddLString(b' buff' (uint)strlen(buff));  				}  			}
Magic Number,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,str_format,The following statement contains a magic number: while (strfrmt < strfrmt_end)  			{  				if (strfrmt[0] != L_ESC)  				{  					LuaLAddChar(b' strfrmt[0]);  					strfrmt = strfrmt.next();  				}  				else if (strfrmt[1] == L_ESC)  				{  					LuaLAddChar(b' strfrmt[0]);  /* %% */  					strfrmt = strfrmt + 2;  				}  				else  				{ /* format item */  					strfrmt = strfrmt.next();  					CharPtr form = new char[MAX_FORMAT];  /* to store the format (`%...') */  					CharPtr buff = new char[MAX_ITEM];  /* to store the formatted item */  					if (++arg > top)  						LuaLArgError(L' arg' "no value");  					strfrmt = scanformat(L' strfrmt' form);  					char ch = strfrmt[0];  					strfrmt = strfrmt.next();  					switch (ch)  					{  						case 'c':  							{  								sprintf(buff' form' (int)LuaLCheckNumber(L' arg));  								break;  							}  						case 'd':  						case 'i':  							{  								addintlen(form);  								sprintf(buff' form' (LUA_INTFRM_T)LuaLCheckNumber(L' arg));  								break;  							}  						case 'o':  						case 'u':  						case 'x':  						case 'X':  							{  								addintlen(form);  								sprintf(buff' form' (UNSIGNED_LUA_INTFRM_T)LuaLCheckNumber(L' arg));  								break;  							}  						case 'e':  						case 'E':  						case 'f':  						case 'g':  						case 'G':  							{  								sprintf(buff' form' (double)LuaLCheckNumber(L' arg));  								break;  							}  						case 'q':  							{  								addquoted(L' b' arg);  								continue;  /* skip the 'addsize' at the end */  							}  						case 's':  							{  								uint l;  								CharPtr s = LuaLCheckLString(L' arg' out l);  								if ((strchr(form' '.') == null) && l >= 100)  								{  									/* no precision and string is too long to be formatted;  									   keep original string */  									LuaPushValue(L' arg);  									LuaLAddValue(b);  									continue;  /* skip the `addsize' at the end */  								}  								else  								{  									sprintf(buff' form' s);  									break;  								}  							}  						default:  							{  /* also treat cases `pnLlh' */  								return LuaLError(L' "invalid option " + LUA_QL("%" + ch) + " to " +  													 LUA_QL("format")' strfrmt[-1]);  							}  					}  					LuaLAddLString(b' buff' (uint)strlen(buff));  				}  			}
Magic Number,MoonSharp.Interpreter.Debugging,SourceRef,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Debugging\SourceRef.cs,GetLocationDistance,The following statement contains a magic number: const int PER_LINE_FACTOR = 1600;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,IsDumpStream,The following statement contains a magic number: if (stream.Length >= 8)  			{  				using (BinaryReader br = new BinaryReader(stream' Encoding.UTF8))  				{  					ulong magic = br.ReadUInt64();  					stream.Seek(-8' SeekOrigin.Current);  					return magic == DUMP_CHUNK_MAGIC;  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,IsDumpStream,The following statement contains a magic number: if (stream.Length >= 8)  			{  				using (BinaryReader br = new BinaryReader(stream' Encoding.UTF8))  				{  					ulong magic = br.ReadUInt64();  					stream.Seek(-8' SeekOrigin.Current);  					return magic == DUMP_CHUNK_MAGIC;  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Debugger_RefreshVStack,The following statement contains a magic number: for (int i = 0; i < Math.Min(32' m_ValueStack.Count); i++)  			{  				lwi.Add(new WatchItem()  				{  					Address = i'  					Value = m_ValueStack.Peek(i)  				});  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterUpd,The following statement contains a magic number: t.Tuple[2] = v;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterPrep,The following statement contains a magic number: DynValue s = v.Tuple.Length >= 2 ? v.Tuple[1] : DynValue.Nil;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterPrep,The following statement contains a magic number: DynValue var = v.Tuple.Length >= 3 ? v.Tuple[2] : DynValue.Nil;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterPrep,The following statement contains a magic number: DynValue var = v.Tuple.Length >= 3 ? v.Tuple[2] : DynValue.Nil;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterPrep,The following statement contains a magic number: if (f.Type != DataType.Function && f.Type != DataType.ClrFunction)  			{  				DynValue meta = this.GetMetamethod(f' "__iterator");    				if (meta != null && !meta.IsNil())  				{  					if (meta.Type != DataType.Tuple)  						v = this.GetScript().Call(meta' f' s' var);  					else  						v = meta;    					f = v.Tuple.Length >= 1 ? v.Tuple[0] : DynValue.Nil;  					s = v.Tuple.Length >= 2 ? v.Tuple[1] : DynValue.Nil;  					var = v.Tuple.Length >= 3 ? v.Tuple[2] : DynValue.Nil;    					m_ValueStack.Push(DynValue.NewTuple(f' s' var));  				}  				else if (f.Type == DataType.Table)  				{  					DynValue callmeta = this.GetMetamethod(f' "__call");    					if (callmeta == null || callmeta.IsNil())  					{  						m_ValueStack.Push(EnumerableWrapper.ConvertTable(f.Table));  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterPrep,The following statement contains a magic number: if (f.Type != DataType.Function && f.Type != DataType.ClrFunction)  			{  				DynValue meta = this.GetMetamethod(f' "__iterator");    				if (meta != null && !meta.IsNil())  				{  					if (meta.Type != DataType.Tuple)  						v = this.GetScript().Call(meta' f' s' var);  					else  						v = meta;    					f = v.Tuple.Length >= 1 ? v.Tuple[0] : DynValue.Nil;  					s = v.Tuple.Length >= 2 ? v.Tuple[1] : DynValue.Nil;  					var = v.Tuple.Length >= 3 ? v.Tuple[2] : DynValue.Nil;    					m_ValueStack.Push(DynValue.NewTuple(f' s' var));  				}  				else if (f.Type == DataType.Table)  				{  					DynValue callmeta = this.GetMetamethod(f' "__call");    					if (callmeta == null || callmeta.IsNil())  					{  						m_ValueStack.Push(EnumerableWrapper.ConvertTable(f.Table));  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIterPrep,The following statement contains a magic number: if (f.Type != DataType.Function && f.Type != DataType.ClrFunction)  			{  				DynValue meta = this.GetMetamethod(f' "__iterator");    				if (meta != null && !meta.IsNil())  				{  					if (meta.Type != DataType.Tuple)  						v = this.GetScript().Call(meta' f' s' var);  					else  						v = meta;    					f = v.Tuple.Length >= 1 ? v.Tuple[0] : DynValue.Nil;  					s = v.Tuple.Length >= 2 ? v.Tuple[1] : DynValue.Nil;  					var = v.Tuple.Length >= 3 ? v.Tuple[2] : DynValue.Nil;    					m_ValueStack.Push(DynValue.NewTuple(f' s' var));  				}  				else if (f.Type == DataType.Table)  				{  					DynValue callmeta = this.GetMetamethod(f' "__call");    					if (callmeta == null || callmeta.IsNil())  					{  						m_ValueStack.Push(EnumerableWrapper.ConvertTable(f.Table));  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecJFor,The following statement contains a magic number: double stop = m_ValueStack.Peek(2).Number;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIndexSet,The following statement contains a magic number: int nestedMetaOps = 100;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIndexSet,The following statement contains a magic number: while (nestedMetaOps > 0)  			{  				--nestedMetaOps;    				if (obj.Type == DataType.Table)  				{  					if (!isMultiIndex)  					{  						if (!obj.Table.Get(idx).IsNil())  						{  							obj.Table.Set(idx' value);  							return instructionPtr;  						}  					}    					h = GetMetamethodRaw(obj' "__newindex");    					if (h == null || h.IsNil())  					{  						if (isMultiIndex) throw new ScriptRuntimeException("cannot multi-index a table. userdata expected");    						obj.Table.Set(idx' value);  						return instructionPtr;  					}  				}  				else if (obj.Type == DataType.UserData)  				{  					UserData ud = obj.UserData;    					if (!ud.Descriptor.SetIndex(this.GetScript()' ud.Object' originalIdx' value' isNameIndex))  					{  						throw ScriptRuntimeException.UserDataMissingField(ud.Descriptor.Name' idx.String);  					}    					return instructionPtr;  				}  				else  				{  					h = GetMetamethodRaw(obj' "__newindex");    					if (h == null || h.IsNil())  						throw ScriptRuntimeException.IndexType(obj);  				}    				if (h.Type == DataType.Function || h.Type == DataType.ClrFunction)  				{  					if (isMultiIndex) throw new ScriptRuntimeException("cannot multi-index through metamethods. userdata expected");  					m_ValueStack.Pop(); // burn extra value ?    					m_ValueStack.Push(h);  					m_ValueStack.Push(obj);  					m_ValueStack.Push(idx);  					m_ValueStack.Push(value);  					return Internal_ExecCall(3' instructionPtr);  				}  				else  				{  					obj = h;  					h = null;  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIndex,The following statement contains a magic number: int nestedMetaOps = 100;
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ExecIndex,The following statement contains a magic number: while (nestedMetaOps > 0)  			{  				--nestedMetaOps;    				if (obj.Type == DataType.Table)  				{  					if (!isMultiIndex)  					{  						var v = obj.Table.Get(idx);    						if (!v.IsNil())  						{  							m_ValueStack.Push(v.AsReadOnly());  							return instructionPtr;  						}  					}    					h = GetMetamethodRaw(obj' "__index");    					if (h == null || h.IsNil())  					{  						if (isMultiIndex) throw new ScriptRuntimeException("cannot multi-index a table. userdata expected");    						m_ValueStack.Push(DynValue.Nil);  						return instructionPtr;  					}  				}  				else if (obj.Type == DataType.UserData)  				{  					UserData ud = obj.UserData;    					var v = ud.Descriptor.Index(this.GetScript()' ud.Object' originalIdx' isNameIndex);    					if (v == null)  					{  						throw ScriptRuntimeException.UserDataMissingField(ud.Descriptor.Name' idx.String);  					}    					m_ValueStack.Push(v.AsReadOnly());  					return instructionPtr;  				}  				else  				{  					h = GetMetamethodRaw(obj' "__index");    					if (h == null || h.IsNil())  						throw ScriptRuntimeException.IndexType(obj);  				}    				if (h.Type == DataType.Function || h.Type == DataType.ClrFunction)  				{  					if (isMultiIndex) throw new ScriptRuntimeException("cannot multi-index through metamethods. userdata expected");  					m_ValueStack.Push(h);  					m_ValueStack.Push(obj);  					m_ValueStack.Push(idx);  					return Internal_ExecCall(2' instructionPtr);  				}  				else  				{  					obj = h;  					h = null;  				}  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,Internal_InvokeBinaryMetaMethod,The following statement contains a magic number: if (m != null)  			{  				if (extraPush != null)  					m_ValueStack.Push(extraPush);    				m_ValueStack.Push(m);  				m_ValueStack.Push(l);  				m_ValueStack.Push(r);  				return Internal_ExecCall(2' instructionPtr);  			}  			else  			{  				return -1;  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Debug,The following statement contains a magic number: AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Debug' Name = str.Substring(0' Math.Min(32' str.Length)) });
Magic Number,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Load,The following statement contains a magic number: switch (sym.Type)  			{  				case SymbolRefType.Global:  					Emit_Load(sym.i_Env);  					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Index' Value = DynValue.NewString(sym.i_Name) });  					return 2;  				case SymbolRefType.Local:  					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Local' Symbol = sym });  					return 1;  				case SymbolRefType.Upvalue:  					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.Upvalue' Symbol = sym });  					return 1;  				default:  					throw new InternalErrorException("Unexpected symbol type : {0}"' sym);  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,ByteCode,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\ByteCode.cs,Emit_Store,The following statement contains a magic number: switch (sym.Type)  			{  				case SymbolRefType.Global:  					Emit_Load(sym.i_Env);  					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.IndexSet' Symbol = sym' NumVal = stackofs' NumVal2 = tupleidx' Value = DynValue.NewString(sym.i_Name) });  					return 2;  				case SymbolRefType.Local:  					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.StoreLcl' Symbol = sym' NumVal = stackofs' NumVal2 = tupleidx });  					return 1;  				case SymbolRefType.Upvalue:  					AppendInstruction(new Instruction(m_CurrentSourceRef) { OpCode = OpCode.StoreUpv' Symbol = sym' NumVal = stackofs' NumVal2 = tupleidx });  					return 1;  				default:  					throw new InternalErrorException("Unexpected symbol type : {0}"' sym);  			}
Magic Number,MoonSharp.Interpreter.Execution.VM,Instruction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Instruction.cs,GenSpaces,The following statement contains a magic number: return new string(' '' 10 - this.OpCode.ToString().Length);
Magic Number,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,ConvertToNumberFailed,The following statement contains a magic number: switch (stage)  			{  				case 1:  					return new ScriptRuntimeException("'for' initial value must be a number");  				case 2:  					return new ScriptRuntimeException("'for' step must be a number");  				case 3:  					return new ScriptRuntimeException("'for' limit must be a number");  				default:  					return new ScriptRuntimeException("value must be a number");  			}
Magic Number,MoonSharp.Interpreter,ScriptRuntimeException,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Errors\ScriptRuntimeException.cs,ConvertToNumberFailed,The following statement contains a magic number: switch (stage)  			{  				case 1:  					return new ScriptRuntimeException("'for' initial value must be a number");  				case 2:  					return new ScriptRuntimeException("'for' step must be a number");  				case 3:  					return new ScriptRuntimeException("'for' limit must be a number");  				default:  					return new ScriptRuntimeException("value must be a number");  			}
Magic Number,MoonSharp.Interpreter,CallbackFunction,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\CallbackFunction.cs,CheckCallbackSignature,The following statement contains a magic number: return (pi.Length == 2 && pi[0].ParameterType == typeof(ScriptExecutionContext)  				&& pi[1].ParameterType == typeof(CallbackArguments) && mi.ReturnType == typeof(DynValue) && (requirePublicVisibility || mi.IsPublic));
Magic Number,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,GetHashCode,The following statement contains a magic number: int baseValue = ((int)(Type)) << 27;
Magic Number,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,GetHashCode,The following statement contains a magic number: switch (Type)  			{  				case DataType.Void:  				case DataType.Nil:  					m_HashCode = 0;  					break;  				case DataType.Boolean:  					m_HashCode = Boolean ? 1 : 2;  					break;  				case DataType.Number:  					m_HashCode = baseValue ^ Number.GetHashCode();  					break;  				case DataType.String:  					m_HashCode = baseValue ^ String.GetHashCode();  					break;  				case DataType.Function:  					m_HashCode = baseValue ^ Function.GetHashCode();  					break;  				case DataType.ClrFunction:  					m_HashCode = baseValue ^ Callback.GetHashCode();  					break;  				case DataType.Table:  					m_HashCode = baseValue ^ Table.GetHashCode();  					break;  				case DataType.Tuple:  				case DataType.TailCallRequest:  					m_HashCode = baseValue ^ Tuple.GetHashCode();  					break;  				case DataType.UserData:  				case DataType.Thread:  				default:  					m_HashCode = 999;  					break;  			}
Magic Number,MoonSharp.Interpreter,DynValue,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\DataTypes\DynValue.cs,GetHashCode,The following statement contains a magic number: switch (Type)  			{  				case DataType.Void:  				case DataType.Nil:  					m_HashCode = 0;  					break;  				case DataType.Boolean:  					m_HashCode = Boolean ? 1 : 2;  					break;  				case DataType.Number:  					m_HashCode = baseValue ^ Number.GetHashCode();  					break;  				case DataType.String:  					m_HashCode = baseValue ^ String.GetHashCode();  					break;  				case DataType.Function:  					m_HashCode = baseValue ^ Function.GetHashCode();  					break;  				case DataType.ClrFunction:  					m_HashCode = baseValue ^ Callback.GetHashCode();  					break;  				case DataType.Table:  					m_HashCode = baseValue ^ Table.GetHashCode();  					break;  				case DataType.Tuple:  				case DataType.TailCallRequest:  					m_HashCode = baseValue ^ Tuple.GetHashCode();  					break;  				case DataType.UserData:  				case DataType.Thread:  				default:  					m_HashCode = 999;  					break;  			}
Magic Number,MoonSharp.Interpreter,ScriptExecutionContext,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\ScriptExecutionContext.cs,Call,The following statement contains a magic number: if (func.Type == DataType.Function)  			{  				return this.GetScript().Call(func' args);  			}  			else if (func.Type == DataType.ClrFunction)  			{  				while (true)  				{  					DynValue ret = func.Callback.Invoke(this' args' false);    					if (ret.Type == DataType.YieldRequest)  					{  						throw ScriptRuntimeException.CannotYield();  					}  					else if (ret.Type == DataType.TailCallRequest)  					{  						var tail = ret.TailCallData;    						if (tail.Continuation != null || tail.ErrorHandler != null)  						{  							throw new ScriptRuntimeException("the function passed cannot be called directly. wrap in a script function instead.");  						}  						else  						{  							args = tail.Args;  							func = tail.Function;  						}  					}  					else  					{  						return ret;  					}  				}  			}  			else  			{  				int maxloops = 10;    				while (maxloops > 0)  				{  					DynValue v = this.GetMetamethod(func' "__call");    					if (v == null && v.IsNil())  					{  						throw ScriptRuntimeException.AttemptToCallNonFunc(func.Type);  					}    					func = v;    					if (func.Type == DataType.Function || func.Type == DataType.ClrFunction)  					{  						return Call(func' args);  					}  				}    				throw ScriptRuntimeException.LoopInCall();  			}
Magic Number,MoonSharp.Interpreter,Script,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Script.cs,Script,The following statement contains a magic number: DefaultOptions = new ScriptOptions()  			{  				DebugPrint = s => { Script.GlobalOptions.Platform.DefaultPrint(s); }'  				DebugInput = s => { return Script.GlobalOptions.Platform.DefaultInput(s); }'  				CheckThreadAccess = true'  				ScriptLoader = PlatformAutoDetector.GetDefaultScriptLoader()'  				TailCallOptimizationThreshold = 65536  			};
Magic Number,MoonSharp.Interpreter,ModuleRegister,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Modules\ModuleRegister.cs,RegisterModuleType,The following statement contains a magic number: foreach (MethodInfo mi in Framework.Do.GetMethods(t).Where(__mi => __mi.IsStatic))  			{  				if (mi.GetCustomAttributes(typeof(MoonSharpModuleMethodAttribute)' false).ToArray().Length > 0)  				{  					MoonSharpModuleMethodAttribute attr = (MoonSharpModuleMethodAttribute)mi.GetCustomAttributes(typeof(MoonSharpModuleMethodAttribute)' false).First();    					if (!CallbackFunction.CheckCallbackSignature(mi' true))  							throw new ArgumentException(string.Format("Method {0} does not have the right signature."' mi.Name));    #if NETFX_CORE  					Delegate deleg = mi.CreateDelegate(typeof(Func<ScriptExecutionContext' CallbackArguments' DynValue>));  #else  					Delegate deleg = Delegate.CreateDelegate(typeof(Func<ScriptExecutionContext' CallbackArguments' DynValue>)' mi);  #endif    					Func<ScriptExecutionContext' CallbackArguments' DynValue> func =  						(Func<ScriptExecutionContext' CallbackArguments' DynValue>)deleg;  						    					string name = (!string.IsNullOrEmpty(attr.Name)) ? attr.Name : mi.Name;    					table.Set(name' DynValue.NewCallback(func' name));  				}  				else if (mi.Name == "MoonSharpInit")  				{  					object[] args = new object[2] { gtable' table };  					mi.Invoke(null' args);  				}  			}
Magic Number,MoonSharp.Interpreter.Interop,ReflectionSpecialName,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\ReflectionSpecialNames.cs,ReflectionSpecialName,The following statement contains a magic number: if (name.StartsWith("get_"))  			{  				Type = ReflectionSpecialNameType.PropertyGetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("set_"))  			{  				Type = ReflectionSpecialNameType.PropertySetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("add_"))  			{  				Type = ReflectionSpecialNameType.AddEvent;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("remove_"))  			{  				Type = ReflectionSpecialNameType.RemoveEvent;  				Argument = name.Substring(7);  			}
Magic Number,MoonSharp.Interpreter.Interop,ReflectionSpecialName,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\ReflectionSpecialNames.cs,ReflectionSpecialName,The following statement contains a magic number: if (name.StartsWith("get_"))  			{  				Type = ReflectionSpecialNameType.PropertyGetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("set_"))  			{  				Type = ReflectionSpecialNameType.PropertySetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("add_"))  			{  				Type = ReflectionSpecialNameType.AddEvent;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("remove_"))  			{  				Type = ReflectionSpecialNameType.RemoveEvent;  				Argument = name.Substring(7);  			}
Magic Number,MoonSharp.Interpreter.Interop,ReflectionSpecialName,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\ReflectionSpecialNames.cs,ReflectionSpecialName,The following statement contains a magic number: if (name.StartsWith("get_"))  			{  				Type = ReflectionSpecialNameType.PropertyGetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("set_"))  			{  				Type = ReflectionSpecialNameType.PropertySetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("add_"))  			{  				Type = ReflectionSpecialNameType.AddEvent;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("remove_"))  			{  				Type = ReflectionSpecialNameType.RemoveEvent;  				Argument = name.Substring(7);  			}
Magic Number,MoonSharp.Interpreter.Interop,ReflectionSpecialName,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\ReflectionSpecialNames.cs,ReflectionSpecialName,The following statement contains a magic number: if (name.StartsWith("get_"))  			{  				Type = ReflectionSpecialNameType.PropertyGetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("set_"))  			{  				Type = ReflectionSpecialNameType.PropertySetter;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("add_"))  			{  				Type = ReflectionSpecialNameType.AddEvent;  				Argument = name.Substring(4);  			}  			else if (name.StartsWith("remove_"))  			{  				Type = ReflectionSpecialNameType.RemoveEvent;  				Argument = name.Substring(7);  			}
Magic Number,MoonSharp.Interpreter.Interop,StandardEnumUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardEnumUserDataDescriptor.cs,PerformBinaryOperationS,The following statement contains a magic number: if (args.Count != 2)  				throw new ScriptRuntimeException("Enum.{0} expects two arguments"' funcName);
Magic Number,MoonSharp.Interpreter.Interop,StandardEnumUserDataDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\StandardEnumUserDataDescriptor.cs,PerformBinaryOperationU,The following statement contains a magic number: if (args.Count != 2)  				throw new ScriptRuntimeException("Enum.{0} expects two arguments"' funcName);
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,EventMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\EventMemberDescriptor.cs,CreateDelegate,The following statement contains a magic number: switch (Framework.Do.GetMethod(EventInfo.EventHandlerType' "Invoke").GetParameters().Length)  			{  				case 0:  					return (EventWrapper00)(() => DispatchEvent(sender));  				case 1:  					return (EventWrapper01)((o1) => DispatchEvent(sender' o1));  				case 2:  					return (EventWrapper02)((o1' o2) => DispatchEvent(sender' o1' o2));  				case 3:  					return (EventWrapper03)((o1' o2' o3) => DispatchEvent(sender' o1' o2' o3));  				case 4:  					return (EventWrapper04)((o1' o2' o3' o4) => DispatchEvent(sender' o1' o2' o3' o4));  				case 5:   					return (EventWrapper05)((o1' o2' o3' o4' o5) => DispatchEvent(sender' o1' o2' o3' o4' o5));  				case 6:   					return (EventWrapper06)((o1' o2' o3' o4' o5' o6) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6));  				case 7:   					return (EventWrapper07)((o1' o2' o3' o4' o5' o6' o7) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7));  				case 8:   					return (EventWrapper08)((o1' o2' o3' o4' o5' o6' o7' o8) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8));  				case 9:   					return (EventWrapper09)((o1' o2' o3' o4' o5' o6' o7' o8' o9) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9));  				case 10:   					return (EventWrapper10)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10));  				case 11:   					return (EventWrapper11)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11));  				case 12:   					return (EventWrapper12)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12));  				case 13:   					return (EventWrapper13)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13));  				case 14:   					return (EventWrapper14)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14));  				case 15:   					return (EventWrapper15)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15));  				case 16:   					return (EventWrapper16)((o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16) => DispatchEvent(sender' o1' o2' o3' o4' o5' o6' o7' o8' o9' o10' o11' o12' o13' o14' o15' o16));  				default:  					throw new InternalErrorException("too many args in delegate type");  			}
Magic Number,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,CalcScoreForOverload,The following statement contains a magic number: if (totalScore > 0)  			{  				if ((args.Count - argsBase) <= method.Parameters.Length)  				{  					totalScore += ScriptToClrConversions.WEIGHT_NO_EXTRA_PARAMS_BONUS;  					totalScore *= 1000;  				}  				else if (varArgsUsed)  				{  					totalScore -= ScriptToClrConversions.WEIGHT_VARARGS_MALUS;  					totalScore *= 1000;  				}  				else  				{  					totalScore *= 1000;  					totalScore -= ScriptToClrConversions.WEIGHT_EXTRA_PARAMS_MALUS * ((args.Count - argsBase) - method.Parameters.Length);  					totalScore = Math.Max(1' totalScore);  				}  			}
Magic Number,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,CalcScoreForOverload,The following statement contains a magic number: if (totalScore > 0)  			{  				if ((args.Count - argsBase) <= method.Parameters.Length)  				{  					totalScore += ScriptToClrConversions.WEIGHT_NO_EXTRA_PARAMS_BONUS;  					totalScore *= 1000;  				}  				else if (varArgsUsed)  				{  					totalScore -= ScriptToClrConversions.WEIGHT_VARARGS_MALUS;  					totalScore *= 1000;  				}  				else  				{  					totalScore *= 1000;  					totalScore -= ScriptToClrConversions.WEIGHT_EXTRA_PARAMS_MALUS * ((args.Count - argsBase) - method.Parameters.Length);  					totalScore = Math.Max(1' totalScore);  				}  			}
Magic Number,MoonSharp.Interpreter.Interop,OverloadedMethodMemberDescriptor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\StandardDescriptors\ReflectionMemberDescriptors\OverloadedMethodMemberDescriptor.cs,CalcScoreForOverload,The following statement contains a magic number: if (totalScore > 0)  			{  				if ((args.Count - argsBase) <= method.Parameters.Length)  				{  					totalScore += ScriptToClrConversions.WEIGHT_NO_EXTRA_PARAMS_BONUS;  					totalScore *= 1000;  				}  				else if (varArgsUsed)  				{  					totalScore -= ScriptToClrConversions.WEIGHT_VARARGS_MALUS;  					totalScore *= 1000;  				}  				else  				{  					totalScore *= 1000;  					totalScore -= ScriptToClrConversions.WEIGHT_EXTRA_PARAMS_MALUS * ((args.Count - argsBase) - method.Parameters.Length);  					totalScore = Math.Max(1' totalScore);  				}  			}
Magic Number,MoonSharp.Interpreter.Execution,BuildTimeScope,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\Scopes\BuildTimeScope.cs,Find,The following statement contains a magic number: for (int i = m_Frames.Count - 2; i >= 0; i--)  			{  				SymbolRef symb = m_Frames[i].Find(name);    				if (symb != null)  				{  					symb = CreateUpValue(this' symb' i' m_Frames.Count - 2);  						  					if (symb != null)  						return symb;  				}  			}
Magic Number,MoonSharp.Interpreter.Execution,BuildTimeScope,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\Scopes\BuildTimeScope.cs,Find,The following statement contains a magic number: for (int i = m_Frames.Count - 2; i >= 0; i--)  			{  				SymbolRef symb = m_Frames[i].Find(name);    				if (symb != null)  				{  					symb = CreateUpValue(this' symb' i' m_Frames.Count - 2);  						  					if (symb != null)  						return symb;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups[2].Length == 3)  				return Convert.ToChar(Convert.ToByte(m.Groups[2].Value' 8)).ToString();  			else  			{  				// convert all other special meta characters  				//TODO: \xhhh hex and possible dec !!  				switch (m.Groups[2].Value)  				{  					case "0":           // null  						return "\0";  					case "a":           // alert (beep)  						return "\a";  					case "b":           // BS  						return "\b";  					case "f":           // FF  						return "\f";  					case "v":           // vertical tab  						return "\v";  					case "r":           // CR  						return "\r";  					case "n":           // LF  						return "\n";  					case "t":           // Tab  						return "\t";  					default:  						// if neither an octal quote nor a special meta character  						// so just remove the backslash  						return m.Groups[2].Value;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups[2].Length == 3)  				return Convert.ToChar(Convert.ToByte(m.Groups[2].Value' 8)).ToString();  			else  			{  				// convert all other special meta characters  				//TODO: \xhhh hex and possible dec !!  				switch (m.Groups[2].Value)  				{  					case "0":           // null  						return "\0";  					case "a":           // alert (beep)  						return "\a";  					case "b":           // BS  						return "\b";  					case "f":           // FF  						return "\f";  					case "v":           // vertical tab  						return "\v";  					case "r":           // CR  						return "\r";  					case "n":           // LF  						return "\n";  					case "t":           // Tab  						return "\t";  					default:  						// if neither an octal quote nor a special meta character  						// so just remove the backslash  						return m.Groups[2].Value;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups[2].Length == 3)  				return Convert.ToChar(Convert.ToByte(m.Groups[2].Value' 8)).ToString();  			else  			{  				// convert all other special meta characters  				//TODO: \xhhh hex and possible dec !!  				switch (m.Groups[2].Value)  				{  					case "0":           // null  						return "\0";  					case "a":           // alert (beep)  						return "\a";  					case "b":           // BS  						return "\b";  					case "f":           // FF  						return "\f";  					case "v":           // vertical tab  						return "\v";  					case "r":           // CR  						return "\r";  					case "n":           // LF  						return "\n";  					case "t":           // Tab  						return "\t";  					default:  						// if neither an octal quote nor a special meta character  						// so just remove the backslash  						return m.Groups[2].Value;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups[2].Length == 3)  				return Convert.ToChar(Convert.ToByte(m.Groups[2].Value' 8)).ToString();  			else  			{  				// convert all other special meta characters  				//TODO: \xhhh hex and possible dec !!  				switch (m.Groups[2].Value)  				{  					case "0":           // null  						return "\0";  					case "a":           // alert (beep)  						return "\a";  					case "b":           // BS  						return "\b";  					case "f":           // FF  						return "\f";  					case "v":           // vertical tab  						return "\v";  					case "r":           // CR  						return "\r";  					case "n":           // LF  						return "\n";  					case "t":           // Tab  						return "\t";  					default:  						// if neither an octal quote nor a special meta character  						// so just remove the backslash  						return m.Groups[2].Value;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups[2].Length == 3)  				return Convert.ToChar(Convert.ToByte(m.Groups[2].Value' 8)).ToString();  			else  			{  				// convert all other special meta characters  				//TODO: \xhhh hex and possible dec !!  				switch (m.Groups[2].Value)  				{  					case "0":           // null  						return "\0";  					case "a":           // alert (beep)  						return "\a";  					case "b":           // BS  						return "\b";  					case "f":           // FF  						return "\f";  					case "v":           // vertical tab  						return "\v";  					case "r":           // CR  						return "\r";  					case "n":           // LF  						return "\n";  					case "t":           // Tab  						return "\t";  					default:  						// if neither an octal quote nor a special meta character  						// so just remove the backslash  						return m.Groups[2].Value;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,ReplaceMetaCharsMatch,The following statement contains a magic number: if (m.Groups[2].Length == 3)  				return Convert.ToChar(Convert.ToByte(m.Groups[2].Value' 8)).ToString();  			else  			{  				// convert all other special meta characters  				//TODO: \xhhh hex and possible dec !!  				switch (m.Groups[2].Value)  				{  					case "0":           // null  						return "\0";  					case "a":           // alert (beep)  						return "\a";  					case "b":           // BS  						return "\b";  					case "f":           // FF  						return "\f";  					case "v":           // vertical tab  						return "\v";  					case "r":           // CR  						return "\r";  					case "n":           // LF  						return "\n";  					case "t":           // Tab  						return "\t";  					default:  						// if neither an octal quote nor a special meta character  						// so just remove the backslash  						return m.Groups[2].Value;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,sprintf,The following statement contains a magic number: while (m.Success)  			{  				#region parameter index  				paramIx = defaultParamIx;  				if (m.Groups[1] != null && m.Groups[1].Value.Length > 0)  				{  					string val = m.Groups[1].Value.Substring(0' m.Groups[1].Value.Length - 1);  					paramIx = Convert.ToInt32(val) - 1;  				};  				#endregion    				#region format flags  				// extract format flags  				flagAlternate = false;  				flagLeft2Right = false;  				flagPositiveSign = false;  				flagPositiveSpace = false;  				flagZeroPadding = false;  				flagGroupThousands = false;  				if (m.Groups[2] != null && m.Groups[2].Value.Length > 0)  				{  					string flags = m.Groups[2].Value;    					flagAlternate = (flags.IndexOf('#') >= 0);  					flagLeft2Right = (flags.IndexOf('-') >= 0);  					flagPositiveSign = (flags.IndexOf('+') >= 0);  					flagPositiveSpace = (flags.IndexOf(' ') >= 0);  					flagGroupThousands = (flags.IndexOf('\'') >= 0);    					// positive + indicator overrides a  					// positive space character  					if (flagPositiveSign && flagPositiveSpace)  						flagPositiveSpace = false;  				}  				#endregion    				#region field length  				// extract field length and   				// pading character  				paddingCharacter = ' ';  				fieldLength = int.MinValue;  				if (m.Groups[3] != null && m.Groups[3].Value.Length > 0)  				{  					fieldLength = Convert.ToInt32(m.Groups[3].Value);  					flagZeroPadding = (m.Groups[3].Value[0] == '0');  				}  				#endregion    				if (flagZeroPadding)  					paddingCharacter = '0';    				// left2right allignment overrides zero padding  				if (flagLeft2Right && flagZeroPadding)  				{  					flagZeroPadding = false;  					paddingCharacter = ' ';  				}    				#region field precision  				// extract field precision  				fieldPrecision = int.MinValue;  				if (m.Groups[4] != null && m.Groups[4].Value.Length > 0)  					fieldPrecision = Convert.ToInt32(m.Groups[4].Value);  				#endregion    				#region short / long indicator  				// extract short / long indicator  				shortLongIndicator = Char.MinValue;  				if (m.Groups[5] != null && m.Groups[5].Value.Length > 0)  					shortLongIndicator = m.Groups[5].Value[0];  				#endregion    				#region format specifier  				// extract format  				formatSpecifier = Char.MinValue;  				if (m.Groups[6] != null && m.Groups[6].Value.Length > 0)  					formatSpecifier = m.Groups[6].Value[0];  				#endregion    				// default precision is 6 digits if none is specified except  				if (fieldPrecision == int.MinValue &&  					formatSpecifier != 's' &&  					formatSpecifier != 'c' &&  					Char.ToUpper(formatSpecifier) != 'X' &&  					formatSpecifier != 'o')  					fieldPrecision = 6;    				#region get next value parameter  				// get next value parameter and convert value parameter depending on short / long indicator  				if (Parameters == null || paramIx >= Parameters.Length)  					o = null;  				else  				{  					o = Parameters[paramIx];    					if (shortLongIndicator == 'h')  					{  						if (o is int)  							o = (short)((int)o);  						else if (o is long)  							o = (short)((long)o);  						else if (o is uint)  							o = (ushort)((uint)o);  						else if (o is ulong)  							o = (ushort)((ulong)o);  					}  					else if (shortLongIndicator == 'l')  					{  						if (o is short)  							o = (long)((short)o);  						else if (o is int)  							o = (long)((int)o);  						else if (o is ushort)  							o = (ulong)((ushort)o);  						else if (o is uint)  							o = (ulong)((uint)o);  					}  				}  				#endregion    				// convert value parameters to a string depending on the formatSpecifier  				w = String.Empty;  				switch (formatSpecifier)  				{  					#region % - character  					case '%':   // % character  						w = "%";  						break;  					#endregion  					#region d - integer  					case 'd':   // integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region i - integer  					case 'i':   // integer  						goto case 'd';  					#endregion  					#region o - octal integer  					case 'o':   // octal integer - no leading zero  						w = FormatOct("o"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region x - hex integer  					case 'x':   // hex integer - no leading zero  						w = FormatHex("x"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region X - hex integer  					case 'X':   // same as x but with capital hex characters  						w = FormatHex("X"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region u - unsigned integer  					case 'u':   // unsigned integer  						w = FormatNumber((flagGroupThousands ? "n" : "d")' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										false' false'  										paddingCharacter' ToUnsigned(o));  						defaultParamIx++;  						break;  					#endregion  					#region c - character  					case 'c':   // character  						if (IsNumericType(o))  							w = Convert.ToChar(o).ToString();  						else if (o is char)  							w = ((char)o).ToString();  						else if (o is string && ((string)o).Length > 0)  							w = ((string)o)[0].ToString();  						defaultParamIx++;  						break;  					#endregion  					#region s - string  					case 's':   // string  								//string t = "{0" + ( fieldLength != int.MinValue ? "'" + ( flagLeft2Right ? "-" : String.Empty ) + fieldLength.ToString() : String.Empty ) + ":s}";  						w = o.ToString();  						if (fieldPrecision >= 0)  							w = w.Substring(0' fieldPrecision);    						if (fieldLength != int.MinValue)  							if (flagLeft2Right)  								w = w.PadRight(fieldLength' paddingCharacter);  							else  								w = w.PadLeft(fieldLength' paddingCharacter);  						defaultParamIx++;  						break;  					#endregion  					#region f - double number  					case 'f':   // double  						w = FormatNumber((flagGroupThousands ? "n" : "f")' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region e - exponent number  					case 'e':   // double / exponent  						w = FormatNumber("e"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region E - exponent number  					case 'E':   // double / exponent  						w = FormatNumber("E"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region g - general number  					case 'g':   // double / exponent  						w = FormatNumber("g"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region G - general number  					case 'G':   // double / exponent  						w = FormatNumber("G"' flagAlternate'  										fieldLength' fieldPrecision' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' o);  						defaultParamIx++;  						break;  					#endregion  					#region p - pointer  					case 'p':   // pointer  						if (o is IntPtr)  #if PCL || ENABLE_DOTNET  							w = ( (IntPtr)o ).ToString();  #else  							w = "0x" + ((IntPtr)o).ToString("x");  #endif  						defaultParamIx++;  						break;  					#endregion  					#region n - number of processed chars so far  					case 'n':   // number of characters so far  						w = FormatNumber("d"' flagAlternate'  										fieldLength' int.MinValue' flagLeft2Right'  										flagPositiveSign' flagPositiveSpace'  										paddingCharacter' m.Index);  						break;  					#endregion  					default:  						w = String.Empty;  						defaultParamIx++;  						break;  				}    				// replace format parameter with parameter value  				// and start searching for the next format parameter  				// AFTER the position of the current inserted value  				// to prohibit recursive matches if the value also  				// includes a format specifier  				f.Remove(m.Index' m.Length);  				f.Insert(m.Index' w);  				m = r.Match(f.ToString()' m.Index + w.Length);  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,FormatOct,The following statement contains a magic number: if (IsNumericType(Value))  			{  				w = Convert.ToString(UnboxToLong(Value' true)' 8);    				if (Left2Right || Padding == ' ')  				{  					if (Alternate && w != "0")  						w = "0" + w;  					w = String.Format(lengthFormat' w);  				}  				else  				{  					if (FieldLength != int.MinValue)  						w = w.PadLeft(FieldLength - (Alternate && w != "0" ? 1 : 0)' Padding);  					if (Alternate && w != "0")  						w = "0" + w;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,Tools,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\Tools.cs,FormatHex,The following statement contains a magic number: if (IsNumericType(Value))  			{  				w = String.Format(numberFormat' Value);    				if (Left2Right || Padding == ' ')  				{  					if (Alternate)  						w = (NativeFormat == "x" ? "0x" : "0X") + w;  					w = String.Format(lengthFormat' w);  				}  				else  				{  					if (FieldLength != int.MinValue)  						w = w.PadLeft(FieldLength - (Alternate ? 2 : 0)' Padding);  					if (Alternate)  						w = (NativeFormat == "x" ? "0x" : "0X") + w;  				}  			}
Magic Number,MoonSharp.Interpreter.Interop.LuaStateInterop,LuaState,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\LuaStateInterop\LuaState.cs,LuaState,The following statement contains a magic number: m_Stack = new List<DynValue>(16);
Magic Number,MoonSharp.Interpreter.Tree.Expressions,FunctionDefinitionExpression,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Expressions\FunctionDefinitionExpression.cs,Compile,The following statement contains a magic number: using (bc.EnterSource(m_Begin))  			{  				SymbolRef[] symbs = m_Closure  					//.Select((s' idx) => s.CloneLocalAndSetFrame(m_ClosureFrames[idx]))  					.ToArray();    				m_ClosureInstruction = bc.Emit_Closure(symbs' bc.GetJumpPointForNextInstruction());  				int ops = afterDecl();    				m_ClosureInstruction.NumVal += 2 + ops;  			}
Magic Number,MoonSharp.Interpreter.Tree.Statements,FunctionDefinitionStatement,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Statements\FunctionDefinitionStatement.cs,Compile,The following statement contains a magic number: using (bc.EnterSource(m_SourceRef))  			{  				if (m_Local)  				{  					bc.Emit_Literal(DynValue.Nil);  					bc.Emit_Store(m_FuncSymbol' 0' 0);  					m_FuncDef.Compile(bc' () => SetFunction(bc' 2)' m_FriendlyName);  				}  				else if (m_MethodName == null)  				{  					m_FuncDef.Compile(bc' () => SetFunction(bc' 1)' m_FriendlyName);  				}  				else  				{  					m_FuncDef.Compile(bc' () => SetMethod(bc)' m_FriendlyName);  				}  			}
Magic Number,MoonSharp.Interpreter.Tree.Statements,ForEachLoopStatement,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Statements\ForEachLoopStatement.cs,Compile,The following statement contains a magic number: bc.Emit_Call(2' "for..in");
Magic Number,MoonSharp.Interpreter.Tree.Statements,ForLoopStatement,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Statements\ForLoopStatement.cs,Compile,The following statement contains a magic number: bc.Emit_ToNum(3);
Magic Number,MoonSharp.Interpreter.Tree.Statements,ForLoopStatement,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Statements\ForLoopStatement.cs,Compile,The following statement contains a magic number: bc.Emit_ToNum(2);
Magic Number,MoonSharp.Interpreter.Tree.Statements,ForLoopStatement,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Statements\ForLoopStatement.cs,Compile,The following statement contains a magic number: bc.Emit_Pop(3);
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexInteger,The following statement contains a magic number: if ((txt.Length < 2) || (txt[0] != '0' && (char.ToUpper(txt[1]) != 'X')))  				throw new InternalErrorException("hex numbers must start with '0x' near '{0}'."' txt);
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexInteger,The following statement contains a magic number: if (!ulong.TryParse(txt.Substring(2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out res))  				throw new SyntaxErrorException(T' "malformed number near '{0}'"' txt);
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ReadHexProgressive,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)  			{  				char c = s[i];    				if (LexerUtils.CharIsHexDigit(c))  				{  					int v = LexerUtils.HexDigit2Value(c);  					d *= 16.0;  					d += v;  					++digits;  				}  				else  				{  					return s.Substring(i);  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexFloat,The following statement contains a magic number: try  			{  				if ((s.Length < 2) || (s[0] != '0' && (char.ToUpper(s[1]) != 'X')))  					throw new InternalErrorException("hex float must start with '0x' near '{0}'"' s);    				s = s.Substring(2);    				double value = 0.0;  				int dummy' exp = 0;    				s = ReadHexProgressive(s' ref value' out dummy);    				if (s.Length > 0 && s[0] == '.')  				{  					s = s.Substring(1);  					s = ReadHexProgressive(s' ref value' out exp);  				}    				exp *= -4;    				if (s.Length > 0 && char.ToUpper(s[0]) == 'P')  				{  					if (s.Length == 1)  						throw new SyntaxErrorException(T' "invalid hex float format near '{0}'"' s);    					s = s.Substring(s[1] == '+' ? 2 : 1);    					int exp1 = int.Parse(s' CultureInfo.InvariantCulture);    					exp += exp1;  				}    				double result = value * Math.Pow(2' exp);  				return result;  			}  			catch (FormatException)  			{  				throw new SyntaxErrorException(T' "malformed number near '{0}'"' s);  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexFloat,The following statement contains a magic number: try  			{  				if ((s.Length < 2) || (s[0] != '0' && (char.ToUpper(s[1]) != 'X')))  					throw new InternalErrorException("hex float must start with '0x' near '{0}'"' s);    				s = s.Substring(2);    				double value = 0.0;  				int dummy' exp = 0;    				s = ReadHexProgressive(s' ref value' out dummy);    				if (s.Length > 0 && s[0] == '.')  				{  					s = s.Substring(1);  					s = ReadHexProgressive(s' ref value' out exp);  				}    				exp *= -4;    				if (s.Length > 0 && char.ToUpper(s[0]) == 'P')  				{  					if (s.Length == 1)  						throw new SyntaxErrorException(T' "invalid hex float format near '{0}'"' s);    					s = s.Substring(s[1] == '+' ? 2 : 1);    					int exp1 = int.Parse(s' CultureInfo.InvariantCulture);    					exp += exp1;  				}    				double result = value * Math.Pow(2' exp);  				return result;  			}  			catch (FormatException)  			{  				throw new SyntaxErrorException(T' "malformed number near '{0}'"' s);  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexFloat,The following statement contains a magic number: try  			{  				if ((s.Length < 2) || (s[0] != '0' && (char.ToUpper(s[1]) != 'X')))  					throw new InternalErrorException("hex float must start with '0x' near '{0}'"' s);    				s = s.Substring(2);    				double value = 0.0;  				int dummy' exp = 0;    				s = ReadHexProgressive(s' ref value' out dummy);    				if (s.Length > 0 && s[0] == '.')  				{  					s = s.Substring(1);  					s = ReadHexProgressive(s' ref value' out exp);  				}    				exp *= -4;    				if (s.Length > 0 && char.ToUpper(s[0]) == 'P')  				{  					if (s.Length == 1)  						throw new SyntaxErrorException(T' "invalid hex float format near '{0}'"' s);    					s = s.Substring(s[1] == '+' ? 2 : 1);    					int exp1 = int.Parse(s' CultureInfo.InvariantCulture);    					exp += exp1;  				}    				double result = value * Math.Pow(2' exp);  				return result;  			}  			catch (FormatException)  			{  				throw new SyntaxErrorException(T' "malformed number near '{0}'"' s);  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexFloat,The following statement contains a magic number: try  			{  				if ((s.Length < 2) || (s[0] != '0' && (char.ToUpper(s[1]) != 'X')))  					throw new InternalErrorException("hex float must start with '0x' near '{0}'"' s);    				s = s.Substring(2);    				double value = 0.0;  				int dummy' exp = 0;    				s = ReadHexProgressive(s' ref value' out dummy);    				if (s.Length > 0 && s[0] == '.')  				{  					s = s.Substring(1);  					s = ReadHexProgressive(s' ref value' out exp);  				}    				exp *= -4;    				if (s.Length > 0 && char.ToUpper(s[0]) == 'P')  				{  					if (s.Length == 1)  						throw new SyntaxErrorException(T' "invalid hex float format near '{0}'"' s);    					s = s.Substring(s[1] == '+' ? 2 : 1);    					int exp1 = int.Parse(s' CultureInfo.InvariantCulture);    					exp += exp1;  				}    				double result = value * Math.Pow(2' exp);  				return result;  			}  			catch (FormatException)  			{  				throw new SyntaxErrorException(T' "malformed number near '{0}'"' s);  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,ParseHexFloat,The following statement contains a magic number: try  			{  				if ((s.Length < 2) || (s[0] != '0' && (char.ToUpper(s[1]) != 'X')))  					throw new InternalErrorException("hex float must start with '0x' near '{0}'"' s);    				s = s.Substring(2);    				double value = 0.0;  				int dummy' exp = 0;    				s = ReadHexProgressive(s' ref value' out dummy);    				if (s.Length > 0 && s[0] == '.')  				{  					s = s.Substring(1);  					s = ReadHexProgressive(s' ref value' out exp);  				}    				exp *= -4;    				if (s.Length > 0 && char.ToUpper(s[0]) == 'P')  				{  					if (s.Length == 1)  						throw new SyntaxErrorException(T' "invalid hex float format near '{0}'"' s);    					s = s.Substring(s[1] == '+' ? 2 : 1);    					int exp1 = int.Parse(s' CultureInfo.InvariantCulture);    					exp += exp1;  				}    				double result = value * Math.Pow(2' exp);  				return result;  			}  			catch (FormatException)  			{  				throw new SyntaxErrorException(T' "malformed number near '{0}'"' s);  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,HexDigit2Value,The following statement contains a magic number: if (c >= '0' && c <= '9')  				return c - '0';  			else if (c >= 'A' && c <= 'F')  				return 10 + (c - 'A');  			else if (c >= 'a' && c <= 'f')  				return 10 + (c - 'a');  			else  				throw new InternalErrorException("invalid hex digit near '{0}'"' c);
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,HexDigit2Value,The following statement contains a magic number: if (c >= '0' && c <= '9')  				return c - '0';  			else if (c >= 'A' && c <= 'F')  				return 10 + (c - 'A');  			else if (c >= 'a' && c <= 'f')  				return 10 + (c - 'a');  			else  				throw new InternalErrorException("invalid hex digit near '{0}'"' c);
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,AdjustLuaLongString,The following statement contains a magic number: if (str.StartsWith("\r\n"))  				str = str.Substring(2);  			else if (str.StartsWith("\n"))  				str = str.Substring(1);
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The following statement contains a magic number: foreach (char c in str)  			{  			redo:  				if (escape)  				{  					if (val.Length == 0 && !hex && unicode_state == 0)  					{  						if (c == 'a') { sb.Append('\a'); escape = false; zmode = false; }  						else if (c == '\r') { }  // this makes \\r\n -> \\n  						else if (c == '\n') { sb.Append('\n'); escape = false; }  						else if (c == 'b') { sb.Append('\b'); escape = false; }  						else if (c == 'f') { sb.Append('\f'); escape = false; }  						else if (c == 'n') { sb.Append('\n'); escape = false; }  						else if (c == 'r') { sb.Append('\r'); escape = false; }  						else if (c == 't') { sb.Append('\t'); escape = false; }  						else if (c == 'v') { sb.Append('\v'); escape = false; }  						else if (c == '\\') { sb.Append('\\'); escape = false; zmode = false; }  						else if (c == '"') { sb.Append('\"'); escape = false; zmode = false; }  						else if (c == '\'') { sb.Append('\''); escape = false; zmode = false; }  						else if (c == '[') { sb.Append('['); escape = false; zmode = false; }  						else if (c == ']') { sb.Append(']'); escape = false; zmode = false; }  						else if (c == 'x') { hex = true; }  						else if (c == 'u') { unicode_state = 1; }  						else if (c == 'z') { zmode = true; escape = false; }  						else if (CharIsDigit(c)) { val = val + c; }  						else throw new SyntaxErrorException(token' "invalid escape sequence near '\\{0}'"' c);  					}  					else  					{  						if (unicode_state == 1)  						{  							if (c != '{')  								throw new SyntaxErrorException(token' "'{' expected near '\\u'");    							unicode_state = 2;  						}  						else if (unicode_state == 2)  						{  							if (c == '}')  							{  								int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  								sb.Append(ConvertUtf32ToChar(i));  								unicode_state = 0;  								val = string.Empty;  								escape = false;  							}  							else if (val.Length >= 8)  							{  								throw new SyntaxErrorException(token' "'}' missing' or unicode code point too large after '\\u'");  							}  							else  							{  								val += c;  							}  						}  						else if (hex)  						{  							if (CharIsHexDigit(c))  							{  								val += c;  								if (val.Length == 2)  								{  									int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  									sb.Append(ConvertUtf32ToChar(i));  									zmode = false;  									escape = false;  								}  							}  							else  							{  								throw new SyntaxErrorException(token' "hexadecimal digit expected near '\\{0}{1}{2}'"' hexprefix' val' c);  							}  						}  						else if (val.Length > 0)  						{  							if (CharIsDigit(c))  							{  								val = val + c;  							}    							if (val.Length == 3 || !CharIsDigit(c))  							{  								int i = int.Parse(val' CultureInfo.InvariantCulture);    								if (i > 255)  									throw new SyntaxErrorException(token' "decimal escape too large near '\\{0}'"' val);    								sb.Append(ConvertUtf32ToChar(i));    								zmode = false;  								escape = false;    								if (!CharIsDigit(c))  									goto redo;  							}  						}  					}  				}  				else  				{  					if (c == '\\')  					{  						escape = true;  						hex = false;  						val = "";  					}  					else  					{  						if (!zmode || !char.IsWhiteSpace(c))  						{  							sb.Append(c);  							zmode = false;  						}  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The following statement contains a magic number: foreach (char c in str)  			{  			redo:  				if (escape)  				{  					if (val.Length == 0 && !hex && unicode_state == 0)  					{  						if (c == 'a') { sb.Append('\a'); escape = false; zmode = false; }  						else if (c == '\r') { }  // this makes \\r\n -> \\n  						else if (c == '\n') { sb.Append('\n'); escape = false; }  						else if (c == 'b') { sb.Append('\b'); escape = false; }  						else if (c == 'f') { sb.Append('\f'); escape = false; }  						else if (c == 'n') { sb.Append('\n'); escape = false; }  						else if (c == 'r') { sb.Append('\r'); escape = false; }  						else if (c == 't') { sb.Append('\t'); escape = false; }  						else if (c == 'v') { sb.Append('\v'); escape = false; }  						else if (c == '\\') { sb.Append('\\'); escape = false; zmode = false; }  						else if (c == '"') { sb.Append('\"'); escape = false; zmode = false; }  						else if (c == '\'') { sb.Append('\''); escape = false; zmode = false; }  						else if (c == '[') { sb.Append('['); escape = false; zmode = false; }  						else if (c == ']') { sb.Append(']'); escape = false; zmode = false; }  						else if (c == 'x') { hex = true; }  						else if (c == 'u') { unicode_state = 1; }  						else if (c == 'z') { zmode = true; escape = false; }  						else if (CharIsDigit(c)) { val = val + c; }  						else throw new SyntaxErrorException(token' "invalid escape sequence near '\\{0}'"' c);  					}  					else  					{  						if (unicode_state == 1)  						{  							if (c != '{')  								throw new SyntaxErrorException(token' "'{' expected near '\\u'");    							unicode_state = 2;  						}  						else if (unicode_state == 2)  						{  							if (c == '}')  							{  								int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  								sb.Append(ConvertUtf32ToChar(i));  								unicode_state = 0;  								val = string.Empty;  								escape = false;  							}  							else if (val.Length >= 8)  							{  								throw new SyntaxErrorException(token' "'}' missing' or unicode code point too large after '\\u'");  							}  							else  							{  								val += c;  							}  						}  						else if (hex)  						{  							if (CharIsHexDigit(c))  							{  								val += c;  								if (val.Length == 2)  								{  									int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  									sb.Append(ConvertUtf32ToChar(i));  									zmode = false;  									escape = false;  								}  							}  							else  							{  								throw new SyntaxErrorException(token' "hexadecimal digit expected near '\\{0}{1}{2}'"' hexprefix' val' c);  							}  						}  						else if (val.Length > 0)  						{  							if (CharIsDigit(c))  							{  								val = val + c;  							}    							if (val.Length == 3 || !CharIsDigit(c))  							{  								int i = int.Parse(val' CultureInfo.InvariantCulture);    								if (i > 255)  									throw new SyntaxErrorException(token' "decimal escape too large near '\\{0}'"' val);    								sb.Append(ConvertUtf32ToChar(i));    								zmode = false;  								escape = false;    								if (!CharIsDigit(c))  									goto redo;  							}  						}  					}  				}  				else  				{  					if (c == '\\')  					{  						escape = true;  						hex = false;  						val = "";  					}  					else  					{  						if (!zmode || !char.IsWhiteSpace(c))  						{  							sb.Append(c);  							zmode = false;  						}  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The following statement contains a magic number: foreach (char c in str)  			{  			redo:  				if (escape)  				{  					if (val.Length == 0 && !hex && unicode_state == 0)  					{  						if (c == 'a') { sb.Append('\a'); escape = false; zmode = false; }  						else if (c == '\r') { }  // this makes \\r\n -> \\n  						else if (c == '\n') { sb.Append('\n'); escape = false; }  						else if (c == 'b') { sb.Append('\b'); escape = false; }  						else if (c == 'f') { sb.Append('\f'); escape = false; }  						else if (c == 'n') { sb.Append('\n'); escape = false; }  						else if (c == 'r') { sb.Append('\r'); escape = false; }  						else if (c == 't') { sb.Append('\t'); escape = false; }  						else if (c == 'v') { sb.Append('\v'); escape = false; }  						else if (c == '\\') { sb.Append('\\'); escape = false; zmode = false; }  						else if (c == '"') { sb.Append('\"'); escape = false; zmode = false; }  						else if (c == '\'') { sb.Append('\''); escape = false; zmode = false; }  						else if (c == '[') { sb.Append('['); escape = false; zmode = false; }  						else if (c == ']') { sb.Append(']'); escape = false; zmode = false; }  						else if (c == 'x') { hex = true; }  						else if (c == 'u') { unicode_state = 1; }  						else if (c == 'z') { zmode = true; escape = false; }  						else if (CharIsDigit(c)) { val = val + c; }  						else throw new SyntaxErrorException(token' "invalid escape sequence near '\\{0}'"' c);  					}  					else  					{  						if (unicode_state == 1)  						{  							if (c != '{')  								throw new SyntaxErrorException(token' "'{' expected near '\\u'");    							unicode_state = 2;  						}  						else if (unicode_state == 2)  						{  							if (c == '}')  							{  								int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  								sb.Append(ConvertUtf32ToChar(i));  								unicode_state = 0;  								val = string.Empty;  								escape = false;  							}  							else if (val.Length >= 8)  							{  								throw new SyntaxErrorException(token' "'}' missing' or unicode code point too large after '\\u'");  							}  							else  							{  								val += c;  							}  						}  						else if (hex)  						{  							if (CharIsHexDigit(c))  							{  								val += c;  								if (val.Length == 2)  								{  									int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  									sb.Append(ConvertUtf32ToChar(i));  									zmode = false;  									escape = false;  								}  							}  							else  							{  								throw new SyntaxErrorException(token' "hexadecimal digit expected near '\\{0}{1}{2}'"' hexprefix' val' c);  							}  						}  						else if (val.Length > 0)  						{  							if (CharIsDigit(c))  							{  								val = val + c;  							}    							if (val.Length == 3 || !CharIsDigit(c))  							{  								int i = int.Parse(val' CultureInfo.InvariantCulture);    								if (i > 255)  									throw new SyntaxErrorException(token' "decimal escape too large near '\\{0}'"' val);    								sb.Append(ConvertUtf32ToChar(i));    								zmode = false;  								escape = false;    								if (!CharIsDigit(c))  									goto redo;  							}  						}  					}  				}  				else  				{  					if (c == '\\')  					{  						escape = true;  						hex = false;  						val = "";  					}  					else  					{  						if (!zmode || !char.IsWhiteSpace(c))  						{  							sb.Append(c);  							zmode = false;  						}  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The following statement contains a magic number: foreach (char c in str)  			{  			redo:  				if (escape)  				{  					if (val.Length == 0 && !hex && unicode_state == 0)  					{  						if (c == 'a') { sb.Append('\a'); escape = false; zmode = false; }  						else if (c == '\r') { }  // this makes \\r\n -> \\n  						else if (c == '\n') { sb.Append('\n'); escape = false; }  						else if (c == 'b') { sb.Append('\b'); escape = false; }  						else if (c == 'f') { sb.Append('\f'); escape = false; }  						else if (c == 'n') { sb.Append('\n'); escape = false; }  						else if (c == 'r') { sb.Append('\r'); escape = false; }  						else if (c == 't') { sb.Append('\t'); escape = false; }  						else if (c == 'v') { sb.Append('\v'); escape = false; }  						else if (c == '\\') { sb.Append('\\'); escape = false; zmode = false; }  						else if (c == '"') { sb.Append('\"'); escape = false; zmode = false; }  						else if (c == '\'') { sb.Append('\''); escape = false; zmode = false; }  						else if (c == '[') { sb.Append('['); escape = false; zmode = false; }  						else if (c == ']') { sb.Append(']'); escape = false; zmode = false; }  						else if (c == 'x') { hex = true; }  						else if (c == 'u') { unicode_state = 1; }  						else if (c == 'z') { zmode = true; escape = false; }  						else if (CharIsDigit(c)) { val = val + c; }  						else throw new SyntaxErrorException(token' "invalid escape sequence near '\\{0}'"' c);  					}  					else  					{  						if (unicode_state == 1)  						{  							if (c != '{')  								throw new SyntaxErrorException(token' "'{' expected near '\\u'");    							unicode_state = 2;  						}  						else if (unicode_state == 2)  						{  							if (c == '}')  							{  								int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  								sb.Append(ConvertUtf32ToChar(i));  								unicode_state = 0;  								val = string.Empty;  								escape = false;  							}  							else if (val.Length >= 8)  							{  								throw new SyntaxErrorException(token' "'}' missing' or unicode code point too large after '\\u'");  							}  							else  							{  								val += c;  							}  						}  						else if (hex)  						{  							if (CharIsHexDigit(c))  							{  								val += c;  								if (val.Length == 2)  								{  									int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  									sb.Append(ConvertUtf32ToChar(i));  									zmode = false;  									escape = false;  								}  							}  							else  							{  								throw new SyntaxErrorException(token' "hexadecimal digit expected near '\\{0}{1}{2}'"' hexprefix' val' c);  							}  						}  						else if (val.Length > 0)  						{  							if (CharIsDigit(c))  							{  								val = val + c;  							}    							if (val.Length == 3 || !CharIsDigit(c))  							{  								int i = int.Parse(val' CultureInfo.InvariantCulture);    								if (i > 255)  									throw new SyntaxErrorException(token' "decimal escape too large near '\\{0}'"' val);    								sb.Append(ConvertUtf32ToChar(i));    								zmode = false;  								escape = false;    								if (!CharIsDigit(c))  									goto redo;  							}  						}  					}  				}  				else  				{  					if (c == '\\')  					{  						escape = true;  						hex = false;  						val = "";  					}  					else  					{  						if (!zmode || !char.IsWhiteSpace(c))  						{  							sb.Append(c);  							zmode = false;  						}  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The following statement contains a magic number: foreach (char c in str)  			{  			redo:  				if (escape)  				{  					if (val.Length == 0 && !hex && unicode_state == 0)  					{  						if (c == 'a') { sb.Append('\a'); escape = false; zmode = false; }  						else if (c == '\r') { }  // this makes \\r\n -> \\n  						else if (c == '\n') { sb.Append('\n'); escape = false; }  						else if (c == 'b') { sb.Append('\b'); escape = false; }  						else if (c == 'f') { sb.Append('\f'); escape = false; }  						else if (c == 'n') { sb.Append('\n'); escape = false; }  						else if (c == 'r') { sb.Append('\r'); escape = false; }  						else if (c == 't') { sb.Append('\t'); escape = false; }  						else if (c == 'v') { sb.Append('\v'); escape = false; }  						else if (c == '\\') { sb.Append('\\'); escape = false; zmode = false; }  						else if (c == '"') { sb.Append('\"'); escape = false; zmode = false; }  						else if (c == '\'') { sb.Append('\''); escape = false; zmode = false; }  						else if (c == '[') { sb.Append('['); escape = false; zmode = false; }  						else if (c == ']') { sb.Append(']'); escape = false; zmode = false; }  						else if (c == 'x') { hex = true; }  						else if (c == 'u') { unicode_state = 1; }  						else if (c == 'z') { zmode = true; escape = false; }  						else if (CharIsDigit(c)) { val = val + c; }  						else throw new SyntaxErrorException(token' "invalid escape sequence near '\\{0}'"' c);  					}  					else  					{  						if (unicode_state == 1)  						{  							if (c != '{')  								throw new SyntaxErrorException(token' "'{' expected near '\\u'");    							unicode_state = 2;  						}  						else if (unicode_state == 2)  						{  							if (c == '}')  							{  								int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  								sb.Append(ConvertUtf32ToChar(i));  								unicode_state = 0;  								val = string.Empty;  								escape = false;  							}  							else if (val.Length >= 8)  							{  								throw new SyntaxErrorException(token' "'}' missing' or unicode code point too large after '\\u'");  							}  							else  							{  								val += c;  							}  						}  						else if (hex)  						{  							if (CharIsHexDigit(c))  							{  								val += c;  								if (val.Length == 2)  								{  									int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  									sb.Append(ConvertUtf32ToChar(i));  									zmode = false;  									escape = false;  								}  							}  							else  							{  								throw new SyntaxErrorException(token' "hexadecimal digit expected near '\\{0}{1}{2}'"' hexprefix' val' c);  							}  						}  						else if (val.Length > 0)  						{  							if (CharIsDigit(c))  							{  								val = val + c;  							}    							if (val.Length == 3 || !CharIsDigit(c))  							{  								int i = int.Parse(val' CultureInfo.InvariantCulture);    								if (i > 255)  									throw new SyntaxErrorException(token' "decimal escape too large near '\\{0}'"' val);    								sb.Append(ConvertUtf32ToChar(i));    								zmode = false;  								escape = false;    								if (!CharIsDigit(c))  									goto redo;  							}  						}  					}  				}  				else  				{  					if (c == '\\')  					{  						escape = true;  						hex = false;  						val = "";  					}  					else  					{  						if (!zmode || !char.IsWhiteSpace(c))  						{  							sb.Append(c);  							zmode = false;  						}  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,LexerUtils,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\LexerUtils.cs,UnescapeLuaString,The following statement contains a magic number: foreach (char c in str)  			{  			redo:  				if (escape)  				{  					if (val.Length == 0 && !hex && unicode_state == 0)  					{  						if (c == 'a') { sb.Append('\a'); escape = false; zmode = false; }  						else if (c == '\r') { }  // this makes \\r\n -> \\n  						else if (c == '\n') { sb.Append('\n'); escape = false; }  						else if (c == 'b') { sb.Append('\b'); escape = false; }  						else if (c == 'f') { sb.Append('\f'); escape = false; }  						else if (c == 'n') { sb.Append('\n'); escape = false; }  						else if (c == 'r') { sb.Append('\r'); escape = false; }  						else if (c == 't') { sb.Append('\t'); escape = false; }  						else if (c == 'v') { sb.Append('\v'); escape = false; }  						else if (c == '\\') { sb.Append('\\'); escape = false; zmode = false; }  						else if (c == '"') { sb.Append('\"'); escape = false; zmode = false; }  						else if (c == '\'') { sb.Append('\''); escape = false; zmode = false; }  						else if (c == '[') { sb.Append('['); escape = false; zmode = false; }  						else if (c == ']') { sb.Append(']'); escape = false; zmode = false; }  						else if (c == 'x') { hex = true; }  						else if (c == 'u') { unicode_state = 1; }  						else if (c == 'z') { zmode = true; escape = false; }  						else if (CharIsDigit(c)) { val = val + c; }  						else throw new SyntaxErrorException(token' "invalid escape sequence near '\\{0}'"' c);  					}  					else  					{  						if (unicode_state == 1)  						{  							if (c != '{')  								throw new SyntaxErrorException(token' "'{' expected near '\\u'");    							unicode_state = 2;  						}  						else if (unicode_state == 2)  						{  							if (c == '}')  							{  								int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  								sb.Append(ConvertUtf32ToChar(i));  								unicode_state = 0;  								val = string.Empty;  								escape = false;  							}  							else if (val.Length >= 8)  							{  								throw new SyntaxErrorException(token' "'}' missing' or unicode code point too large after '\\u'");  							}  							else  							{  								val += c;  							}  						}  						else if (hex)  						{  							if (CharIsHexDigit(c))  							{  								val += c;  								if (val.Length == 2)  								{  									int i = int.Parse(val' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  									sb.Append(ConvertUtf32ToChar(i));  									zmode = false;  									escape = false;  								}  							}  							else  							{  								throw new SyntaxErrorException(token' "hexadecimal digit expected near '\\{0}{1}{2}'"' hexprefix' val' c);  							}  						}  						else if (val.Length > 0)  						{  							if (CharIsDigit(c))  							{  								val = val + c;  							}    							if (val.Length == 3 || !CharIsDigit(c))  							{  								int i = int.Parse(val' CultureInfo.InvariantCulture);    								if (i > 255)  									throw new SyntaxErrorException(token' "decimal escape too large near '\\{0}'"' val);    								sb.Append(ConvertUtf32ToChar(i));    								zmode = false;  								escape = false;    								if (!CharIsDigit(c))  									goto redo;  							}  						}  					}  				}  				else  				{  					if (c == '\\')  					{  						escape = true;  						hex = false;  						val = "";  					}  					else  					{  						if (!zmode || !char.IsWhiteSpace(c))  						{  							sb.Append(c);  							zmode = false;  						}  					}  				}  			}
Magic Number,MoonSharp.Interpreter.Tree,Expression,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Expression_.cs,SubExpr,The following statement contains a magic number: if (T.IsUnaryOperator())  			{  				lcontext.Lexer.Next();  				e = SubExpr(lcontext' false);    				// check for power operator -- it be damned forever and ever for being higher priority than unary ops  				Token unaryOp = T;  				T = lcontext.Lexer.Current;    				if (isPrimary && T.Type == TokenType.Op_Pwr)  				{  					List<Expression> powerChain = new List<Expression>();  					powerChain.Add(e);    					while (isPrimary && T.Type == TokenType.Op_Pwr)  					{  						lcontext.Lexer.Next();  						powerChain.Add(SubExpr(lcontext' false));  						T = lcontext.Lexer.Current;  					}    					e = powerChain[powerChain.Count - 1];    					for (int i = powerChain.Count - 2; i >= 0; i--)  					{  						e = BinaryOperatorExpression.CreatePowerExpression(powerChain[i]' e' lcontext);  					}  				}    				e = new UnaryOperatorExpression(lcontext' e' unaryOp);  			}  			else  			{  				e = SimpleExp(lcontext);  			}
Magic Number,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadLongString,The following statement contains a magic number: StringBuilder text = new StringBuilder(1024);
Magic Number,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadNumberToken,The following statement contains a magic number: StringBuilder text = new StringBuilder(32);
Magic Number,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadHashBang,The following statement contains a magic number: StringBuilder text = new StringBuilder(32);
Magic Number,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadComment,The following statement contains a magic number: StringBuilder text = new StringBuilder(32);
Magic Number,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadSimpleStringToken,The following statement contains a magic number: StringBuilder text = new StringBuilder(32);
Magic Number,MoonSharp.Interpreter.Tree,Lexer,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Lexer.cs,ReadNameToken,The following statement contains a magic number: StringBuilder name = new StringBuilder(32);
Magic Number,MoonSharp.Interpreter.Tree,Token,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Token.cs,ToString,The following statement contains a magic number: string tokenTypeString = (Type.ToString() + "                                                      ").Substring(0' 16);
Magic Number,MoonSharp.Interpreter.Tree,Token,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Tree\Lexer\Token.cs,ToString,The following statement contains a magic number: location = (location + "                                                      ").Substring(0' 10);
Duplicate Code,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,match,The method contains a code clone-set at the following line numbers (starting from the method definition): ((52' 82)' (99' 129))
Missing Default,MoonSharp.Interpreter.CoreLib.StringLib,KopiLua_StringLib,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\CoreLib\StringLib\KopiLua_StrLib.cs,add_value,The following switch statement is missing a default case: switch (LuaType(L' 3))  			{  				case LUA_TNUMBER:  				case LUA_TSTRING:  					{  						add_s(ms' b' s' e);  						return;  					}  				// case LUA_TUSERDATA: /// +++ does this make sense ??  				case LUA_TFUNCTION:  					{  						int n;  						LuaPushValue(L' 3);  						n = push_captures(ms' s' e);  						LuaCall(L' n' 1);  						break;  					}  				case LUA_TTABLE:  					{  						push_onecapture(ms' 0' s' e);  						LuaGetTable(L' 3);  						break;  					}  			}
Missing Default,MoonSharp.Interpreter.Execution.VM,Processor,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Execution\VM\Processor\Processor_BinaryDump.cs,ListenDebugger,The following switch statement is missing a default case: switch (m_Debug.DebuggerCurrentAction)  			{  				case DebuggerAction.ActionType.Run:  					if (m_Debug.LineBasedBreakPoints)  						m_Debug.LastHlRef = instr.SourceCodeRef;  					return;  				case DebuggerAction.ActionType.ByteCodeStepOver:  					if (m_Debug.DebuggerCurrentActionTarget != instructionPtr) return;  					break;  				case DebuggerAction.ActionType.ByteCodeStepOut:  				case DebuggerAction.ActionType.StepOut:  					if (m_ExecutionStack.Count >= m_Debug.ExStackDepthAtStep) return;  					break;  				case DebuggerAction.ActionType.StepIn:  					if ((m_ExecutionStack.Count >= m_Debug.ExStackDepthAtStep) && (instr.SourceCodeRef == null || instr.SourceCodeRef == m_Debug.LastHlRef)) return;  					break;  				case DebuggerAction.ActionType.StepOver:  					if (instr.SourceCodeRef == null || instr.SourceCodeRef == m_Debug.LastHlRef || m_ExecutionStack.Count > m_Debug.ExStackDepthAtStep) return;  					break;  			}
Missing Default,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,DynValueToObjectOfType,The following switch statement is missing a default case: switch (value.Type)  			{  				case DataType.Void:  					if (isOptional)  						return defaultValue;  					else if ((!Framework.Do.IsValueType(desiredType)) || (nullableType != null))  						return null;  					break;  				case DataType.Nil:  					if (Framework.Do.IsValueType(desiredType))  					{  						if (nullableType != null)  							return null;    						if (isOptional)  							return defaultValue;  					}  					else  					{  						return null;  					}  					break;  				case DataType.Boolean:  					if (desiredType == typeof(bool))  						return value.Boolean;  					if (stringSubType != StringConversions.StringSubtype.None)  						str = value.Boolean.ToString();  					break;  				case DataType.Number:  					if (Framework.Do.IsEnum(desiredType))  					{	// number to enum conv  						Type underType = Enum.GetUnderlyingType(desiredType);  						return NumericConversions.DoubleToType(underType' value.Number);  					}  					if (NumericConversions.NumericTypes.Contains(desiredType))  						return NumericConversions.DoubleToType(desiredType' value.Number);  					if (stringSubType != StringConversions.StringSubtype.None)  						str = value.Number.ToString();  					break;  				case DataType.String:  					if (stringSubType != StringConversions.StringSubtype.None)  						str = value.String;  					break;  				case DataType.Function:  					if (desiredType == typeof(Closure)) return value.Function;  					else if (desiredType == typeof(ScriptFunctionDelegate)) return value.Function.GetDelegate();  					break;  				case DataType.ClrFunction:  					if (desiredType == typeof(CallbackFunction)) return value.Callback;  					else if (desiredType == typeof(Func<ScriptExecutionContext' CallbackArguments' DynValue>)) return value.Callback.ClrCallback;  					break;  				case DataType.UserData:  					if (value.UserData.Object != null)  					{  						var udObj = value.UserData.Object;  						var udDesc = value.UserData.Descriptor;    						if (udDesc.IsTypeCompatible(desiredType' udObj))  							return udObj;    						if (stringSubType != StringConversions.StringSubtype.None)  							str = udDesc.AsString(udObj);  					}  					break;  				case DataType.Table:  					if (desiredType == typeof(Table) || Framework.Do.IsAssignableFrom(desiredType' typeof(Table)))  						return value.Table;  					else  					{  						object o = TableConversions.ConvertTableToType(value.Table' desiredType);  						if (o != null)  							return o;  					}  					break;  				case DataType.Tuple:  					break;  			}
Missing Default,MoonSharp.Interpreter.Interop.Converters,ScriptToClrConversions,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\Converters\ScriptToClrConversions.cs,DynValueToObjectOfTypeWeight,The following switch statement is missing a default case: switch (value.Type)  			{  				case DataType.Void:  					if (isOptional)  						return WEIGHT_VOID_WITH_DEFAULT;  					else if ((!Framework.Do.IsValueType(desiredType)) || (nullableType != null))  						return WEIGHT_VOID_WITHOUT_DEFAULT;  					break;  				case DataType.Nil:  					if (Framework.Do.IsValueType(desiredType))  					{  						if (nullableType != null)  							return WEIGHT_NIL_TO_NULLABLE;    						if (isOptional)  							return WEIGHT_NIL_WITH_DEFAULT;  					}  					else  					{  						return WEIGHT_NIL_TO_REFTYPE;  					}  					break;  				case DataType.Boolean:  					if (desiredType == typeof(bool))  						return WEIGHT_EXACT_MATCH;  					if (stringSubType != StringConversions.StringSubtype.None)  						return WEIGHT_BOOL_TO_STRING;  					break;  				case DataType.Number:  					if (Framework.Do.IsEnum(desiredType))  					{	// number to enum conv  						return WEIGHT_NUMBER_TO_ENUM;  					}  					if (NumericConversions.NumericTypes.Contains(desiredType))  						return GetNumericTypeWeight(desiredType);  					if (stringSubType != StringConversions.StringSubtype.None)  						return WEIGHT_NUMBER_TO_STRING;  					break;  				case DataType.String:  					if (stringSubType == StringConversions.StringSubtype.String)  						return WEIGHT_EXACT_MATCH;  					else if (stringSubType == StringConversions.StringSubtype.StringBuilder)  						return WEIGHT_STRING_TO_STRINGBUILDER;  					else if (stringSubType == StringConversions.StringSubtype.Char)  						return WEIGHT_STRING_TO_CHAR;  					break;  				case DataType.Function:  					if (desiredType == typeof(Closure)) return WEIGHT_EXACT_MATCH;  					else if (desiredType == typeof(ScriptFunctionDelegate)) return WEIGHT_EXACT_MATCH;  					break;  				case DataType.ClrFunction:  					if (desiredType == typeof(CallbackFunction)) return WEIGHT_EXACT_MATCH;  					else if (desiredType == typeof(Func<ScriptExecutionContext' CallbackArguments' DynValue>)) return WEIGHT_EXACT_MATCH;  					break;  				case DataType.UserData:  					if (value.UserData.Object != null)  					{  						var udObj = value.UserData.Object;  						var udDesc = value.UserData.Descriptor;    						if (udDesc.IsTypeCompatible(desiredType' udObj))  							return WEIGHT_EXACT_MATCH;    						if (stringSubType != StringConversions.StringSubtype.None)  							return WEIGHT_USERDATA_TO_STRING;  					}  					break;  				case DataType.Table:  					if (desiredType == typeof(Table) || Framework.Do.IsAssignableFrom(desiredType' typeof(Table)))  						return WEIGHT_EXACT_MATCH;  					else if (TableConversions.CanConvertTableToType(value.Table' desiredType))  						return WEIGHT_TABLE_CONVERSION;  					break;  				case DataType.Tuple:  					break;  			}
Missing Default,MoonSharp.Interpreter.Interop,ReflectionSpecialName,C:\repos\xanathar_moonsharp\src\MoonSharp.Interpreter\Interop\ReflectionSpecialNames.cs,ReflectionSpecialName,The following switch statement is missing a default case: switch (name)  			{  				case "op_Explicit":  					Type = ReflectionSpecialNameType.ExplicitCast;  					return;  				case "op_Implicit":  					Type = ReflectionSpecialNameType.ImplicitCast;  					return;  				case "set_Item":  					Type = ReflectionSpecialNameType.IndexSetter;  					return;  				case "get_Item":  					Type = ReflectionSpecialNameType.IndexGetter;  					return;  				case "op_Addition":  					Type = ReflectionSpecialNameType.OperatorAdd;  					Argument = "+";  					return;  				case "op_BitwiseAnd":  					Type = ReflectionSpecialNameType.OperatorAnd;  					Argument = "&";  					return;  				case "op_BitwiseOr":  					Type = ReflectionSpecialNameType.OperatorOr;  					Argument = "|";  					return;  				case "op_Decrement":  					Type = ReflectionSpecialNameType.OperatorDec;  					Argument = "--";  					return;  				case "op_Division":  					Type = ReflectionSpecialNameType.OperatorDiv;  					Argument = "/";  					return;  				case "op_Equality":  					Type = ReflectionSpecialNameType.OperatorEq;  					Argument = "==";  					return;  				case "op_ExclusiveOr":  					Type = ReflectionSpecialNameType.OperatorXor;  					Argument = "^";  					return;  				case "op_False":  					Type = ReflectionSpecialNameType.OperatorFalse;  					return;  				case "op_GreaterThan":  					Type = ReflectionSpecialNameType.OperatorGt;  					Argument = ">";  					return;  				case "op_GreaterThanOrEqual":  					Type = ReflectionSpecialNameType.OperatorGte;  					Argument = ">=";  					return;  				case "op_Increment":  					Type = ReflectionSpecialNameType.OperatorInc;  					Argument = "++";  					return;  				case "op_Inequality":  					Type = ReflectionSpecialNameType.OperatorNeq;  					Argument = "!=";  					return;  				case "op_LessThan":  					Type = ReflectionSpecialNameType.OperatorLt;  					Argument = "<";  					return;  				case "op_LessThanOrEqual":  					Type = ReflectionSpecialNameType.OperatorLte;  					Argument = "<=";  					return;  				case "op_LogicalNot":  					Type = ReflectionSpecialNameType.OperatorNot;  					Argument = "!";  					return;  				case "op_Modulus":  					Type = ReflectionSpecialNameType.OperatorMod;  					Argument = "%";  					return;  				case "op_Multiply":  					Type = ReflectionSpecialNameType.OperatorMul;  					Argument = "*";  					return;  				case "op_OnesComplement":  					Type = ReflectionSpecialNameType.OperatorCompl;  					Argument = "~";  					return;  				case "op_Subtraction":  					Type = ReflectionSpecialNameType.OperatorSub;  					Argument = "-";  					return;  				case "op_True":  					Type = ReflectionSpecialNameType.OperatorTrue;  					return;  				case "op_UnaryNegation":  					Type = ReflectionSpecialNameType.OperatorNeg;  					Argument = "-";  					return;  				case "op_UnaryPlus":  					Type = ReflectionSpecialNameType.OperatorUnaryPlus;  					Argument = "+";  					return;  			}
