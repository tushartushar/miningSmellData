Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The method has 100 lines of code.
Long Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The method has 122 lines of code.
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,Cyclomatic complexity of the method is 14
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseFile,Cyclomatic complexity of the method is 10
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectFrame,Cyclomatic complexity of the method is 10
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectMesh,Cyclomatic complexity of the method is 17
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectMeshMaterialList,Cyclomatic complexity of the method is 14
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,Cyclomatic complexity of the method is 16
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseUnknownDataObject,Cyclomatic complexity of the method is 8
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,Cyclomatic complexity of the method is 53
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextTokenAsString,Cyclomatic complexity of the method is 8
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,Cyclomatic complexity of the method is 9
Complex Method,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,Cyclomatic complexity of the method is 11
Long Identifier,SharpXFileParser,Mesh,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileHelper.cs,Mesh,The length of the parameter AI_MAX_NUMBER_OF_TEXTURECOORDS is 30.
Long Statement,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The length of the statement  "			QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ())); " is 122.
Long Statement,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The length of the statement  "	if (Encoding.Default.GetString (buffer' p' 9) == "-1.#IND00" || Encoding.Default.GetString (buffer' p' 8) == "1.#IND00") { " is 122.
Complex Conditional,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The conditional expression  "buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == '''"  is complex.
Complex Conditional,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The conditional expression  "char.IsDigit ((char)c) || c == '+' || c == '.' || c == '-' || c == 'e' || c == 'E'"  is complex.
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (0' 4) != "xof ")  	throw new Exception ("Header mismatch' file is not an XFile.");  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: majorVersion = uint.Parse (header.Substring (4' 2));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: majorVersion = uint.Parse (header.Substring (4' 2));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: minorVersion = uint.Parse (header.Substring (6' 2));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: minorVersion = uint.Parse (header.Substring (6' 2));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "txt ") {  	isBinaryFormat = false;  }  // bin - Binary format  else if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bin ") {  	isBinaryFormat = true;  }  // tzip - Inflate compressed text format  else if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "tzip") {  	isBinaryFormat = false;  	compressed = true;  }  // bzip - Inflate compressed binary format  else if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (header.Substring (8' 4) == "bzip") {  	isBinaryFormat = true;  	compressed = true;  }  else  	ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: ThrowException (string.Format ("Unsupported xfile format '{0}'"' header.Substring (8' 4)));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: binaryFloatSize = uint.Parse (header.Substring (12' 4));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: binaryFloatSize = uint.Parse (header.Substring (12' 4));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (binaryFloatSize != 32 && binaryFloatSize != 64)  	ThrowException (string.Format ("Unknown float size {0} specified in xfile header."' binaryFloatSize));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (binaryFloatSize != 32 && binaryFloatSize != 64)  	ThrowException (string.Format ("Unknown float size {0} specified in xfile header."' binaryFloatSize));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: binaryFloatSize /= 8;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: p += 16;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (compressed) {  	//throw (new Exception("Assimp was built without compressed X support"));  	MemoryStream stream = new MemoryStream (buffer);  	stream.Position += 16;  	stream.Position += 6;  	long p = stream.Position;  	long p1 = stream.Position;  	uint estOut = 0;  	while (p1 + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (ofs >= MSZIP_BLOCK) {  			throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  		}  		ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  		p1 += 2;  		if (magic != MSZIP_MAGIC) {  			throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  		}  		p1 += ofs;  		estOut += MSZIP_BLOCK;  	}  	uncompressed = new byte[estOut + 1];  	int uncompressedEnd = 0;  	while (p + 3 < end) {  		ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  		p += 4;  		if (p + ofs > end + 2) {  			throw (new Exception ("X: Unexpected EOF in compressed chunk"));  		}  		stream.Position = p;  		DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  		int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  		uncompressedEnd += readLnegth;  		p += ofs;  	}  	this.buffer = uncompressed;  	this.end = uncompressedEnd;  	this.p = 0;  }  else {  	// start reading here  	ReadUntilEndOfLine ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: stream.Position += 16;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: stream.Position += 6;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: while (p1 + 3 < end) {  	ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  	p1 += 2;  	if (ofs >= MSZIP_BLOCK) {  		throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  	}  	ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  	p1 += 2;  	if (magic != MSZIP_MAGIC) {  		throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  	}  	p1 += ofs;  	estOut += MSZIP_BLOCK;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: while (p1 + 3 < end) {  	ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  	p1 += 2;  	if (ofs >= MSZIP_BLOCK) {  		throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  	}  	ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  	p1 += 2;  	if (magic != MSZIP_MAGIC) {  		throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  	}  	p1 += ofs;  	estOut += MSZIP_BLOCK;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: while (p1 + 3 < end) {  	ushort ofs = BitConverter.ToUInt16 (buffer' (int)p1);  	p1 += 2;  	if (ofs >= MSZIP_BLOCK) {  		throw (new Exception ("X: Invalid offset to next MSZIP compressed block"));  	}  	ushort magic = BitConverter.ToUInt16 (buffer' (int)p1);  	p1 += 2;  	if (magic != MSZIP_MAGIC) {  		throw (new Exception ("X: Unsupported compressed format' expected MSZIP header"));  	}  	p1 += ofs;  	estOut += MSZIP_BLOCK;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: p1 += 2;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: p1 += 2;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: while (p + 3 < end) {  	ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  	p += 4;  	if (p + ofs > end + 2) {  		throw (new Exception ("X: Unexpected EOF in compressed chunk"));  	}  	stream.Position = p;  	DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  	int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  	uncompressedEnd += readLnegth;  	p += ofs;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: while (p + 3 < end) {  	ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  	p += 4;  	if (p + ofs > end + 2) {  		throw (new Exception ("X: Unexpected EOF in compressed chunk"));  	}  	stream.Position = p;  	DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  	int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  	uncompressedEnd += readLnegth;  	p += ofs;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: while (p + 3 < end) {  	ushort ofs = BitConverter.ToUInt16 (buffer' (int)p);  	p += 4;  	if (p + ofs > end + 2) {  		throw (new Exception ("X: Unexpected EOF in compressed chunk"));  	}  	stream.Position = p;  	DeflateStream uncomp = new DeflateStream (stream' CompressionMode.Decompress);  	int readLnegth = uncomp.Read (uncompressed' 0' (int)MSZIP_BLOCK);  	uncompressedEnd += readLnegth;  	p += ofs;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: p += 4;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,XFileParser,The following statement contains a magic number: if (p + ofs > end + 2) {  	throw (new Exception ("X: Unexpected EOF in compressed chunk"));  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectMesh,The following statement contains a magic number: for (uint a = 0; a < numPosFaces; a++) {  	uint numIndices = ReadInt ();  	if (numIndices < 3)  		ThrowException (string.Format ("Invalid index count {0} for face {1}."' numIndices' a));  	// read indices  	Face face = new Face ();  	face.Indices = new List<uint> ();  	for (uint b = 0; b < numIndices; b++)  		face.Indices.Add (ReadInt ());  	mesh.PosFaces.Add (face);  	TestForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectMesh,The following statement contains a magic number: if (numIndices < 3)  	ThrowException (string.Format ("Invalid index count {0} for face {1}."' numIndices' a));  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: for (uint a = 0; a < numKeys; a++) {  	// read time  	uint time = ReadInt ();  	// read keys  	switch (keyType) {  	case 0: {  		if (ReadInt () != 4)  			ThrowException ("Invalid number of arguments for quaternion key in animation");  		QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  		animBone.RotKeys.Add (key);  		CheckForSemicolon ();  		break;  	}  	case 1:  	// scale vector  	case 2:// position vector  	 {  		// read count  		if (ReadInt () != 3) {  			ThrowException ("Invalid number of arguments for vector key in animation");  		}  		VectorKey key = new VectorKey ((double)time' ReadVector3 ());  		if (keyType == 2) {  			animBone.PosKeys.Add (key);  		}  		else {  			animBone.ScaleKeys.Add (key);  		}  		break;  	}  	case 3:  	case 4: {  		// read count  		if (ReadInt () != 16)  			ThrowException ("Invalid number of arguments for matrix key in animation");  		// read matrix  		double key = (double)time;  		Matrix4x4 value = new Matrix4x4 ();  		value.M11 = ReadFloat ();  		value.M21 = ReadFloat ();  		value.M31 = ReadFloat ();  		value.M41 = ReadFloat ();  		value.M12 = ReadFloat ();  		value.M22 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M42 = ReadFloat ();  		value.M13 = ReadFloat ();  		value.M23 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M43 = ReadFloat ();  		value.M14 = ReadFloat ();  		value.M24 = ReadFloat ();  		value.M33 = ReadFloat ();  		value.M44 = ReadFloat ();  		animBone.TrafoKeys.Add (new MatrixKey (key' value));  		CheckForSemicolon ();  		break;  	}  	default:  		ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  		break;  	}  	CheckForSeparator ();  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: switch (keyType) {  case 0: {  	if (ReadInt () != 4)  		ThrowException ("Invalid number of arguments for quaternion key in animation");  	QuatKey key = new QuatKey ((double)time' new SharpDX.Quaternion (ReadFloat ()' ReadFloat ()' ReadFloat ()' ReadFloat ()));  	animBone.RotKeys.Add (key);  	CheckForSemicolon ();  	break;  }  case 1:  // scale vector  case 2:// position vector   {  	// read count  	if (ReadInt () != 3) {  		ThrowException ("Invalid number of arguments for vector key in animation");  	}  	VectorKey key = new VectorKey ((double)time' ReadVector3 ());  	if (keyType == 2) {  		animBone.PosKeys.Add (key);  	}  	else {  		animBone.ScaleKeys.Add (key);  	}  	break;  }  case 3:  case 4: {  	// read count  	if (ReadInt () != 16)  		ThrowException ("Invalid number of arguments for matrix key in animation");  	// read matrix  	double key = (double)time;  	Matrix4x4 value = new Matrix4x4 ();  	value.M11 = ReadFloat ();  	value.M21 = ReadFloat ();  	value.M31 = ReadFloat ();  	value.M41 = ReadFloat ();  	value.M12 = ReadFloat ();  	value.M22 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M42 = ReadFloat ();  	value.M13 = ReadFloat ();  	value.M23 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M43 = ReadFloat ();  	value.M14 = ReadFloat ();  	value.M24 = ReadFloat ();  	value.M33 = ReadFloat ();  	value.M44 = ReadFloat ();  	animBone.TrafoKeys.Add (new MatrixKey (key' value));  	CheckForSemicolon ();  	break;  }  default:  	ThrowException (string.Format ("Unknown key type {0} in animation."' keyType));  	break;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: if (ReadInt () != 4)  	ThrowException ("Invalid number of arguments for quaternion key in animation");  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: if (ReadInt () != 3) {  	ThrowException ("Invalid number of arguments for vector key in animation");  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: if (keyType == 2) {  	animBone.PosKeys.Add (key);  }  else {  	animBone.ScaleKeys.Add (key);  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ParseDataObjectAnimationKey,The following statement contains a magic number: if (ReadInt () != 16)  	ThrowException ("Invalid number of arguments for matrix key in animation");  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (isBinaryFormat) {  	// in binary mode it will only return NAME and STRING token  	// and (correctly) skip over other tokens.  	if (end - p < 2)  		return s;  	uint tok = ReadBinWord ();  	uint len;  	// standalone tokens  	switch (tok) {  	case 1:  		// name token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += (int)len;  		return s;  	case 2:  		// string token  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		if (end - p < (int)len)  			return s;  		s = Encoding.Default.GetString (buffer' p' (int)len);  		p += ((int)len + 2);  		return s;  	case 3:  		// integer token  		p += 4;  		return "<integer>";  	case 5:  		// GUID token  		p += 16;  		return "<guid>";  	case 6:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += ((int)len * 4);  		return "<int_list>";  	case 7:  		if (end - p < 4)  			return s;  		len = ReadBinDWord ();  		p += (int)(len * binaryFloatSize);  		return "<flt_list>";  	case 0x0a:  		return "{";  	case 0x0b:  		return "}";  	case 0x0c:  		return "(";  	case 0x0d:  		return ")";  	case 0x0e:  		return "[";  	case 0x0f:  		return "]";  	case 0x10:  		return "<";  	case 0x11:  		return ">";  	case 0x12:  		return ".";  	case 0x13:  		return "'";  	case 0x14:  		return ";";  	case 0x1f:  		return "template";  	case 0x28:  		return "WORD";  	case 0x29:  		return "DWORD";  	case 0x2a:  		return "FLOAT";  	case 0x2b:  		return "DOUBLE";  	case 0x2c:  		return "CHAR";  	case 0x2d:  		return "UCHAR";  	case 0x2e:  		return "SWORD";  	case 0x2f:  		return "SDWORD";  	case 0x30:  		return "void";  	case 0x31:  		return "string";  	case 0x32:  		return "unicode";  	case 0x33:  		return "cstring";  	case 0x34:  		return "array";  	}  }  // process text-formatted file  else {  	FindNextNoneWhiteSpace ();  	if (p >= end)  		return s;  	while ((p < end) && !char.IsSeparator ((char)buffer [p])) {  		// either keep token delimiters when already holding a token' or return if first valid char  		if (buffer [p] == ';' || buffer [p] == '}' || buffer [p] == '{' || buffer [p] == ''') {  			if (s.Length == 0)  				s += (char)buffer [p++];  			break;  			// stop for delimiter  		}  		s += (char)buffer [p++];  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (end - p < 2)  	return s;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (end - p < 4)  	return s;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (end - p < 4)  	return s;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: p += ((int)len + 2);  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: p += 4;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: p += 16;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (end - p < 4)  	return s;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: p += ((int)len * 4);  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following statement contains a magic number: if (end - p < 4)  	return s;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextTokenAsString,The following statement contains a magic number: p += 2;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadBinWord,The following statement contains a magic number: Debug.Assert (end - p >= 2);  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadBinWord,The following statement contains a magic number: p += 2;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadBinDWord,The following statement contains a magic number: Debug.Assert (end - p >= 4);  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadBinDWord,The following statement contains a magic number: p += 4;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		// 0x06 or 0x03  		if (tmp == 0x06 && end - p >= 4)  			// array of ints follows  			binaryNumCount = ReadBinDWord ();  		else  			// single int follows  			binaryNumCount = 1;  	}  	--binaryNumCount;  	if (end - p >= 4) {  		return ReadBinDWord ();  	}  	else {  		p = end;  		return 0;  	}  }  else {  	FindNextNoneWhiteSpace ();  	// TODO: consider using strtol10 instead???  	// check preceeding minus sign  	bool isNegative = false;  	if (buffer [p] == '-') {  		isNegative = true;  		p++;  	}  	// at least one digit expected  	if (!char.IsDigit ((char)buffer [p]))  		ThrowException ("Number expected.");  	// read digits  	uint number = 0;  	while (p < end) {  		if (!char.IsDigit ((char)buffer [p]))  			break;  		number = number * 10 + ((uint)buffer [p] - 48);  		p++;  	}  	CheckForSeparator ();  	return isNegative ? (uint)(-1 * (int)number) : number;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		// 0x06 or 0x03  		if (tmp == 0x06 && end - p >= 4)  			// array of ints follows  			binaryNumCount = ReadBinDWord ();  		else  			// single int follows  			binaryNumCount = 1;  	}  	--binaryNumCount;  	if (end - p >= 4) {  		return ReadBinDWord ();  	}  	else {  		p = end;  		return 0;  	}  }  else {  	FindNextNoneWhiteSpace ();  	// TODO: consider using strtol10 instead???  	// check preceeding minus sign  	bool isNegative = false;  	if (buffer [p] == '-') {  		isNegative = true;  		p++;  	}  	// at least one digit expected  	if (!char.IsDigit ((char)buffer [p]))  		ThrowException ("Number expected.");  	// read digits  	uint number = 0;  	while (p < end) {  		if (!char.IsDigit ((char)buffer [p]))  			break;  		number = number * 10 + ((uint)buffer [p] - 48);  		p++;  	}  	CheckForSeparator ();  	return isNegative ? (uint)(-1 * (int)number) : number;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		// 0x06 or 0x03  		if (tmp == 0x06 && end - p >= 4)  			// array of ints follows  			binaryNumCount = ReadBinDWord ();  		else  			// single int follows  			binaryNumCount = 1;  	}  	--binaryNumCount;  	if (end - p >= 4) {  		return ReadBinDWord ();  	}  	else {  		p = end;  		return 0;  	}  }  else {  	FindNextNoneWhiteSpace ();  	// TODO: consider using strtol10 instead???  	// check preceeding minus sign  	bool isNegative = false;  	if (buffer [p] == '-') {  		isNegative = true;  		p++;  	}  	// at least one digit expected  	if (!char.IsDigit ((char)buffer [p]))  		ThrowException ("Number expected.");  	// read digits  	uint number = 0;  	while (p < end) {  		if (!char.IsDigit ((char)buffer [p]))  			break;  		number = number * 10 + ((uint)buffer [p] - 48);  		p++;  	}  	CheckForSeparator ();  	return isNegative ? (uint)(-1 * (int)number) : number;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		// 0x06 or 0x03  		if (tmp == 0x06 && end - p >= 4)  			// array of ints follows  			binaryNumCount = ReadBinDWord ();  		else  			// single int follows  			binaryNumCount = 1;  	}  	--binaryNumCount;  	if (end - p >= 4) {  		return ReadBinDWord ();  	}  	else {  		p = end;  		return 0;  	}  }  else {  	FindNextNoneWhiteSpace ();  	// TODO: consider using strtol10 instead???  	// check preceeding minus sign  	bool isNegative = false;  	if (buffer [p] == '-') {  		isNegative = true;  		p++;  	}  	// at least one digit expected  	if (!char.IsDigit ((char)buffer [p]))  		ThrowException ("Number expected.");  	// read digits  	uint number = 0;  	while (p < end) {  		if (!char.IsDigit ((char)buffer [p]))  			break;  		number = number * 10 + ((uint)buffer [p] - 48);  		p++;  	}  	CheckForSeparator ();  	return isNegative ? (uint)(-1 * (int)number) : number;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		// 0x06 or 0x03  		if (tmp == 0x06 && end - p >= 4)  			// array of ints follows  			binaryNumCount = ReadBinDWord ();  		else  			// single int follows  			binaryNumCount = 1;  	}  	--binaryNumCount;  	if (end - p >= 4) {  		return ReadBinDWord ();  	}  	else {  		p = end;  		return 0;  	}  }  else {  	FindNextNoneWhiteSpace ();  	// TODO: consider using strtol10 instead???  	// check preceeding minus sign  	bool isNegative = false;  	if (buffer [p] == '-') {  		isNegative = true;  		p++;  	}  	// at least one digit expected  	if (!char.IsDigit ((char)buffer [p]))  		ThrowException ("Number expected.");  	// read digits  	uint number = 0;  	while (p < end) {  		if (!char.IsDigit ((char)buffer [p]))  			break;  		number = number * 10 + ((uint)buffer [p] - 48);  		p++;  	}  	CheckForSeparator ();  	return isNegative ? (uint)(-1 * (int)number) : number;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (binaryNumCount == 0 && end - p >= 2) {  	ushort tmp = ReadBinWord ();  	// 0x06 or 0x03  	if (tmp == 0x06 && end - p >= 4)  		// array of ints follows  		binaryNumCount = ReadBinDWord ();  	else  		// single int follows  		binaryNumCount = 1;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (binaryNumCount == 0 && end - p >= 2) {  	ushort tmp = ReadBinWord ();  	// 0x06 or 0x03  	if (tmp == 0x06 && end - p >= 4)  		// array of ints follows  		binaryNumCount = ReadBinDWord ();  	else  		// single int follows  		binaryNumCount = 1;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (tmp == 0x06 && end - p >= 4)  	// array of ints follows  	binaryNumCount = ReadBinDWord ();  else  	// single int follows  	binaryNumCount = 1;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: if (end - p >= 4) {  	return ReadBinDWord ();  }  else {  	p = end;  	return 0;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: while (p < end) {  	if (!char.IsDigit ((char)buffer [p]))  		break;  	number = number * 10 + ((uint)buffer [p] - 48);  	p++;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: while (p < end) {  	if (!char.IsDigit ((char)buffer [p]))  		break;  	number = number * 10 + ((uint)buffer [p] - 48);  	p++;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: number = number * 10 + ((uint)buffer [p] - 48);  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadInt,The following statement contains a magic number: number = number * 10 + ((uint)buffer [p] - 48);  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (isBinaryFormat) {  	if (binaryNumCount == 0 && end - p >= 2) {  		ushort tmp = ReadBinWord ();  		if (tmp == 0x07 && end - p >= 4) {  			binaryNumCount = ReadBinDWord ();  		}  		else {  			binaryNumCount = 1;  		}  	}  	--binaryNumCount;  	if (binaryFloatSize == 8) {  		if (end - p >= 8) {  			float result = (float)BitConverter.ToDouble (buffer' p);  			p += 8;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  	else {  		if (end - p >= 4) {  			float result = BitConverter.ToSingle (buffer' p);  			p += 4;  			return result;  		}  		else {  			p = end;  			return 0;  		}  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryNumCount == 0 && end - p >= 2) {  	ushort tmp = ReadBinWord ();  	if (tmp == 0x07 && end - p >= 4) {  		binaryNumCount = ReadBinDWord ();  	}  	else {  		binaryNumCount = 1;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryNumCount == 0 && end - p >= 2) {  	ushort tmp = ReadBinWord ();  	if (tmp == 0x07 && end - p >= 4) {  		binaryNumCount = ReadBinDWord ();  	}  	else {  		binaryNumCount = 1;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (tmp == 0x07 && end - p >= 4) {  	binaryNumCount = ReadBinDWord ();  }  else {  	binaryNumCount = 1;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryFloatSize == 8) {  	if (end - p >= 8) {  		float result = (float)BitConverter.ToDouble (buffer' p);  		p += 8;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  else {  	if (end - p >= 4) {  		float result = BitConverter.ToSingle (buffer' p);  		p += 4;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryFloatSize == 8) {  	if (end - p >= 8) {  		float result = (float)BitConverter.ToDouble (buffer' p);  		p += 8;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  else {  	if (end - p >= 4) {  		float result = BitConverter.ToSingle (buffer' p);  		p += 4;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryFloatSize == 8) {  	if (end - p >= 8) {  		float result = (float)BitConverter.ToDouble (buffer' p);  		p += 8;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  else {  	if (end - p >= 4) {  		float result = BitConverter.ToSingle (buffer' p);  		p += 4;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryFloatSize == 8) {  	if (end - p >= 8) {  		float result = (float)BitConverter.ToDouble (buffer' p);  		p += 8;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  else {  	if (end - p >= 4) {  		float result = BitConverter.ToSingle (buffer' p);  		p += 4;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (binaryFloatSize == 8) {  	if (end - p >= 8) {  		float result = (float)BitConverter.ToDouble (buffer' p);  		p += 8;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  else {  	if (end - p >= 4) {  		float result = BitConverter.ToSingle (buffer' p);  		p += 4;  		return result;  	}  	else {  		p = end;  		return 0;  	}  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (end - p >= 8) {  	float result = (float)BitConverter.ToDouble (buffer' p);  	p += 8;  	return result;  }  else {  	p = end;  	return 0;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (end - p >= 8) {  	float result = (float)BitConverter.ToDouble (buffer' p);  	p += 8;  	return result;  }  else {  	p = end;  	return 0;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: p += 8;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (end - p >= 4) {  	float result = BitConverter.ToSingle (buffer' p);  	p += 4;  	return result;  }  else {  	p = end;  	return 0;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (end - p >= 4) {  	float result = BitConverter.ToSingle (buffer' p);  	p += 4;  	return result;  }  else {  	p = end;  	return 0;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: p += 4;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 9) == "-1.#IND00" || Encoding.Default.GetString (buffer' p' 8) == "1.#IND00") {  	p += 9;  	CheckForSeparator ();  	return 0.0f;  }  else if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 9) == "-1.#IND00" || Encoding.Default.GetString (buffer' p' 8) == "1.#IND00") {  	p += 9;  	CheckForSeparator ();  	return 0.0f;  }  else if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 9) == "-1.#IND00" || Encoding.Default.GetString (buffer' p' 8) == "1.#IND00") {  	p += 9;  	CheckForSeparator ();  	return 0.0f;  }  else if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 9) == "-1.#IND00" || Encoding.Default.GetString (buffer' p' 8) == "1.#IND00") {  	p += 9;  	CheckForSeparator ();  	return 0.0f;  }  else if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 9) == "-1.#IND00" || Encoding.Default.GetString (buffer' p' 8) == "1.#IND00") {  	p += 9;  	CheckForSeparator ();  	return 0.0f;  }  else if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: p += 9;  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: if (Encoding.Default.GetString (buffer' p' 8) == "1.#QNAN0") {  	p += 8;  	CheckForSeparator ();  	return 0.0f;  }  
Magic Number,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,ReadFloat,The following statement contains a magic number: p += 8;  
Missing Default,SharpXFileParser,XFileParser,C:\repos\oguna_SharpXFileParser\SharpXFileParser\XFileParser.cs,GetNextToken,The following switch statement is missing a default case: switch (tok) {  case 1:  	// name token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += (int)len;  	return s;  case 2:  	// string token  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	if (end - p < (int)len)  		return s;  	s = Encoding.Default.GetString (buffer' p' (int)len);  	p += ((int)len + 2);  	return s;  case 3:  	// integer token  	p += 4;  	return "<integer>";  case 5:  	// GUID token  	p += 16;  	return "<guid>";  case 6:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += ((int)len * 4);  	return "<int_list>";  case 7:  	if (end - p < 4)  		return s;  	len = ReadBinDWord ();  	p += (int)(len * binaryFloatSize);  	return "<flt_list>";  case 0x0a:  	return "{";  case 0x0b:  	return "}";  case 0x0c:  	return "(";  case 0x0d:  	return ")";  case 0x0e:  	return "[";  case 0x0f:  	return "]";  case 0x10:  	return "<";  case 0x11:  	return ">";  case 0x12:  	return ".";  case 0x13:  	return "'";  case 0x14:  	return ";";  case 0x1f:  	return "template";  case 0x28:  	return "WORD";  case 0x29:  	return "DWORD";  case 0x2a:  	return "FLOAT";  case 0x2b:  	return "DOUBLE";  case 0x2c:  	return "CHAR";  case 0x2d:  	return "UCHAR";  case 0x2e:  	return "SWORD";  case 0x2f:  	return "SDWORD";  case 0x30:  	return "void";  case 0x31:  	return "string";  case 0x32:  	return "unicode";  case 0x33:  	return "cstring";  case 0x34:  	return "array";  }  
