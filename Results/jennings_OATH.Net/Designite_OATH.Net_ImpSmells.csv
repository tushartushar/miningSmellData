Implementation smell,Namespace,Class,File,Method,Description
Long Statement,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The length of the statement  "                    result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3); " is 129.
Long Statement,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The length of the statement  "                    result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4); " is 129.
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: var fullSegments = data.Length / 5;
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: var finalSegmentLength = data.Length % 5;
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: for (int i = 0; i < segments; i++)              {                  var segment = data.Skip(i * 5).Take(5).ToArray();                  result = String.Concat(result' Base32.ConvertSegmentToBase32(segment));              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: for (int i = 0; i < segments; i++)              {                  var segment = data.Skip(i * 5).Take(5).ToArray();                  result = String.Concat(result' Base32.ConvertSegmentToBase32(segment));              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: var fullSegments = base32.Length / 8;
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: var finalSegmentLength = base32.Length % 8;
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: for (int i = 0; i < segments; i++)              {                  var segment = base32.Skip(i * 8).Take(8).ToArray();                  var slice = Base32.ConvertSegmentToBinary(segment);                  result = result.Concat(slice);              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: for (int i = 0; i < segments; i++)              {                  var segment = base32.Skip(i * 8).Take(8).ToArray();                  var slice = Base32.ConvertSegmentToBinary(segment);                  result = result.Concat(slice);              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: if (segment.Length > 8)              {                  throw new ArgumentException("Segment must be no more than 8 characters in length.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: byte[] result = new byte[5];
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: if (segment.Length > 5)              {                  throw new ArgumentException("Segment must be five bytes or fewer.");              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: int bitsRemaining = 5;
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: foreach (var b in segment)              {                  // Accumulate the bits remaining from the previous byte' if any                  int bottomBitsInThisByte = 8 - bitsRemaining;                  accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];                    // Add the accumulated character to the result string                  result = result + Alphabet[accumulator];                    if (bottomBitsInThisByte >= 5)                  {                      bottomBitsInThisByte -= 5;                        // Set the accumulator to the next 5 bits in this byte                      accumulator = (b >> bottomBitsInThisByte) & masks[5];                        // Add the accumulated character to the result string                      result = result + Alphabet[accumulator];                  }                    // Decide how many more bits we need to accumulate from the next byte                  bitsRemaining = (5 - bottomBitsInThisByte) % 5;                    // Set the accumulator to the remaining bits in this byte                  accumulator = (b & masks[bottomBitsInThisByte]) << bitsRemaining;              }
Magic Number,OathNet,Base32,C:\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: result = result.PadRight(8' Padding);
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  Array.Resize(ref text' 8);      // text = { 04' 03' 02' 01' 00' 00' 00' 00 }                  Array.Reverse(text);            // text = { 00' 00' 00' 00' 01' 02' 03' 04 }              }              else              {                  Array.Reverse(text);            // text = { 04' 03' 02' 01 }                  Array.Resize(ref text' 8);      // text = { 04' 03' 02' 01' 00' 00' 00' 00 }                  Array.Reverse(text);            // text = { 00' 00' 00' 00' 01' 02' 03' 04 }              }
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  Array.Resize(ref text' 8);      // text = { 04' 03' 02' 01' 00' 00' 00' 00 }                  Array.Reverse(text);            // text = { 00' 00' 00' 00' 01' 02' 03' 04 }              }              else              {                  Array.Reverse(text);            // text = { 04' 03' 02' 01 }                  Array.Resize(ref text' 8);      // text = { 04' 03' 02' 01' 00' 00' 00' 00 }                  Array.Reverse(text);            // text = { 00' 00' 00' 00' 01' 02' 03' 04 }              }
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,TimeBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: var unixEpoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,OathNet,TimeBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: var steps = (int)(span.TotalSeconds / 30);
Magic Number,OathNet,TimeBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,ValidateOtp,The following statement contains a magic number: var unixEpoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,OathNet,TimeBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,ValidateOtp,The following statement contains a magic number: var steps = (int)(span.TotalSeconds / 30);
Magic Number,OathNet,TimeBasedOtpGenerator,C:\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,ValidateOtp,The following statement contains a magic number: var interval = (int)(Math.Abs(validityPeriod.TotalSeconds) / 30);
