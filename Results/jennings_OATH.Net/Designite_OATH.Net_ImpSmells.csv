Implementation smell,Namespace,Class,File,Method,Description
Complex Method,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,Cyclomatic complexity of the method is 12
Long Statement,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The length of the statement  "                    result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3); " is 129.
Long Statement,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The length of the statement  "                    result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4); " is 129.
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: var fullSegments = data.Length / 5;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: var finalSegmentLength = data.Length % 5;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: var segment = data.Skip(i * 5).Take(5).ToArray();
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBase32,The following statement contains a magic number: var segment = data.Skip(i * 5).Take(5).ToArray();
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: var fullSegments = base32.Length / 8;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: var finalSegmentLength = base32.Length % 8;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: var segment = base32.Skip(i * 8).Take(8).ToArray();
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ToBinary,The following statement contains a magic number: var segment = base32.Skip(i * 8).Take(8).ToArray();
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: segment.Length > 8
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: byte[] result = new byte[5];
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBinary,The following statement contains a magic number: switch (length)              {                  case 8:                      resized = true;                      result[4] = (byte)(Array.IndexOf(Alphabet' s[6]) << 5 | Array.IndexOf(Alphabet' s[7]));                      goto case 7;                  case 7:                      if (!resized)                      {                          Array.Resize(ref result' 4);                          resized = true;                      }                        result[3] = (byte)(Array.IndexOf(Alphabet' s[4]) << 7 | Array.IndexOf(Alphabet' s[5]) << 2 | Array.IndexOf(Alphabet' s[6]) >> 3);                      goto case 5;                  case 5:                      if (!resized)                      {                          Array.Resize(ref result' 3);                          resized = true;                      }                        result[2] = (byte)(Array.IndexOf(Alphabet' s[3]) << 4 | Array.IndexOf(Alphabet' s[4]) >> 1);                      goto case 4;                  case 4:                      if (!resized)                      {                          Array.Resize(ref result' 2);                          resized = true;                      }                        result[1] = (byte)(Array.IndexOf(Alphabet' s[1]) << 6 | Array.IndexOf(Alphabet' s[2]) << 1 | Array.IndexOf(Alphabet' s[3]) >> 4);                      goto case 2;                  case 2:                      if (!resized)                      {                          Array.Resize(ref result' 1);                          resized = true;                      }                        result[0] = (byte)(Array.IndexOf(Alphabet' s[0]) << 3 | Array.IndexOf(Alphabet' s[1]) >> 2);                      break;                  default:                      throw new ArgumentException("Segment is not a valid 8 character block of base32.");              }
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: segment.Length > 5
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: int bitsRemaining = 5;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: int bottomBitsInThisByte = 8 - bitsRemaining;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: accumulator += (b >> bottomBitsInThisByte) & masks[Math.Min(bitsRemaining' 5)];
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: bottomBitsInThisByte -= 5;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: accumulator = (b >> bottomBitsInThisByte) & masks[5];
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: bottomBitsInThisByte >= 5
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: bitsRemaining = (5 - bottomBitsInThisByte) % 5;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: bitsRemaining = (5 - bottomBitsInThisByte) % 5;
Magic Number,OathNet,Base32,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\Base32.cs,ConvertSegmentToBase32,The following statement contains a magic number: result = result.PadRight(8' Padding);
Magic Number,OathNet,CounterBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: Array.Resize(ref text' 8);
Magic Number,OathNet,CounterBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,CounterBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\CounterBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: int binary = ((hash[offset] & 0x7F) << 24) |                           ((hash[offset + 1] & 0xFF) << 16) |                           ((hash[offset + 2] & 0xFF) << 8) |                           (hash[offset + 3] & 0xFF);
Magic Number,OathNet,TimeBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: var unixEpoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,OathNet,TimeBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,GenerateOtp,The following statement contains a magic number: var steps = (int)(span.TotalSeconds / 30);
Magic Number,OathNet,TimeBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,ValidateOtp,The following statement contains a magic number: var unixEpoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,OathNet,TimeBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,ValidateOtp,The following statement contains a magic number: var steps = (int)(span.TotalSeconds / 30);
Magic Number,OathNet,TimeBasedOtpGenerator,D:\research\architectureSmells\repos\jennings_OATH.Net\OATH.Net\TimeBasedOtpGenerator.cs,ValidateOtp,The following statement contains a magic number: var interval = (int)(Math.Abs(validityPeriod.TotalSeconds) / 30);
