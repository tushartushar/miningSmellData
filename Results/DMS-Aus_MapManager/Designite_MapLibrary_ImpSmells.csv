Implementation smell,Namespace,Class,File,Method,Description
Long Method,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The method has 126 lines of code.
Long Method,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The method has 108 lines of code.
Long Method,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,RefreshView,The method has 100 lines of code.
Long Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,UpdateToolbar,The method has 192 lines of code.
Long Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,MoveTreeNode,The method has 136 lines of code.
Long Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenVectorLayer,The method has 113 lines of code.
Long Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The method has 171 lines of code.
Long Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateValues,The method has 213 lines of code.
Long Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,RefreshView,The method has 173 lines of code.
Long Method,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The method has 134 lines of code.
Long Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The method has 102 lines of code.
Long Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,RefreshView,The method has 118 lines of code.
Complex Method,DMS.MapLibrary,AddGraticuleLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddGraticuleLayerForm.cs,buttonOK_Click,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,LabelBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,StyleBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,Cyclomatic complexity of the method is 27
Complex Method,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,UpdateProjBinding,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,GetLayerAttributes,Cyclomatic complexity of the method is 15
Complex Method,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,AddLayerToMap,Cyclomatic complexity of the method is 16
Complex Method,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,Cyclomatic complexity of the method is 17
Complex Method,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,layerControlStyles_GoToLayerText,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,scintillaControlSymbolset_Validating,Cyclomatic complexity of the method is 14
Complex Method,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonRemoveFont_Click,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,CreateLayerTheme,Cyclomatic complexity of the method is 23
Complex Method,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,UpdateValues,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,RefreshView,Cyclomatic complexity of the method is 14
Complex Method,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,SetConnectionString,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,SetDataString,Cyclomatic complexity of the method is 13
Complex Method,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,LoadColumns,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,Cyclomatic complexity of the method is 12
Complex Method,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,Cyclomatic complexity of the method is 28
Complex Method,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,UpdateValues,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateControlState,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,RefreshView,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddClassNode,Cyclomatic complexity of the method is 14
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,UpdateNodeState,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,RefreshView,Cyclomatic complexity of the method is 12
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,UpdateToolbar,Cyclomatic complexity of the method is 26
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_AfterCheck,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,toolStripButtonDown_Click,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,toolStripButtonDelete_Click,Cyclomatic complexity of the method is 12
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,MoveTreeNode,Cyclomatic complexity of the method is 29
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_DragOver,Cyclomatic complexity of the method is 12
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,CreateNewLayer,Cyclomatic complexity of the method is 12
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenVectorLayer,Cyclomatic complexity of the method is 21
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,Cyclomatic complexity of the method is 32
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addLayerToolStripMenuItem_Click,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,ZoomToLayerExtent,Cyclomatic complexity of the method is 16
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addWMSLayerToolStripMenuItem_Click,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addMSSQLSpatialLayerToolStripMenuItem_Click,Cyclomatic complexity of the method is 27
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_AfterLabelEdit,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddMapFileLayers,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateControlState,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateValues,Cyclomatic complexity of the method is 49
Complex Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,RefreshView,Cyclomatic complexity of the method is 34
Complex Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,buttonConnection_Click,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,buttonData_Click,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,buttonEditDefaultLabel_Click,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,Cyclomatic complexity of the method is 22
Complex Method,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetLayerType,Cyclomatic complexity of the method is 13
Complex Method,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitName,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,Cyclomatic complexity of the method is 22
Complex Method,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,Cyclomatic complexity of the method is 39
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SetSelectionMode,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,Cyclomatic complexity of the method is 13
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,Cyclomatic complexity of the method is 24
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,InitializeDefaultLayer,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,CreateSampleMap,Cyclomatic complexity of the method is 21
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,Cyclomatic complexity of the method is 18
Complex Method,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,Cyclomatic complexity of the method is 18
Complex Method,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,PopulateList,Cyclomatic complexity of the method is 9
Complex Method,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,buttonSearch_Click,Cyclomatic complexity of the method is 11
Complex Method,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,UpdateValues,Cyclomatic complexity of the method is 27
Complex Method,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,Cyclomatic complexity of the method is 23
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateEnabledState,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,Cyclomatic complexity of the method is 12
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,Cyclomatic complexity of the method is 8
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateStyleList,Cyclomatic complexity of the method is 15
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateValues,Cyclomatic complexity of the method is 10
Complex Method,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,RefreshView,Cyclomatic complexity of the method is 24
Complex Method,DMS.MapLibrary,SymbolSelectorControl,C:\repos\DMS-Aus_MapManager\MapLibrary\SymbolSelectorControl.cs,RefreshView,Cyclomatic complexity of the method is 16
Long Parameter List,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,SetBoundsCore,The method has 5 parameters.
Long Statement,DMS.MapLibrary,LabelBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The length of the statement  "		pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2); " is 169.
Long Statement,DMS.MapLibrary,StyleBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The length of the statement  "		pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2); " is 169.
Long Statement,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The length of the statement  "				if (httpResponse.StatusCode == HttpStatusCode.Unauthorized || httpResponse.StatusCode == HttpStatusCode.ProxyAuthenticationRequired) { " is 134.
Long Statement,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The length of the statement  "			MessageBox.Show ("Unable to load WMS capabilities of the layer' " + wex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 139.
Long Statement,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The length of the statement  "			MessageBox.Show ("Unable to load WMS capabilities of the layer' " + ex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 138.
Long Statement,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The length of the statement  "		if (comboBoxImageFormat.Items [index].ToString () == map.outputformat.mimetype || (comboBoxImageFormat.SelectedIndex < 0 && map.outputformat.mimetype.StartsWith (comboBoxImageFormat.Items [index].ToString ())) || comboBoxImageFormat.Items [index].ToString ().ToLower ().StartsWith ("image/png")) " is 295.
Long Statement,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,AddLayerToMap,The length of the statement  "		colorObj color = new colorObj (colorPickerLayerColor.Value.R' colorPickerLayerColor.Value.G' colorPickerLayerColor.Value.B' 255); " is 129.
Long Statement,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,ValidateSettings,The length of the statement  "		MessageBox.Show ("The projection of the layer has not been specified!"' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 130.
Long Statement,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The length of the statement  "				Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height); " is 205.
Long Statement,DMS.MapLibrary,AddFontForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddFontForm.cs,buttonOK_Click,The length of the statement  "	if (textBoxFontName.Text.Trim ().Length == 0 || textBoxFontName.Text.Contains (" ") || textBoxFontName.Text.Contains ("\t") || textBoxFontName.Text.Contains ("#")) { " is 165.
Long Statement,DMS.MapLibrary,AddStyleCategoryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddStyleCategoryForm.cs,buttonCharMap_Click,The length of the statement  "		MessageBox.Show ("Unable to start character map' " + ex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 123.
Long Statement,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The length of the statement  "					throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name."); " is 148.
Long Statement,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The length of the statement  "						newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font)); " is 205.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,StyleLibraryForm_Load,The length of the statement  "	ScintillaNet.Configuration.Configuration config = new ScintillaNet.Configuration.Configuration (Environment.CurrentDirectory + "\\MapfileConfig.xml"' "user"' true); " is 164.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,StyleLibraryForm_FormClosing,The length of the statement  "		DialogResult result = MessageBox.Show ("The Style Library has been edited' would you like to save the changes?"' "MapManager"' MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question); " is 183.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The length of the statement  "			textBoxInfo.Text = "WARNING: The fontset of the map doesn't contain " + font + " font. This symbol will not be selectable on the map."; " is 135.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,layerControlStyles_EditProperties,The length of the statement  "			mapPropertyEditor = new MapPropertyEditorForm (new MapObjectHolder (classobj.getStyle (0)' target)' new StyleLibraryPropertyEditor ()); " is 135.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonSave_Click,The length of the statement  "			MessageBox.Show ("Style library was saved successfully!"' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 122.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,ValidateTextContents,The length of the statement  "			MessageBox.Show (ex.Message + ". Please correct the issue in the text tab."' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 135.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMargins,The length of the statement  "	scintillaControl.Margins.Margin0.Width = scintillaControl.NativeInterface.TextWidth (33' scintillaControl.Lines.Count.ToString ()) + 6; " is 135.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMarginsSymbolset,The length of the statement  "	scintillaControlSymbolset.Margins.Margin0.Width = scintillaControlSymbolset.NativeInterface.TextWidth (33' scintillaControlSymbolset.Lines.Count.ToString ()) + 6; " is 162.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The length of the statement  "		if (MessageBox.Show ("Do you wish to save the modifications of the symbolset?"' "MapManager"' MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question) == DialogResult.Yes) { " is 172.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,scintillaControlSymbolset_Validating,The length of the statement  "			if (MessageBox.Show (ex.Message + "\n\rPress OK to correct the errors or Cancel to ignore the changes!"' "MapManager"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.OK) " is 188.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,scintillaControlSymbolset_Validating,The length of the statement  "		DialogResult res = MessageBox.Show ("Do you wish to save the modifications of the symbolset?"' "MapManager"' MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question); " is 165.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonRemoveFont_Click,The length of the statement  "					MessageBox.Show ("Unable to remove the selected font! The map file contains symbol referring to this font: " + sym.name' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 179.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonRemoveFont_Click,The length of the statement  "					MessageBox.Show ("Unable to remove the selected font! The style library contains symbol referring to this font: " + sym.name' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 184.
Long Statement,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonRemoveFont_Click,The length of the statement  "		if (MessageBox.Show ("Are you sure you want to delete the selected font?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) != DialogResult.Yes) " is 159.
Long Statement,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,CreateLayerTheme,The length of the statement  "		classobj.setExpression ("(([" + comboBoxColumns.SelectedItem + "] >= " + breaks [i].ToString (ni) + ") && ([" + comboBoxColumns.SelectedItem + "] <= " + breaks [i + 1].ToString (ni) + "))"); " is 190.
Long Statement,DMS.MapLibrary,CredentialsForm,C:\repos\DMS-Aus_MapManager\MapLibrary\CredentialsForm.cs,UpdateControls,The length of the statement  "	textBoxProxyUser.Enabled = textBoxProxyPassword.Enabled = textBoxServer.Enabled = textBoxPort.Enabled = comboBoxType.Enabled = checkBoxUseProxy.Checked; " is 152.
Long Statement,DMS.MapLibrary,CredentialsForm,C:\repos\DMS-Aus_MapManager\MapLibrary\CredentialsForm.cs,buttonOK_Click,The length of the statement  "			proxy.Credentials = resolver.ProxyCredentials = new NetworkCredential (textBoxProxyUser.Text' textBoxProxyPassword.Text); " is 121.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,SetDataString,The length of the statement  "	string geom = Regex.Match (dataString' @"(?<geometry>\s*[A-Za-z0-9-_]+(?=\s+from))"' RegexOptions.IgnoreCase).ToString ().Trim (); " is 130.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,SetDataString,The length of the statement  "	string table = Regex.Match (dataString' @"(?<=from\s+)[A-Za-z0-9-_]+(?=\s*)"' RegexOptions.IgnoreCase).ToString ().Trim (); " is 123.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,SetDataString,The length of the statement  "	string fid = Regex.Match (dataString' @"(?<=using\s+unique\s+)[A-Za-z0-9-_]+(?=\s*)"' RegexOptions.IgnoreCase).ToString ().Trim (); " is 131.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,LoadColumns,The length of the statement  "		SqlCom.CommandText = "select DATA_TYPE' COLUMN_NAME from INFORMATION_SCHEMA.Columns where TABLE_SCHEMA = '" + tableName [0] + "' and TABLE_NAME = '" + tableName [1] + "'"; " is 171.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,LoadSRID,The length of the statement  "		SqlCom.CommandText = "select top 1 [" + geomCol + "].STSrid' [" + geomCol + "].STGeometryType() from [" + tableName [0] + "].[" + tableName [1] + "] where [" + geomCol + "] is not null"; " is 186.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonTestConnection_Click,The length of the statement  "		MessageBox.Show ("Test connection succeeded!"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 130.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,ValidateInteger,The length of the statement  "		MessageBox.Show ("Invalid integer number"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 120.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,The length of the statement  "		MessageBox.Show ("SQL Server has not been specified!"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 132.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,The length of the statement  "		MessageBox.Show ("SQL Server database has not been specified!"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 141.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,The length of the statement  "		MessageBox.Show ("Data table has not been specified!"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 132.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,The length of the statement  "		MessageBox.Show ("Geometry column has not been specified!"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 137.
Long Statement,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,The length of the statement  "		MessageBox.Show ("SRID has not been specified!"' "SQL Server Connection Manager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 126.
Long Statement,DMS.MapLibrary,ScalebarPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ScalebarPropertyEditor.cs,buttonEditLabel_Click,The length of the statement  "			if (MessageBox.Show ("Changing label settings will automatically apply the pending changes of the scalebar. Would you like to continue?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) { " is 224.
Long Statement,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The length of the statement  "				if (MessageBox.Show ("The number of the individual values is greater than 100 would you like to continue?"' "MapManager"' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation) == DialogResult.Cancel) { " is 203.
Long Statement,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateControlState,The length of the statement  "	labelBindingControllerAngle.Enabled = textBoxAngle.Enabled = (MS_POSITIONS_ENUM)comboBoxAngleMode.SelectedItem == MS_POSITIONS_ENUM.MS_NONE; " is 140.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddLabelNode,The length of the statement  "			labelclass.drawLegendIcon (map' layer' legendDrawingSize.Width' legendDrawingSize.Height' image2' LegendIconPadding.Left' LegendIconPadding.Top); " is 145.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddStyleNode,The length of the statement  "			styleclass.drawLegendIcon (map' layer' legendDrawingSize.Width' legendDrawingSize.Height' image2' LegendIconPadding.Left' LegendIconPadding.Top); " is 145.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddStyleNode,The length of the statement  "			TreeNode styleNode = new TreeNode ("Style (" + nodes.Count + ")"' imageList.Images.Count - 1' imageList.Images.Count - 1); " is 122.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddClassNode,The length of the statement  "			layerclass.drawLegendIcon (map' layer' legendDrawingSize.Width' legendDrawingSize.Height' image' LegendIconPadding.Left' LegendIconPadding.Top); " is 144.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddClassNode,The length of the statement  "			if (layer.numclasses > 1 || (layer.numclasses == 1 && target.GetType () == typeof(layerObj) && showRootObject == false))// classes should always be shown if the layer is not shown (#7118) " is 187.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,RefreshView,The length of the statement  "				if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) { " is 271.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,UpdateToolbar,The length of the statement  "	moveItemDownToolStripMenuItem.Visible = moveItemUpToolStripMenuItem.Visible = deleteItemToolStripMenuItem.Visible = propertiesToolStripMenuItem.Visible = addThemeToolStripMenuItem.Visible = toolStripMenuItemSplitItems.Visible = toolStripMenuItemSplitProp.Visible = toolStripMenuItemSplitTheme.Visible = addLayerToolStripMenuItem.Visible = addClassToolStripMenuItem.Visible = addStyleToolStripMenuItem.Visible = addLabelToolStripMenuItem.Visible = addNewLayerToolStripMenuItem.Visible = addVectorLayerToolStripMenuItem.Visible = addMapFileToolStripMenuItem.Visible = addMapFileToolStripMenuItem1.Visible = addVectorLayerFromFileToolStripMenuItem.Visible = addTileIndexLayerToolStripMenuItem.Visible = addTileIndexLayerToolStripMenuItem1.Visible = addGraticuleLayerToolStripMenuItem.Visible = addGraticuleLayerToolStripMenuItem1.Visible = addRasterLayerToolStripMenuItem.Visible = addRasterLayerFromFileToolStripMenuItem.Visible = addWMSLayerToolStripMenuItem.Visible = addWMSLayerToolStripMenuItem1.Visible = addMSSQLSpatialLayerToolStripMenuItem.Visible = addMSSQLSpatialLayerToolStripMenuItem1.Visible = addNewClassToolStripMenuItem.Visible = addNewStyleToolStripMenuItem.Visible = addNewLabelToolStripMenuItem.Visible = zoomToLayerExtentToolStripMenuItem.Visible = toolStripSplitButtonNew.Enabled = toolStripButtonUp.Enabled = moveItemUpToolStripMenuItem.Enabled = toolStripButtonDown.Enabled = toolStripButtonDelete.Enabled = autoStyleToolStripMenuItem.Visible = goToLayerTextToolStripMenuItem.Visible = goToClassTextToolStripMenuItem.Visible = renameToolStripMenuItem.Visible = false; " is 1588.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,UpdateToolbar,The length of the statement  "		toolStripButtonUp.Enabled = moveItemUpToolStripMenuItem.Enabled = toolStripButtonDown.Enabled = moveItemDownToolStripMenuItem.Enabled = true; " is 141.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,toolStripButtonDelete_Click,The length of the statement  "		if (MessageBox.Show ("Are you sure you want to delete layer " + layer.name + "?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) != DialogResult.Yes) " is 166.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,toolStripButtonDelete_Click,The length of the statement  "		if (MessageBox.Show ("Are you sure you want to delete the selected class?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) != DialogResult.Yes) " is 160.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,toolStripButtonDelete_Click,The length of the statement  "		if (MessageBox.Show ("Are you sure you want to delete the selected style?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) != DialogResult.Yes) " is 160.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,toolStripButtonDelete_Click,The length of the statement  "		if (MessageBox.Show ("Are you sure you want to delete the selected label?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) != DialogResult.Yes) " is 160.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_ItemDrag,The length of the statement  "			if (node.GetType () == typeof(layerObj) || node.GetType () == typeof(classObj) || node.GetType () == typeof(styleObj) || node.GetType () == typeof(labelObj)) { " is 159.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The length of the statement  "							throw new Exception ("File fot found: " + src [0] + ". If your tile file contains relative pathes try to set SHAPEPATH to the base directory."); " is 144.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The length of the statement  "		SqlCom.CommandText = "select MIN(" + geomCol + ".STStartPoint().Long)' MIN(" + geomCol + ".STStartPoint().Lat)' MAX(" + geomCol + ".STStartPoint().Long)' MAX(" + geomCol + ".STStartPoint().Lat) from " + tableName; " is 213.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The length of the statement  "		SqlCom.CommandText = "select MIN(" + geomCol + ".STStartPoint().STX)' MIN(" + geomCol + ".STStartPoint().STY)' MAX(" + geomCol + ".STStartPoint().STX)' MAX(" + geomCol + ".STStartPoint().STY) from " + tableName; " is 211.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_NodeMouseDoubleClick,The length of the statement  "	if (node.GetType () == typeof(classObj) || node.GetType () == typeof(styleObj) || node.GetType () == typeof(labelObj)) { " is 120.
Long Statement,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_BeforeLabelEdit,The length of the statement  "		if (current.GetType () != typeof(mapObj) && current.GetType () != typeof(layerObj) && current.GetType () != typeof(classObj)) " is 125.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateControlState,The length of the statement  "	comboBoxDisplayRange.Enabled = textBoxMinZoom.Enabled = textBoxMaxZoom.Enabled = labelMaxZoom.Enabled = labelMinZoom.Enabled = labelUnitMaxZoom.Enabled = labelUnitMinZoom.Enabled = textBoxMinScale.Enabled = textBoxMaxScale.Enabled = buttonMinScale.Enabled = buttonMaxScale.Enabled = false; " is 289.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateControlState,The length of the statement  "		if (comboBoxConnectionType.SelectedValue != null && (MS_CONNECTION_TYPE)comboBoxConnectionType.SelectedValue == MS_CONNECTION_TYPE.MS_WMS) { " is 140.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateControlState,The length of the statement  "			this.comboBoxPlugin.Enabled = ((MS_CONNECTION_TYPE)comboBoxConnectionType.SelectedValue == MS_CONNECTION_TYPE.MS_PLUGIN); " is 121.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateControlState,The length of the statement  "		comboBoxDisplayRange.Enabled = textBoxMinZoom.Enabled = textBoxMaxZoom.Enabled = labelMaxZoom.Enabled = labelMinZoom.Enabled = labelUnitMaxZoom.Enabled = labelUnitMinZoom.Enabled = textBoxMinScale.Enabled = textBoxMaxScale.Enabled = checkBoxDisplayRange.Checked; " is 262.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateValues,The length of the statement  "				if ((MS_CONNECTION_TYPE)comboBoxConnectionType.SelectedItem == MS_CONNECTION_TYPE.MS_PLUGIN && comboBoxPlugin.SelectedIndex >= 0) " is 129.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateValues,The length of the statement  "				MessageBox.Show ("Error setting the connection type' " + ex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 127.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateValues,The length of the statement  "		if ((MS_LAYER_TYPE)comboBoxType.SelectedItem == MS_LAYER_TYPE.MS_LAYER_ANNOTATION && layer.type != MS_LAYER_TYPE.MS_LAYER_ANNOTATION) { " is 135.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,UpdateValues,The length of the statement  "		if (layer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON && type != MS_LAYER_TYPE.MS_LAYER_POLYGON && layer.styleitem == null) { " is 120.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,RefreshView,The length of the statement  "	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER && layer.connectiontype != MS_CONNECTION_TYPE.MS_WMS && layer.connectiontype != MS_CONNECTION_TYPE.MS_RASTER) " is 157.
Long Statement,DMS.MapLibrary,LayerPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerPropertyEditor.cs,textBoxName_Validating,The length of the statement  "			MessageBox.Show ("Duplicated layer names are not supported by IntraMaps' the layer will be renamed to an unique name."' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Warning); " is 180.
Long Statement,DMS.MapLibrary,ListViewColumnSorter,C:\repos\DMS-Aus_MapManager\MapLibrary\ListViewColumnSorter.cs,Compare,The length of the statement  "		compareResult = ObjectCompare.Compare (System.Convert.ChangeType (listviewX.SubItems [ColumnToSort].Text' ColumnType)' System.Convert.ChangeType (listviewY.SubItems [ColumnToSort].Text' ColumnType)); " is 199.
Long Statement,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindLibrary,The length of the statement  "	string[] pathes = System.Environment.GetEnvironmentVariable ("PATH"' EnvironmentVariableTarget.Process).Split (new char[] { " is 123.
Long Statement,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindLibrary,The length of the statement  "		System.Environment.SetEnvironmentVariable ("PATH"' Path.GetDirectoryName (dialog.FileName) + ";" + System.Environment.GetEnvironmentVariable ("PATH"' EnvironmentVariableTarget.Process)' EnvironmentVariableTarget.Process); " is 221.
Long Statement,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The length of the statement  "				if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~")) " is 140.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The length of the statement  "					if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y)) " is 132.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RaisePositionChanged,The length of the statement  "	target.RaisePositionChanged (this' Math.Round ((map.extent.maxx + map.extent.minx) / 2' MapUtils.GetUnitPrecision (mapunits))' Math.Round ((map.extent.maxy + map.extent.miny) / 2' MapUtils.GetUnitPrecision (mapunits))); " is 219.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SetSelectionMode,The length of the statement  "						if (layer.type != MS_LAYER_TYPE.MS_LAYER_POINT && layer.type != MS_LAYER_TYPE.MS_LAYER_POLYGON && layer.type != MS_LAYER_TYPE.MS_LAYER_LINE && layer.type != MS_LAYER_TYPE.MS_LAYER_ANNOTATION && layer.type != MS_LAYER_TYPE.MS_LAYER_RASTER) " is 238.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The length of the statement  "				Rectangle normalizedRectangle = new Rectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Abs (dragRect.Width)' Math.Abs (dragRect.Height)); " is 207.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The length of the statement  "				if ((format.renderer != mapscript.MS_RENDER_WITH_AGG && format.renderer != mapscript.MS_RENDER_WITH_CAIRO_RASTER) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0) { " is 262.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The length of the statement  "							BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb); " is 143.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The length of the statement  "							BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb); " is 143.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The length of the statement  "		this.ZoomRectangle ((double)offsetX' (double)offsetY' (double)offsetX + (double)mapImage.Width / magnify' (double)offsetY + (double)mapImage.Height / magnify); " is 159.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The length of the statement  "			ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height)); " is 225.
Long Statement,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,timerRefresh_Tick,The length of the statement  "		this.ZoomRectangle ((double)offsetX' (double)offsetY' (double)offsetX + (double)mapImage.Width / magnify' (double)offsetY + (double)mapImage.Height / magnify); " is 159.
Long Statement,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,LayoutControls,The length of the statement  "			pickerTextBox.SetBounds (editor.X + PaintValueWidth + split' editor.Y' editor.Width - PaintValueWidth - split' editor.Height); " is 126.
Long Statement,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,IsEnumerable,The length of the statement  "	if (Converter != null && Converter.GetStandardValuesSupported (typeContext) && (Converter.GetStandardValues (typeContext).Count != 0)) { " is 136.
Long Statement,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,SetValue,The length of the statement  "			throw new InvalidCastException ("PickerBase.Value : Bad value type." + EditedType.ToString () + " - " + value.GetType ().ToString ()); " is 134.
Long Statement,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,UpdateValues,The length of the statement  "				if (map.getProjection () != "" && this.textBoxProjection.Tag.ToString () != "" && map.extent.minx < map.extent.maxx && map.extent.miny < map.extent.maxy) { " is 155.
Long Statement,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,UpdateValues,The length of the statement  "			MessageBox.Show ("Unable to set projection value' " + ex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 124.
Long Statement,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,RefreshView,The length of the statement  "	checkBoxTransparent.Checked = (map.outputformat.transparent == mapscript.MS_TRUE && map.outputformat.imagemode == (int)MS_IMAGEMODE.MS_IMAGEMODE_RGBA); " is 151.
Long Statement,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,RefreshView,The length of the statement  "	checkBoxTransparent.Enabled = (map.outputformat.imagemode == (int)MS_IMAGEMODE.MS_IMAGEMODE_RGB || map.outputformat.imagemode == (int)MS_IMAGEMODE.MS_IMAGEMODE_RGBA); " is 166.
Long Statement,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,buttonScalebar_Click,The length of the statement  "			if (MessageBox.Show ("Changing scalebar settings will automatically apply the pending changes of the map. Would you like to continue?"' "MapManager"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) { " is 222.
Long Statement,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The length of the statement  "			if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) { " is 271.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The length of the statement  "			using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) { " is 121.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The length of the statement  "					else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid")) " is 132.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The length of the statement  "		using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) { " is 123.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The length of the statement  "				//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview  " is 130.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,RefreshView,The length of the statement  "			if (selectedCategory == null && ((stylelayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON && style.getGeomTransform ().Contains ("labelpoly")) || (stylelayer.type == MS_LAYER_TYPE.MS_LAYER_POINT && style.getGeomTransform ().Contains ("labelpnt")))) " is 242.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,RefreshView,The length of the statement  "		else if ((layer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON || layer.type == MS_LAYER_TYPE.MS_LAYER_CIRCLE) && (stylelayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON || stylelayer.type == MS_LAYER_TYPE.MS_LAYER_LINE)) { " is 210.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,textBoxGeomTransform_Validating,The length of the statement  "			MessageBox.Show ("Label styles must have labelpnt or labelpoly geometry transformations specified!"' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 159.
Long Statement,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,listView_SelectedIndexChanged,The length of the statement  "		//STEPH: only applied the property of the selected style when user click on a style' not when dialog first load to display  " is 122.
Long Statement,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The length of the statement  "	if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled " is 125.
Long Statement,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The length of the statement  "			e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor); " is 135.
Complex Conditional,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The conditional expression  "comboBoxImageFormat.Items [index].ToString () == map.outputformat.mimetype || (comboBoxImageFormat.SelectedIndex < 0 && map.outputformat.mimetype.StartsWith (comboBoxImageFormat.Items [index].ToString ())) || comboBoxImageFormat.Items [index].ToString ().ToLower ().StartsWith ("image/png")"  is complex.
Complex Conditional,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,GetLayerAttributes,The conditional expression  "minx != null && miny != null && maxx != null && maxy != null"  is complex.
Complex Conditional,DMS.MapLibrary,AddFontForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddFontForm.cs,buttonOK_Click,The conditional expression  "textBoxFontName.Text.Trim ().Length == 0 || textBoxFontName.Text.Contains (" ") || textBoxFontName.Text.Contains ("\t") || textBoxFontName.Text.Contains ("#")"  is complex.
Complex Conditional,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,SqlConnectionDialog,The conditional expression  "server != null && server != "" && database != null && database != """  is complex.
Complex Conditional,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,AddClassNode,The conditional expression  "layer.numclasses > 1 || (layer.numclasses == 1 && target.GetType () == typeof(layerObj) && showRootObject == false)"  is complex.
Complex Conditional,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,RefreshView,The conditional expression  "(format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0"  is complex.
Complex Conditional,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,treeView_ItemDrag,The conditional expression  "node.GetType () == typeof(layerObj) || node.GetType () == typeof(classObj) || node.GetType () == typeof(styleObj) || node.GetType () == typeof(labelObj)"  is complex.
Complex Conditional,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The conditional expression  "!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3)"  is complex.
Complex Conditional,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The conditional expression  "layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~")"  is complex.
Complex Conditional,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SetSelectionMode,The conditional expression  "layer.type != MS_LAYER_TYPE.MS_LAYER_POINT && layer.type != MS_LAYER_TYPE.MS_LAYER_POLYGON && layer.type != MS_LAYER_TYPE.MS_LAYER_LINE && layer.type != MS_LAYER_TYPE.MS_LAYER_ANNOTATION && layer.type != MS_LAYER_TYPE.MS_LAYER_RASTER"  is complex.
Complex Conditional,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The conditional expression  "this.Height > 2 && this.Width > 2 && map.extent.maxx > map.extent.minx && map.extent.maxy > map.extent.miny"  is complex.
Complex Conditional,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The conditional expression  "(format.renderer != mapscript.MS_RENDER_WITH_AGG && format.renderer != mapscript.MS_RENDER_WITH_CAIRO_RASTER) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0"  is complex.
Complex Conditional,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,SetValue,The conditional expression  "editedValue == value || (editedValue != null && value != null && editedValue.Equals (value))"  is complex.
Complex Conditional,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,UpdateValues,The conditional expression  "map.getProjection () != "" && this.textBoxProjection.Tag.ToString () != "" && map.extent.minx < map.extent.maxx && map.extent.miny < map.extent.maxy"  is complex.
Complex Conditional,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The conditional expression  "(format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0"  is complex.
Complex Conditional,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,RefreshView,The conditional expression  "selectedCategory == null && ((stylelayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON && style.getGeomTransform ().Contains ("labelpoly")) || (stylelayer.type == MS_LAYER_TYPE.MS_LAYER_POINT && style.getGeomTransform ().Contains ("labelpnt")))"  is complex.
Complex Conditional,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,RefreshView,The conditional expression  "(layer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON || layer.type == MS_LAYER_TYPE.MS_LAYER_CIRCLE) && (stylelayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON || stylelayer.type == MS_LAYER_TYPE.MS_LAYER_LINE)"  is complex.
Empty Catch Block,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,comboBoxDatabases_DropDown,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,comboBoxDataTable_DropDown,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,comboBoxFIDCol_DropDown,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,comboBoxGeomCol_DropDown,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,buttonOK_Click,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,CommitText,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,GetValueAsText,The method has an empty catch block.
Empty Catch Block,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The method has an empty catch block.
Magic Number,DMS.MapLibrary,LabelBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: if (itemList == null) {  	itemList = new ComboBox ();  	itemList.Width = targetControl.Width;  	itemList.Height = targetControl.Height;  	itemList.Location = targetControl.Location;  	itemList.DropDownStyle = ComboBoxStyle.DropDownList;  	itemList.SelectedIndexChanged += new EventHandler (itemList_SelectedIndexChanged);  	targetControl.Parent.Controls.Add (itemList);  	itemList.BringToFront ();  	Bitmap bmp = Resources.DataConnection;  	bmp.MakeTransparent (Color.Magenta);  	pbox = new PictureBox ();  	pbox.Image = bmp;  	pbox.SizeMode = PictureBoxSizeMode.AutoSize;  	pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  	targetControl.Parent.Controls.Add (pbox);  	pbox.BringToFront ();  }  
Magic Number,DMS.MapLibrary,LabelBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: if (itemList == null) {  	itemList = new ComboBox ();  	itemList.Width = targetControl.Width;  	itemList.Height = targetControl.Height;  	itemList.Location = targetControl.Location;  	itemList.DropDownStyle = ComboBoxStyle.DropDownList;  	itemList.SelectedIndexChanged += new EventHandler (itemList_SelectedIndexChanged);  	targetControl.Parent.Controls.Add (itemList);  	itemList.BringToFront ();  	Bitmap bmp = Resources.DataConnection;  	bmp.MakeTransparent (Color.Magenta);  	pbox = new PictureBox ();  	pbox.Image = bmp;  	pbox.SizeMode = PictureBoxSizeMode.AutoSize;  	pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  	targetControl.Parent.Controls.Add (pbox);  	pbox.BringToFront ();  }  
Magic Number,DMS.MapLibrary,LabelBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  
Magic Number,DMS.MapLibrary,LabelBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  
Magic Number,DMS.MapLibrary,StyleBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: if (itemList == null) {  	itemList = new ComboBox ();  	itemList.Width = targetControl.Width;  	itemList.Height = targetControl.Height;  	itemList.Location = targetControl.Location;  	itemList.DropDownStyle = ComboBoxStyle.DropDownList;  	itemList.SelectedIndexChanged += new EventHandler (itemList_SelectedIndexChanged);  	targetControl.Parent.Controls.Add (itemList);  	itemList.BringToFront ();  	Bitmap bmp = Resources.DataConnection;  	bmp.MakeTransparent (Color.Magenta);  	pbox = new PictureBox ();  	pbox.Image = bmp;  	pbox.SizeMode = PictureBoxSizeMode.AutoSize;  	pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  	targetControl.Parent.Controls.Add (pbox);  	pbox.BringToFront ();  }  
Magic Number,DMS.MapLibrary,StyleBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: if (itemList == null) {  	itemList = new ComboBox ();  	itemList.Width = targetControl.Width;  	itemList.Height = targetControl.Height;  	itemList.Location = targetControl.Location;  	itemList.DropDownStyle = ComboBoxStyle.DropDownList;  	itemList.SelectedIndexChanged += new EventHandler (itemList_SelectedIndexChanged);  	targetControl.Parent.Controls.Add (itemList);  	itemList.BringToFront ();  	Bitmap bmp = Resources.DataConnection;  	bmp.MakeTransparent (Color.Magenta);  	pbox = new PictureBox ();  	pbox.Image = bmp;  	pbox.SizeMode = PictureBoxSizeMode.AutoSize;  	pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  	targetControl.Parent.Controls.Add (pbox);  	pbox.BringToFront ();  }  
Magic Number,DMS.MapLibrary,StyleBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  
Magic Number,DMS.MapLibrary,StyleBindingController,C:\repos\DMS-Aus_MapManager\MapLibrary\BindingController.cs,InitializeBinding,The following statement contains a magic number: pbox.Location = new System.Drawing.Point (targetControl.Location.X + targetControl.Width + 2' targetControl.Location.Y + (targetControl.Height - pbox.Image.Height) / 2);  
Magic Number,DMS.MapLibrary,ChangeViewForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ChangeViewForm.cs,RefreshView,The following statement contains a magic number: textBoxX.Text = Convert.ToString (Math.Round ((map.extent.maxx + map.extent.minx) / 2' unitPrecision));  
Magic Number,DMS.MapLibrary,ChangeViewForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ChangeViewForm.cs,RefreshView,The following statement contains a magic number: textBoxY.Text = Convert.ToString (Math.Round ((map.extent.maxy + map.extent.miny) / 2' unitPrecision));  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: using (Stream s = File.OpenRead (MapUtils.GetPROJ_LIB () + "\\epsg")) {  	using (StreamReader reader = new StreamReader (s)) {  		string line;  		string projName = "";  		while ((line = reader.ReadLine ()) != null) {  			if (line.StartsWith ("#") && line.Length > 2)  				projName = line.Substring (2);  			else if (line.StartsWith ("<")) {  				string[] items = line.Split (new char[] {  					'<''  					'>'  				}' StringSplitOptions.RemoveEmptyEntries);  				if (items.Length > 0)  					epsg.Add ("EPSG:" + items [0]' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: using (Stream s = File.OpenRead (MapUtils.GetPROJ_LIB () + "\\epsg")) {  	using (StreamReader reader = new StreamReader (s)) {  		string line;  		string projName = "";  		while ((line = reader.ReadLine ()) != null) {  			if (line.StartsWith ("#") && line.Length > 2)  				projName = line.Substring (2);  			else if (line.StartsWith ("<")) {  				string[] items = line.Split (new char[] {  					'<''  					'>'  				}' StringSplitOptions.RemoveEmptyEntries);  				if (items.Length > 0)  					epsg.Add ("EPSG:" + items [0]' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: using (StreamReader reader = new StreamReader (s)) {  	string line;  	string projName = "";  	while ((line = reader.ReadLine ()) != null) {  		if (line.StartsWith ("#") && line.Length > 2)  			projName = line.Substring (2);  		else if (line.StartsWith ("<")) {  			string[] items = line.Split (new char[] {  				'<''  				'>'  			}' StringSplitOptions.RemoveEmptyEntries);  			if (items.Length > 0)  				epsg.Add ("EPSG:" + items [0]' projName);  		}  	}  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: using (StreamReader reader = new StreamReader (s)) {  	string line;  	string projName = "";  	while ((line = reader.ReadLine ()) != null) {  		if (line.StartsWith ("#") && line.Length > 2)  			projName = line.Substring (2);  		else if (line.StartsWith ("<")) {  			string[] items = line.Split (new char[] {  				'<''  				'>'  			}' StringSplitOptions.RemoveEmptyEntries);  			if (items.Length > 0)  				epsg.Add ("EPSG:" + items [0]' projName);  		}  	}  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("#") && line.Length > 2)  		projName = line.Substring (2);  	else if (line.StartsWith ("<")) {  		string[] items = line.Split (new char[] {  			'<''  			'>'  		}' StringSplitOptions.RemoveEmptyEntries);  		if (items.Length > 0)  			epsg.Add ("EPSG:" + items [0]' projName);  	}  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("#") && line.Length > 2)  		projName = line.Substring (2);  	else if (line.StartsWith ("<")) {  		string[] items = line.Split (new char[] {  			'<''  			'>'  		}' StringSplitOptions.RemoveEmptyEntries);  		if (items.Length > 0)  			epsg.Add ("EPSG:" + items [0]' projName);  	}  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: if (line.StartsWith ("#") && line.Length > 2)  	projName = line.Substring (2);  else if (line.StartsWith ("<")) {  	string[] items = line.Split (new char[] {  		'<''  		'>'  	}' StringSplitOptions.RemoveEmptyEntries);  	if (items.Length > 0)  		epsg.Add ("EPSG:" + items [0]' projName);  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: if (line.StartsWith ("#") && line.Length > 2)  	projName = line.Substring (2);  else if (line.StartsWith ("<")) {  	string[] items = line.Split (new char[] {  		'<''  		'>'  	}' StringSplitOptions.RemoveEmptyEntries);  	if (items.Length > 0)  		epsg.Add ("EPSG:" + items [0]' projName);  }  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,LoadLayers,The following statement contains a magic number: projName = line.Substring (2);  
Magic Number,DMS.MapLibrary,AddWMSLayerForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddWMSLayerForm.cs,AddLayerToMap,The following statement contains a magic number: if (!colorPickerLayerColor.Value.IsEmpty) {  	colorObj color = new colorObj (colorPickerLayerColor.Value.R' colorPickerLayerColor.Value.G' colorPickerLayerColor.Value.B' 255);  	layer.metadata.set ("wms_bgcolor"' "0x" + color.toHex ().Substring (1));  }  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampPicker,The following statement contains a magic number: PaintValueWidth = 40;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: if (R > 255)  	R = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: if (R > 255)  	R = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: R = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: if (G > 255)  	G = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: if (G > 255)  	G = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: G = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: if (B > 255)  	B = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: if (B > 255)  	B = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetInterpolatedColor,The following statement contains a magic number: B = 255;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (Value.Text == "Random values")  	return Color.FromArgb (MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256));  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (Value.Text == "Random values")  	return Color.FromArgb (MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256));  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (Value.Text == "Random values")  	return Color.FromArgb (MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256));  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: return Color.FromArgb (MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256));  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: return Color.FromArgb (MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256));  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: return Color.FromArgb (MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256)' MapUtils.GetRandomValue (256));  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (i > 0) {  	if (i < 2 || Value.Style == ColorRampStyle.Discrete)  		return Value.Values [i - 1];  	else  		return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  }  else  	return Color.Empty;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (i > 0) {  	if (i < 2 || Value.Style == ColorRampStyle.Discrete)  		return Value.Values [i - 1];  	else  		return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  }  else  	return Color.Empty;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (i > 0) {  	if (i < 2 || Value.Style == ColorRampStyle.Discrete)  		return Value.Values [i - 1];  	else  		return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  }  else  	return Color.Empty;  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (i < 2 || Value.Style == ColorRampStyle.Discrete)  	return Value.Values [i - 1];  else  	return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (i < 2 || Value.Style == ColorRampStyle.Discrete)  	return Value.Values [i - 1];  else  	return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: if (i < 2 || Value.Style == ColorRampStyle.Discrete)  	return Value.Values [i - 1];  else  	return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetColorAtValue,The following statement contains a magic number: return GetInterpolatedColor (Value.Values [i - 2]' Value.Values [i - 1]' percent / 100);  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetMapColorAtValue,The following statement contains a magic number: if (source == Color.Empty) {  	return new colorObj (-1' -1' -1' 255);  }  else {  	return new colorObj (source.R' source.G' source.B' 255);  }  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetMapColorAtValue,The following statement contains a magic number: if (source == Color.Empty) {  	return new colorObj (-1' -1' -1' 255);  }  else {  	return new colorObj (source.R' source.G' source.B' 255);  }  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetMapColorAtValue,The following statement contains a magic number: return new colorObj (-1' -1' -1' 255);  
Magic Number,DMS.MapLibrary,ColorRampPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,GetMapColorAtValue,The following statement contains a magic number: return new colorObj (source.R' source.G' source.B' 255);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (50' Color.Blue);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (100' Color.Green);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (100' Color.Orange);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (20' Color.Orange);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (40' Color.Brown);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (60' Color.Cyan);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (80' Color.Magenta);  
Magic Number,DMS.MapLibrary,ColorRampConverter,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,ColorRampConverter,The following statement contains a magic number: valueList.Add (100' Color.Empty);  
Magic Number,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The following statement contains a magic number: if (e.Value != null) {  	ColorRampValueList valueList = (ColorRampValueList)e.Value;  	if (valueList.Count > 0) {  		for (int i = 1; i < valueList.Count; i++) {  			Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height);  			if (valueList.Style == ColorRampStyle.Discrete) {  				using (Brush brush = new SolidBrush (valueList.Values [i - 1])) {  					e.Graphics.FillRectangle (brush' rect);  				}  			}  			else {  				using (Brush brush = new LinearGradientBrush (rect' valueList.Values [i - 1]' valueList.Values [i]' 0.0)) {  					e.Graphics.FillRectangle (brush' rect);  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The following statement contains a magic number: if (e.Value != null) {  	ColorRampValueList valueList = (ColorRampValueList)e.Value;  	if (valueList.Count > 0) {  		for (int i = 1; i < valueList.Count; i++) {  			Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height);  			if (valueList.Style == ColorRampStyle.Discrete) {  				using (Brush brush = new SolidBrush (valueList.Values [i - 1])) {  					e.Graphics.FillRectangle (brush' rect);  				}  			}  			else {  				using (Brush brush = new LinearGradientBrush (rect' valueList.Values [i - 1]' valueList.Values [i]' 0.0)) {  					e.Graphics.FillRectangle (brush' rect);  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The following statement contains a magic number: if (valueList.Count > 0) {  	for (int i = 1; i < valueList.Count; i++) {  		Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height);  		if (valueList.Style == ColorRampStyle.Discrete) {  			using (Brush brush = new SolidBrush (valueList.Values [i - 1])) {  				e.Graphics.FillRectangle (brush' rect);  			}  		}  		else {  			using (Brush brush = new LinearGradientBrush (rect' valueList.Values [i - 1]' valueList.Values [i]' 0.0)) {  				e.Graphics.FillRectangle (brush' rect);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The following statement contains a magic number: if (valueList.Count > 0) {  	for (int i = 1; i < valueList.Count; i++) {  		Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height);  		if (valueList.Style == ColorRampStyle.Discrete) {  			using (Brush brush = new SolidBrush (valueList.Values [i - 1])) {  				e.Graphics.FillRectangle (brush' rect);  			}  		}  		else {  			using (Brush brush = new LinearGradientBrush (rect' valueList.Values [i - 1]' valueList.Values [i]' 0.0)) {  				e.Graphics.FillRectangle (brush' rect);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The following statement contains a magic number: for (int i = 1; i < valueList.Count; i++) {  	Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height);  	if (valueList.Style == ColorRampStyle.Discrete) {  		using (Brush brush = new SolidBrush (valueList.Values [i - 1])) {  			e.Graphics.FillRectangle (brush' rect);  		}  	}  	else {  		using (Brush brush = new LinearGradientBrush (rect' valueList.Values [i - 1]' valueList.Values [i]' 0.0)) {  			e.Graphics.FillRectangle (brush' rect);  		}  	}  }  
Magic Number,DMS.MapLibrary,ColorRampEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampPicker.cs,PaintValue,The following statement contains a magic number: for (int i = 1; i < valueList.Count; i++) {  	Rectangle rect = new Rectangle (e.Bounds.X + (int)(valueList.Keys [i - 1] * e.Bounds.Width / 100)' e.Bounds.Y' (int)((valueList.Keys [i] - valueList.Keys [i - 1]) * e.Bounds.Width / 100)' e.Bounds.Height);  	if (valueList.Style == ColorRampStyle.Discrete) {  		using (Brush brush = new SolidBrush (valueList.Values [i - 1])) {  			e.Graphics.FillRectangle (brush' rect);  		}  	}  	else {  		using (Brush brush = new LinearGradientBrush (rect' valueList.Values [i - 1]' valueList.Values [i]' 0.0)) {  			e.Graphics.FillRectangle (brush' rect);  		}  	}  }  
Magic Number,DMS.MapLibrary,ColorStopForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorStopForm.cs,buttonOK_Click,The following statement contains a magic number: if (!Double.TryParse (textBoxOffset.Text' out value) || value < 0 || value > 100) {  	MessageBox.Show ("Invalid offset value"' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error);  	return;  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: if (key != null && ColorRampConverter.ColorRampList.ContainsKey (key)) {  	values = ColorRampConverter.ColorRampList [key];  	this.Text = "Edit Colour Ramp";  	textBoxName.Text = key;  	textBoxName.Enabled = false;  	if (values.ContainsKey (0))  		colorPickerStart.Value = values [0];  	if (values.ContainsKey (100))  		colorPickerEnd.Value = values [100];  }  else {  	values = new ColorRampValueList ();  	values.Add (0' colorPickerStart.Value);  	values.Add (100' colorPickerEnd.Value);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: if (key != null && ColorRampConverter.ColorRampList.ContainsKey (key)) {  	values = ColorRampConverter.ColorRampList [key];  	this.Text = "Edit Colour Ramp";  	textBoxName.Text = key;  	textBoxName.Enabled = false;  	if (values.ContainsKey (0))  		colorPickerStart.Value = values [0];  	if (values.ContainsKey (100))  		colorPickerEnd.Value = values [100];  }  else {  	values = new ColorRampValueList ();  	values.Add (0' colorPickerStart.Value);  	values.Add (100' colorPickerEnd.Value);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: if (key != null && ColorRampConverter.ColorRampList.ContainsKey (key)) {  	values = ColorRampConverter.ColorRampList [key];  	this.Text = "Edit Colour Ramp";  	textBoxName.Text = key;  	textBoxName.Enabled = false;  	if (values.ContainsKey (0))  		colorPickerStart.Value = values [0];  	if (values.ContainsKey (100))  		colorPickerEnd.Value = values [100];  }  else {  	values = new ColorRampValueList ();  	values.Add (0' colorPickerStart.Value);  	values.Add (100' colorPickerEnd.Value);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: if (values.ContainsKey (100))  	colorPickerEnd.Value = values [100];  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: if (values.ContainsKey (100))  	colorPickerEnd.Value = values [100];  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: colorPickerEnd.Value = values [100];  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,ColorRampForm,The following statement contains a magic number: values.Add (100' colorPickerEnd.Value);  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: for (int i = 1; i < values.Count - 1; i++) {  	Bitmap image2 = new Bitmap (16' 16);  	using (Graphics gfx = Graphics.FromImage (image2))  		using (SolidBrush brush = new SolidBrush (values.Values [i])) {  			gfx.FillRectangle (brush' 0' 0' 16' 16);  		}  	imageListPreview.Images.Add (image2);  	string colorName = new ColorConverter ().ConvertToInvariantString (values.Values [i]);  	ListViewItem item = new ListViewItem (colorName' i - 1);  	item.SubItems.Add (values.Keys [i].ToString ());  	item.Tag = values.Keys [i];  	listViewStops.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: for (int i = 1; i < values.Count - 1; i++) {  	Bitmap image2 = new Bitmap (16' 16);  	using (Graphics gfx = Graphics.FromImage (image2))  		using (SolidBrush brush = new SolidBrush (values.Values [i])) {  			gfx.FillRectangle (brush' 0' 0' 16' 16);  		}  	imageListPreview.Images.Add (image2);  	string colorName = new ColorConverter ().ConvertToInvariantString (values.Values [i]);  	ListViewItem item = new ListViewItem (colorName' i - 1);  	item.SubItems.Add (values.Keys [i].ToString ());  	item.Tag = values.Keys [i];  	listViewStops.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: for (int i = 1; i < values.Count - 1; i++) {  	Bitmap image2 = new Bitmap (16' 16);  	using (Graphics gfx = Graphics.FromImage (image2))  		using (SolidBrush brush = new SolidBrush (values.Values [i])) {  			gfx.FillRectangle (brush' 0' 0' 16' 16);  		}  	imageListPreview.Images.Add (image2);  	string colorName = new ColorConverter ().ConvertToInvariantString (values.Values [i]);  	ListViewItem item = new ListViewItem (colorName' i - 1);  	item.SubItems.Add (values.Keys [i].ToString ());  	item.Tag = values.Keys [i];  	listViewStops.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: for (int i = 1; i < values.Count - 1; i++) {  	Bitmap image2 = new Bitmap (16' 16);  	using (Graphics gfx = Graphics.FromImage (image2))  		using (SolidBrush brush = new SolidBrush (values.Values [i])) {  			gfx.FillRectangle (brush' 0' 0' 16' 16);  		}  	imageListPreview.Images.Add (image2);  	string colorName = new ColorConverter ().ConvertToInvariantString (values.Values [i]);  	ListViewItem item = new ListViewItem (colorName' i - 1);  	item.SubItems.Add (values.Keys [i].ToString ());  	item.Tag = values.Keys [i];  	listViewStops.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: using (Graphics gfx = Graphics.FromImage (image2))  	using (SolidBrush brush = new SolidBrush (values.Values [i])) {  		gfx.FillRectangle (brush' 0' 0' 16' 16);  	}  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: using (Graphics gfx = Graphics.FromImage (image2))  	using (SolidBrush brush = new SolidBrush (values.Values [i])) {  		gfx.FillRectangle (brush' 0' 0' 16' 16);  	}  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: using (SolidBrush brush = new SolidBrush (values.Values [i])) {  	gfx.FillRectangle (brush' 0' 0' 16' 16);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: using (SolidBrush brush = new SolidBrush (values.Values [i])) {  	gfx.FillRectangle (brush' 0' 0' 16' 16);  }  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: gfx.FillRectangle (brush' 0' 0' 16' 16);  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,UpdatePreview,The following statement contains a magic number: gfx.FillRectangle (brush' 0' 0' 16' 16);  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,colorPickerEnd_ValueChanged,The following statement contains a magic number: values.Remove (100);  
Magic Number,DMS.MapLibrary,ColorRampForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ColorRampForm.cs,colorPickerEnd_ValueChanged,The following statement contains a magic number: values.Add (100' colorPickerEnd.Value);  
Magic Number,DMS.MapLibrary,AddStyleCategoryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddStyleCategoryForm.cs,AddStyleCategoryForm,The following statement contains a magic number: if (StyleLibrary.FontsetFileName != null) {  	using (StringReader r = new StringReader (File.ReadAllText (StyleLibrary.FontsetFileName))) {  		string line;  		while ((line = r.ReadLine ()) != null) {  			string[] vals = line.Split (new char[] {  				' ''  				'\t'  			}' StringSplitOptions.RemoveEmptyEntries);  			if (vals.Length >= 2) {  				comboBoxFonts.Items.Add (vals [0]);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,AddStyleCategoryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddStyleCategoryForm.cs,AddStyleCategoryForm,The following statement contains a magic number: using (StringReader r = new StringReader (File.ReadAllText (StyleLibrary.FontsetFileName))) {  	string line;  	while ((line = r.ReadLine ()) != null) {  		string[] vals = line.Split (new char[] {  			' ''  			'\t'  		}' StringSplitOptions.RemoveEmptyEntries);  		if (vals.Length >= 2) {  			comboBoxFonts.Items.Add (vals [0]);  		}  	}  }  
Magic Number,DMS.MapLibrary,AddStyleCategoryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddStyleCategoryForm.cs,AddStyleCategoryForm,The following statement contains a magic number: while ((line = r.ReadLine ()) != null) {  	string[] vals = line.Split (new char[] {  		' ''  		'\t'  	}' StringSplitOptions.RemoveEmptyEntries);  	if (vals.Length >= 2) {  		comboBoxFonts.Items.Add (vals [0]);  	}  }  
Magic Number,DMS.MapLibrary,AddStyleCategoryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\AddStyleCategoryForm.cs,AddStyleCategoryForm,The following statement contains a magic number: if (vals.Length >= 2) {  	comboBoxFonts.Items.Add (vals [0]);  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (MapUtils.HasMetadata (layer' "character-count")) {  		string charcount = layer.getMetaData ("character-count");  		int num;  		if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  			classObj classobj = layer.getClass (0);  			if (!fontSetFileContents.Contains (classobj.name)) {  				throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  			}  			for (int c = 33; c < 33 + num; c++) {  				string symbolname = classobj.name + "-" + c.ToString ();  				if (!symbolSetFileContents.Contains (symbolname)) {  					symbolObj sym = new symbolObj (symbolname' null);  					sym.character = "&#" + c.ToString () + ";";  					sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  					sym.font = classobj.name;  					sym.inmapfile = 0;  					map.symbolset.appendSymbol (sym);  					newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  				}  				if (c > 33) {  					// the first class is already inserted  					classObj class2 = classobj.clone ();  					class2.name = symbolname;  					styleObj style2 = class2.getStyle (0);  					style2.setSymbolByName (map' symbolname);  					layer.insertClass (class2' -1);  				}  				else {  					styleObj style2 = classobj.getStyle (0);  					style2.setSymbolByName (map' symbolname);  				}  			}  			if (!classobj.name.EndsWith ("-33"))  				classobj.name += "-33";  		}  		layer.removeMetaData ("character-count");  	}  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (MapUtils.HasMetadata (layer' "character-count")) {  		string charcount = layer.getMetaData ("character-count");  		int num;  		if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  			classObj classobj = layer.getClass (0);  			if (!fontSetFileContents.Contains (classobj.name)) {  				throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  			}  			for (int c = 33; c < 33 + num; c++) {  				string symbolname = classobj.name + "-" + c.ToString ();  				if (!symbolSetFileContents.Contains (symbolname)) {  					symbolObj sym = new symbolObj (symbolname' null);  					sym.character = "&#" + c.ToString () + ";";  					sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  					sym.font = classobj.name;  					sym.inmapfile = 0;  					map.symbolset.appendSymbol (sym);  					newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  				}  				if (c > 33) {  					// the first class is already inserted  					classObj class2 = classobj.clone ();  					class2.name = symbolname;  					styleObj style2 = class2.getStyle (0);  					style2.setSymbolByName (map' symbolname);  					layer.insertClass (class2' -1);  				}  				else {  					styleObj style2 = classobj.getStyle (0);  					style2.setSymbolByName (map' symbolname);  				}  			}  			if (!classobj.name.EndsWith ("-33"))  				classobj.name += "-33";  		}  		layer.removeMetaData ("character-count");  	}  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (MapUtils.HasMetadata (layer' "character-count")) {  		string charcount = layer.getMetaData ("character-count");  		int num;  		if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  			classObj classobj = layer.getClass (0);  			if (!fontSetFileContents.Contains (classobj.name)) {  				throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  			}  			for (int c = 33; c < 33 + num; c++) {  				string symbolname = classobj.name + "-" + c.ToString ();  				if (!symbolSetFileContents.Contains (symbolname)) {  					symbolObj sym = new symbolObj (symbolname' null);  					sym.character = "&#" + c.ToString () + ";";  					sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  					sym.font = classobj.name;  					sym.inmapfile = 0;  					map.symbolset.appendSymbol (sym);  					newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  				}  				if (c > 33) {  					// the first class is already inserted  					classObj class2 = classobj.clone ();  					class2.name = symbolname;  					styleObj style2 = class2.getStyle (0);  					style2.setSymbolByName (map' symbolname);  					layer.insertClass (class2' -1);  				}  				else {  					styleObj style2 = classobj.getStyle (0);  					style2.setSymbolByName (map' symbolname);  				}  			}  			if (!classobj.name.EndsWith ("-33"))  				classobj.name += "-33";  		}  		layer.removeMetaData ("character-count");  	}  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (MapUtils.HasMetadata (layer' "character-count")) {  	string charcount = layer.getMetaData ("character-count");  	int num;  	if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  		classObj classobj = layer.getClass (0);  		if (!fontSetFileContents.Contains (classobj.name)) {  			throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  		}  		for (int c = 33; c < 33 + num; c++) {  			string symbolname = classobj.name + "-" + c.ToString ();  			if (!symbolSetFileContents.Contains (symbolname)) {  				symbolObj sym = new symbolObj (symbolname' null);  				sym.character = "&#" + c.ToString () + ";";  				sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  				sym.font = classobj.name;  				sym.inmapfile = 0;  				map.symbolset.appendSymbol (sym);  				newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  			}  			if (c > 33) {  				// the first class is already inserted  				classObj class2 = classobj.clone ();  				class2.name = symbolname;  				styleObj style2 = class2.getStyle (0);  				style2.setSymbolByName (map' symbolname);  				layer.insertClass (class2' -1);  			}  			else {  				styleObj style2 = classobj.getStyle (0);  				style2.setSymbolByName (map' symbolname);  			}  		}  		if (!classobj.name.EndsWith ("-33"))  			classobj.name += "-33";  	}  	layer.removeMetaData ("character-count");  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (MapUtils.HasMetadata (layer' "character-count")) {  	string charcount = layer.getMetaData ("character-count");  	int num;  	if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  		classObj classobj = layer.getClass (0);  		if (!fontSetFileContents.Contains (classobj.name)) {  			throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  		}  		for (int c = 33; c < 33 + num; c++) {  			string symbolname = classobj.name + "-" + c.ToString ();  			if (!symbolSetFileContents.Contains (symbolname)) {  				symbolObj sym = new symbolObj (symbolname' null);  				sym.character = "&#" + c.ToString () + ";";  				sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  				sym.font = classobj.name;  				sym.inmapfile = 0;  				map.symbolset.appendSymbol (sym);  				newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  			}  			if (c > 33) {  				// the first class is already inserted  				classObj class2 = classobj.clone ();  				class2.name = symbolname;  				styleObj style2 = class2.getStyle (0);  				style2.setSymbolByName (map' symbolname);  				layer.insertClass (class2' -1);  			}  			else {  				styleObj style2 = classobj.getStyle (0);  				style2.setSymbolByName (map' symbolname);  			}  		}  		if (!classobj.name.EndsWith ("-33"))  			classobj.name += "-33";  	}  	layer.removeMetaData ("character-count");  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (MapUtils.HasMetadata (layer' "character-count")) {  	string charcount = layer.getMetaData ("character-count");  	int num;  	if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  		classObj classobj = layer.getClass (0);  		if (!fontSetFileContents.Contains (classobj.name)) {  			throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  		}  		for (int c = 33; c < 33 + num; c++) {  			string symbolname = classobj.name + "-" + c.ToString ();  			if (!symbolSetFileContents.Contains (symbolname)) {  				symbolObj sym = new symbolObj (symbolname' null);  				sym.character = "&#" + c.ToString () + ";";  				sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  				sym.font = classobj.name;  				sym.inmapfile = 0;  				map.symbolset.appendSymbol (sym);  				newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  			}  			if (c > 33) {  				// the first class is already inserted  				classObj class2 = classobj.clone ();  				class2.name = symbolname;  				styleObj style2 = class2.getStyle (0);  				style2.setSymbolByName (map' symbolname);  				layer.insertClass (class2' -1);  			}  			else {  				styleObj style2 = classobj.getStyle (0);  				style2.setSymbolByName (map' symbolname);  			}  		}  		if (!classobj.name.EndsWith ("-33"))  			classobj.name += "-33";  	}  	layer.removeMetaData ("character-count");  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  	classObj classobj = layer.getClass (0);  	if (!fontSetFileContents.Contains (classobj.name)) {  		throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  	}  	for (int c = 33; c < 33 + num; c++) {  		string symbolname = classobj.name + "-" + c.ToString ();  		if (!symbolSetFileContents.Contains (symbolname)) {  			symbolObj sym = new symbolObj (symbolname' null);  			sym.character = "&#" + c.ToString () + ";";  			sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  			sym.font = classobj.name;  			sym.inmapfile = 0;  			map.symbolset.appendSymbol (sym);  			newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  		}  		if (c > 33) {  			// the first class is already inserted  			classObj class2 = classobj.clone ();  			class2.name = symbolname;  			styleObj style2 = class2.getStyle (0);  			style2.setSymbolByName (map' symbolname);  			layer.insertClass (class2' -1);  		}  		else {  			styleObj style2 = classobj.getStyle (0);  			style2.setSymbolByName (map' symbolname);  		}  	}  	if (!classobj.name.EndsWith ("-33"))  		classobj.name += "-33";  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  	classObj classobj = layer.getClass (0);  	if (!fontSetFileContents.Contains (classobj.name)) {  		throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  	}  	for (int c = 33; c < 33 + num; c++) {  		string symbolname = classobj.name + "-" + c.ToString ();  		if (!symbolSetFileContents.Contains (symbolname)) {  			symbolObj sym = new symbolObj (symbolname' null);  			sym.character = "&#" + c.ToString () + ";";  			sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  			sym.font = classobj.name;  			sym.inmapfile = 0;  			map.symbolset.appendSymbol (sym);  			newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  		}  		if (c > 33) {  			// the first class is already inserted  			classObj class2 = classobj.clone ();  			class2.name = symbolname;  			styleObj style2 = class2.getStyle (0);  			style2.setSymbolByName (map' symbolname);  			layer.insertClass (class2' -1);  		}  		else {  			styleObj style2 = classobj.getStyle (0);  			style2.setSymbolByName (map' symbolname);  		}  	}  	if (!classobj.name.EndsWith ("-33"))  		classobj.name += "-33";  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (layer.numclasses == 1 && charcount != null && int.TryParse (charcount' out num)) {  	classObj classobj = layer.getClass (0);  	if (!fontSetFileContents.Contains (classobj.name)) {  		throw new Exception ("Invalid font reference in mmstyles.map: " + classobj.name + ". The fontset file should contain an entry for this font name.");  	}  	for (int c = 33; c < 33 + num; c++) {  		string symbolname = classobj.name + "-" + c.ToString ();  		if (!symbolSetFileContents.Contains (symbolname)) {  			symbolObj sym = new symbolObj (symbolname' null);  			sym.character = "&#" + c.ToString () + ";";  			sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  			sym.font = classobj.name;  			sym.inmapfile = 0;  			map.symbolset.appendSymbol (sym);  			newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  		}  		if (c > 33) {  			// the first class is already inserted  			classObj class2 = classobj.clone ();  			class2.name = symbolname;  			styleObj style2 = class2.getStyle (0);  			style2.setSymbolByName (map' symbolname);  			layer.insertClass (class2' -1);  		}  		else {  			styleObj style2 = classobj.getStyle (0);  			style2.setSymbolByName (map' symbolname);  		}  	}  	if (!classobj.name.EndsWith ("-33"))  		classobj.name += "-33";  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: for (int c = 33; c < 33 + num; c++) {  	string symbolname = classobj.name + "-" + c.ToString ();  	if (!symbolSetFileContents.Contains (symbolname)) {  		symbolObj sym = new symbolObj (symbolname' null);  		sym.character = "&#" + c.ToString () + ";";  		sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  		sym.font = classobj.name;  		sym.inmapfile = 0;  		map.symbolset.appendSymbol (sym);  		newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  	}  	if (c > 33) {  		// the first class is already inserted  		classObj class2 = classobj.clone ();  		class2.name = symbolname;  		styleObj style2 = class2.getStyle (0);  		style2.setSymbolByName (map' symbolname);  		layer.insertClass (class2' -1);  	}  	else {  		styleObj style2 = classobj.getStyle (0);  		style2.setSymbolByName (map' symbolname);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: for (int c = 33; c < 33 + num; c++) {  	string symbolname = classobj.name + "-" + c.ToString ();  	if (!symbolSetFileContents.Contains (symbolname)) {  		symbolObj sym = new symbolObj (symbolname' null);  		sym.character = "&#" + c.ToString () + ";";  		sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  		sym.font = classobj.name;  		sym.inmapfile = 0;  		map.symbolset.appendSymbol (sym);  		newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  	}  	if (c > 33) {  		// the first class is already inserted  		classObj class2 = classobj.clone ();  		class2.name = symbolname;  		styleObj style2 = class2.getStyle (0);  		style2.setSymbolByName (map' symbolname);  		layer.insertClass (class2' -1);  	}  	else {  		styleObj style2 = classobj.getStyle (0);  		style2.setSymbolByName (map' symbolname);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: for (int c = 33; c < 33 + num; c++) {  	string symbolname = classobj.name + "-" + c.ToString ();  	if (!symbolSetFileContents.Contains (symbolname)) {  		symbolObj sym = new symbolObj (symbolname' null);  		sym.character = "&#" + c.ToString () + ";";  		sym.type = (int)MS_SYMBOL_TYPE.MS_SYMBOL_TRUETYPE;  		sym.font = classobj.name;  		sym.inmapfile = 0;  		map.symbolset.appendSymbol (sym);  		newSymbols.Append (String.Format ("SYMBOL{0}  NAME \"{1}\"{0}  TYPE TRUETYPE{0}  ANTIALIAS TRUE{0}  CHARACTER \"{2}\"{0}  FONT \"{3}\"{0}END{0}"' Environment.NewLine' symbolname' sym.character' sym.font));  	}  	if (c > 33) {  		// the first class is already inserted  		classObj class2 = classobj.clone ();  		class2.name = symbolname;  		styleObj style2 = class2.getStyle (0);  		style2.setSymbolByName (map' symbolname);  		layer.insertClass (class2' -1);  	}  	else {  		styleObj style2 = classobj.getStyle (0);  		style2.setSymbolByName (map' symbolname);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibrary,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibrary.cs,ExpandFontStyles,The following statement contains a magic number: if (c > 33) {  	// the first class is already inserted  	classObj class2 = classobj.clone ();  	class2.name = symbolname;  	styleObj style2 = class2.getStyle (0);  	style2.setSymbolByName (map' symbolname);  	layer.insertClass (class2' -1);  }  else {  	styleObj style2 = classobj.getStyle (0);  	style2.setSymbolByName (map' symbolname);  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  			styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxPreview.Image = Image.FromStream (ms);  			}  		}  	}  }  else  	pictureBoxPreview.Image = null;  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  			styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxPreview.Image = Image.FromStream (ms);  			}  		}  	}  }  else  	pictureBoxPreview.Image = null;  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  			styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxPreview.Image = Image.FromStream (ms);  			}  		}  	}  }  else  	pictureBoxPreview.Image = null;  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  			styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxPreview.Image = Image.FromStream (ms);  			}  		}  	}  }  else  	pictureBoxPreview.Image = null;  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  		styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxPreview.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  		styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxPreview.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  		styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxPreview.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  		styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxPreview.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  	styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxPreview.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  	styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxPreview.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  	styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxPreview.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxPreview.Width' pictureBoxPreview.Height)) {  	styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxPreview.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StyleLibraryPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryPropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' pictureBoxPreview.Width - 10' pictureBoxPreview.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_POINT) {  	// apply magnification for point styles  	style.size = size * trackBarMagnify.Value / 4;  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: style.size = size * trackBarMagnify.Value / 4;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: try {  	using (classObj def_class = new classObj (null))// for drawing legend image  	 {  		using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  			classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxSample.Image = Image.FromStream (ms);  			}  		}  	}  }  finally {  	style.size = size;  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: try {  	using (classObj def_class = new classObj (null))// for drawing legend image  	 {  		using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  			classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxSample.Image = Image.FromStream (ms);  			}  		}  	}  }  finally {  	style.size = size;  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend image   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  		classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxSample.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend image   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  		classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxSample.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  	classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxSample.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  	classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxSample.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,UpdateSample,The following statement contains a magic number: classobj.drawLegendIcon (map' layer' pictureBoxSample.Width' pictureBoxSample.Height' image2' 5' 5);  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonSave_Click,The following statement contains a magic number: try {  	if (tabControl.SelectedIndex == 3) {  		SaveFontset ();  	}  	else {  		SaveAll ();  		MessageBox.Show ("Style library was saved successfully!"' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Information);  		SetStyleLibModified (false);  	}  }  catch (Exception ex) {  	MessageBox.Show (ex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,buttonSave_Click,The following statement contains a magic number: if (tabControl.SelectedIndex == 3) {  	SaveFontset ();  }  else {  	SaveAll ();  	MessageBox.Show ("Style library was saved successfully!"' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Information);  	SetStyleLibModified (false);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,trackBarMagnify_Scroll,The following statement contains a magic number: labelPercent.Text = Convert.ToString (trackBarMagnify.Value * 25) + "%";  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMargins,The following statement contains a magic number: scintillaControl.Margins.Margin0.Width = scintillaControl.NativeInterface.TextWidth (33' scintillaControl.Lines.Count.ToString ()) + 6;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMargins,The following statement contains a magic number: scintillaControl.Margins.Margin0.Width = scintillaControl.NativeInterface.TextWidth (33' scintillaControl.Lines.Count.ToString ()) + 6;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMargins,The following statement contains a magic number: scintillaControl.Margins.Margin2.Width = 20;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMarginsSymbolset,The following statement contains a magic number: scintillaControlSymbolset.Margins.Margin0.Width = scintillaControlSymbolset.NativeInterface.TextWidth (33' scintillaControlSymbolset.Lines.Count.ToString ()) + 6;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMarginsSymbolset,The following statement contains a magic number: scintillaControlSymbolset.Margins.Margin0.Width = scintillaControlSymbolset.NativeInterface.TextWidth (33' scintillaControlSymbolset.Lines.Count.ToString ()) + 6;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,SetMarginsSymbolset,The following statement contains a magic number: scintillaControlSymbolset.Margins.Margin2.Width = 20;  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 0) {  	scrollPos = scintillaControl.Lines.FirstVisible.Number;  	caretPos = scintillaControl.Caret.Position;  	ValidateTextContents ();  	buttonSave.Enabled = styleLibraryChanged;  }  else if (tabControl.SelectedIndex == 1) {  	string txt = StyleLibrary.LoadTextContents ();  	if (scintillaControl.Text != txt) {  		isInitStyleLibText = true;  		scintillaControl.Text = txt;  		SetMargins ();  		if (caretPos > 0) {  			scintillaControl.Selection.Start = caretPos;  			scintillaControl.Caret.Position = caretPos;  		}  		if (scrollPos > 0)  			scintillaControl.Scrolling.ScrollBy (0' scrollPos);  		textChanged = false;  		isInitStyleLibText = false;  	}  	scintillaControl.Focus ();  	textChanged = false;  	buttonSave.Enabled = styleLibraryChanged;  }  else if (tabControl.SelectedIndex == 2) {  	buttonSave.Enabled = false;  }  else if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 0) {  	scrollPos = scintillaControl.Lines.FirstVisible.Number;  	caretPos = scintillaControl.Caret.Position;  	ValidateTextContents ();  	buttonSave.Enabled = styleLibraryChanged;  }  else if (tabControl.SelectedIndex == 1) {  	string txt = StyleLibrary.LoadTextContents ();  	if (scintillaControl.Text != txt) {  		isInitStyleLibText = true;  		scintillaControl.Text = txt;  		SetMargins ();  		if (caretPos > 0) {  			scintillaControl.Selection.Start = caretPos;  			scintillaControl.Caret.Position = caretPos;  		}  		if (scrollPos > 0)  			scintillaControl.Scrolling.ScrollBy (0' scrollPos);  		textChanged = false;  		isInitStyleLibText = false;  	}  	scintillaControl.Focus ();  	textChanged = false;  	buttonSave.Enabled = styleLibraryChanged;  }  else if (tabControl.SelectedIndex == 2) {  	buttonSave.Enabled = false;  }  else if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 1) {  	string txt = StyleLibrary.LoadTextContents ();  	if (scintillaControl.Text != txt) {  		isInitStyleLibText = true;  		scintillaControl.Text = txt;  		SetMargins ();  		if (caretPos > 0) {  			scintillaControl.Selection.Start = caretPos;  			scintillaControl.Caret.Position = caretPos;  		}  		if (scrollPos > 0)  			scintillaControl.Scrolling.ScrollBy (0' scrollPos);  		textChanged = false;  		isInitStyleLibText = false;  	}  	scintillaControl.Focus ();  	textChanged = false;  	buttonSave.Enabled = styleLibraryChanged;  }  else if (tabControl.SelectedIndex == 2) {  	buttonSave.Enabled = false;  }  else if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 1) {  	string txt = StyleLibrary.LoadTextContents ();  	if (scintillaControl.Text != txt) {  		isInitStyleLibText = true;  		scintillaControl.Text = txt;  		SetMargins ();  		if (caretPos > 0) {  			scintillaControl.Selection.Start = caretPos;  			scintillaControl.Caret.Position = caretPos;  		}  		if (scrollPos > 0)  			scintillaControl.Scrolling.ScrollBy (0' scrollPos);  		textChanged = false;  		isInitStyleLibText = false;  	}  	scintillaControl.Focus ();  	textChanged = false;  	buttonSave.Enabled = styleLibraryChanged;  }  else if (tabControl.SelectedIndex == 2) {  	buttonSave.Enabled = false;  }  else if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 2) {  	buttonSave.Enabled = false;  }  else if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 2) {  	buttonSave.Enabled = false;  }  else if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex == 3) {  	buttonSave.Enabled = false;  	buttonAddFont.Visible = true;  	buttonRemoveFont.Visible = true;  	buttonRemoveFont.Enabled = (listViewFonts.SelectedItems.Count > 0);  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,tabControl_SelectedIndexChanged,The following statement contains a magic number: if (tabControl.SelectedIndex != 3 && fontsetChanged) {  	if (MessageBox.Show ("Do you wish to save the modifications of the symbolset?"' "MapManager"' MessageBoxButtons.YesNoCancel' MessageBoxIcon.Question) == DialogResult.Yes) {  		SaveFontset ();  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,LoadFontset,The following statement contains a magic number: if (StyleLibrary.FontsetFileName != null) {  	using (StringReader r = new StringReader (File.ReadAllText (StyleLibrary.FontsetFileName))) {  		string line;  		while ((line = r.ReadLine ()) != null) {  			string[] vals = line.Split (new char[] {  				' ''  				'\t'  			}' StringSplitOptions.RemoveEmptyEntries);  			if (vals.Length >= 2) {  				ListViewItem item = new ListViewItem (vals [0]);  				item.SubItems.Add (vals [1]);  				listViewFonts.Items.Add (item);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,LoadFontset,The following statement contains a magic number: using (StringReader r = new StringReader (File.ReadAllText (StyleLibrary.FontsetFileName))) {  	string line;  	while ((line = r.ReadLine ()) != null) {  		string[] vals = line.Split (new char[] {  			' ''  			'\t'  		}' StringSplitOptions.RemoveEmptyEntries);  		if (vals.Length >= 2) {  			ListViewItem item = new ListViewItem (vals [0]);  			item.SubItems.Add (vals [1]);  			listViewFonts.Items.Add (item);  		}  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,LoadFontset,The following statement contains a magic number: while ((line = r.ReadLine ()) != null) {  	string[] vals = line.Split (new char[] {  		' ''  		'\t'  	}' StringSplitOptions.RemoveEmptyEntries);  	if (vals.Length >= 2) {  		ListViewItem item = new ListViewItem (vals [0]);  		item.SubItems.Add (vals [1]);  		listViewFonts.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,StyleLibraryForm,C:\repos\DMS-Aus_MapManager\MapLibrary\StyleLibraryForm.cs,LoadFontset,The following statement contains a magic number: if (vals.Length >= 2) {  	ListViewItem item = new ListViewItem (vals [0]);  	item.SubItems.Add (vals [1]);  	listViewFonts.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,CreateLayerTheme,The following statement contains a magic number: if (checkBoxKeepStyles.Checked) {  	classobj = layer.getClass (0).clone ();  	classobj.setExpression ("");  	// remove expression to have the class shown  	// bindings are not supported with sample maps  	for (int s = 0; s < classobj.numstyles; s++)  		StyleBindingController.RemoveAllBindings (classobj.getStyle (s));  	for (int l = 0; l < classobj.numlabels; l++)  		LabelBindingController.RemoveAllBindings (classobj.getLabel (l));  	newLayer.insertClass (classobj' -1);  }  else {  	classobj = new classObj (newLayer);  	classobj.name = MapUtils.GetClassName (newLayer);  	styleObj style = new styleObj (classobj);  	style.size = 8;  	// set default size (#4339)   	if (layer.type == MS_LAYER_TYPE.MS_LAYER_POINT) {  		// initialize with the default marker if specified in the symbol file for point symbols  		symbolObj symbol;  		for (int s = 0; s < map.symbolset.numsymbols; s++) {  			symbol = map.symbolset.getSymbol (s);  			if (symbol.name == "default-marker") {  				style.symbol = s;  				style.symbolname = "default-marker";  				break;  			}  		}  	}  	MapUtils.SetDefaultColor (layer.type' style);  }  
Magic Number,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,CreateLayerTheme,The following statement contains a magic number: style.size = 8;  
Magic Number,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,CreateLayerTheme,The following statement contains a magic number: for (int i = 0; i < classes; i++) {  	double percent = ((double)(i + 1)) / classes * 100;  	// creating the corresponding class object  	if (i > 0) {  		classobj = classobj.clone ();  		// bindings are not supported with sample maps  		for (int s = 0; s < classobj.numstyles; s++)  			StyleBindingController.RemoveAllBindings (classobj.getStyle (s));  		for (int l = 0; l < classobj.numlabels; l++)  			LabelBindingController.RemoveAllBindings (classobj.getLabel (l));  		newLayer.insertClass (classobj' -1);  	}  	classobj.name = breaks [i].ToString (ni) + " - " + breaks [i + 1].ToString (ni);  	classobj.setExpression ("(([" + comboBoxColumns.SelectedItem + "] >= " + breaks [i].ToString (ni) + ") && ([" + comboBoxColumns.SelectedItem + "] <= " + breaks [i + 1].ToString (ni) + "))");  	for (int j = 0; j < classobj.numstyles; j++) {  		styleObj style = classobj.getStyle (j);  		style.color = colorRampPickerColor.GetMapColorAtValue (percent);  		style.outlinecolor = colorRampPickerOutlineColor.GetMapColorAtValue (percent);  		style.backgroundcolor = colorRampPickerBackgroundColor.GetMapColorAtValue (percent);  		if (checkBoxFirstOnly.Checked)  			break;  	}  }  
Magic Number,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,SelectPage,The following statement contains a magic number: if (page >= 2) {  	WizardPage2.BringToFront ();  	UpdateThemeView ();  }  else {  	WizardPage1.BringToFront ();  }  
Magic Number,DMS.MapLibrary,RangeTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\RangeTheme.cs,GetPageCount,The following statement contains a magic number: return 2;  
Magic Number,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,GetDataString,The following statement contains a magic number: if (comboBoxDataTable.Text.StartsWith ("dbo."))  	s.Append (comboBoxDataTable.Text.Substring (4));  else  	s.Append (comboBoxDataTable.Text);  
Magic Number,DMS.MapLibrary,SqlConnectionDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\SqlConnectionDialog.cs,GetDataString,The following statement contains a magic number: s.Append (comboBoxDataTable.Text.Substring (4));  
Magic Number,DMS.MapLibrary,FontsetPicker,C:\repos\DMS-Aus_MapManager\MapLibrary\FontsetPicker.cs,FontsetPicker,The following statement contains a magic number: PaintValueWidth = 40;  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The following statement contains a magic number: if (checkBoxKeepStyles.Checked) {  	classobj = layer.getClass (0).clone ();  	classobj.setExpression ("");  	// remove expression to have the class shown  	// bindings are not supported with sample maps  	for (int s = 0; s < classobj.numstyles; s++)  		StyleBindingController.RemoveAllBindings (classobj.getStyle (s));  	for (int l = 0; l < classobj.numlabels; l++)  		LabelBindingController.RemoveAllBindings (classobj.getLabel (l));  	newLayer.insertClass (classobj' -1);  }  else {  	classobj = new classObj (newLayer);  	classobj.name = MapUtils.GetClassName (newLayer);  	styleObj style = new styleObj (classobj);  	style.size = 8;  	// set default size (#4339)  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_POINT) {  		// initialize with the default marker if specified in the symbol file for point symbols  		symbolObj symbol;  		for (int s = 0; s < map.symbolset.numsymbols; s++) {  			symbol = map.symbolset.getSymbol (s);  			if (symbol.name == "default-marker") {  				style.symbol = s;  				style.symbolname = "default-marker";  				break;  			}  		}  	}  	MapUtils.SetDefaultColor (layer.type' style);  }  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The following statement contains a magic number: style.size = 8;  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The following statement contains a magic number: while ((shape = layer.nextShape ()) != null) {  	string value = shape.getValue (comboBoxColumns.SelectedIndex);  	if (checkBoxZero.Checked && (value == "" || value == ""))  		continue;  	if (!items.ContainsValue (value)) {  		if (i == 100) {  			if (MessageBox.Show ("The number of the individual values is greater than 100 would you like to continue?"' "MapManager"' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation) == DialogResult.Cancel) {  				break;  			}  		}  		items.Add (value' value);  		++i;  	}  }  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The following statement contains a magic number: if (!items.ContainsValue (value)) {  	if (i == 100) {  		if (MessageBox.Show ("The number of the individual values is greater than 100 would you like to continue?"' "MapManager"' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation) == DialogResult.Cancel) {  			break;  		}  	}  	items.Add (value' value);  	++i;  }  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The following statement contains a magic number: if (i == 100) {  	if (MessageBox.Show ("The number of the individual values is greater than 100 would you like to continue?"' "MapManager"' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation) == DialogResult.Cancel) {  		break;  	}  }  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,CreateLayerTheme,The following statement contains a magic number: foreach (string value in items.Keys) {  	double percent = ((double)(i + 1)) / items.Count * 100;  	// creating the corresponding class object  	if (i > 0) {  		classobj = classobj.clone ();  		// bindings are not supported with sample maps  		for (int s = 0; s < classobj.numstyles; s++)  			StyleBindingController.RemoveAllBindings (classobj.getStyle (s));  		for (int l = 0; l < classobj.numlabels; l++)  			LabelBindingController.RemoveAllBindings (classobj.getLabel (l));  		newLayer.insertClass (classobj' -1);  	}  	classobj.name = value;  	if (checkBoxClassItem.Checked)  		classobj.setExpression (value);  	else  		classobj.setExpression ("('[" + comboBoxColumns.SelectedItem + "]' = '" + value + "')");  	for (int j = 0; j < classobj.numstyles; j++) {  		styleObj style = classobj.getStyle (j);  		style.color = colorRampPickerColor.GetMapColorAtValue (percent);  		style.outlinecolor = colorRampPickerOutlineColor.GetMapColorAtValue (percent);  		style.backgroundcolor = colorRampPickerBackgroundColor.GetMapColorAtValue (percent);  		if (checkBoxFirstOnly.Checked)  			break;  	}  	++i;  }  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,SelectPage,The following statement contains a magic number: if (page >= 2) {  	WizardPage2.BringToFront ();  	UpdateThemeView ();  }  else {  	WizardPage1.BringToFront ();  }  
Magic Number,DMS.MapLibrary,IndividualValuesTheme,C:\repos\DMS-Aus_MapManager\MapLibrary\IndividualValuesTheme.cs,GetPageCount,The following statement contains a magic number: return 2;  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		ListViewItem item = new ListViewItem (new string[] {  			""'  			style.size.ToString ()'  			style.width.ToString ()'  			style.symbolname  		});  		item.ImageIndex = imageList.Images.Count - 1;  		item.Tag = style;  		listViewStyles.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		ListViewItem item = new ListViewItem (new string[] {  			""'  			style.size.ToString ()'  			style.width.ToString ()'  			style.symbolname  		});  		item.ImageIndex = imageList.Images.Count - 1;  		item.Tag = style;  		listViewStyles.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		ListViewItem item = new ListViewItem (new string[] {  			""'  			style.size.ToString ()'  			style.width.ToString ()'  			style.symbolname  		});  		item.ImageIndex = imageList.Images.Count - 1;  		item.Tag = style;  		listViewStyles.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		ListViewItem item = new ListViewItem (new string[] {  			""'  			style.size.ToString ()'  			style.width.ToString ()'  			style.symbolname  		});  		item.ImageIndex = imageList.Images.Count - 1;  		item.Tag = style;  		listViewStyles.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		ListViewItem item = new ListViewItem (new string[] {  			""'  			style.size.ToString ()'  			style.width.ToString ()'  			style.symbolname  		});  		item.ImageIndex = imageList.Images.Count - 1;  		item.Tag = style;  		listViewStyles.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		ListViewItem item = new ListViewItem (new string[] {  			""'  			style.size.ToString ()'  			style.width.ToString ()'  			style.symbolname  		});  		item.ImageIndex = imageList.Images.Count - 1;  		item.Tag = style;  		listViewStyles.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	ListViewItem item = new ListViewItem (new string[] {  		""'  		style.size.ToString ()'  		style.width.ToString ()'  		style.symbolname  	});  	item.ImageIndex = imageList.Images.Count - 1;  	item.Tag = style;  	listViewStyles.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	ListViewItem item = new ListViewItem (new string[] {  		""'  		style.size.ToString ()'  		style.width.ToString ()'  		style.symbolname  	});  	item.ImageIndex = imageList.Images.Count - 1;  	item.Tag = style;  	listViewStyles.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	ListViewItem item = new ListViewItem (new string[] {  		""'  		style.size.ToString ()'  		style.width.ToString ()'  		style.symbolname  	});  	item.ImageIndex = imageList.Images.Count - 1;  	item.Tag = style;  	listViewStyles.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	ListViewItem item = new ListViewItem (new string[] {  		""'  		style.size.ToString ()'  		style.width.ToString ()'  		style.symbolname  	});  	item.ImageIndex = imageList.Images.Count - 1;  	item.Tag = style;  	listViewStyles.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	ListViewItem item = new ListViewItem (new string[] {  		""'  		style.size.ToString ()'  		style.width.ToString ()'  		style.symbolname  	});  	item.ImageIndex = imageList.Images.Count - 1;  	item.Tag = style;  	listViewStyles.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	ListViewItem item = new ListViewItem (new string[] {  		""'  		style.size.ToString ()'  		style.width.ToString ()'  		style.symbolname  	});  	item.ImageIndex = imageList.Images.Count - 1;  	item.Tag = style;  	listViewStyles.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,AddStyleToList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			string geomtransform = style.getGeomTransform ().ToLower ();  			if (geomtransform != null) {  				if (geomtransform.Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (geomtransform.Contains ("labelpnt"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			}  			styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images [item.ImageIndex] = Image.FromStream (ms);  		}  		item.SubItems [1].Text = style.size.ToString ();  		item.SubItems [2].Text = style.width.ToString ();  		item.SubItems [3].Text = style.symbolname;  	}  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map' layer' 30' 20)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		string geomtransform = style.getGeomTransform ().ToLower ();  		if (geomtransform != null) {  			if (geomtransform.Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (geomtransform.Contains ("labelpnt"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		}  		styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images [item.ImageIndex] = Image.FromStream (ms);  	}  	item.SubItems [1].Text = style.size.ToString ();  	item.SubItems [2].Text = style.width.ToString ();  	item.SubItems [3].Text = style.symbolname;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	string geomtransform = style.getGeomTransform ().ToLower ();  	if (geomtransform != null) {  		if (geomtransform.Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (geomtransform.Contains ("labelpnt"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	}  	styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: styleclass.drawLegendIcon (map' layer' 20' 10' image2' 5' 5);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: item.SubItems [2].Text = style.width.ToString ();  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,UpdateStyleInList,The following statement contains a magic number: item.SubItems [3].Text = style.symbolname;  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,RefreshStyles,The following statement contains a magic number: imageList.ImageSize = new Size (30' 20);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,RefreshStyles,The following statement contains a magic number: imageList.ImageSize = new Size (30' 20);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,buttonAddStyle_Click,The following statement contains a magic number: style.color = new colorObj (0' 0' 0' 255);  
Magic Number,DMS.MapLibrary,LabelPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\LabelPropertyEditor.cs,buttonAddStyle_Click,The following statement contains a magic number: style.size = 8;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,LayerControl,The following statement contains a magic number: legendIconSize = new Size (30' 20);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,LayerControl,The following statement contains a magic number: legendIconSize = new Size (30' 20);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,LayerControl,The following statement contains a magic number: legendDrawingSize = new Size (20' 10);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,LayerControl,The following statement contains a magic number: legendDrawingSize = new Size (20' 10);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,LayerControl,The following statement contains a magic number: legendIconPadding = new Padding (5);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: try {  	// trying to open the layer  	layer = CreateNewLayer ();  	layer.connection = fileName;  	layer.connectiontype = MS_CONNECTION_TYPE.MS_OGR;  	layer.name = MapUtils.GetUniqueLayerName (map' Path.GetFileNameWithoutExtension (fileName)' 0);  	layer.setProjection ("+AUTO");  	layer.data = null;  	layer.status = mapscript.MS_OFF;  	layer.template = "query.html";  	MapUtils.CreateRandomClass (layer);  	//MapUtils.InitializeDefaultLabel(layer);  	// setting auto style for the mapinfo layers  	string ext = Path.GetExtension (fileName).Trim ().ToLower ();  	if (ext == ".tab" || ext == ".mif")  		layer.styleitem = "AUTO";  	layer.open ();  	layer.close ();  	// try to find out the shape type using OGR  	Ogr.RegisterAll ();  	DataSource ds = Ogr.Open (layer.connection' 0);  	if (ds != null) {  		if (ds.GetLayerCount () > 0) {  			Layer ogrLayer;  			if (layer.data != null)  				ogrLayer = ds.GetLayerByName (layer.data);  			else  				ogrLayer = ds.GetLayerByIndex (0);  			wkbGeometryType gType = ogrLayer.GetLayerDefn ().GetGeomType ();  			if (gType != wkbGeometryType.wkbUnknown)  				layer.type = MapUtils.GetLayerType (gType);  			int tileFieldIndex = ogrLayer.GetLayerDefn ().GetFieldIndex ("location");  			if (tileFieldIndex < 0) {  				// Prompt for the index  				FieldSelectionForm form = new FieldSelectionForm (layer' "Select the field for the file locations");  				if (form.ShowDialog (this) == DialogResult.OK) {  					tileFieldIndex = ogrLayer.GetLayerDefn ().GetFieldIndex (form.SelectedItem);  					layer.tileitem = form.SelectedItem;  				}  			}  			Feature feat;  			while ((feat = ogrLayer.GetNextFeature ()) != null) {  				string basePath = "";  				string tileFile = feat.GetFieldAsString (tileFieldIndex);  				// separate source and layer  				string[] src = tileFile.Split (new char[] {  					'''  				});  				if (!File.Exists (src [0])) {  					if (map.shapepath != "" && File.Exists (map.shapepath + "\\" + src [0]))  						basePath = map.shapepath + "\\";  					else if (map.mappath != "" && File.Exists (map.mappath + "\\" + src [0]))  						basePath = map.mappath + "\\";  					else  						throw new Exception ("File fot found: " + src [0] + ". If your tile file contains relative pathes try to set SHAPEPATH to the base directory.");  				}  				// trying to open as vector data source  				DataSource ds2 = Ogr.Open (basePath + src [0]' 0);  				if (ds2 == null) {  					// trying to open as raster data source  					Dataset ds3 = Gdal.Open (basePath + src [0]' Access.GA_ReadOnly);  					if (ds3 == null)  						throw new Exception ("Can't open data source: " + src [0] + ".");  					// successfully opened  					layer.type = MS_LAYER_TYPE.MS_LAYER_RASTER;  					layer.styleitem = null;  					// TODO: check for SRS entry (if upgrading to Mapserver 6.4)  					ds3.Dispose ();  				}  				else {  					try {  						// find out geometry type  						if (gType == wkbGeometryType.wkbUnknown) {  							Geometry geom = feat.GetGeometryRef ();  							if (geom != null)  								gType = geom.GetGeometryType ();  							layer.type = MapUtils.GetLayerType (gType);  						}  						feat.Dispose ();  						Layer l;  						if (src.Length == 2) {  							int layerIndex;  							if (int.TryParse (src [1]' out layerIndex))  								l = ds2.GetLayerByIndex (layerIndex);  							else  								l = ds2.GetLayerByName (src [1]);  						}  						else  							l = ds2.GetLayerByIndex (0);  						if (l == null) {  							throw new Exception ("Can't open layer: " + tileFile + ".");  						}  						else  							l.Dispose ();  					}  					finally {  						ds2.Dispose ();  					}  				}  			}  		}  		ds.Dispose ();  	}  	if (layer.styleitem != "AUTO") {  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_POINT) {  			// initialize with the default marker if specified in the symbol file for point symbols  			symbolObj symbol;  			for (int i = 0; i < map.symbolset.numsymbols; i++) {  				symbol = map.symbolset.getSymbol (i);  				if (symbol.name == "default-marker") {  					layer.getClass (0).getStyle (0).symbol = i;  					layer.getClass (0).getStyle (0).symbolname = "default-marker";  					break;  				}  			}  		}  		// setting the default color  		styleObj style = layer.getClass (0).getStyle (0);  		MapUtils.SetDefaultColor (layer.type' style);  	}  	// setting up the selected layer  	selected = new MapObjectHolder (layer' target.GetParent ());  }  catch (Exception ex) {  	MessageBox.Show ("Unable to open layer' " + ex.Message' "MapManager"' MessageBoxButtons.OK' MessageBoxIcon.Error);  	if (layer != null) {  		if (layer.map != null)  			layer.map.removeLayer (layer.index);  		layer = null;  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: if (ds != null) {  	if (ds.GetLayerCount () > 0) {  		Layer ogrLayer;  		if (layer.data != null)  			ogrLayer = ds.GetLayerByName (layer.data);  		else  			ogrLayer = ds.GetLayerByIndex (0);  		wkbGeometryType gType = ogrLayer.GetLayerDefn ().GetGeomType ();  		if (gType != wkbGeometryType.wkbUnknown)  			layer.type = MapUtils.GetLayerType (gType);  		int tileFieldIndex = ogrLayer.GetLayerDefn ().GetFieldIndex ("location");  		if (tileFieldIndex < 0) {  			// Prompt for the index  			FieldSelectionForm form = new FieldSelectionForm (layer' "Select the field for the file locations");  			if (form.ShowDialog (this) == DialogResult.OK) {  				tileFieldIndex = ogrLayer.GetLayerDefn ().GetFieldIndex (form.SelectedItem);  				layer.tileitem = form.SelectedItem;  			}  		}  		Feature feat;  		while ((feat = ogrLayer.GetNextFeature ()) != null) {  			string basePath = "";  			string tileFile = feat.GetFieldAsString (tileFieldIndex);  			// separate source and layer  			string[] src = tileFile.Split (new char[] {  				'''  			});  			if (!File.Exists (src [0])) {  				if (map.shapepath != "" && File.Exists (map.shapepath + "\\" + src [0]))  					basePath = map.shapepath + "\\";  				else if (map.mappath != "" && File.Exists (map.mappath + "\\" + src [0]))  					basePath = map.mappath + "\\";  				else  					throw new Exception ("File fot found: " + src [0] + ". If your tile file contains relative pathes try to set SHAPEPATH to the base directory.");  			}  			// trying to open as vector data source  			DataSource ds2 = Ogr.Open (basePath + src [0]' 0);  			if (ds2 == null) {  				// trying to open as raster data source  				Dataset ds3 = Gdal.Open (basePath + src [0]' Access.GA_ReadOnly);  				if (ds3 == null)  					throw new Exception ("Can't open data source: " + src [0] + ".");  				// successfully opened  				layer.type = MS_LAYER_TYPE.MS_LAYER_RASTER;  				layer.styleitem = null;  				// TODO: check for SRS entry (if upgrading to Mapserver 6.4)  				ds3.Dispose ();  			}  			else {  				try {  					// find out geometry type  					if (gType == wkbGeometryType.wkbUnknown) {  						Geometry geom = feat.GetGeometryRef ();  						if (geom != null)  							gType = geom.GetGeometryType ();  						layer.type = MapUtils.GetLayerType (gType);  					}  					feat.Dispose ();  					Layer l;  					if (src.Length == 2) {  						int layerIndex;  						if (int.TryParse (src [1]' out layerIndex))  							l = ds2.GetLayerByIndex (layerIndex);  						else  							l = ds2.GetLayerByName (src [1]);  					}  					else  						l = ds2.GetLayerByIndex (0);  					if (l == null) {  						throw new Exception ("Can't open layer: " + tileFile + ".");  					}  					else  						l.Dispose ();  				}  				finally {  					ds2.Dispose ();  				}  			}  		}  	}  	ds.Dispose ();  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: if (ds.GetLayerCount () > 0) {  	Layer ogrLayer;  	if (layer.data != null)  		ogrLayer = ds.GetLayerByName (layer.data);  	else  		ogrLayer = ds.GetLayerByIndex (0);  	wkbGeometryType gType = ogrLayer.GetLayerDefn ().GetGeomType ();  	if (gType != wkbGeometryType.wkbUnknown)  		layer.type = MapUtils.GetLayerType (gType);  	int tileFieldIndex = ogrLayer.GetLayerDefn ().GetFieldIndex ("location");  	if (tileFieldIndex < 0) {  		// Prompt for the index  		FieldSelectionForm form = new FieldSelectionForm (layer' "Select the field for the file locations");  		if (form.ShowDialog (this) == DialogResult.OK) {  			tileFieldIndex = ogrLayer.GetLayerDefn ().GetFieldIndex (form.SelectedItem);  			layer.tileitem = form.SelectedItem;  		}  	}  	Feature feat;  	while ((feat = ogrLayer.GetNextFeature ()) != null) {  		string basePath = "";  		string tileFile = feat.GetFieldAsString (tileFieldIndex);  		// separate source and layer  		string[] src = tileFile.Split (new char[] {  			'''  		});  		if (!File.Exists (src [0])) {  			if (map.shapepath != "" && File.Exists (map.shapepath + "\\" + src [0]))  				basePath = map.shapepath + "\\";  			else if (map.mappath != "" && File.Exists (map.mappath + "\\" + src [0]))  				basePath = map.mappath + "\\";  			else  				throw new Exception ("File fot found: " + src [0] + ". If your tile file contains relative pathes try to set SHAPEPATH to the base directory.");  		}  		// trying to open as vector data source  		DataSource ds2 = Ogr.Open (basePath + src [0]' 0);  		if (ds2 == null) {  			// trying to open as raster data source  			Dataset ds3 = Gdal.Open (basePath + src [0]' Access.GA_ReadOnly);  			if (ds3 == null)  				throw new Exception ("Can't open data source: " + src [0] + ".");  			// successfully opened  			layer.type = MS_LAYER_TYPE.MS_LAYER_RASTER;  			layer.styleitem = null;  			// TODO: check for SRS entry (if upgrading to Mapserver 6.4)  			ds3.Dispose ();  		}  		else {  			try {  				// find out geometry type  				if (gType == wkbGeometryType.wkbUnknown) {  					Geometry geom = feat.GetGeometryRef ();  					if (geom != null)  						gType = geom.GetGeometryType ();  					layer.type = MapUtils.GetLayerType (gType);  				}  				feat.Dispose ();  				Layer l;  				if (src.Length == 2) {  					int layerIndex;  					if (int.TryParse (src [1]' out layerIndex))  						l = ds2.GetLayerByIndex (layerIndex);  					else  						l = ds2.GetLayerByName (src [1]);  				}  				else  					l = ds2.GetLayerByIndex (0);  				if (l == null) {  					throw new Exception ("Can't open layer: " + tileFile + ".");  				}  				else  					l.Dispose ();  			}  			finally {  				ds2.Dispose ();  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: while ((feat = ogrLayer.GetNextFeature ()) != null) {  	string basePath = "";  	string tileFile = feat.GetFieldAsString (tileFieldIndex);  	// separate source and layer  	string[] src = tileFile.Split (new char[] {  		'''  	});  	if (!File.Exists (src [0])) {  		if (map.shapepath != "" && File.Exists (map.shapepath + "\\" + src [0]))  			basePath = map.shapepath + "\\";  		else if (map.mappath != "" && File.Exists (map.mappath + "\\" + src [0]))  			basePath = map.mappath + "\\";  		else  			throw new Exception ("File fot found: " + src [0] + ". If your tile file contains relative pathes try to set SHAPEPATH to the base directory.");  	}  	// trying to open as vector data source  	DataSource ds2 = Ogr.Open (basePath + src [0]' 0);  	if (ds2 == null) {  		// trying to open as raster data source  		Dataset ds3 = Gdal.Open (basePath + src [0]' Access.GA_ReadOnly);  		if (ds3 == null)  			throw new Exception ("Can't open data source: " + src [0] + ".");  		// successfully opened  		layer.type = MS_LAYER_TYPE.MS_LAYER_RASTER;  		layer.styleitem = null;  		// TODO: check for SRS entry (if upgrading to Mapserver 6.4)  		ds3.Dispose ();  	}  	else {  		try {  			// find out geometry type  			if (gType == wkbGeometryType.wkbUnknown) {  				Geometry geom = feat.GetGeometryRef ();  				if (geom != null)  					gType = geom.GetGeometryType ();  				layer.type = MapUtils.GetLayerType (gType);  			}  			feat.Dispose ();  			Layer l;  			if (src.Length == 2) {  				int layerIndex;  				if (int.TryParse (src [1]' out layerIndex))  					l = ds2.GetLayerByIndex (layerIndex);  				else  					l = ds2.GetLayerByName (src [1]);  			}  			else  				l = ds2.GetLayerByIndex (0);  			if (l == null) {  				throw new Exception ("Can't open layer: " + tileFile + ".");  			}  			else  				l.Dispose ();  		}  		finally {  			ds2.Dispose ();  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: if (ds2 == null) {  	// trying to open as raster data source  	Dataset ds3 = Gdal.Open (basePath + src [0]' Access.GA_ReadOnly);  	if (ds3 == null)  		throw new Exception ("Can't open data source: " + src [0] + ".");  	// successfully opened  	layer.type = MS_LAYER_TYPE.MS_LAYER_RASTER;  	layer.styleitem = null;  	// TODO: check for SRS entry (if upgrading to Mapserver 6.4)  	ds3.Dispose ();  }  else {  	try {  		// find out geometry type  		if (gType == wkbGeometryType.wkbUnknown) {  			Geometry geom = feat.GetGeometryRef ();  			if (geom != null)  				gType = geom.GetGeometryType ();  			layer.type = MapUtils.GetLayerType (gType);  		}  		feat.Dispose ();  		Layer l;  		if (src.Length == 2) {  			int layerIndex;  			if (int.TryParse (src [1]' out layerIndex))  				l = ds2.GetLayerByIndex (layerIndex);  			else  				l = ds2.GetLayerByName (src [1]);  		}  		else  			l = ds2.GetLayerByIndex (0);  		if (l == null) {  			throw new Exception ("Can't open layer: " + tileFile + ".");  		}  		else  			l.Dispose ();  	}  	finally {  		ds2.Dispose ();  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: try {  	// find out geometry type  	if (gType == wkbGeometryType.wkbUnknown) {  		Geometry geom = feat.GetGeometryRef ();  		if (geom != null)  			gType = geom.GetGeometryType ();  		layer.type = MapUtils.GetLayerType (gType);  	}  	feat.Dispose ();  	Layer l;  	if (src.Length == 2) {  		int layerIndex;  		if (int.TryParse (src [1]' out layerIndex))  			l = ds2.GetLayerByIndex (layerIndex);  		else  			l = ds2.GetLayerByName (src [1]);  	}  	else  		l = ds2.GetLayerByIndex (0);  	if (l == null) {  		throw new Exception ("Can't open layer: " + tileFile + ".");  	}  	else  		l.Dispose ();  }  finally {  	ds2.Dispose ();  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenTileIndexLayer,The following statement contains a magic number: if (src.Length == 2) {  	int layerIndex;  	if (int.TryParse (src [1]' out layerIndex))  		l = ds2.GetLayerByIndex (layerIndex);  	else  		l = ds2.GetLayerByName (src [1]);  }  else  	l = ds2.GetLayerByIndex (0);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: if (ds != null) {  	double[] adfGeoTransform = new double[6];  	double minx' miny' maxx' maxy;  	ds.GetGeoTransform (adfGeoTransform);  	minx = adfGeoTransform [0];  	miny = adfGeoTransform [3];  	maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  	maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  	if (minx != maxx || miny != maxy) {  		layer.setExtent (Math.Min (minx' maxx)' Math.Min (miny' maxy)' Math.Max (minx' maxx)' Math.Max (miny' maxy));  	}  	// try to find out the projection and use that explicitly  	string wkt = ds.GetProjection ();  	if (wkt != "") {  		SpatialReference srs = new SpatialReference (wkt);  		string proj4;  		srs.ExportToProj4 (out proj4);  		if (proj4 != null || proj4 != "") {  			string proj4_out;  			int epsg;  			string projName = MapUtils.FindProjection (proj4' out proj4_out' out epsg);  			if (proj4_out.StartsWith ("+")) {  				layer.setProjection (proj4_out);  				layer.setMetaData ("coordsys_name"' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: if (ds != null) {  	double[] adfGeoTransform = new double[6];  	double minx' miny' maxx' maxy;  	ds.GetGeoTransform (adfGeoTransform);  	minx = adfGeoTransform [0];  	miny = adfGeoTransform [3];  	maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  	maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  	if (minx != maxx || miny != maxy) {  		layer.setExtent (Math.Min (minx' maxx)' Math.Min (miny' maxy)' Math.Max (minx' maxx)' Math.Max (miny' maxy));  	}  	// try to find out the projection and use that explicitly  	string wkt = ds.GetProjection ();  	if (wkt != "") {  		SpatialReference srs = new SpatialReference (wkt);  		string proj4;  		srs.ExportToProj4 (out proj4);  		if (proj4 != null || proj4 != "") {  			string proj4_out;  			int epsg;  			string projName = MapUtils.FindProjection (proj4' out proj4_out' out epsg);  			if (proj4_out.StartsWith ("+")) {  				layer.setProjection (proj4_out);  				layer.setMetaData ("coordsys_name"' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: if (ds != null) {  	double[] adfGeoTransform = new double[6];  	double minx' miny' maxx' maxy;  	ds.GetGeoTransform (adfGeoTransform);  	minx = adfGeoTransform [0];  	miny = adfGeoTransform [3];  	maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  	maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  	if (minx != maxx || miny != maxy) {  		layer.setExtent (Math.Min (minx' maxx)' Math.Min (miny' maxy)' Math.Max (minx' maxx)' Math.Max (miny' maxy));  	}  	// try to find out the projection and use that explicitly  	string wkt = ds.GetProjection ();  	if (wkt != "") {  		SpatialReference srs = new SpatialReference (wkt);  		string proj4;  		srs.ExportToProj4 (out proj4);  		if (proj4 != null || proj4 != "") {  			string proj4_out;  			int epsg;  			string projName = MapUtils.FindProjection (proj4' out proj4_out' out epsg);  			if (proj4_out.StartsWith ("+")) {  				layer.setProjection (proj4_out);  				layer.setMetaData ("coordsys_name"' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: if (ds != null) {  	double[] adfGeoTransform = new double[6];  	double minx' miny' maxx' maxy;  	ds.GetGeoTransform (adfGeoTransform);  	minx = adfGeoTransform [0];  	miny = adfGeoTransform [3];  	maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  	maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  	if (minx != maxx || miny != maxy) {  		layer.setExtent (Math.Min (minx' maxx)' Math.Min (miny' maxy)' Math.Max (minx' maxx)' Math.Max (miny' maxy));  	}  	// try to find out the projection and use that explicitly  	string wkt = ds.GetProjection ();  	if (wkt != "") {  		SpatialReference srs = new SpatialReference (wkt);  		string proj4;  		srs.ExportToProj4 (out proj4);  		if (proj4 != null || proj4 != "") {  			string proj4_out;  			int epsg;  			string projName = MapUtils.FindProjection (proj4' out proj4_out' out epsg);  			if (proj4_out.StartsWith ("+")) {  				layer.setProjection (proj4_out);  				layer.setMetaData ("coordsys_name"' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: if (ds != null) {  	double[] adfGeoTransform = new double[6];  	double minx' miny' maxx' maxy;  	ds.GetGeoTransform (adfGeoTransform);  	minx = adfGeoTransform [0];  	miny = adfGeoTransform [3];  	maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  	maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  	if (minx != maxx || miny != maxy) {  		layer.setExtent (Math.Min (minx' maxx)' Math.Min (miny' maxy)' Math.Max (minx' maxx)' Math.Max (miny' maxy));  	}  	// try to find out the projection and use that explicitly  	string wkt = ds.GetProjection ();  	if (wkt != "") {  		SpatialReference srs = new SpatialReference (wkt);  		string proj4;  		srs.ExportToProj4 (out proj4);  		if (proj4 != null || proj4 != "") {  			string proj4_out;  			int epsg;  			string projName = MapUtils.FindProjection (proj4' out proj4_out' out epsg);  			if (proj4_out.StartsWith ("+")) {  				layer.setProjection (proj4_out);  				layer.setMetaData ("coordsys_name"' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: if (ds != null) {  	double[] adfGeoTransform = new double[6];  	double minx' miny' maxx' maxy;  	ds.GetGeoTransform (adfGeoTransform);  	minx = adfGeoTransform [0];  	miny = adfGeoTransform [3];  	maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  	maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  	if (minx != maxx || miny != maxy) {  		layer.setExtent (Math.Min (minx' maxx)' Math.Min (miny' maxy)' Math.Max (minx' maxx)' Math.Max (miny' maxy));  	}  	// try to find out the projection and use that explicitly  	string wkt = ds.GetProjection ();  	if (wkt != "") {  		SpatialReference srs = new SpatialReference (wkt);  		string proj4;  		srs.ExportToProj4 (out proj4);  		if (proj4 != null || proj4 != "") {  			string proj4_out;  			int epsg;  			string projName = MapUtils.FindProjection (proj4' out proj4_out' out epsg);  			if (proj4_out.StartsWith ("+")) {  				layer.setProjection (proj4_out);  				layer.setMetaData ("coordsys_name"' projName);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: miny = adfGeoTransform [3];  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: maxx = adfGeoTransform [0] + adfGeoTransform [1] * ds.RasterXSize + adfGeoTransform [2] * ds.RasterYSize;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,OpenRasterLayer,The following statement contains a magic number: maxy = adfGeoTransform [3] + adfGeoTransform [4] * ds.RasterXSize + adfGeoTransform [5] * ds.RasterYSize;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addLayerToolStripMenuItem_Click,The following statement contains a magic number: if (IsStyleLibraryControl) {  	AddStyleCategoryForm form = new AddStyleCategoryForm (MapUtils.GetUniqueLayerName (map' "New Category"' 0));  	if (form.ShowDialog (this) == DialogResult.OK) {  		if (form.CategoryType != "(Empty Category)") {  			layer = CreateNewLayer ();  			layer.connectiontype = MS_CONNECTION_TYPE.MS_INLINE;  			layer.template = "query.html";  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			layer.name = MapUtils.GetUniqueLayerName (map' form.CategoryName' 0);  			classobj = new classObj (layer);  			classobj.name = form.CategoryName;  			style = new styleObj (classobj);  			layer.setMetaData ("character-count"' form.CharCount.ToString ());  			MapUtils.SetDefaultColor (layer.type' style);  			style.width = 1;  			style.size = 24;  			// create all symbols  			StyleLibrary.ExpandFontStyles ();  			this.selected = new MapObjectHolder (layer' target);  			RefreshView ();  			if (target != null)  				target.RaisePropertyChanged (this);  			return;  		}  	}  	else  		return;  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addLayerToolStripMenuItem_Click,The following statement contains a magic number: if (form.ShowDialog (this) == DialogResult.OK) {  	if (form.CategoryType != "(Empty Category)") {  		layer = CreateNewLayer ();  		layer.connectiontype = MS_CONNECTION_TYPE.MS_INLINE;  		layer.template = "query.html";  		layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		layer.name = MapUtils.GetUniqueLayerName (map' form.CategoryName' 0);  		classobj = new classObj (layer);  		classobj.name = form.CategoryName;  		style = new styleObj (classobj);  		layer.setMetaData ("character-count"' form.CharCount.ToString ());  		MapUtils.SetDefaultColor (layer.type' style);  		style.width = 1;  		style.size = 24;  		// create all symbols  		StyleLibrary.ExpandFontStyles ();  		this.selected = new MapObjectHolder (layer' target);  		RefreshView ();  		if (target != null)  			target.RaisePropertyChanged (this);  		return;  	}  }  else  	return;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addLayerToolStripMenuItem_Click,The following statement contains a magic number: if (form.CategoryType != "(Empty Category)") {  	layer = CreateNewLayer ();  	layer.connectiontype = MS_CONNECTION_TYPE.MS_INLINE;  	layer.template = "query.html";  	layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	layer.name = MapUtils.GetUniqueLayerName (map' form.CategoryName' 0);  	classobj = new classObj (layer);  	classobj.name = form.CategoryName;  	style = new styleObj (classobj);  	layer.setMetaData ("character-count"' form.CharCount.ToString ());  	MapUtils.SetDefaultColor (layer.type' style);  	style.width = 1;  	style.size = 24;  	// create all symbols  	StyleLibrary.ExpandFontStyles ();  	this.selected = new MapObjectHolder (layer' target);  	RefreshView ();  	if (target != null)  		target.RaisePropertyChanged (this);  	return;  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addLayerToolStripMenuItem_Click,The following statement contains a magic number: style.size = 24;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addLayerToolStripMenuItem_Click,The following statement contains a magic number: style.size = 8;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addClassToolStripMenuItem_Click,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_POINT) {  	style.symbolname = "default-marker";  	style.size = 8;  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,addClassToolStripMenuItem_Click,The following statement contains a magic number: style.size = 8;  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: if (usingPos > 0)  	tableName = layer.data.Substring (fromPos + 6' usingPos - fromPos - 6);  else  	tableName = layer.data.Substring (fromPos + 6);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: if (usingPos > 0)  	tableName = layer.data.Substring (fromPos + 6' usingPos - fromPos - 6);  else  	tableName = layer.data.Substring (fromPos + 6);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: if (usingPos > 0)  	tableName = layer.data.Substring (fromPos + 6' usingPos - fromPos - 6);  else  	tableName = layer.data.Substring (fromPos + 6);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: tableName = layer.data.Substring (fromPos + 6' usingPos - fromPos - 6);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: tableName = layer.data.Substring (fromPos + 6' usingPos - fromPos - 6);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: tableName = layer.data.Substring (fromPos + 6);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: using (SqlDR = SqlCom.ExecuteReader ()) {  	while (SqlDR.Read ()) {  		if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  			layer.extent.minx = SqlDR.GetDouble (0);  		layer.extent.miny = SqlDR.GetDouble (1);  		layer.extent.maxx = SqlDR.GetDouble (2);  		layer.extent.maxy = SqlDR.GetDouble (3);  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: using (SqlDR = SqlCom.ExecuteReader ()) {  	while (SqlDR.Read ()) {  		if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  			layer.extent.minx = SqlDR.GetDouble (0);  		layer.extent.miny = SqlDR.GetDouble (1);  		layer.extent.maxx = SqlDR.GetDouble (2);  		layer.extent.maxy = SqlDR.GetDouble (3);  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: using (SqlDR = SqlCom.ExecuteReader ()) {  	while (SqlDR.Read ()) {  		if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  			layer.extent.minx = SqlDR.GetDouble (0);  		layer.extent.miny = SqlDR.GetDouble (1);  		layer.extent.maxx = SqlDR.GetDouble (2);  		layer.extent.maxy = SqlDR.GetDouble (3);  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: using (SqlDR = SqlCom.ExecuteReader ()) {  	while (SqlDR.Read ()) {  		if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  			layer.extent.minx = SqlDR.GetDouble (0);  		layer.extent.miny = SqlDR.GetDouble (1);  		layer.extent.maxx = SqlDR.GetDouble (2);  		layer.extent.maxy = SqlDR.GetDouble (3);  	}  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: while (SqlDR.Read ()) {  	if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  		layer.extent.minx = SqlDR.GetDouble (0);  	layer.extent.miny = SqlDR.GetDouble (1);  	layer.extent.maxx = SqlDR.GetDouble (2);  	layer.extent.maxy = SqlDR.GetDouble (3);  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: while (SqlDR.Read ()) {  	if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  		layer.extent.minx = SqlDR.GetDouble (0);  	layer.extent.miny = SqlDR.GetDouble (1);  	layer.extent.maxx = SqlDR.GetDouble (2);  	layer.extent.maxy = SqlDR.GetDouble (3);  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: while (SqlDR.Read ()) {  	if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  		layer.extent.minx = SqlDR.GetDouble (0);  	layer.extent.miny = SqlDR.GetDouble (1);  	layer.extent.maxx = SqlDR.GetDouble (2);  	layer.extent.maxy = SqlDR.GetDouble (3);  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: while (SqlDR.Read ()) {  	if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  		layer.extent.minx = SqlDR.GetDouble (0);  	layer.extent.miny = SqlDR.GetDouble (1);  	layer.extent.maxx = SqlDR.GetDouble (2);  	layer.extent.maxy = SqlDR.GetDouble (3);  }  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  	layer.extent.minx = SqlDR.GetDouble (0);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: if (!SqlDR.IsDBNull (0) && !SqlDR.IsDBNull (1) && !SqlDR.IsDBNull (2) && !SqlDR.IsDBNull (3))  	layer.extent.minx = SqlDR.GetDouble (0);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: layer.extent.maxx = SqlDR.GetDouble (2);  
Magic Number,DMS.MapLibrary,LayerControl,C:\repos\DMS-Aus_MapManager\MapLibrary\LayerControl.cs,GetMssqlSpatialLayerExtent,The following statement contains a magic number: layer.extent.maxy = SqlDR.GetDouble (3);  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: if (this.editor != null) {  	Control c = (Control)this.editor;  	c.Location = new System.Drawing.Point (3' 4);  	c.TabIndex = 0;  	editor.Target = target;  	this.Controls.Add (c);  	target.PropertyChanging += new EventHandler (target_PropertyChanging);  	editor.EditProperties += new EditPropertiesEventHandler (editor_EditProperties);  	buttonOK.Top = c.Bottom + 8;  	buttonCancel.Top = c.Bottom + 8;  	buttonApply.Top = c.Bottom + 8;  }  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: if (this.editor != null) {  	Control c = (Control)this.editor;  	c.Location = new System.Drawing.Point (3' 4);  	c.TabIndex = 0;  	editor.Target = target;  	this.Controls.Add (c);  	target.PropertyChanging += new EventHandler (target_PropertyChanging);  	editor.EditProperties += new EditPropertiesEventHandler (editor_EditProperties);  	buttonOK.Top = c.Bottom + 8;  	buttonCancel.Top = c.Bottom + 8;  	buttonApply.Top = c.Bottom + 8;  }  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: if (this.editor != null) {  	Control c = (Control)this.editor;  	c.Location = new System.Drawing.Point (3' 4);  	c.TabIndex = 0;  	editor.Target = target;  	this.Controls.Add (c);  	target.PropertyChanging += new EventHandler (target_PropertyChanging);  	editor.EditProperties += new EditPropertiesEventHandler (editor_EditProperties);  	buttonOK.Top = c.Bottom + 8;  	buttonCancel.Top = c.Bottom + 8;  	buttonApply.Top = c.Bottom + 8;  }  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: if (this.editor != null) {  	Control c = (Control)this.editor;  	c.Location = new System.Drawing.Point (3' 4);  	c.TabIndex = 0;  	editor.Target = target;  	this.Controls.Add (c);  	target.PropertyChanging += new EventHandler (target_PropertyChanging);  	editor.EditProperties += new EditPropertiesEventHandler (editor_EditProperties);  	buttonOK.Top = c.Bottom + 8;  	buttonCancel.Top = c.Bottom + 8;  	buttonApply.Top = c.Bottom + 8;  }  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: if (this.editor != null) {  	Control c = (Control)this.editor;  	c.Location = new System.Drawing.Point (3' 4);  	c.TabIndex = 0;  	editor.Target = target;  	this.Controls.Add (c);  	target.PropertyChanging += new EventHandler (target_PropertyChanging);  	editor.EditProperties += new EditPropertiesEventHandler (editor_EditProperties);  	buttonOK.Top = c.Bottom + 8;  	buttonCancel.Top = c.Bottom + 8;  	buttonApply.Top = c.Bottom + 8;  }  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: c.Location = new System.Drawing.Point (3' 4);  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: c.Location = new System.Drawing.Point (3' 4);  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: buttonOK.Top = c.Bottom + 8;  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: buttonCancel.Top = c.Bottom + 8;  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,MapPropertyEditorForm,The following statement contains a magic number: buttonApply.Top = c.Bottom + 8;  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (darkPen' 0' buttonCancel.Top - 4' this.Width' buttonCancel.Top - 4);  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (darkPen' 0' buttonCancel.Top - 4' this.Width' buttonCancel.Top - 4);  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (lightPen' 0' buttonCancel.Top - 3' this.Width' buttonCancel.Top - 3);  
Magic Number,DMS.MapLibrary,MapPropertyEditorForm,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditorForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (lightPen' 0' buttonCancel.Top - 3' this.Width' buttonCancel.Top - 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetRandomColor,The following statement contains a magic number: return new colorObj (rand.Next (256)' rand.Next (256)' rand.Next (256)' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetRandomColor,The following statement contains a magic number: return new colorObj (rand.Next (256)' rand.Next (256)' rand.Next (256)' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetRandomColor,The following statement contains a magic number: return new colorObj (rand.Next (256)' rand.Next (256)' rand.Next (256)' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetRandomColor,The following statement contains a magic number: return new colorObj (rand.Next (256)' rand.Next (256)' rand.Next (256)' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: if (type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	style.color = new colorObj (255' 255' 255' 255);  	style.outlinecolor = new colorObj (0' 0' 0' 255);  	style.symbol = 0;  	style.symbolname = null;  }  else {  	style.color = new colorObj (0' 0' 0' 255);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: if (type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	style.color = new colorObj (255' 255' 255' 255);  	style.outlinecolor = new colorObj (0' 0' 0' 255);  	style.symbol = 0;  	style.symbolname = null;  }  else {  	style.color = new colorObj (0' 0' 0' 255);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: if (type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	style.color = new colorObj (255' 255' 255' 255);  	style.outlinecolor = new colorObj (0' 0' 0' 255);  	style.symbol = 0;  	style.symbolname = null;  }  else {  	style.color = new colorObj (0' 0' 0' 255);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: if (type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	style.color = new colorObj (255' 255' 255' 255);  	style.outlinecolor = new colorObj (0' 0' 0' 255);  	style.symbol = 0;  	style.symbolname = null;  }  else {  	style.color = new colorObj (0' 0' 0' 255);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: if (type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	style.color = new colorObj (255' 255' 255' 255);  	style.outlinecolor = new colorObj (0' 0' 0' 255);  	style.symbol = 0;  	style.symbolname = null;  }  else {  	style.color = new colorObj (0' 0' 0' 255);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: if (type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	style.color = new colorObj (255' 255' 255' 255);  	style.outlinecolor = new colorObj (0' 0' 0' 255);  	style.symbol = 0;  	style.symbolname = null;  }  else {  	style.color = new colorObj (0' 0' 0' 255);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: style.color = new colorObj (255' 255' 255' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: style.color = new colorObj (255' 255' 255' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: style.color = new colorObj (255' 255' 255' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: style.color = new colorObj (255' 255' 255' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: style.outlinecolor = new colorObj (0' 0' 0' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultColor,The following statement contains a magic number: style.color = new colorObj (0' 0' 0' 255);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,CreateRandomClass,The following statement contains a magic number: using (classObj newclass = new classObj (layer)) {  	newclass.name = GetClassName (layer);  	newclass.template = "query.html";  	styleObj style = new styleObj (newclass);  	style.size = 8;  	// set default size (#4339)  	SetDefaultColor (layer.type' style);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,CreateRandomClass,The following statement contains a magic number: style.size = 8;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultLabel,The following statement contains a magic number: label.size = 8;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultLabel,The following statement contains a magic number: if (map != null) {  	string key = null;  	string lastkey = null;  	while ((key = map.fontset.fonts.nextKey (key)) != null) {  		if (File.Exists (map.fontset.fonts.get (key' ""))) {  			lastkey = key;  			if (string.Compare (key' "arial"' true) == 0) {  				// set the default font to Arial if exists  				break;  			}  		}  	}  	if (lastkey != null) {  		label.font = lastkey;  		label.size = 8;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultLabel,The following statement contains a magic number: if (lastkey != null) {  	label.font = lastkey;  	label.size = 8;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,SetDefaultLabel,The following statement contains a magic number: label.size = 8;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,CreateMap,The following statement contains a magic number: map.setExtent (0' 0' 100' 100);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,CreateMap,The following statement contains a magic number: map.setExtent (0' 0' 100' 100);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 4374754;  case MS_UNITS.MS_FEET:  	return 12;  case MS_UNITS.MS_INCHES:  	return 1;  case MS_UNITS.MS_KILOMETERS:  	return 39370.1;  case MS_UNITS.MS_METERS:  	return 39.3701;  case MS_UNITS.MS_MILES:  	return 63360.0;  default:  	return 1;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 4374754;  case MS_UNITS.MS_FEET:  	return 12;  case MS_UNITS.MS_INCHES:  	return 1;  case MS_UNITS.MS_KILOMETERS:  	return 39370.1;  case MS_UNITS.MS_METERS:  	return 39.3701;  case MS_UNITS.MS_MILES:  	return 63360.0;  default:  	return 1;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 4374754;  case MS_UNITS.MS_FEET:  	return 12;  case MS_UNITS.MS_INCHES:  	return 1;  case MS_UNITS.MS_KILOMETERS:  	return 39370.1;  case MS_UNITS.MS_METERS:  	return 39.3701;  case MS_UNITS.MS_MILES:  	return 63360.0;  default:  	return 1;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 4374754;  case MS_UNITS.MS_FEET:  	return 12;  case MS_UNITS.MS_INCHES:  	return 1;  case MS_UNITS.MS_KILOMETERS:  	return 39370.1;  case MS_UNITS.MS_METERS:  	return 39.3701;  case MS_UNITS.MS_MILES:  	return 63360.0;  default:  	return 1;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 4374754;  case MS_UNITS.MS_FEET:  	return 12;  case MS_UNITS.MS_INCHES:  	return 1;  case MS_UNITS.MS_KILOMETERS:  	return 39370.1;  case MS_UNITS.MS_METERS:  	return 39.3701;  case MS_UNITS.MS_MILES:  	return 63360.0;  default:  	return 1;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: return 4374754;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: return 12;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: return 39370.1;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: return 39.3701;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,InchesPerUnit,The following statement contains a magic number: return 63360.0;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 5;  case MS_UNITS.MS_FEET:  	return 0;  case MS_UNITS.MS_INCHES:  	return 0;  case MS_UNITS.MS_KILOMETERS:  	return 3;  case MS_UNITS.MS_METERS:  	return 0;  case MS_UNITS.MS_MILES:  	return 3;  case MS_UNITS.MS_PERCENTAGES:  	return 2;  case MS_UNITS.MS_PIXELS:  	return 0;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 5;  case MS_UNITS.MS_FEET:  	return 0;  case MS_UNITS.MS_INCHES:  	return 0;  case MS_UNITS.MS_KILOMETERS:  	return 3;  case MS_UNITS.MS_METERS:  	return 0;  case MS_UNITS.MS_MILES:  	return 3;  case MS_UNITS.MS_PERCENTAGES:  	return 2;  case MS_UNITS.MS_PIXELS:  	return 0;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 5;  case MS_UNITS.MS_FEET:  	return 0;  case MS_UNITS.MS_INCHES:  	return 0;  case MS_UNITS.MS_KILOMETERS:  	return 3;  case MS_UNITS.MS_METERS:  	return 0;  case MS_UNITS.MS_MILES:  	return 3;  case MS_UNITS.MS_PERCENTAGES:  	return 2;  case MS_UNITS.MS_PIXELS:  	return 0;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: switch (unit) {  case MS_UNITS.MS_DD:  	return 5;  case MS_UNITS.MS_FEET:  	return 0;  case MS_UNITS.MS_INCHES:  	return 0;  case MS_UNITS.MS_KILOMETERS:  	return 3;  case MS_UNITS.MS_METERS:  	return 0;  case MS_UNITS.MS_MILES:  	return 3;  case MS_UNITS.MS_PERCENTAGES:  	return 2;  case MS_UNITS.MS_PIXELS:  	return 0;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: return 5;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: return 3;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: return 3;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following statement contains a magic number: return 2;  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: using (Stream s = File.OpenRead (MapUtils.GetPROJ_LIB () + "\\epsg")) {  	using (StreamReader reader = new StreamReader (s)) {  		string line;  		int i;  		int minrank = 100;  		string line2 = "";  		while ((line = reader.ReadLine ()) != null) {  			int rank = 0;  			if (def != null) {  				// proj4 based search  				for (i = 0; i < def.Length; i++) {  					if (!line.Contains (def [i])) {  						if (def [i].StartsWith ("+proj"))  							break;  						if (def [i].StartsWith ("+ellps"))  							break;  						if (def [i].StartsWith ("+zone"))  							break;  						if (def [i].StartsWith ("+datum"))  							break;  						if (def [i].StartsWith ("+units"))  							break;  						if (def [i].StartsWith ("+south"))  							break;  						if (def [i].StartsWith ("+north"))  							break;  						else  							++rank;  					}  				}  				if (i == def.Length) {  					if (rank < minrank) {  						minrank = rank;  						projName = line2.Substring (2);  						proj4 = line;  						if (rank == 0) {  							// found  							break;  						}  					}  				}  			}  			else {  				// name based search  				if (line.Contains (projection))  					break;  			}  			if (line.StartsWith ("#"))  				line2 = line;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: using (Stream s = File.OpenRead (MapUtils.GetPROJ_LIB () + "\\epsg")) {  	using (StreamReader reader = new StreamReader (s)) {  		string line;  		int i;  		int minrank = 100;  		string line2 = "";  		while ((line = reader.ReadLine ()) != null) {  			int rank = 0;  			if (def != null) {  				// proj4 based search  				for (i = 0; i < def.Length; i++) {  					if (!line.Contains (def [i])) {  						if (def [i].StartsWith ("+proj"))  							break;  						if (def [i].StartsWith ("+ellps"))  							break;  						if (def [i].StartsWith ("+zone"))  							break;  						if (def [i].StartsWith ("+datum"))  							break;  						if (def [i].StartsWith ("+units"))  							break;  						if (def [i].StartsWith ("+south"))  							break;  						if (def [i].StartsWith ("+north"))  							break;  						else  							++rank;  					}  				}  				if (i == def.Length) {  					if (rank < minrank) {  						minrank = rank;  						projName = line2.Substring (2);  						proj4 = line;  						if (rank == 0) {  							// found  							break;  						}  					}  				}  			}  			else {  				// name based search  				if (line.Contains (projection))  					break;  			}  			if (line.StartsWith ("#"))  				line2 = line;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: using (StreamReader reader = new StreamReader (s)) {  	string line;  	int i;  	int minrank = 100;  	string line2 = "";  	while ((line = reader.ReadLine ()) != null) {  		int rank = 0;  		if (def != null) {  			// proj4 based search  			for (i = 0; i < def.Length; i++) {  				if (!line.Contains (def [i])) {  					if (def [i].StartsWith ("+proj"))  						break;  					if (def [i].StartsWith ("+ellps"))  						break;  					if (def [i].StartsWith ("+zone"))  						break;  					if (def [i].StartsWith ("+datum"))  						break;  					if (def [i].StartsWith ("+units"))  						break;  					if (def [i].StartsWith ("+south"))  						break;  					if (def [i].StartsWith ("+north"))  						break;  					else  						++rank;  				}  			}  			if (i == def.Length) {  				if (rank < minrank) {  					minrank = rank;  					projName = line2.Substring (2);  					proj4 = line;  					if (rank == 0) {  						// found  						break;  					}  				}  			}  		}  		else {  			// name based search  			if (line.Contains (projection))  				break;  		}  		if (line.StartsWith ("#"))  			line2 = line;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: using (StreamReader reader = new StreamReader (s)) {  	string line;  	int i;  	int minrank = 100;  	string line2 = "";  	while ((line = reader.ReadLine ()) != null) {  		int rank = 0;  		if (def != null) {  			// proj4 based search  			for (i = 0; i < def.Length; i++) {  				if (!line.Contains (def [i])) {  					if (def [i].StartsWith ("+proj"))  						break;  					if (def [i].StartsWith ("+ellps"))  						break;  					if (def [i].StartsWith ("+zone"))  						break;  					if (def [i].StartsWith ("+datum"))  						break;  					if (def [i].StartsWith ("+units"))  						break;  					if (def [i].StartsWith ("+south"))  						break;  					if (def [i].StartsWith ("+north"))  						break;  					else  						++rank;  				}  			}  			if (i == def.Length) {  				if (rank < minrank) {  					minrank = rank;  					projName = line2.Substring (2);  					proj4 = line;  					if (rank == 0) {  						// found  						break;  					}  				}  			}  		}  		else {  			// name based search  			if (line.Contains (projection))  				break;  		}  		if (line.StartsWith ("#"))  			line2 = line;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	int rank = 0;  	if (def != null) {  		// proj4 based search  		for (i = 0; i < def.Length; i++) {  			if (!line.Contains (def [i])) {  				if (def [i].StartsWith ("+proj"))  					break;  				if (def [i].StartsWith ("+ellps"))  					break;  				if (def [i].StartsWith ("+zone"))  					break;  				if (def [i].StartsWith ("+datum"))  					break;  				if (def [i].StartsWith ("+units"))  					break;  				if (def [i].StartsWith ("+south"))  					break;  				if (def [i].StartsWith ("+north"))  					break;  				else  					++rank;  			}  		}  		if (i == def.Length) {  			if (rank < minrank) {  				minrank = rank;  				projName = line2.Substring (2);  				proj4 = line;  				if (rank == 0) {  					// found  					break;  				}  			}  		}  	}  	else {  		// name based search  		if (line.Contains (projection))  			break;  	}  	if (line.StartsWith ("#"))  		line2 = line;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: if (def != null) {  	// proj4 based search  	for (i = 0; i < def.Length; i++) {  		if (!line.Contains (def [i])) {  			if (def [i].StartsWith ("+proj"))  				break;  			if (def [i].StartsWith ("+ellps"))  				break;  			if (def [i].StartsWith ("+zone"))  				break;  			if (def [i].StartsWith ("+datum"))  				break;  			if (def [i].StartsWith ("+units"))  				break;  			if (def [i].StartsWith ("+south"))  				break;  			if (def [i].StartsWith ("+north"))  				break;  			else  				++rank;  		}  	}  	if (i == def.Length) {  		if (rank < minrank) {  			minrank = rank;  			projName = line2.Substring (2);  			proj4 = line;  			if (rank == 0) {  				// found  				break;  			}  		}  	}  }  else {  	// name based search  	if (line.Contains (projection))  		break;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: if (i == def.Length) {  	if (rank < minrank) {  		minrank = rank;  		projName = line2.Substring (2);  		proj4 = line;  		if (rank == 0) {  			// found  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: if (rank < minrank) {  	minrank = rank;  	projName = line2.Substring (2);  	proj4 = line;  	if (rank == 0) {  		// found  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: projName = line2.Substring (2);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: if (proj_defs.Length >= 3) {  	proj4 = proj_defs [2].Trim ();  	int.TryParse (proj_defs [1].Trim ()' out epsg);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: if (proj_defs.Length >= 3) {  	proj4 = proj_defs [2].Trim ();  	int.TryParse (proj_defs [1].Trim ()' out epsg);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,FindProjection,The following statement contains a magic number: proj4 = proj_defs [2].Trim ();  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int phase = 0; phase < 2; phase++) {  	if (phase == 0)  		bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	else  		bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  	g = Graphics.FromImage (bmp);  	Stack groupPositions = new Stack ();  	// for storing the group text positions  	Font legendFont = new Font ("MS Sans Sherif"' 8);  	// set default font  	g.Clear (Color.White);  	// clear the background  	int xPos = 5;  	// padding  	int yPos = 5;  	int xOffset = 24;  	// legend indent in pixels  	int yOffset = 18;  	// item height in pixels  	// force the recalculation of the current scale  	map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  	// start drawing the legend in reverse layer order  	using (intarray ar = map.getLayersDrawingOrder ()) {  		for (int i = map.numlayers - 1; i >= 0; i--) {  			layerObj layer = map.getLayer (ar.getitem (i));  			if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  				continue;  			if (map.scaledenom > 0) {  				if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  					continue;  				if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  					continue;  			}  			if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  				if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  					continue;  				if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  					continue;  			}  			// draw raster or WMS layers  			if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  				if (phase == 1) {  					g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  				continue;  			}  			int numClasses = 0;  			Image legendImage = null;  			string legendText = null;  			for (int j = 0; j < layer.numclasses; j++) {  				classObj layerclass = layer.getClass (j);  				if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  					continue;  				if (layerclass.status == mapscript.MS_OFF)  					continue;  				if (map.scaledenom > 0) {  					/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  						continue;  					if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  						continue;  				}  				if (numClasses == 1) {  					// draw subclasses  					xPos += xOffset;  					if (phase == 1) {  						// drawing the first class item (same as the layer)  						g.DrawImage (legendImage' xPos' yPos);  						g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  					}  					SizeF size = g.MeasureString (legendText' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					yPos += yOffset;  				}  				++numClasses;  				// number of visible classes  				// creating the treeicons  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							legendImage = Image.FromStream (ms);  							legendText = layerclass.name;  							if (phase == 1)  								g.DrawImage (legendImage' xPos' yPos);  							if (numClasses > 1) {  								// draw the class item  								if (phase == 1)  									g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layerclass.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							}  							else {  								// draw the layer item  								if (phase == 1)  									g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  								SizeF size = g.MeasureString (layer.name' legendFont);  								if (xPos + 30 + size.Width + 5 > width)  									width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  								if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  									yPos += yOffset;  									break;  								}  							}  						}  					}  				}  				yPos += yOffset;  			}  			if (numClasses > 1)  				xPos -= xOffset;  		}  	}  	height = yPos + 5;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 0)  	bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  else  	bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 0)  	bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  else  	bmp = new Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: bmp = new Bitmap (100' 100' System.Drawing.Imaging.PixelFormat.Format24bppRgb);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (intarray ar = map.getLayersDrawingOrder ()) {  	for (int i = map.numlayers - 1; i >= 0; i--) {  		layerObj layer = map.getLayer (ar.getitem (i));  		if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  			continue;  		if (map.scaledenom > 0) {  			if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  				continue;  			if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  				continue;  		}  		if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  			if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  				continue;  			if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  				continue;  		}  		// draw raster or WMS layers  		if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  			if (phase == 1) {  				g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  			continue;  		}  		int numClasses = 0;  		Image legendImage = null;  		string legendText = null;  		for (int j = 0; j < layer.numclasses; j++) {  			classObj layerclass = layer.getClass (j);  			if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  				continue;  			if (layerclass.status == mapscript.MS_OFF)  				continue;  			if (map.scaledenom > 0) {  				/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  					continue;  				if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  					continue;  			}  			if (numClasses == 1) {  				// draw subclasses  				xPos += xOffset;  				if (phase == 1) {  					// drawing the first class item (same as the layer)  					g.DrawImage (legendImage' xPos' yPos);  					g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  				}  				SizeF size = g.MeasureString (legendText' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				yPos += yOffset;  			}  			++numClasses;  			// number of visible classes  			// creating the treeicons  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						legendImage = Image.FromStream (ms);  						legendText = layerclass.name;  						if (phase == 1)  							g.DrawImage (legendImage' xPos' yPos);  						if (numClasses > 1) {  							// draw the class item  							if (phase == 1)  								g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layerclass.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						}  						else {  							// draw the layer item  							if (phase == 1)  								g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  							SizeF size = g.MeasureString (layer.name' legendFont);  							if (xPos + 30 + size.Width + 5 > width)  								width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  							if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  								yPos += yOffset;  								break;  							}  						}  					}  				}  			}  			yPos += yOffset;  		}  		if (numClasses > 1)  			xPos -= xOffset;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int i = map.numlayers - 1; i >= 0; i--) {  	layerObj layer = map.getLayer (ar.getitem (i));  	if (layer.name == "__embed__scalebar" || layer.name == "__embed__legend" || layer.status == mapscript.MS_OFF || layer.name.StartsWith ("~"))  		continue;  	if (map.scaledenom > 0) {  		if (layer.maxscaledenom > 0 && map.scaledenom > layer.maxscaledenom)  			continue;  		if (layer.minscaledenom > 0 && map.scaledenom <= layer.minscaledenom)  			continue;  	}  	if (layer.maxscaledenom <= 0 && layer.minscaledenom <= 0) {  		if (layer.maxgeowidth > 0 && ((map.extent.maxx - map.extent.minx) > layer.maxgeowidth))  			continue;  		if (layer.mingeowidth > 0 && ((map.extent.maxx - map.extent.minx) < layer.mingeowidth))  			continue;  	}  	// draw raster or WMS layers  	if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  		if (phase == 1) {  			g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  		continue;  	}  	int numClasses = 0;  	Image legendImage = null;  	string legendText = null;  	for (int j = 0; j < layer.numclasses; j++) {  		classObj layerclass = layer.getClass (j);  		if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  			continue;  		if (layerclass.status == mapscript.MS_OFF)  			continue;  		if (map.scaledenom > 0) {  			/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  				continue;  			if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  				continue;  		}  		if (numClasses == 1) {  			// draw subclasses  			xPos += xOffset;  			if (phase == 1) {  				// drawing the first class item (same as the layer)  				g.DrawImage (legendImage' xPos' yPos);  				g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  			}  			SizeF size = g.MeasureString (legendText' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			yPos += yOffset;  		}  		++numClasses;  		// number of visible classes  		// creating the treeicons  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					legendImage = Image.FromStream (ms);  					legendText = layerclass.name;  					if (phase == 1)  						g.DrawImage (legendImage' xPos' yPos);  					if (numClasses > 1) {  						// draw the class item  						if (phase == 1)  							g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layerclass.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					}  					else {  						// draw the layer item  						if (phase == 1)  							g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  						SizeF size = g.MeasureString (layer.name' legendFont);  						if (xPos + 30 + size.Width + 5 > width)  							width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  						if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  							yPos += yOffset;  							break;  						}  					}  				}  			}  		}  		yPos += yOffset;  	}  	if (numClasses > 1)  		xPos -= xOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  	if (phase == 1) {  		g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  	continue;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  	if (phase == 1) {  		g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  	continue;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  	if (phase == 1) {  		g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  	continue;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  	if (phase == 1) {  		g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  	continue;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  	if (phase == 1) {  		g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  	continue;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (layer.type == MS_LAYER_TYPE.MS_LAYER_RASTER) {  	if (phase == 1) {  		g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  	continue;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1) {  	g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  	g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1) {  	g.DrawIcon (global::MapLibrary.Properties.Resources.raster' xPos' yPos);  	g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 2);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: for (int j = 0; j < layer.numclasses; j++) {  	classObj layerclass = layer.getClass (j);  	if (layerclass.name == "EntireSelection" || layerclass.name == "CurrentSelection")  		continue;  	if (layerclass.status == mapscript.MS_OFF)  		continue;  	if (map.scaledenom > 0) {  		/* verify class scale here */if (layerclass.maxscaledenom > 0 && (map.scaledenom > layerclass.maxscaledenom))  			continue;  		if (layerclass.minscaledenom > 0 && (map.scaledenom <= layerclass.minscaledenom))  			continue;  	}  	if (numClasses == 1) {  		// draw subclasses  		xPos += xOffset;  		if (phase == 1) {  			// drawing the first class item (same as the layer)  			g.DrawImage (legendImage' xPos' yPos);  			g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  		}  		SizeF size = g.MeasureString (legendText' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		yPos += yOffset;  	}  	++numClasses;  	// number of visible classes  	// creating the treeicons  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				legendImage = Image.FromStream (ms);  				legendText = layerclass.name;  				if (phase == 1)  					g.DrawImage (legendImage' xPos' yPos);  				if (numClasses > 1) {  					// draw the class item  					if (phase == 1)  						g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layerclass.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				}  				else {  					// draw the layer item  					if (phase == 1)  						g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  					SizeF size = g.MeasureString (layer.name' legendFont);  					if (xPos + 30 + size.Width + 5 > width)  						width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  					if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  						yPos += yOffset;  						break;  					}  				}  			}  		}  	}  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses == 1) {  	// draw subclasses  	xPos += xOffset;  	if (phase == 1) {  		// drawing the first class item (same as the layer)  		g.DrawImage (legendImage' xPos' yPos);  		g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (legendText' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses == 1) {  	// draw subclasses  	xPos += xOffset;  	if (phase == 1) {  		// drawing the first class item (same as the layer)  		g.DrawImage (legendImage' xPos' yPos);  		g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (legendText' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses == 1) {  	// draw subclasses  	xPos += xOffset;  	if (phase == 1) {  		// drawing the first class item (same as the layer)  		g.DrawImage (legendImage' xPos' yPos);  		g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (legendText' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses == 1) {  	// draw subclasses  	xPos += xOffset;  	if (phase == 1) {  		// drawing the first class item (same as the layer)  		g.DrawImage (legendImage' xPos' yPos);  		g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (legendText' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses == 1) {  	// draw subclasses  	xPos += xOffset;  	if (phase == 1) {  		// drawing the first class item (same as the layer)  		g.DrawImage (legendImage' xPos' yPos);  		g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (legendText' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses == 1) {  	// draw subclasses  	xPos += xOffset;  	if (phase == 1) {  		// drawing the first class item (same as the layer)  		g.DrawImage (legendImage' xPos' yPos);  		g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  	}  	SizeF size = g.MeasureString (legendText' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	yPos += yOffset;  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1) {  	// drawing the first class item (same as the layer)  	g.DrawImage (legendImage' xPos' yPos);  	g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1) {  	// drawing the first class item (same as the layer)  	g.DrawImage (legendImage' xPos' yPos);  	g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (legendText' legendFont' Brushes.Black' xPos + 30' yPos + 2);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			legendImage = Image.FromStream (ms);  			legendText = layerclass.name;  			if (phase == 1)  				g.DrawImage (legendImage' xPos' yPos);  			if (numClasses > 1) {  				// draw the class item  				if (phase == 1)  					g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layerclass.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			}  			else {  				// draw the layer item  				if (phase == 1)  					g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  				SizeF size = g.MeasureString (layer.name' legendFont);  				if (xPos + 30 + size.Width + 5 > width)  					width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  				if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  					yPos += yOffset;  					break;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		legendImage = Image.FromStream (ms);  		legendText = layerclass.name;  		if (phase == 1)  			g.DrawImage (legendImage' xPos' yPos);  		if (numClasses > 1) {  			// draw the class item  			if (phase == 1)  				g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layerclass.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		}  		else {  			// draw the layer item  			if (phase == 1)  				g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  			SizeF size = g.MeasureString (layer.name' legendFont);  			if (xPos + 30 + size.Width + 5 > width)  				width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  			if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  				yPos += yOffset;  				break;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: layerclass.drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (img)) {  	legendImage = Image.FromStream (ms);  	legendText = layerclass.name;  	if (phase == 1)  		g.DrawImage (legendImage' xPos' yPos);  	if (numClasses > 1) {  		// draw the class item  		if (phase == 1)  			g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layerclass.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	}  	else {  		// draw the layer item  		if (phase == 1)  			g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  		SizeF size = g.MeasureString (layer.name' legendFont);  		if (xPos + 30 + size.Width + 5 > width)  			width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  		if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  			yPos += yOffset;  			break;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (numClasses > 1) {  	// draw the class item  	if (phase == 1)  		g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layerclass.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  }  else {  	// draw the layer item  	if (phase == 1)  		g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  	SizeF size = g.MeasureString (layer.name' legendFont);  	if (xPos + 30 + size.Width + 5 > width)  		width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  	if (string.Compare (layer.styleitem' "AUTO"' true) == 0) {  		yPos += yOffset;  		break;  	}  }  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1)  	g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1)  	g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (layerclass.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1)  	g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (phase == 1)  	g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: g.DrawString (layer.name' legendFont' Brushes.Black' xPos + 30' yPos + 3);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: if (xPos + 30 + size.Width + 5 > width)  	width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: width = Convert.ToInt32 (xPos + 30 + size.Width + 5);  
Magic Number,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,ExportLegend,The following statement contains a magic number: height = yPos + 5;  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl,The following statement contains a magic number: selectionBrush = new SolidBrush (Color.FromArgb (75' Color.Gray));  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl,The following statement contains a magic number: gap = 10;  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl,The following statement contains a magic number: unitPrecision = 4;  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,UpdateTansformations,The following statement contains a magic number: if (this.Width > 2)  	a11 = (map.extent.maxx - map.extent.minx) / this.Width;  else  	a11 = 0;  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,UpdateTansformations,The following statement contains a magic number: if (this.Height > 2)  	a21 = -a11;  else  	a21 = 0;  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: if (path != null) {  	using (GraphicsPathIterator myPathIterator = new GraphicsPathIterator (path)) {  		int myStartIndex;  		int myEndIndex;  		bool myIsClosed;  		// get the number of Subpaths.  		int numSubpaths = myPathIterator.SubpathCount;  		while (myPathIterator.NextSubpath (out myStartIndex' out myEndIndex' out myIsClosed) > 0) {  			lineObj line = new lineObj ();  			for (int i = myStartIndex; i <= myEndIndex; i++) {  				if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y))  					line.add (new pointObj (Pixel2MapX (path.PathPoints [i].X)' Pixel2MapY (path.PathPoints [i].Y)' 0' 0));  			}  			if (feature == null) {  				if (myIsClosed && line.numpoints > 2)  					feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  				else  					feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  			}  			if (line.numpoints >= 2)  				feature.add (line);  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: if (path != null) {  	using (GraphicsPathIterator myPathIterator = new GraphicsPathIterator (path)) {  		int myStartIndex;  		int myEndIndex;  		bool myIsClosed;  		// get the number of Subpaths.  		int numSubpaths = myPathIterator.SubpathCount;  		while (myPathIterator.NextSubpath (out myStartIndex' out myEndIndex' out myIsClosed) > 0) {  			lineObj line = new lineObj ();  			for (int i = myStartIndex; i <= myEndIndex; i++) {  				if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y))  					line.add (new pointObj (Pixel2MapX (path.PathPoints [i].X)' Pixel2MapY (path.PathPoints [i].Y)' 0' 0));  			}  			if (feature == null) {  				if (myIsClosed && line.numpoints > 2)  					feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  				else  					feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  			}  			if (line.numpoints >= 2)  				feature.add (line);  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: using (GraphicsPathIterator myPathIterator = new GraphicsPathIterator (path)) {  	int myStartIndex;  	int myEndIndex;  	bool myIsClosed;  	// get the number of Subpaths.  	int numSubpaths = myPathIterator.SubpathCount;  	while (myPathIterator.NextSubpath (out myStartIndex' out myEndIndex' out myIsClosed) > 0) {  		lineObj line = new lineObj ();  		for (int i = myStartIndex; i <= myEndIndex; i++) {  			if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y))  				line.add (new pointObj (Pixel2MapX (path.PathPoints [i].X)' Pixel2MapY (path.PathPoints [i].Y)' 0' 0));  		}  		if (feature == null) {  			if (myIsClosed && line.numpoints > 2)  				feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  			else  				feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  		}  		if (line.numpoints >= 2)  			feature.add (line);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: using (GraphicsPathIterator myPathIterator = new GraphicsPathIterator (path)) {  	int myStartIndex;  	int myEndIndex;  	bool myIsClosed;  	// get the number of Subpaths.  	int numSubpaths = myPathIterator.SubpathCount;  	while (myPathIterator.NextSubpath (out myStartIndex' out myEndIndex' out myIsClosed) > 0) {  		lineObj line = new lineObj ();  		for (int i = myStartIndex; i <= myEndIndex; i++) {  			if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y))  				line.add (new pointObj (Pixel2MapX (path.PathPoints [i].X)' Pixel2MapY (path.PathPoints [i].Y)' 0' 0));  		}  		if (feature == null) {  			if (myIsClosed && line.numpoints > 2)  				feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  			else  				feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  		}  		if (line.numpoints >= 2)  			feature.add (line);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: while (myPathIterator.NextSubpath (out myStartIndex' out myEndIndex' out myIsClosed) > 0) {  	lineObj line = new lineObj ();  	for (int i = myStartIndex; i <= myEndIndex; i++) {  		if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y))  			line.add (new pointObj (Pixel2MapX (path.PathPoints [i].X)' Pixel2MapY (path.PathPoints [i].Y)' 0' 0));  	}  	if (feature == null) {  		if (myIsClosed && line.numpoints > 2)  			feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  		else  			feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  	}  	if (line.numpoints >= 2)  		feature.add (line);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: while (myPathIterator.NextSubpath (out myStartIndex' out myEndIndex' out myIsClosed) > 0) {  	lineObj line = new lineObj ();  	for (int i = myStartIndex; i <= myEndIndex; i++) {  		if (i == myStartIndex || (path.PathPoints [i].X != path.PathPoints [i - 1].X && path.PathPoints [i].Y != path.PathPoints [i - 1].Y))  			line.add (new pointObj (Pixel2MapX (path.PathPoints [i].X)' Pixel2MapY (path.PathPoints [i].Y)' 0' 0));  	}  	if (feature == null) {  		if (myIsClosed && line.numpoints > 2)  			feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  		else  			feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  	}  	if (line.numpoints >= 2)  		feature.add (line);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: if (feature == null) {  	if (myIsClosed && line.numpoints > 2)  		feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  	else  		feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: if (myIsClosed && line.numpoints > 2)  	feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON);  else  	feature = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,GraphicsPathToShape,The following statement contains a magic number: if (line.numpoints >= 2)  	feature.add (line);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,ZoomOut,The following statement contains a magic number: if (map != null) {  	using (pointObj center = new pointObj (map.width / 2' map.height / 2' 0' 0)) {  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  	}  	this.RefreshView ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,ZoomOut,The following statement contains a magic number: if (map != null) {  	using (pointObj center = new pointObj (map.width / 2' map.height / 2' 0' 0)) {  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  	}  	this.RefreshView ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,ZoomOut,The following statement contains a magic number: using (pointObj center = new pointObj (map.width / 2' map.height / 2' 0' 0)) {  	map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  	history.Add (new NavigationHistoryItem (map.extent));  	RaiseZoomChanged ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,ZoomOut,The following statement contains a magic number: using (pointObj center = new pointObj (map.width / 2' map.height / 2' 0' 0)) {  	map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  	history.Add (new NavigationHistoryItem (map.extent));  	RaiseZoomChanged ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,ZoomRectangle,The following statement contains a magic number: if (map != null && (maxx - minx) > 2 && (maxy - miny) > 2) {  	using (rectObj imgrect = new rectObj (minx' miny' maxx' maxy' 0)) {  		// mapscript requires this hack  		imgrect.miny = maxy;  		imgrect.maxy = miny;  		map.zoomRectangle (imgrect' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  		return;  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,ZoomRectangle,The following statement contains a magic number: if (map != null && (maxx - minx) > 2 && (maxy - miny) > 2) {  	using (rectObj imgrect = new rectObj (minx' miny' maxx' maxy' 0)) {  		// mapscript requires this hack  		imgrect.miny = maxy;  		imgrect.maxy = miny;  		map.zoomRectangle (imgrect' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  		return;  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RaisePositionChanged,The following statement contains a magic number: target.RaisePositionChanged (this' Math.Round ((map.extent.maxx + map.extent.minx) / 2' MapUtils.GetUnitPrecision (mapunits))' Math.Round ((map.extent.maxy + map.extent.miny) / 2' MapUtils.GetUnitPrecision (mapunits)));  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RaisePositionChanged,The following statement contains a magic number: target.RaisePositionChanged (this' Math.Round ((map.extent.maxx + map.extent.minx) / 2' MapUtils.GetUnitPrecision (mapunits))' Math.Round ((map.extent.maxy + map.extent.miny) / 2' MapUtils.GetUnitPrecision (mapunits)));  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (mapImage != null) {  	if (dragging) {  		if (inputMode == InputModes.Pan || forcePan) {  			float offsetX = (magnify - 1) * mouseX - magnify * dragRect.Width;  			float offsetY = (magnify - 1) * mouseY - magnify * dragRect.Height;  			pe.Graphics.DrawImage (mapImage' -offsetX' -offsetY' magnify * mapImage.Width' magnify * mapImage.Height);  		}  		else if (inputMode == InputModes.ZoomIn || inputMode == InputModes.ZoomOut || inputMode == InputModes.TrackRectangle) {  			// drawing the map image  			pe.Graphics.DrawImage (mapImage' 0' 0);  			// drawing the rectangle  			Rectangle normalizedRectangle = new Rectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Abs (dragRect.Width)' Math.Abs (dragRect.Height));  			pe.Graphics.FillRectangle (selectionBrush' normalizedRectangle);  			pe.Graphics.DrawRectangle (selectionPen' normalizedRectangle);  		}  	}  	else {  		float offsetX = (magnify - 1) * mouseX;  		float offsetY = (magnify - 1) * mouseY;  		// drawing the map image  		pe.Graphics.DrawImage (mapImage' -offsetX' -offsetY' magnify * mapImage.Width' magnify * mapImage.Height);  		if (inputMode == InputModes.TrackPolygon || inputMode == InputModes.TrackLine) {  			if (trackPoints != null && trackPoints.PointCount >= 2) {  				if (inputMode == InputModes.TrackPolygon)  					pe.Graphics.FillPath (selectionBrush' trackPoints);  				pe.Graphics.DrawPath (selectionPen' trackPoints);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (dragging) {  	if (inputMode == InputModes.Pan || forcePan) {  		float offsetX = (magnify - 1) * mouseX - magnify * dragRect.Width;  		float offsetY = (magnify - 1) * mouseY - magnify * dragRect.Height;  		pe.Graphics.DrawImage (mapImage' -offsetX' -offsetY' magnify * mapImage.Width' magnify * mapImage.Height);  	}  	else if (inputMode == InputModes.ZoomIn || inputMode == InputModes.ZoomOut || inputMode == InputModes.TrackRectangle) {  		// drawing the map image  		pe.Graphics.DrawImage (mapImage' 0' 0);  		// drawing the rectangle  		Rectangle normalizedRectangle = new Rectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Abs (dragRect.Width)' Math.Abs (dragRect.Height));  		pe.Graphics.FillRectangle (selectionBrush' normalizedRectangle);  		pe.Graphics.DrawRectangle (selectionPen' normalizedRectangle);  	}  }  else {  	float offsetX = (magnify - 1) * mouseX;  	float offsetY = (magnify - 1) * mouseY;  	// drawing the map image  	pe.Graphics.DrawImage (mapImage' -offsetX' -offsetY' magnify * mapImage.Width' magnify * mapImage.Height);  	if (inputMode == InputModes.TrackPolygon || inputMode == InputModes.TrackLine) {  		if (trackPoints != null && trackPoints.PointCount >= 2) {  			if (inputMode == InputModes.TrackPolygon)  				pe.Graphics.FillPath (selectionBrush' trackPoints);  			pe.Graphics.DrawPath (selectionPen' trackPoints);  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (inputMode == InputModes.TrackPolygon || inputMode == InputModes.TrackLine) {  	if (trackPoints != null && trackPoints.PointCount >= 2) {  		if (inputMode == InputModes.TrackPolygon)  			pe.Graphics.FillPath (selectionBrush' trackPoints);  		pe.Graphics.DrawPath (selectionPen' trackPoints);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (trackPoints != null && trackPoints.PointCount >= 2) {  	if (inputMode == InputModes.TrackPolygon)  		pe.Graphics.FillPath (selectionBrush' trackPoints);  	pe.Graphics.DrawPath (selectionPen' trackPoints);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (drawMessage != null) {  	using (Font font1 = new Font ("Arial"' 12' FontStyle.Bold' GraphicsUnit.Point)) {  		RectangleF rectF1 = new RectangleF (0' 0' this.Width' this.Height);  		pe.Graphics.DrawString (drawMessage' font1' Brushes.Blue' rectF1);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: using (Font font1 = new Font ("Arial"' 12' FontStyle.Bold' GraphicsUnit.Point)) {  	RectangleF rectF1 = new RectangleF (0' 0' this.Width' this.Height);  	pe.Graphics.DrawString (drawMessage' font1' Brushes.Blue' rectF1);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (centerMarker) {  	float centerX = ((float)this.Width - 1) / 2;  	float centerY = ((float)this.Height - 1) / 2;  	pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  	pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (centerMarker) {  	float centerX = ((float)this.Width - 1) / 2;  	float centerY = ((float)this.Height - 1) / 2;  	pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  	pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (centerMarker) {  	float centerX = ((float)this.Width - 1) / 2;  	float centerY = ((float)this.Height - 1) / 2;  	pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  	pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (centerMarker) {  	float centerX = ((float)this.Width - 1) / 2;  	float centerY = ((float)this.Height - 1) / 2;  	pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  	pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (centerMarker) {  	float centerX = ((float)this.Width - 1) / 2;  	float centerY = ((float)this.Height - 1) / 2;  	pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  	pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: if (centerMarker) {  	float centerX = ((float)this.Width - 1) / 2;  	float centerY = ((float)this.Height - 1) / 2;  	pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  	pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawLine (centerMarkerPen' centerX - 10' centerY' centerX + 10' centerY);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnPaint,The following statement contains a magic number: pe.Graphics.DrawLine (centerMarkerPen' centerX' centerY - 10' centerX' centerY + 10);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_LINE) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE)) {  		// adding a horizontal line sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height / 2' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON)) {  		// adding a rectangle sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.gap' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.gap' 0);  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.gap' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  		// adding a point sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_LINE) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE)) {  		// adding a horizontal line sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height / 2' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON)) {  		// adding a rectangle sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.gap' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.gap' 0);  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.gap' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  		// adding a point sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_LINE) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE)) {  		// adding a horizontal line sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height / 2' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON)) {  		// adding a rectangle sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.gap' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.gap' 0);  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.gap' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  		// adding a point sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_LINE) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE)) {  		// adding a horizontal line sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height / 2' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON)) {  		// adding a rectangle sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.gap' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.gap' 0);  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.gap' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  		// adding a point sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE)) {  	// adding a horizontal line sample  	using (lineObj line = new lineObj ()) {  		using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  			line.add (point);  			point.setXY (this.Width - this.gap' this.Height / 2' 0);  			line.add (point);  		}  		shape.add (line);  	}  	if (numvalues > 0)  		shape.initValues (numvalues);  	srcLayer.addFeature (shape);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_LINE)) {  	// adding a horizontal line sample  	using (lineObj line = new lineObj ()) {  		using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  			line.add (point);  			point.setXY (this.Width - this.gap' this.Height / 2' 0);  			line.add (point);  		}  		shape.add (line);  	}  	if (numvalues > 0)  		shape.initValues (numvalues);  	srcLayer.addFeature (shape);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (lineObj line = new lineObj ()) {  	using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  		line.add (point);  		point.setXY (this.Width - this.gap' this.Height / 2' 0);  		line.add (point);  	}  	shape.add (line);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (lineObj line = new lineObj ()) {  	using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  		line.add (point);  		point.setXY (this.Width - this.gap' this.Height / 2' 0);  		line.add (point);  	}  	shape.add (line);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  	line.add (point);  	point.setXY (this.Width - this.gap' this.Height / 2' 0);  	line.add (point);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (pointObj point = new pointObj (this.gap' this.Height / 2' 0' 0)) {  	line.add (point);  	point.setXY (this.Width - this.gap' this.Height / 2' 0);  	line.add (point);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: point.setXY (this.Width - this.gap' this.Height / 2' 0);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON)) {  		// adding a rectangle sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.gap' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.gap' 0);  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.gap' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  		// adding a point sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: if (srcLayer.type == MS_LAYER_TYPE.MS_LAYER_POLYGON) {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POLYGON)) {  		// adding a rectangle sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.gap' this.gap' 0' 0)) {  				line.add (point);  				point.setXY (this.Width - this.gap' this.gap' 0);  				line.add (point);  				point.setXY (this.Width - this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.Height - this.gap' 0);  				line.add (point);  				point.setXY (this.gap' this.gap' 0);  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  else {  	using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  		// adding a point sample  		using (lineObj line = new lineObj ()) {  			using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  				line.add (point);  			}  			shape.add (line);  		}  		if (numvalues > 0)  			shape.initValues (numvalues);  		srcLayer.addFeature (shape);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  	// adding a point sample  	using (lineObj line = new lineObj ()) {  		using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  			line.add (point);  		}  		shape.add (line);  	}  	if (numvalues > 0)  		shape.initValues (numvalues);  	srcLayer.addFeature (shape);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (shapeObj shape = new shapeObj ((int)MS_SHAPE_TYPE.MS_SHAPE_POINT)) {  	// adding a point sample  	using (lineObj line = new lineObj ()) {  		using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  			line.add (point);  		}  		shape.add (line);  	}  	if (numvalues > 0)  		shape.initValues (numvalues);  	srcLayer.addFeature (shape);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (lineObj line = new lineObj ()) {  	using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  		line.add (point);  	}  	shape.add (line);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (lineObj line = new lineObj ()) {  	using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  		line.add (point);  	}  	shape.add (line);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  	line.add (point);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,AddSampleFeature,The following statement contains a magic number: using (pointObj point = new pointObj (this.Width / 2' this.Height / 2' 0' 0)) {  	line.add (point);  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	if (this.Height > 2 && this.Width > 2 && map.extent.maxx > map.extent.minx && map.extent.maxy > map.extent.miny) {  		if (map.width != this.Width || map.height != this.Height) {  			map.height = this.Height;  			map.width = this.Width;  			map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  			RaiseZoomChanged ();  		}  		UpdateTansformations ();  		using (outputFormatObj format = map.outputformat) {  			string imageType = null;  			if ((format.renderer != mapscript.MS_RENDER_WITH_AGG && format.renderer != mapscript.MS_RENDER_WITH_CAIRO_RASTER) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0) {  				// falling back to the png type in case of the esoteric types  				imageType = map.imagetype;  				map.selectOutputFormat ("png");  				drawMessage = "MapManager cannot display maps in the output format " + imageType + "' rendering with png instead.";  			}  			else {  				drawMessage = null;  			}  			Cursor cur = this.Cursor;  			try {  				this.Cursor = Cursors.WaitCursor;  				if (drawQuery) {  					Stopwatch stopwatch = new Stopwatch ();  					stopwatch.Start ();  					using (imageObj image = map.drawQuery ()) {  						if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  							mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  						}  						Bitmap bitmap = (Bitmap)mapImage;  						BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  						try {  							image.getRawPixels (bitmapData.Scan0);  						}  						finally {  							bitmap.UnlockBits (bitmapData);  						}  						//byte[] img = image.getBytes();  						//using (MemoryStream ms = new MemoryStream(img))  						//{  						//    mapImage = Image.FromStream(ms);  						//}  						lastRenderTime = stopwatch.ElapsedMilliseconds;  					}  					stopwatch.Stop ();  				}  				else {  					Stopwatch stopwatch = new Stopwatch ();  					stopwatch.Start ();  					using (imageObj image = map.draw ()) {  						if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  							mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  						}  						Bitmap bitmap = (Bitmap)mapImage;  						BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  						try {  							image.getRawPixels (bitmapData.Scan0);  						}  						finally {  							bitmap.UnlockBits (bitmapData);  						}  						//byte[] img = image.getBytes();  						//using (MemoryStream ms = new MemoryStream(img))  						//{  						//    mapImage = Image.FromStream(ms);  						//}  						lastRenderTime = stopwatch.ElapsedMilliseconds;  					}  					stopwatch.Stop ();  				}  			}  			catch (Exception ex) {  				//drawMessage = "Unable to render image. " + ex.Message;  				EventProvider.RaiseEventMessage (this' ex.Message' EventProvider.EventTypes.Error);  			}  			finally {  				// switch back to the original type  				if (imageType != null)  					map.selectOutputFormat (imageType);  				this.Cursor = cur;  			}  		}  	}  	UpdateUnitValues ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	if (this.Height > 2 && this.Width > 2 && map.extent.maxx > map.extent.minx && map.extent.maxy > map.extent.miny) {  		if (map.width != this.Width || map.height != this.Height) {  			map.height = this.Height;  			map.width = this.Width;  			map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  			RaiseZoomChanged ();  		}  		UpdateTansformations ();  		using (outputFormatObj format = map.outputformat) {  			string imageType = null;  			if ((format.renderer != mapscript.MS_RENDER_WITH_AGG && format.renderer != mapscript.MS_RENDER_WITH_CAIRO_RASTER) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0) {  				// falling back to the png type in case of the esoteric types  				imageType = map.imagetype;  				map.selectOutputFormat ("png");  				drawMessage = "MapManager cannot display maps in the output format " + imageType + "' rendering with png instead.";  			}  			else {  				drawMessage = null;  			}  			Cursor cur = this.Cursor;  			try {  				this.Cursor = Cursors.WaitCursor;  				if (drawQuery) {  					Stopwatch stopwatch = new Stopwatch ();  					stopwatch.Start ();  					using (imageObj image = map.drawQuery ()) {  						if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  							mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  						}  						Bitmap bitmap = (Bitmap)mapImage;  						BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  						try {  							image.getRawPixels (bitmapData.Scan0);  						}  						finally {  							bitmap.UnlockBits (bitmapData);  						}  						//byte[] img = image.getBytes();  						//using (MemoryStream ms = new MemoryStream(img))  						//{  						//    mapImage = Image.FromStream(ms);  						//}  						lastRenderTime = stopwatch.ElapsedMilliseconds;  					}  					stopwatch.Stop ();  				}  				else {  					Stopwatch stopwatch = new Stopwatch ();  					stopwatch.Start ();  					using (imageObj image = map.draw ()) {  						if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  							mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  						}  						Bitmap bitmap = (Bitmap)mapImage;  						BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  						try {  							image.getRawPixels (bitmapData.Scan0);  						}  						finally {  							bitmap.UnlockBits (bitmapData);  						}  						//byte[] img = image.getBytes();  						//using (MemoryStream ms = new MemoryStream(img))  						//{  						//    mapImage = Image.FromStream(ms);  						//}  						lastRenderTime = stopwatch.ElapsedMilliseconds;  					}  					stopwatch.Stop ();  				}  			}  			catch (Exception ex) {  				//drawMessage = "Unable to render image. " + ex.Message;  				EventProvider.RaiseEventMessage (this' ex.Message' EventProvider.EventTypes.Error);  			}  			finally {  				// switch back to the original type  				if (imageType != null)  					map.selectOutputFormat (imageType);  				this.Cursor = cur;  			}  		}  	}  	UpdateUnitValues ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The following statement contains a magic number: if (this.Height > 2 && this.Width > 2 && map.extent.maxx > map.extent.minx && map.extent.maxy > map.extent.miny) {  	if (map.width != this.Width || map.height != this.Height) {  		map.height = this.Height;  		map.width = this.Width;  		map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  		RaiseZoomChanged ();  	}  	UpdateTansformations ();  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG && format.renderer != mapscript.MS_RENDER_WITH_CAIRO_RASTER) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0) {  			// falling back to the png type in case of the esoteric types  			imageType = map.imagetype;  			map.selectOutputFormat ("png");  			drawMessage = "MapManager cannot display maps in the output format " + imageType + "' rendering with png instead.";  		}  		else {  			drawMessage = null;  		}  		Cursor cur = this.Cursor;  		try {  			this.Cursor = Cursors.WaitCursor;  			if (drawQuery) {  				Stopwatch stopwatch = new Stopwatch ();  				stopwatch.Start ();  				using (imageObj image = map.drawQuery ()) {  					if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  						mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  					}  					Bitmap bitmap = (Bitmap)mapImage;  					BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  					try {  						image.getRawPixels (bitmapData.Scan0);  					}  					finally {  						bitmap.UnlockBits (bitmapData);  					}  					//byte[] img = image.getBytes();  					//using (MemoryStream ms = new MemoryStream(img))  					//{  					//    mapImage = Image.FromStream(ms);  					//}  					lastRenderTime = stopwatch.ElapsedMilliseconds;  				}  				stopwatch.Stop ();  			}  			else {  				Stopwatch stopwatch = new Stopwatch ();  				stopwatch.Start ();  				using (imageObj image = map.draw ()) {  					if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  						mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  					}  					Bitmap bitmap = (Bitmap)mapImage;  					BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  					try {  						image.getRawPixels (bitmapData.Scan0);  					}  					finally {  						bitmap.UnlockBits (bitmapData);  					}  					//byte[] img = image.getBytes();  					//using (MemoryStream ms = new MemoryStream(img))  					//{  					//    mapImage = Image.FromStream(ms);  					//}  					lastRenderTime = stopwatch.ElapsedMilliseconds;  				}  				stopwatch.Stop ();  			}  		}  		catch (Exception ex) {  			//drawMessage = "Unable to render image. " + ex.Message;  			EventProvider.RaiseEventMessage (this' ex.Message' EventProvider.EventTypes.Error);  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			this.Cursor = cur;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The following statement contains a magic number: if (this.Height > 2 && this.Width > 2 && map.extent.maxx > map.extent.minx && map.extent.maxy > map.extent.miny) {  	if (map.width != this.Width || map.height != this.Height) {  		map.height = this.Height;  		map.width = this.Width;  		map.setExtent (map.extent.minx' map.extent.miny' map.extent.maxx' map.extent.maxy);  		RaiseZoomChanged ();  	}  	UpdateTansformations ();  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG && format.renderer != mapscript.MS_RENDER_WITH_CAIRO_RASTER) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0) {  			// falling back to the png type in case of the esoteric types  			imageType = map.imagetype;  			map.selectOutputFormat ("png");  			drawMessage = "MapManager cannot display maps in the output format " + imageType + "' rendering with png instead.";  		}  		else {  			drawMessage = null;  		}  		Cursor cur = this.Cursor;  		try {  			this.Cursor = Cursors.WaitCursor;  			if (drawQuery) {  				Stopwatch stopwatch = new Stopwatch ();  				stopwatch.Start ();  				using (imageObj image = map.drawQuery ()) {  					if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  						mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  					}  					Bitmap bitmap = (Bitmap)mapImage;  					BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  					try {  						image.getRawPixels (bitmapData.Scan0);  					}  					finally {  						bitmap.UnlockBits (bitmapData);  					}  					//byte[] img = image.getBytes();  					//using (MemoryStream ms = new MemoryStream(img))  					//{  					//    mapImage = Image.FromStream(ms);  					//}  					lastRenderTime = stopwatch.ElapsedMilliseconds;  				}  				stopwatch.Stop ();  			}  			else {  				Stopwatch stopwatch = new Stopwatch ();  				stopwatch.Start ();  				using (imageObj image = map.draw ()) {  					if (mapImage == null || mapImage.Width != image.width || mapImage.Height != image.height) {  						mapImage = new Bitmap (image.width' image.height' PixelFormat.Format32bppRgb);  					}  					Bitmap bitmap = (Bitmap)mapImage;  					BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' image.width' image.height)' ImageLockMode.ReadWrite' PixelFormat.Format32bppRgb);  					try {  						image.getRawPixels (bitmapData.Scan0);  					}  					finally {  						bitmap.UnlockBits (bitmapData);  					}  					//byte[] img = image.getBytes();  					//using (MemoryStream ms = new MemoryStream(img))  					//{  					//    mapImage = Image.FromStream(ms);  					//}  					lastRenderTime = stopwatch.ElapsedMilliseconds;  				}  				stopwatch.Stop ();  			}  		}  		catch (Exception ex) {  			//drawMessage = "Unable to render image. " + ex.Message;  			EventProvider.RaiseEventMessage (this' ex.Message' EventProvider.EventTypes.Error);  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			this.Cursor = cur;  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SaveImage,The following statement contains a magic number: if (map != null) {  	if (this.Height > 2 && this.Width > 2) {  		map.height = this.Height;  		map.width = this.Width;  		using (imageObj image = map.draw ()) {  			image.save (fileName' map);  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SaveImage,The following statement contains a magic number: if (map != null) {  	if (this.Height > 2 && this.Width > 2) {  		map.height = this.Height;  		map.width = this.Width;  		using (imageObj image = map.draw ()) {  			image.save (fileName' map);  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SaveImage,The following statement contains a magic number: if (this.Height > 2 && this.Width > 2) {  	map.height = this.Height;  	map.width = this.Width;  	using (imageObj image = map.draw ()) {  		image.save (fileName' map);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,SaveImage,The following statement contains a magic number: if (this.Height > 2 && this.Width > 2) {  	map.height = this.Height;  	map.width = this.Width;  	using (imageObj image = map.draw ()) {  		image.save (fileName' map);  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseMove,The following statement contains a magic number: if (inputMode == InputModes.TrackPolygon || inputMode == InputModes.TrackLine) {  	if (trackPoints != null) {  		PointF[] points = trackPoints.PathPoints;  		points [points.Length - 1].X = e.X;  		points [points.Length - 1].Y = e.Y;  		trackPoints = new GraphicsPath ();  		if (inputMode == InputModes.TrackPolygon && points.Length > 2)  			trackPoints.AddPolygon (points);  		else  			trackPoints.AddLines (points);  		this.Refresh ();  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseMove,The following statement contains a magic number: if (trackPoints != null) {  	PointF[] points = trackPoints.PathPoints;  	points [points.Length - 1].X = e.X;  	points [points.Length - 1].Y = e.Y;  	trackPoints = new GraphicsPath ();  	if (inputMode == InputModes.TrackPolygon && points.Length > 2)  		trackPoints.AddPolygon (points);  	else  		trackPoints.AddLines (points);  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseMove,The following statement contains a magic number: if (inputMode == InputModes.TrackPolygon && points.Length > 2)  	trackPoints.AddPolygon (points);  else  	trackPoints.AddLines (points);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,TestResult,The following statement contains a magic number: layer.queryByPoint (map' pt' mapscript.MS_SINGLE' 4);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.Select) {  	//pointObj pt = new pointObj(Pixel2MapX(e.X)' Pixel2MapY(e.Y)' 0' 0);  	//TestResult(pt);  	//return;  	using (pointObj imgpoint = new pointObj (Pixel2MapX (e.X)' Pixel2MapY (e.Y)' 0' 0)) {  		ClearResults ();  		// clear the previous results  		map.queryByPoint (imgpoint' mapscript.MS_MULTIPLE' 4);  		SetSelectionMode (true);  		this.target.RaiseSelectionChanged (this);  		this.RefreshView ();  	}  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: using (pointObj imgpoint = new pointObj (Pixel2MapX (e.X)' Pixel2MapY (e.Y)' 0' 0)) {  	ClearResults ();  	// clear the previous results  	map.queryByPoint (imgpoint' mapscript.MS_MULTIPLE' 4);  	SetSelectionMode (true);  	this.target.RaiseSelectionChanged (this);  	this.RefreshView ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: map.queryByPoint (imgpoint' mapscript.MS_MULTIPLE' 4);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragging) {  	dragging = false;  	dragRect.Width = e.X - dragRect.X;  	dragRect.Height = e.Y - dragRect.Y;  	if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  		if (map != null)  			PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  		return;  	}  	if (inputMode == InputModes.ZoomIn) {  		ZoomRectangle (Math.Min (dragRect.X' dragRect.X + dragRect.Width)' Math.Min (dragRect.Y' dragRect.Y + dragRect.Height)' Math.Max (dragRect.X' dragRect.X + dragRect.Width)' Math.Max (dragRect.Y' dragRect.Y + dragRect.Height));  		return;  	}  	if (inputMode == InputModes.ZoomOut) {  		if (map != null) {  			//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  			//if (dragRect.Width <= 2) dragRect.Width = 2;  			//if (dragRect.Height <= 2) dragRect.Height = 2;  			if (dragRect.Width <= 2 || dragRect.Height <= 2) {  				ZoomOut (2);  			}  			else {  				using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  					double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  					map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  					history.Add (new NavigationHistoryItem (map.extent));  					RaiseZoomChanged ();  					this.RefreshView ();  				}  			}  		}  		return;  	}  	if (inputMode == InputModes.TrackRectangle) {  		double x = Pixel2MapX (dragRect.X);  		double y = Pixel2MapY (dragRect.Y);  		double x2 = Pixel2MapX (dragRect.X + dragRect.Width);  		double y2 = Pixel2MapY (dragRect.Y + dragRect.Height);  		using (rectObj rect = new rectObj (Math.Min (x' x2)' Math.Min (y' y2)' Math.Max (x' x2)' Math.Max (y' y2)' 0)) {  			map.queryByRect (rect);  			SetSelectionMode (true);  			this.target.RaiseSelectionChanged (this);  			this.RefreshView ();  			return;  		}  	}  	this.Refresh ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  	if (map != null)  		PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.Pan || e.Button == MouseButtons.Middle) {  	if (map != null)  		PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null)  	PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null)  	PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: PanTo (map.width / 2 - dragRect.Width' map.height / 2 - dragRect.Height);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.ZoomOut) {  	if (map != null) {  		//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  		//if (dragRect.Width <= 2) dragRect.Width = 2;  		//if (dragRect.Height <= 2) dragRect.Height = 2;  		if (dragRect.Width <= 2 || dragRect.Height <= 2) {  			ZoomOut (2);  		}  		else {  			using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  				double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  				map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  				history.Add (new NavigationHistoryItem (map.extent));  				RaiseZoomChanged ();  				this.RefreshView ();  			}  		}  	}  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.ZoomOut) {  	if (map != null) {  		//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  		//if (dragRect.Width <= 2) dragRect.Width = 2;  		//if (dragRect.Height <= 2) dragRect.Height = 2;  		if (dragRect.Width <= 2 || dragRect.Height <= 2) {  			ZoomOut (2);  		}  		else {  			using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  				double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  				map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  				history.Add (new NavigationHistoryItem (map.extent));  				RaiseZoomChanged ();  				this.RefreshView ();  			}  		}  	}  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.ZoomOut) {  	if (map != null) {  		//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  		//if (dragRect.Width <= 2) dragRect.Width = 2;  		//if (dragRect.Height <= 2) dragRect.Height = 2;  		if (dragRect.Width <= 2 || dragRect.Height <= 2) {  			ZoomOut (2);  		}  		else {  			using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  				double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  				map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  				history.Add (new NavigationHistoryItem (map.extent));  				RaiseZoomChanged ();  				this.RefreshView ();  			}  		}  	}  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.ZoomOut) {  	if (map != null) {  		//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  		//if (dragRect.Width <= 2) dragRect.Width = 2;  		//if (dragRect.Height <= 2) dragRect.Height = 2;  		if (dragRect.Width <= 2 || dragRect.Height <= 2) {  			ZoomOut (2);  		}  		else {  			using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  				double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  				map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  				history.Add (new NavigationHistoryItem (map.extent));  				RaiseZoomChanged ();  				this.RefreshView ();  			}  		}  	}  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (inputMode == InputModes.ZoomOut) {  	if (map != null) {  		//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  		//if (dragRect.Width <= 2) dragRect.Width = 2;  		//if (dragRect.Height <= 2) dragRect.Height = 2;  		if (dragRect.Width <= 2 || dragRect.Height <= 2) {  			ZoomOut (2);  		}  		else {  			using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  				double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  				map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  				history.Add (new NavigationHistoryItem (map.extent));  				RaiseZoomChanged ();  				this.RefreshView ();  			}  		}  	}  	return;  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null) {  	//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  	//if (dragRect.Width <= 2) dragRect.Width = 2;  	//if (dragRect.Height <= 2) dragRect.Height = 2;  	if (dragRect.Width <= 2 || dragRect.Height <= 2) {  		ZoomOut (2);  	}  	else {  		using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  			double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  			map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  			history.Add (new NavigationHistoryItem (map.extent));  			RaiseZoomChanged ();  			this.RefreshView ();  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null) {  	//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  	//if (dragRect.Width <= 2) dragRect.Width = 2;  	//if (dragRect.Height <= 2) dragRect.Height = 2;  	if (dragRect.Width <= 2 || dragRect.Height <= 2) {  		ZoomOut (2);  	}  	else {  		using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  			double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  			map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  			history.Add (new NavigationHistoryItem (map.extent));  			RaiseZoomChanged ();  			this.RefreshView ();  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null) {  	//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  	//if (dragRect.Width <= 2) dragRect.Width = 2;  	//if (dragRect.Height <= 2) dragRect.Height = 2;  	if (dragRect.Width <= 2 || dragRect.Height <= 2) {  		ZoomOut (2);  	}  	else {  		using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  			double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  			map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  			history.Add (new NavigationHistoryItem (map.extent));  			RaiseZoomChanged ();  			this.RefreshView ();  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null) {  	//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  	//if (dragRect.Width <= 2) dragRect.Width = 2;  	//if (dragRect.Height <= 2) dragRect.Height = 2;  	if (dragRect.Width <= 2 || dragRect.Height <= 2) {  		ZoomOut (2);  	}  	else {  		using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  			double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  			map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  			history.Add (new NavigationHistoryItem (map.extent));  			RaiseZoomChanged ();  			this.RefreshView ();  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (map != null) {  	//Stephane: change behaviour if small drag of point click to zoom out by a factor of 2' like IntraMaps  	//if (dragRect.Width <= 2) dragRect.Width = 2;  	//if (dragRect.Height <= 2) dragRect.Height = 2;  	if (dragRect.Width <= 2 || dragRect.Height <= 2) {  		ZoomOut (2);  	}  	else {  		using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  			double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  			map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  			history.Add (new NavigationHistoryItem (map.extent));  			RaiseZoomChanged ();  			this.RefreshView ();  		}  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragRect.Width <= 2 || dragRect.Height <= 2) {  	ZoomOut (2);  }  else {  	using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  		double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragRect.Width <= 2 || dragRect.Height <= 2) {  	ZoomOut (2);  }  else {  	using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  		double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragRect.Width <= 2 || dragRect.Height <= 2) {  	ZoomOut (2);  }  else {  	using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  		double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragRect.Width <= 2 || dragRect.Height <= 2) {  	ZoomOut (2);  }  else {  	using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  		double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: if (dragRect.Width <= 2 || dragRect.Height <= 2) {  	ZoomOut (2);  }  else {  	using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  		double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  		map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  		history.Add (new NavigationHistoryItem (map.extent));  		RaiseZoomChanged ();  		this.RefreshView ();  	}  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: ZoomOut (2);  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  	double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  	map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  	history.Add (new NavigationHistoryItem (map.extent));  	RaiseZoomChanged ();  	this.RefreshView ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,MapControl_MouseUp,The following statement contains a magic number: using (pointObj center = new pointObj (dragRect.X + dragRect.Width / 2' dragRect.Y + dragRect.Height / 2' 0' 0)) {  	double zoomfactor = Math.Min ((double)map.width / dragRect.Width' (double)map.height / dragRect.Height);  	map.zoomScale (zoomfactor * map.scaledenom' center' map.width' map.height' map.extent' null);  	history.Add (new NavigationHistoryItem (map.extent));  	RaiseZoomChanged ();  	this.RefreshView ();  }  
Magic Number,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,OnMouseWheel,The following statement contains a magic number: magnify *= (float)e.Delta / 480 + 1;  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,PickerBase,The following statement contains a magic number: paintValueWidth = 20;  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,LayoutControls,The following statement contains a magic number: inner.Inflate (-2' -2);  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,LayoutControls,The following statement contains a magic number: inner.Inflate (-2' -2);  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: if ((Editor == null) || (Editor.GetEditStyle () == UITypeEditorEditStyle.None)) {  	if (!IsEnumerable ()) {  		return;  	}  	object[] array = GetValueList ();  	pickerListBox.Items.Clear ();  	using (Graphics graphics = base.CreateGraphics ()) {  		int width = 0;  		Font font = pickerListBox.Font;  		foreach (object item in array) {  			if (!pickerListBox.Items.Contains (item)) {  				string text = GetValueAsText (item);  				if (!PaintValueOnly) {  					SizeF size = graphics.MeasureString (text' font);  					width = (int)Math.Max ((float)width' size.Width);  				}  				pickerListBox.Items.Add (item);  			}  		}  		if (this.PaintValueSupported) {  			width += 24;  		}  		Rectangle bound = base.Bounds;  		pickerListBox.SelectedItem = Value;  		pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  		pickerListBox.Width = Math.Max (width' bound.Width - 2);  		dropDownCommit = false;  		pickerService.DropDownControl (pickerListBox);  		return;  	}  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: if ((Editor == null) || (Editor.GetEditStyle () == UITypeEditorEditStyle.None)) {  	if (!IsEnumerable ()) {  		return;  	}  	object[] array = GetValueList ();  	pickerListBox.Items.Clear ();  	using (Graphics graphics = base.CreateGraphics ()) {  		int width = 0;  		Font font = pickerListBox.Font;  		foreach (object item in array) {  			if (!pickerListBox.Items.Contains (item)) {  				string text = GetValueAsText (item);  				if (!PaintValueOnly) {  					SizeF size = graphics.MeasureString (text' font);  					width = (int)Math.Max ((float)width' size.Width);  				}  				pickerListBox.Items.Add (item);  			}  		}  		if (this.PaintValueSupported) {  			width += 24;  		}  		Rectangle bound = base.Bounds;  		pickerListBox.SelectedItem = Value;  		pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  		pickerListBox.Width = Math.Max (width' bound.Width - 2);  		dropDownCommit = false;  		pickerService.DropDownControl (pickerListBox);  		return;  	}  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: if ((Editor == null) || (Editor.GetEditStyle () == UITypeEditorEditStyle.None)) {  	if (!IsEnumerable ()) {  		return;  	}  	object[] array = GetValueList ();  	pickerListBox.Items.Clear ();  	using (Graphics graphics = base.CreateGraphics ()) {  		int width = 0;  		Font font = pickerListBox.Font;  		foreach (object item in array) {  			if (!pickerListBox.Items.Contains (item)) {  				string text = GetValueAsText (item);  				if (!PaintValueOnly) {  					SizeF size = graphics.MeasureString (text' font);  					width = (int)Math.Max ((float)width' size.Width);  				}  				pickerListBox.Items.Add (item);  			}  		}  		if (this.PaintValueSupported) {  			width += 24;  		}  		Rectangle bound = base.Bounds;  		pickerListBox.SelectedItem = Value;  		pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  		pickerListBox.Width = Math.Max (width' bound.Width - 2);  		dropDownCommit = false;  		pickerService.DropDownControl (pickerListBox);  		return;  	}  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: using (Graphics graphics = base.CreateGraphics ()) {  	int width = 0;  	Font font = pickerListBox.Font;  	foreach (object item in array) {  		if (!pickerListBox.Items.Contains (item)) {  			string text = GetValueAsText (item);  			if (!PaintValueOnly) {  				SizeF size = graphics.MeasureString (text' font);  				width = (int)Math.Max ((float)width' size.Width);  			}  			pickerListBox.Items.Add (item);  		}  	}  	if (this.PaintValueSupported) {  		width += 24;  	}  	Rectangle bound = base.Bounds;  	pickerListBox.SelectedItem = Value;  	pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  	pickerListBox.Width = Math.Max (width' bound.Width - 2);  	dropDownCommit = false;  	pickerService.DropDownControl (pickerListBox);  	return;  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: using (Graphics graphics = base.CreateGraphics ()) {  	int width = 0;  	Font font = pickerListBox.Font;  	foreach (object item in array) {  		if (!pickerListBox.Items.Contains (item)) {  			string text = GetValueAsText (item);  			if (!PaintValueOnly) {  				SizeF size = graphics.MeasureString (text' font);  				width = (int)Math.Max ((float)width' size.Width);  			}  			pickerListBox.Items.Add (item);  		}  	}  	if (this.PaintValueSupported) {  		width += 24;  	}  	Rectangle bound = base.Bounds;  	pickerListBox.SelectedItem = Value;  	pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  	pickerListBox.Width = Math.Max (width' bound.Width - 2);  	dropDownCommit = false;  	pickerService.DropDownControl (pickerListBox);  	return;  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: using (Graphics graphics = base.CreateGraphics ()) {  	int width = 0;  	Font font = pickerListBox.Font;  	foreach (object item in array) {  		if (!pickerListBox.Items.Contains (item)) {  			string text = GetValueAsText (item);  			if (!PaintValueOnly) {  				SizeF size = graphics.MeasureString (text' font);  				width = (int)Math.Max ((float)width' size.Width);  			}  			pickerListBox.Items.Add (item);  		}  	}  	if (this.PaintValueSupported) {  		width += 24;  	}  	Rectangle bound = base.Bounds;  	pickerListBox.SelectedItem = Value;  	pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  	pickerListBox.Width = Math.Max (width' bound.Width - 2);  	dropDownCommit = false;  	pickerService.DropDownControl (pickerListBox);  	return;  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: if (this.PaintValueSupported) {  	width += 24;  }  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: width += 24;  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: pickerListBox.Height = (int)Math.Max (font.GetHeight () + 2f' (float)Math.Min (200' pickerListBox.PreferredHeight));  
Magic Number,DMS.MapLibrary,PickerBase,C:\repos\DMS-Aus_MapManager\MapLibrary\PickerBase.cs,DoDropDown,The following statement contains a magic number: pickerListBox.Width = Math.Max (width' bound.Width - 2);  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs.Length > 3) {  	if (names.Length > 1) {  		AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  	else {  		if (proj_defs [2].Contains ("longlat"))  			AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  		else  			AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs.Length > 3) {  	if (names.Length > 1) {  		AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  	else {  		if (proj_defs [2].Contains ("longlat"))  			AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  		else  			AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs.Length > 3) {  	if (names.Length > 1) {  		AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  	else {  		if (proj_defs [2].Contains ("longlat"))  			AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  		else  			AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs.Length > 3) {  	if (names.Length > 1) {  		AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  	else {  		if (proj_defs [2].Contains ("longlat"))  			AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  		else  			AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs.Length > 3) {  	if (names.Length > 1) {  		AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  	else {  		if (proj_defs [2].Contains ("longlat"))  			AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  		else  			AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	}  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (names.Length > 1) {  	AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  else {  	if (proj_defs [2].Contains ("longlat"))  		AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	else  		AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (names.Length > 1) {  	AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  else {  	if (proj_defs [2].Contains ("longlat"))  		AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	else  		AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (names.Length > 1) {  	AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  else {  	if (proj_defs [2].Contains ("longlat"))  		AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	else  		AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (names.Length > 1) {  	AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  else {  	if (proj_defs [2].Contains ("longlat"))  		AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  	else  		AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  }  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: AddListItem (names [0].Trim ()' names [1].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs [2].Contains ("longlat"))  	AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  else  	AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs [2].Contains ("longlat"))  	AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  else  	AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: if (proj_defs [2].Contains ("longlat"))  	AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  else  	AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: AddListItem ("Longitude-Latitude"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  
Magic Number,DMS.MapLibrary,ProjectionBrowserDialog,C:\repos\DMS-Aus_MapManager\MapLibrary\ProjectionBrowserDialog.cs,ProcessLine,The following statement contains a magic number: AddListItem ("Other Non Geographic"' names [0].Trim ()' proj_defs [1].Trim ()' proj_defs [2].Trim ());  
Magic Number,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,UpdateExtentValues,The following statement contains a magic number: textBoxX.Text = Convert.ToString (Math.Round ((map.extent.maxx + map.extent.minx) / 2' unitPrecision));  
Magic Number,DMS.MapLibrary,MapPropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\MapPropertyEditor.cs,UpdateExtentValues,The following statement contains a magic number: textBoxY.Text = Convert.ToString (Math.Round ((map.extent.maxy + map.extent.miny) / 2' unitPrecision));  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (map != null) {  	// setting up the icon background colors createLegendIcon  	// will take over the legend imagecolor setting from the map object   	int red = map.legend.imagecolor.red;  	int green = map.legend.imagecolor.green;  	int blue = map.legend.imagecolor.blue;  	map.legend.imagecolor.red = this.BackColor.R;  	map.legend.imagecolor.green = this.BackColor.G;  	map.legend.imagecolor.blue = this.BackColor.B;  	listView.BackColor = this.BackColor;  	int layerIndex = -1;  	int classIndex = -1;  	using (outputFormatObj format = map.outputformat) {  		string imageType = null;  		if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  			// falling back to the png type in case of the esoteric or bad looking types  			imageType = map.imagetype;  			map.selectOutputFormat ("png24");  		}  		imageList.Images.Clear ();  		imageList.ImageSize = new Size (30' 20);  		try {  			for (int i = 0; i < map.numlayers; i++) {  				layerObj layer = map.getLayer (i);  				if (layer.status != mapscript.MS_OFF) {  					resultObj res;  					shapeObj feature;  					using (resultCacheObj results = layer.getResults ()) {  						if (results != null && results.numresults > 0) {  							// extracting the features found  							for (int j = 0; j < results.numresults; j++) {  								res = results.getResult (j);  								feature = layer.getShape (res);  								if (feature != null) {  									if (layerIndex != layer.index || classIndex != res.classindex) {  										layerIndex = layer.index;  										classIndex = res.classindex;  										if (classIndex < 0)  											classIndex = 0;  										// creating the icon for this class  										using (classObj def_class = new classObj (null))// for drawing legend images  										 {  											using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  												// drawing the class icons  												if (layer.numclasses > classIndex)  													layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  												byte[] img = image.getBytes ();  												using (MemoryStream ms = new MemoryStream (img)) {  													imageList.Images.Add (Image.FromStream (ms));  												}  											}  										}  									}  									ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  									item.SubItems.Add (feature.index.ToString ());  									item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  									listView.Items.Add (item);  									StringBuilder s = new StringBuilder ("");  									s.AppendLine ("Feature Properties:");  									for (int k = 0; k < layer.numitems; k++) {  										s.Append (layer.getItem (k));  										s.Append (" = ");  										s.AppendLine (feature.getValue (k));  									}  									item.Tag = s.ToString ();  									item.SubItems [0].Tag = layer;  									feature.classindex = res.classindex;  									item.SubItems [1].Tag = feature;  								}  							}  						}  					}  				}  			}  		}  		finally {  			// switch back to the original type  			if (imageType != null)  				map.selectOutputFormat (imageType);  			// restoring the original legend backgroundcolor  			map.legend.imagecolor.red = red;  			map.legend.imagecolor.green = green;  			map.legend.imagecolor.blue = blue;  		}  		listView.SmallImageList = imageList;  	}  	if (listView.Items.Count > 0)  		listView.Items [0].Selected = true;  	else  		richTextBox.Text = "";  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (outputFormatObj format = map.outputformat) {  	string imageType = null;  	if ((format.renderer != mapscript.MS_RENDER_WITH_AGG) || string.Compare (format.mimetype.Trim ()' "image/vnd.wap.wbmp"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/tiff"' true) == 0 || string.Compare (format.mimetype.Trim ()' "image/jpeg"' true) == 0) {  		// falling back to the png type in case of the esoteric or bad looking types  		imageType = map.imagetype;  		map.selectOutputFormat ("png24");  	}  	imageList.Images.Clear ();  	imageList.ImageSize = new Size (30' 20);  	try {  		for (int i = 0; i < map.numlayers; i++) {  			layerObj layer = map.getLayer (i);  			if (layer.status != mapscript.MS_OFF) {  				resultObj res;  				shapeObj feature;  				using (resultCacheObj results = layer.getResults ()) {  					if (results != null && results.numresults > 0) {  						// extracting the features found  						for (int j = 0; j < results.numresults; j++) {  							res = results.getResult (j);  							feature = layer.getShape (res);  							if (feature != null) {  								if (layerIndex != layer.index || classIndex != res.classindex) {  									layerIndex = layer.index;  									classIndex = res.classindex;  									if (classIndex < 0)  										classIndex = 0;  									// creating the icon for this class  									using (classObj def_class = new classObj (null))// for drawing legend images  									 {  										using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  											// drawing the class icons  											if (layer.numclasses > classIndex)  												layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  											byte[] img = image.getBytes ();  											using (MemoryStream ms = new MemoryStream (img)) {  												imageList.Images.Add (Image.FromStream (ms));  											}  										}  									}  								}  								ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  								item.SubItems.Add (feature.index.ToString ());  								item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  								listView.Items.Add (item);  								StringBuilder s = new StringBuilder ("");  								s.AppendLine ("Feature Properties:");  								for (int k = 0; k < layer.numitems; k++) {  									s.Append (layer.getItem (k));  									s.Append (" = ");  									s.AppendLine (feature.getValue (k));  								}  								item.Tag = s.ToString ();  								item.SubItems [0].Tag = layer;  								feature.classindex = res.classindex;  								item.SubItems [1].Tag = feature;  							}  						}  					}  				}  			}  		}  	}  	finally {  		// switch back to the original type  		if (imageType != null)  			map.selectOutputFormat (imageType);  		// restoring the original legend backgroundcolor  		map.legend.imagecolor.red = red;  		map.legend.imagecolor.green = green;  		map.legend.imagecolor.blue = blue;  	}  	listView.SmallImageList = imageList;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: imageList.ImageSize = new Size (30' 20);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: imageList.ImageSize = new Size (30' 20);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: try {  	for (int i = 0; i < map.numlayers; i++) {  		layerObj layer = map.getLayer (i);  		if (layer.status != mapscript.MS_OFF) {  			resultObj res;  			shapeObj feature;  			using (resultCacheObj results = layer.getResults ()) {  				if (results != null && results.numresults > 0) {  					// extracting the features found  					for (int j = 0; j < results.numresults; j++) {  						res = results.getResult (j);  						feature = layer.getShape (res);  						if (feature != null) {  							if (layerIndex != layer.index || classIndex != res.classindex) {  								layerIndex = layer.index;  								classIndex = res.classindex;  								if (classIndex < 0)  									classIndex = 0;  								// creating the icon for this class  								using (classObj def_class = new classObj (null))// for drawing legend images  								 {  									using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  										// drawing the class icons  										if (layer.numclasses > classIndex)  											layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  										byte[] img = image.getBytes ();  										using (MemoryStream ms = new MemoryStream (img)) {  											imageList.Images.Add (Image.FromStream (ms));  										}  									}  								}  							}  							ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  							item.SubItems.Add (feature.index.ToString ());  							item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  							listView.Items.Add (item);  							StringBuilder s = new StringBuilder ("");  							s.AppendLine ("Feature Properties:");  							for (int k = 0; k < layer.numitems; k++) {  								s.Append (layer.getItem (k));  								s.Append (" = ");  								s.AppendLine (feature.getValue (k));  							}  							item.Tag = s.ToString ();  							item.SubItems [0].Tag = layer;  							feature.classindex = res.classindex;  							item.SubItems [1].Tag = feature;  						}  					}  				}  			}  		}  	}  }  finally {  	// switch back to the original type  	if (imageType != null)  		map.selectOutputFormat (imageType);  	// restoring the original legend backgroundcolor  	map.legend.imagecolor.red = red;  	map.legend.imagecolor.green = green;  	map.legend.imagecolor.blue = blue;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: try {  	for (int i = 0; i < map.numlayers; i++) {  		layerObj layer = map.getLayer (i);  		if (layer.status != mapscript.MS_OFF) {  			resultObj res;  			shapeObj feature;  			using (resultCacheObj results = layer.getResults ()) {  				if (results != null && results.numresults > 0) {  					// extracting the features found  					for (int j = 0; j < results.numresults; j++) {  						res = results.getResult (j);  						feature = layer.getShape (res);  						if (feature != null) {  							if (layerIndex != layer.index || classIndex != res.classindex) {  								layerIndex = layer.index;  								classIndex = res.classindex;  								if (classIndex < 0)  									classIndex = 0;  								// creating the icon for this class  								using (classObj def_class = new classObj (null))// for drawing legend images  								 {  									using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  										// drawing the class icons  										if (layer.numclasses > classIndex)  											layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  										byte[] img = image.getBytes ();  										using (MemoryStream ms = new MemoryStream (img)) {  											imageList.Images.Add (Image.FromStream (ms));  										}  									}  								}  							}  							ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  							item.SubItems.Add (feature.index.ToString ());  							item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  							listView.Items.Add (item);  							StringBuilder s = new StringBuilder ("");  							s.AppendLine ("Feature Properties:");  							for (int k = 0; k < layer.numitems; k++) {  								s.Append (layer.getItem (k));  								s.Append (" = ");  								s.AppendLine (feature.getValue (k));  							}  							item.Tag = s.ToString ();  							item.SubItems [0].Tag = layer;  							feature.classindex = res.classindex;  							item.SubItems [1].Tag = feature;  						}  					}  				}  			}  		}  	}  }  finally {  	// switch back to the original type  	if (imageType != null)  		map.selectOutputFormat (imageType);  	// restoring the original legend backgroundcolor  	map.legend.imagecolor.red = red;  	map.legend.imagecolor.green = green;  	map.legend.imagecolor.blue = blue;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: try {  	for (int i = 0; i < map.numlayers; i++) {  		layerObj layer = map.getLayer (i);  		if (layer.status != mapscript.MS_OFF) {  			resultObj res;  			shapeObj feature;  			using (resultCacheObj results = layer.getResults ()) {  				if (results != null && results.numresults > 0) {  					// extracting the features found  					for (int j = 0; j < results.numresults; j++) {  						res = results.getResult (j);  						feature = layer.getShape (res);  						if (feature != null) {  							if (layerIndex != layer.index || classIndex != res.classindex) {  								layerIndex = layer.index;  								classIndex = res.classindex;  								if (classIndex < 0)  									classIndex = 0;  								// creating the icon for this class  								using (classObj def_class = new classObj (null))// for drawing legend images  								 {  									using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  										// drawing the class icons  										if (layer.numclasses > classIndex)  											layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  										byte[] img = image.getBytes ();  										using (MemoryStream ms = new MemoryStream (img)) {  											imageList.Images.Add (Image.FromStream (ms));  										}  									}  								}  							}  							ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  							item.SubItems.Add (feature.index.ToString ());  							item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  							listView.Items.Add (item);  							StringBuilder s = new StringBuilder ("");  							s.AppendLine ("Feature Properties:");  							for (int k = 0; k < layer.numitems; k++) {  								s.Append (layer.getItem (k));  								s.Append (" = ");  								s.AppendLine (feature.getValue (k));  							}  							item.Tag = s.ToString ();  							item.SubItems [0].Tag = layer;  							feature.classindex = res.classindex;  							item.SubItems [1].Tag = feature;  						}  					}  				}  			}  		}  	}  }  finally {  	// switch back to the original type  	if (imageType != null)  		map.selectOutputFormat (imageType);  	// restoring the original legend backgroundcolor  	map.legend.imagecolor.red = red;  	map.legend.imagecolor.green = green;  	map.legend.imagecolor.blue = blue;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: try {  	for (int i = 0; i < map.numlayers; i++) {  		layerObj layer = map.getLayer (i);  		if (layer.status != mapscript.MS_OFF) {  			resultObj res;  			shapeObj feature;  			using (resultCacheObj results = layer.getResults ()) {  				if (results != null && results.numresults > 0) {  					// extracting the features found  					for (int j = 0; j < results.numresults; j++) {  						res = results.getResult (j);  						feature = layer.getShape (res);  						if (feature != null) {  							if (layerIndex != layer.index || classIndex != res.classindex) {  								layerIndex = layer.index;  								classIndex = res.classindex;  								if (classIndex < 0)  									classIndex = 0;  								// creating the icon for this class  								using (classObj def_class = new classObj (null))// for drawing legend images  								 {  									using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  										// drawing the class icons  										if (layer.numclasses > classIndex)  											layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  										byte[] img = image.getBytes ();  										using (MemoryStream ms = new MemoryStream (img)) {  											imageList.Images.Add (Image.FromStream (ms));  										}  									}  								}  							}  							ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  							item.SubItems.Add (feature.index.ToString ());  							item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  							listView.Items.Add (item);  							StringBuilder s = new StringBuilder ("");  							s.AppendLine ("Feature Properties:");  							for (int k = 0; k < layer.numitems; k++) {  								s.Append (layer.getItem (k));  								s.Append (" = ");  								s.AppendLine (feature.getValue (k));  							}  							item.Tag = s.ToString ();  							item.SubItems [0].Tag = layer;  							feature.classindex = res.classindex;  							item.SubItems [1].Tag = feature;  						}  					}  				}  			}  		}  	}  }  finally {  	// switch back to the original type  	if (imageType != null)  		map.selectOutputFormat (imageType);  	// restoring the original legend backgroundcolor  	map.legend.imagecolor.red = red;  	map.legend.imagecolor.green = green;  	map.legend.imagecolor.blue = blue;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: try {  	for (int i = 0; i < map.numlayers; i++) {  		layerObj layer = map.getLayer (i);  		if (layer.status != mapscript.MS_OFF) {  			resultObj res;  			shapeObj feature;  			using (resultCacheObj results = layer.getResults ()) {  				if (results != null && results.numresults > 0) {  					// extracting the features found  					for (int j = 0; j < results.numresults; j++) {  						res = results.getResult (j);  						feature = layer.getShape (res);  						if (feature != null) {  							if (layerIndex != layer.index || classIndex != res.classindex) {  								layerIndex = layer.index;  								classIndex = res.classindex;  								if (classIndex < 0)  									classIndex = 0;  								// creating the icon for this class  								using (classObj def_class = new classObj (null))// for drawing legend images  								 {  									using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  										// drawing the class icons  										if (layer.numclasses > classIndex)  											layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  										byte[] img = image.getBytes ();  										using (MemoryStream ms = new MemoryStream (img)) {  											imageList.Images.Add (Image.FromStream (ms));  										}  									}  								}  							}  							ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  							item.SubItems.Add (feature.index.ToString ());  							item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  							listView.Items.Add (item);  							StringBuilder s = new StringBuilder ("");  							s.AppendLine ("Feature Properties:");  							for (int k = 0; k < layer.numitems; k++) {  								s.Append (layer.getItem (k));  								s.Append (" = ");  								s.AppendLine (feature.getValue (k));  							}  							item.Tag = s.ToString ();  							item.SubItems [0].Tag = layer;  							feature.classindex = res.classindex;  							item.SubItems [1].Tag = feature;  						}  					}  				}  			}  		}  	}  }  finally {  	// switch back to the original type  	if (imageType != null)  		map.selectOutputFormat (imageType);  	// restoring the original legend backgroundcolor  	map.legend.imagecolor.red = red;  	map.legend.imagecolor.green = green;  	map.legend.imagecolor.blue = blue;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: try {  	for (int i = 0; i < map.numlayers; i++) {  		layerObj layer = map.getLayer (i);  		if (layer.status != mapscript.MS_OFF) {  			resultObj res;  			shapeObj feature;  			using (resultCacheObj results = layer.getResults ()) {  				if (results != null && results.numresults > 0) {  					// extracting the features found  					for (int j = 0; j < results.numresults; j++) {  						res = results.getResult (j);  						feature = layer.getShape (res);  						if (feature != null) {  							if (layerIndex != layer.index || classIndex != res.classindex) {  								layerIndex = layer.index;  								classIndex = res.classindex;  								if (classIndex < 0)  									classIndex = 0;  								// creating the icon for this class  								using (classObj def_class = new classObj (null))// for drawing legend images  								 {  									using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  										// drawing the class icons  										if (layer.numclasses > classIndex)  											layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  										byte[] img = image.getBytes ();  										using (MemoryStream ms = new MemoryStream (img)) {  											imageList.Images.Add (Image.FromStream (ms));  										}  									}  								}  							}  							ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  							item.SubItems.Add (feature.index.ToString ());  							item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  							listView.Items.Add (item);  							StringBuilder s = new StringBuilder ("");  							s.AppendLine ("Feature Properties:");  							for (int k = 0; k < layer.numitems; k++) {  								s.Append (layer.getItem (k));  								s.Append (" = ");  								s.AppendLine (feature.getValue (k));  							}  							item.Tag = s.ToString ();  							item.SubItems [0].Tag = layer;  							feature.classindex = res.classindex;  							item.SubItems [1].Tag = feature;  						}  					}  				}  			}  		}  	}  }  finally {  	// switch back to the original type  	if (imageType != null)  		map.selectOutputFormat (imageType);  	// restoring the original legend backgroundcolor  	map.legend.imagecolor.red = red;  	map.legend.imagecolor.green = green;  	map.legend.imagecolor.blue = blue;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (layer.status != mapscript.MS_OFF) {  		resultObj res;  		shapeObj feature;  		using (resultCacheObj results = layer.getResults ()) {  			if (results != null && results.numresults > 0) {  				// extracting the features found  				for (int j = 0; j < results.numresults; j++) {  					res = results.getResult (j);  					feature = layer.getShape (res);  					if (feature != null) {  						if (layerIndex != layer.index || classIndex != res.classindex) {  							layerIndex = layer.index;  							classIndex = res.classindex;  							if (classIndex < 0)  								classIndex = 0;  							// creating the icon for this class  							using (classObj def_class = new classObj (null))// for drawing legend images  							 {  								using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  									// drawing the class icons  									if (layer.numclasses > classIndex)  										layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  									byte[] img = image.getBytes ();  									using (MemoryStream ms = new MemoryStream (img)) {  										imageList.Images.Add (Image.FromStream (ms));  									}  								}  							}  						}  						ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  						item.SubItems.Add (feature.index.ToString ());  						item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  						listView.Items.Add (item);  						StringBuilder s = new StringBuilder ("");  						s.AppendLine ("Feature Properties:");  						for (int k = 0; k < layer.numitems; k++) {  							s.Append (layer.getItem (k));  							s.Append (" = ");  							s.AppendLine (feature.getValue (k));  						}  						item.Tag = s.ToString ();  						item.SubItems [0].Tag = layer;  						feature.classindex = res.classindex;  						item.SubItems [1].Tag = feature;  					}  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (layer.status != mapscript.MS_OFF) {  		resultObj res;  		shapeObj feature;  		using (resultCacheObj results = layer.getResults ()) {  			if (results != null && results.numresults > 0) {  				// extracting the features found  				for (int j = 0; j < results.numresults; j++) {  					res = results.getResult (j);  					feature = layer.getShape (res);  					if (feature != null) {  						if (layerIndex != layer.index || classIndex != res.classindex) {  							layerIndex = layer.index;  							classIndex = res.classindex;  							if (classIndex < 0)  								classIndex = 0;  							// creating the icon for this class  							using (classObj def_class = new classObj (null))// for drawing legend images  							 {  								using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  									// drawing the class icons  									if (layer.numclasses > classIndex)  										layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  									byte[] img = image.getBytes ();  									using (MemoryStream ms = new MemoryStream (img)) {  										imageList.Images.Add (Image.FromStream (ms));  									}  								}  							}  						}  						ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  						item.SubItems.Add (feature.index.ToString ());  						item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  						listView.Items.Add (item);  						StringBuilder s = new StringBuilder ("");  						s.AppendLine ("Feature Properties:");  						for (int k = 0; k < layer.numitems; k++) {  							s.Append (layer.getItem (k));  							s.Append (" = ");  							s.AppendLine (feature.getValue (k));  						}  						item.Tag = s.ToString ();  						item.SubItems [0].Tag = layer;  						feature.classindex = res.classindex;  						item.SubItems [1].Tag = feature;  					}  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (layer.status != mapscript.MS_OFF) {  		resultObj res;  		shapeObj feature;  		using (resultCacheObj results = layer.getResults ()) {  			if (results != null && results.numresults > 0) {  				// extracting the features found  				for (int j = 0; j < results.numresults; j++) {  					res = results.getResult (j);  					feature = layer.getShape (res);  					if (feature != null) {  						if (layerIndex != layer.index || classIndex != res.classindex) {  							layerIndex = layer.index;  							classIndex = res.classindex;  							if (classIndex < 0)  								classIndex = 0;  							// creating the icon for this class  							using (classObj def_class = new classObj (null))// for drawing legend images  							 {  								using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  									// drawing the class icons  									if (layer.numclasses > classIndex)  										layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  									byte[] img = image.getBytes ();  									using (MemoryStream ms = new MemoryStream (img)) {  										imageList.Images.Add (Image.FromStream (ms));  									}  								}  							}  						}  						ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  						item.SubItems.Add (feature.index.ToString ());  						item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  						listView.Items.Add (item);  						StringBuilder s = new StringBuilder ("");  						s.AppendLine ("Feature Properties:");  						for (int k = 0; k < layer.numitems; k++) {  							s.Append (layer.getItem (k));  							s.Append (" = ");  							s.AppendLine (feature.getValue (k));  						}  						item.Tag = s.ToString ();  						item.SubItems [0].Tag = layer;  						feature.classindex = res.classindex;  						item.SubItems [1].Tag = feature;  					}  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (layer.status != mapscript.MS_OFF) {  		resultObj res;  		shapeObj feature;  		using (resultCacheObj results = layer.getResults ()) {  			if (results != null && results.numresults > 0) {  				// extracting the features found  				for (int j = 0; j < results.numresults; j++) {  					res = results.getResult (j);  					feature = layer.getShape (res);  					if (feature != null) {  						if (layerIndex != layer.index || classIndex != res.classindex) {  							layerIndex = layer.index;  							classIndex = res.classindex;  							if (classIndex < 0)  								classIndex = 0;  							// creating the icon for this class  							using (classObj def_class = new classObj (null))// for drawing legend images  							 {  								using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  									// drawing the class icons  									if (layer.numclasses > classIndex)  										layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  									byte[] img = image.getBytes ();  									using (MemoryStream ms = new MemoryStream (img)) {  										imageList.Images.Add (Image.FromStream (ms));  									}  								}  							}  						}  						ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  						item.SubItems.Add (feature.index.ToString ());  						item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  						listView.Items.Add (item);  						StringBuilder s = new StringBuilder ("");  						s.AppendLine ("Feature Properties:");  						for (int k = 0; k < layer.numitems; k++) {  							s.Append (layer.getItem (k));  							s.Append (" = ");  							s.AppendLine (feature.getValue (k));  						}  						item.Tag = s.ToString ();  						item.SubItems [0].Tag = layer;  						feature.classindex = res.classindex;  						item.SubItems [1].Tag = feature;  					}  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (layer.status != mapscript.MS_OFF) {  		resultObj res;  		shapeObj feature;  		using (resultCacheObj results = layer.getResults ()) {  			if (results != null && results.numresults > 0) {  				// extracting the features found  				for (int j = 0; j < results.numresults; j++) {  					res = results.getResult (j);  					feature = layer.getShape (res);  					if (feature != null) {  						if (layerIndex != layer.index || classIndex != res.classindex) {  							layerIndex = layer.index;  							classIndex = res.classindex;  							if (classIndex < 0)  								classIndex = 0;  							// creating the icon for this class  							using (classObj def_class = new classObj (null))// for drawing legend images  							 {  								using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  									// drawing the class icons  									if (layer.numclasses > classIndex)  										layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  									byte[] img = image.getBytes ();  									using (MemoryStream ms = new MemoryStream (img)) {  										imageList.Images.Add (Image.FromStream (ms));  									}  								}  							}  						}  						ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  						item.SubItems.Add (feature.index.ToString ());  						item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  						listView.Items.Add (item);  						StringBuilder s = new StringBuilder ("");  						s.AppendLine ("Feature Properties:");  						for (int k = 0; k < layer.numitems; k++) {  							s.Append (layer.getItem (k));  							s.Append (" = ");  							s.AppendLine (feature.getValue (k));  						}  						item.Tag = s.ToString ();  						item.SubItems [0].Tag = layer;  						feature.classindex = res.classindex;  						item.SubItems [1].Tag = feature;  					}  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int i = 0; i < map.numlayers; i++) {  	layerObj layer = map.getLayer (i);  	if (layer.status != mapscript.MS_OFF) {  		resultObj res;  		shapeObj feature;  		using (resultCacheObj results = layer.getResults ()) {  			if (results != null && results.numresults > 0) {  				// extracting the features found  				for (int j = 0; j < results.numresults; j++) {  					res = results.getResult (j);  					feature = layer.getShape (res);  					if (feature != null) {  						if (layerIndex != layer.index || classIndex != res.classindex) {  							layerIndex = layer.index;  							classIndex = res.classindex;  							if (classIndex < 0)  								classIndex = 0;  							// creating the icon for this class  							using (classObj def_class = new classObj (null))// for drawing legend images  							 {  								using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  									// drawing the class icons  									if (layer.numclasses > classIndex)  										layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  									byte[] img = image.getBytes ();  									using (MemoryStream ms = new MemoryStream (img)) {  										imageList.Images.Add (Image.FromStream (ms));  									}  								}  							}  						}  						ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  						item.SubItems.Add (feature.index.ToString ());  						item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  						listView.Items.Add (item);  						StringBuilder s = new StringBuilder ("");  						s.AppendLine ("Feature Properties:");  						for (int k = 0; k < layer.numitems; k++) {  							s.Append (layer.getItem (k));  							s.Append (" = ");  							s.AppendLine (feature.getValue (k));  						}  						item.Tag = s.ToString ();  						item.SubItems [0].Tag = layer;  						feature.classindex = res.classindex;  						item.SubItems [1].Tag = feature;  					}  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.status != mapscript.MS_OFF) {  	resultObj res;  	shapeObj feature;  	using (resultCacheObj results = layer.getResults ()) {  		if (results != null && results.numresults > 0) {  			// extracting the features found  			for (int j = 0; j < results.numresults; j++) {  				res = results.getResult (j);  				feature = layer.getShape (res);  				if (feature != null) {  					if (layerIndex != layer.index || classIndex != res.classindex) {  						layerIndex = layer.index;  						classIndex = res.classindex;  						if (classIndex < 0)  							classIndex = 0;  						// creating the icon for this class  						using (classObj def_class = new classObj (null))// for drawing legend images  						 {  							using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  								// drawing the class icons  								if (layer.numclasses > classIndex)  									layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  								byte[] img = image.getBytes ();  								using (MemoryStream ms = new MemoryStream (img)) {  									imageList.Images.Add (Image.FromStream (ms));  								}  							}  						}  					}  					ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  					item.SubItems.Add (feature.index.ToString ());  					item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  					listView.Items.Add (item);  					StringBuilder s = new StringBuilder ("");  					s.AppendLine ("Feature Properties:");  					for (int k = 0; k < layer.numitems; k++) {  						s.Append (layer.getItem (k));  						s.Append (" = ");  						s.AppendLine (feature.getValue (k));  					}  					item.Tag = s.ToString ();  					item.SubItems [0].Tag = layer;  					feature.classindex = res.classindex;  					item.SubItems [1].Tag = feature;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.status != mapscript.MS_OFF) {  	resultObj res;  	shapeObj feature;  	using (resultCacheObj results = layer.getResults ()) {  		if (results != null && results.numresults > 0) {  			// extracting the features found  			for (int j = 0; j < results.numresults; j++) {  				res = results.getResult (j);  				feature = layer.getShape (res);  				if (feature != null) {  					if (layerIndex != layer.index || classIndex != res.classindex) {  						layerIndex = layer.index;  						classIndex = res.classindex;  						if (classIndex < 0)  							classIndex = 0;  						// creating the icon for this class  						using (classObj def_class = new classObj (null))// for drawing legend images  						 {  							using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  								// drawing the class icons  								if (layer.numclasses > classIndex)  									layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  								byte[] img = image.getBytes ();  								using (MemoryStream ms = new MemoryStream (img)) {  									imageList.Images.Add (Image.FromStream (ms));  								}  							}  						}  					}  					ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  					item.SubItems.Add (feature.index.ToString ());  					item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  					listView.Items.Add (item);  					StringBuilder s = new StringBuilder ("");  					s.AppendLine ("Feature Properties:");  					for (int k = 0; k < layer.numitems; k++) {  						s.Append (layer.getItem (k));  						s.Append (" = ");  						s.AppendLine (feature.getValue (k));  					}  					item.Tag = s.ToString ();  					item.SubItems [0].Tag = layer;  					feature.classindex = res.classindex;  					item.SubItems [1].Tag = feature;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.status != mapscript.MS_OFF) {  	resultObj res;  	shapeObj feature;  	using (resultCacheObj results = layer.getResults ()) {  		if (results != null && results.numresults > 0) {  			// extracting the features found  			for (int j = 0; j < results.numresults; j++) {  				res = results.getResult (j);  				feature = layer.getShape (res);  				if (feature != null) {  					if (layerIndex != layer.index || classIndex != res.classindex) {  						layerIndex = layer.index;  						classIndex = res.classindex;  						if (classIndex < 0)  							classIndex = 0;  						// creating the icon for this class  						using (classObj def_class = new classObj (null))// for drawing legend images  						 {  							using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  								// drawing the class icons  								if (layer.numclasses > classIndex)  									layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  								byte[] img = image.getBytes ();  								using (MemoryStream ms = new MemoryStream (img)) {  									imageList.Images.Add (Image.FromStream (ms));  								}  							}  						}  					}  					ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  					item.SubItems.Add (feature.index.ToString ());  					item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  					listView.Items.Add (item);  					StringBuilder s = new StringBuilder ("");  					s.AppendLine ("Feature Properties:");  					for (int k = 0; k < layer.numitems; k++) {  						s.Append (layer.getItem (k));  						s.Append (" = ");  						s.AppendLine (feature.getValue (k));  					}  					item.Tag = s.ToString ();  					item.SubItems [0].Tag = layer;  					feature.classindex = res.classindex;  					item.SubItems [1].Tag = feature;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.status != mapscript.MS_OFF) {  	resultObj res;  	shapeObj feature;  	using (resultCacheObj results = layer.getResults ()) {  		if (results != null && results.numresults > 0) {  			// extracting the features found  			for (int j = 0; j < results.numresults; j++) {  				res = results.getResult (j);  				feature = layer.getShape (res);  				if (feature != null) {  					if (layerIndex != layer.index || classIndex != res.classindex) {  						layerIndex = layer.index;  						classIndex = res.classindex;  						if (classIndex < 0)  							classIndex = 0;  						// creating the icon for this class  						using (classObj def_class = new classObj (null))// for drawing legend images  						 {  							using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  								// drawing the class icons  								if (layer.numclasses > classIndex)  									layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  								byte[] img = image.getBytes ();  								using (MemoryStream ms = new MemoryStream (img)) {  									imageList.Images.Add (Image.FromStream (ms));  								}  							}  						}  					}  					ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  					item.SubItems.Add (feature.index.ToString ());  					item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  					listView.Items.Add (item);  					StringBuilder s = new StringBuilder ("");  					s.AppendLine ("Feature Properties:");  					for (int k = 0; k < layer.numitems; k++) {  						s.Append (layer.getItem (k));  						s.Append (" = ");  						s.AppendLine (feature.getValue (k));  					}  					item.Tag = s.ToString ();  					item.SubItems [0].Tag = layer;  					feature.classindex = res.classindex;  					item.SubItems [1].Tag = feature;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.status != mapscript.MS_OFF) {  	resultObj res;  	shapeObj feature;  	using (resultCacheObj results = layer.getResults ()) {  		if (results != null && results.numresults > 0) {  			// extracting the features found  			for (int j = 0; j < results.numresults; j++) {  				res = results.getResult (j);  				feature = layer.getShape (res);  				if (feature != null) {  					if (layerIndex != layer.index || classIndex != res.classindex) {  						layerIndex = layer.index;  						classIndex = res.classindex;  						if (classIndex < 0)  							classIndex = 0;  						// creating the icon for this class  						using (classObj def_class = new classObj (null))// for drawing legend images  						 {  							using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  								// drawing the class icons  								if (layer.numclasses > classIndex)  									layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  								byte[] img = image.getBytes ();  								using (MemoryStream ms = new MemoryStream (img)) {  									imageList.Images.Add (Image.FromStream (ms));  								}  							}  						}  					}  					ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  					item.SubItems.Add (feature.index.ToString ());  					item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  					listView.Items.Add (item);  					StringBuilder s = new StringBuilder ("");  					s.AppendLine ("Feature Properties:");  					for (int k = 0; k < layer.numitems; k++) {  						s.Append (layer.getItem (k));  						s.Append (" = ");  						s.AppendLine (feature.getValue (k));  					}  					item.Tag = s.ToString ();  					item.SubItems [0].Tag = layer;  					feature.classindex = res.classindex;  					item.SubItems [1].Tag = feature;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.status != mapscript.MS_OFF) {  	resultObj res;  	shapeObj feature;  	using (resultCacheObj results = layer.getResults ()) {  		if (results != null && results.numresults > 0) {  			// extracting the features found  			for (int j = 0; j < results.numresults; j++) {  				res = results.getResult (j);  				feature = layer.getShape (res);  				if (feature != null) {  					if (layerIndex != layer.index || classIndex != res.classindex) {  						layerIndex = layer.index;  						classIndex = res.classindex;  						if (classIndex < 0)  							classIndex = 0;  						// creating the icon for this class  						using (classObj def_class = new classObj (null))// for drawing legend images  						 {  							using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  								// drawing the class icons  								if (layer.numclasses > classIndex)  									layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  								byte[] img = image.getBytes ();  								using (MemoryStream ms = new MemoryStream (img)) {  									imageList.Images.Add (Image.FromStream (ms));  								}  							}  						}  					}  					ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  					item.SubItems.Add (feature.index.ToString ());  					item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  					listView.Items.Add (item);  					StringBuilder s = new StringBuilder ("");  					s.AppendLine ("Feature Properties:");  					for (int k = 0; k < layer.numitems; k++) {  						s.Append (layer.getItem (k));  						s.Append (" = ");  						s.AppendLine (feature.getValue (k));  					}  					item.Tag = s.ToString ();  					item.SubItems [0].Tag = layer;  					feature.classindex = res.classindex;  					item.SubItems [1].Tag = feature;  				}  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (resultCacheObj results = layer.getResults ()) {  	if (results != null && results.numresults > 0) {  		// extracting the features found  		for (int j = 0; j < results.numresults; j++) {  			res = results.getResult (j);  			feature = layer.getShape (res);  			if (feature != null) {  				if (layerIndex != layer.index || classIndex != res.classindex) {  					layerIndex = layer.index;  					classIndex = res.classindex;  					if (classIndex < 0)  						classIndex = 0;  					// creating the icon for this class  					using (classObj def_class = new classObj (null))// for drawing legend images  					 {  						using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  							// drawing the class icons  							if (layer.numclasses > classIndex)  								layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  							byte[] img = image.getBytes ();  							using (MemoryStream ms = new MemoryStream (img)) {  								imageList.Images.Add (Image.FromStream (ms));  							}  						}  					}  				}  				ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  				item.SubItems.Add (feature.index.ToString ());  				item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  				listView.Items.Add (item);  				StringBuilder s = new StringBuilder ("");  				s.AppendLine ("Feature Properties:");  				for (int k = 0; k < layer.numitems; k++) {  					s.Append (layer.getItem (k));  					s.Append (" = ");  					s.AppendLine (feature.getValue (k));  				}  				item.Tag = s.ToString ();  				item.SubItems [0].Tag = layer;  				feature.classindex = res.classindex;  				item.SubItems [1].Tag = feature;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (resultCacheObj results = layer.getResults ()) {  	if (results != null && results.numresults > 0) {  		// extracting the features found  		for (int j = 0; j < results.numresults; j++) {  			res = results.getResult (j);  			feature = layer.getShape (res);  			if (feature != null) {  				if (layerIndex != layer.index || classIndex != res.classindex) {  					layerIndex = layer.index;  					classIndex = res.classindex;  					if (classIndex < 0)  						classIndex = 0;  					// creating the icon for this class  					using (classObj def_class = new classObj (null))// for drawing legend images  					 {  						using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  							// drawing the class icons  							if (layer.numclasses > classIndex)  								layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  							byte[] img = image.getBytes ();  							using (MemoryStream ms = new MemoryStream (img)) {  								imageList.Images.Add (Image.FromStream (ms));  							}  						}  					}  				}  				ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  				item.SubItems.Add (feature.index.ToString ());  				item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  				listView.Items.Add (item);  				StringBuilder s = new StringBuilder ("");  				s.AppendLine ("Feature Properties:");  				for (int k = 0; k < layer.numitems; k++) {  					s.Append (layer.getItem (k));  					s.Append (" = ");  					s.AppendLine (feature.getValue (k));  				}  				item.Tag = s.ToString ();  				item.SubItems [0].Tag = layer;  				feature.classindex = res.classindex;  				item.SubItems [1].Tag = feature;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (resultCacheObj results = layer.getResults ()) {  	if (results != null && results.numresults > 0) {  		// extracting the features found  		for (int j = 0; j < results.numresults; j++) {  			res = results.getResult (j);  			feature = layer.getShape (res);  			if (feature != null) {  				if (layerIndex != layer.index || classIndex != res.classindex) {  					layerIndex = layer.index;  					classIndex = res.classindex;  					if (classIndex < 0)  						classIndex = 0;  					// creating the icon for this class  					using (classObj def_class = new classObj (null))// for drawing legend images  					 {  						using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  							// drawing the class icons  							if (layer.numclasses > classIndex)  								layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  							byte[] img = image.getBytes ();  							using (MemoryStream ms = new MemoryStream (img)) {  								imageList.Images.Add (Image.FromStream (ms));  							}  						}  					}  				}  				ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  				item.SubItems.Add (feature.index.ToString ());  				item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  				listView.Items.Add (item);  				StringBuilder s = new StringBuilder ("");  				s.AppendLine ("Feature Properties:");  				for (int k = 0; k < layer.numitems; k++) {  					s.Append (layer.getItem (k));  					s.Append (" = ");  					s.AppendLine (feature.getValue (k));  				}  				item.Tag = s.ToString ();  				item.SubItems [0].Tag = layer;  				feature.classindex = res.classindex;  				item.SubItems [1].Tag = feature;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (resultCacheObj results = layer.getResults ()) {  	if (results != null && results.numresults > 0) {  		// extracting the features found  		for (int j = 0; j < results.numresults; j++) {  			res = results.getResult (j);  			feature = layer.getShape (res);  			if (feature != null) {  				if (layerIndex != layer.index || classIndex != res.classindex) {  					layerIndex = layer.index;  					classIndex = res.classindex;  					if (classIndex < 0)  						classIndex = 0;  					// creating the icon for this class  					using (classObj def_class = new classObj (null))// for drawing legend images  					 {  						using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  							// drawing the class icons  							if (layer.numclasses > classIndex)  								layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  							byte[] img = image.getBytes ();  							using (MemoryStream ms = new MemoryStream (img)) {  								imageList.Images.Add (Image.FromStream (ms));  							}  						}  					}  				}  				ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  				item.SubItems.Add (feature.index.ToString ());  				item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  				listView.Items.Add (item);  				StringBuilder s = new StringBuilder ("");  				s.AppendLine ("Feature Properties:");  				for (int k = 0; k < layer.numitems; k++) {  					s.Append (layer.getItem (k));  					s.Append (" = ");  					s.AppendLine (feature.getValue (k));  				}  				item.Tag = s.ToString ();  				item.SubItems [0].Tag = layer;  				feature.classindex = res.classindex;  				item.SubItems [1].Tag = feature;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (resultCacheObj results = layer.getResults ()) {  	if (results != null && results.numresults > 0) {  		// extracting the features found  		for (int j = 0; j < results.numresults; j++) {  			res = results.getResult (j);  			feature = layer.getShape (res);  			if (feature != null) {  				if (layerIndex != layer.index || classIndex != res.classindex) {  					layerIndex = layer.index;  					classIndex = res.classindex;  					if (classIndex < 0)  						classIndex = 0;  					// creating the icon for this class  					using (classObj def_class = new classObj (null))// for drawing legend images  					 {  						using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  							// drawing the class icons  							if (layer.numclasses > classIndex)  								layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  							byte[] img = image.getBytes ();  							using (MemoryStream ms = new MemoryStream (img)) {  								imageList.Images.Add (Image.FromStream (ms));  							}  						}  					}  				}  				ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  				item.SubItems.Add (feature.index.ToString ());  				item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  				listView.Items.Add (item);  				StringBuilder s = new StringBuilder ("");  				s.AppendLine ("Feature Properties:");  				for (int k = 0; k < layer.numitems; k++) {  					s.Append (layer.getItem (k));  					s.Append (" = ");  					s.AppendLine (feature.getValue (k));  				}  				item.Tag = s.ToString ();  				item.SubItems [0].Tag = layer;  				feature.classindex = res.classindex;  				item.SubItems [1].Tag = feature;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (resultCacheObj results = layer.getResults ()) {  	if (results != null && results.numresults > 0) {  		// extracting the features found  		for (int j = 0; j < results.numresults; j++) {  			res = results.getResult (j);  			feature = layer.getShape (res);  			if (feature != null) {  				if (layerIndex != layer.index || classIndex != res.classindex) {  					layerIndex = layer.index;  					classIndex = res.classindex;  					if (classIndex < 0)  						classIndex = 0;  					// creating the icon for this class  					using (classObj def_class = new classObj (null))// for drawing legend images  					 {  						using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  							// drawing the class icons  							if (layer.numclasses > classIndex)  								layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  							byte[] img = image.getBytes ();  							using (MemoryStream ms = new MemoryStream (img)) {  								imageList.Images.Add (Image.FromStream (ms));  							}  						}  					}  				}  				ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  				item.SubItems.Add (feature.index.ToString ());  				item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  				listView.Items.Add (item);  				StringBuilder s = new StringBuilder ("");  				s.AppendLine ("Feature Properties:");  				for (int k = 0; k < layer.numitems; k++) {  					s.Append (layer.getItem (k));  					s.Append (" = ");  					s.AppendLine (feature.getValue (k));  				}  				item.Tag = s.ToString ();  				item.SubItems [0].Tag = layer;  				feature.classindex = res.classindex;  				item.SubItems [1].Tag = feature;  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (results != null && results.numresults > 0) {  	// extracting the features found  	for (int j = 0; j < results.numresults; j++) {  		res = results.getResult (j);  		feature = layer.getShape (res);  		if (feature != null) {  			if (layerIndex != layer.index || classIndex != res.classindex) {  				layerIndex = layer.index;  				classIndex = res.classindex;  				if (classIndex < 0)  					classIndex = 0;  				// creating the icon for this class  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						if (layer.numclasses > classIndex)  							layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							imageList.Images.Add (Image.FromStream (ms));  						}  					}  				}  			}  			ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  			item.SubItems.Add (feature.index.ToString ());  			item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  			listView.Items.Add (item);  			StringBuilder s = new StringBuilder ("");  			s.AppendLine ("Feature Properties:");  			for (int k = 0; k < layer.numitems; k++) {  				s.Append (layer.getItem (k));  				s.Append (" = ");  				s.AppendLine (feature.getValue (k));  			}  			item.Tag = s.ToString ();  			item.SubItems [0].Tag = layer;  			feature.classindex = res.classindex;  			item.SubItems [1].Tag = feature;  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (results != null && results.numresults > 0) {  	// extracting the features found  	for (int j = 0; j < results.numresults; j++) {  		res = results.getResult (j);  		feature = layer.getShape (res);  		if (feature != null) {  			if (layerIndex != layer.index || classIndex != res.classindex) {  				layerIndex = layer.index;  				classIndex = res.classindex;  				if (classIndex < 0)  					classIndex = 0;  				// creating the icon for this class  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						if (layer.numclasses > classIndex)  							layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							imageList.Images.Add (Image.FromStream (ms));  						}  					}  				}  			}  			ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  			item.SubItems.Add (feature.index.ToString ());  			item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  			listView.Items.Add (item);  			StringBuilder s = new StringBuilder ("");  			s.AppendLine ("Feature Properties:");  			for (int k = 0; k < layer.numitems; k++) {  				s.Append (layer.getItem (k));  				s.Append (" = ");  				s.AppendLine (feature.getValue (k));  			}  			item.Tag = s.ToString ();  			item.SubItems [0].Tag = layer;  			feature.classindex = res.classindex;  			item.SubItems [1].Tag = feature;  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (results != null && results.numresults > 0) {  	// extracting the features found  	for (int j = 0; j < results.numresults; j++) {  		res = results.getResult (j);  		feature = layer.getShape (res);  		if (feature != null) {  			if (layerIndex != layer.index || classIndex != res.classindex) {  				layerIndex = layer.index;  				classIndex = res.classindex;  				if (classIndex < 0)  					classIndex = 0;  				// creating the icon for this class  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						if (layer.numclasses > classIndex)  							layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							imageList.Images.Add (Image.FromStream (ms));  						}  					}  				}  			}  			ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  			item.SubItems.Add (feature.index.ToString ());  			item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  			listView.Items.Add (item);  			StringBuilder s = new StringBuilder ("");  			s.AppendLine ("Feature Properties:");  			for (int k = 0; k < layer.numitems; k++) {  				s.Append (layer.getItem (k));  				s.Append (" = ");  				s.AppendLine (feature.getValue (k));  			}  			item.Tag = s.ToString ();  			item.SubItems [0].Tag = layer;  			feature.classindex = res.classindex;  			item.SubItems [1].Tag = feature;  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (results != null && results.numresults > 0) {  	// extracting the features found  	for (int j = 0; j < results.numresults; j++) {  		res = results.getResult (j);  		feature = layer.getShape (res);  		if (feature != null) {  			if (layerIndex != layer.index || classIndex != res.classindex) {  				layerIndex = layer.index;  				classIndex = res.classindex;  				if (classIndex < 0)  					classIndex = 0;  				// creating the icon for this class  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						if (layer.numclasses > classIndex)  							layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							imageList.Images.Add (Image.FromStream (ms));  						}  					}  				}  			}  			ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  			item.SubItems.Add (feature.index.ToString ());  			item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  			listView.Items.Add (item);  			StringBuilder s = new StringBuilder ("");  			s.AppendLine ("Feature Properties:");  			for (int k = 0; k < layer.numitems; k++) {  				s.Append (layer.getItem (k));  				s.Append (" = ");  				s.AppendLine (feature.getValue (k));  			}  			item.Tag = s.ToString ();  			item.SubItems [0].Tag = layer;  			feature.classindex = res.classindex;  			item.SubItems [1].Tag = feature;  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (results != null && results.numresults > 0) {  	// extracting the features found  	for (int j = 0; j < results.numresults; j++) {  		res = results.getResult (j);  		feature = layer.getShape (res);  		if (feature != null) {  			if (layerIndex != layer.index || classIndex != res.classindex) {  				layerIndex = layer.index;  				classIndex = res.classindex;  				if (classIndex < 0)  					classIndex = 0;  				// creating the icon for this class  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						if (layer.numclasses > classIndex)  							layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							imageList.Images.Add (Image.FromStream (ms));  						}  					}  				}  			}  			ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  			item.SubItems.Add (feature.index.ToString ());  			item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  			listView.Items.Add (item);  			StringBuilder s = new StringBuilder ("");  			s.AppendLine ("Feature Properties:");  			for (int k = 0; k < layer.numitems; k++) {  				s.Append (layer.getItem (k));  				s.Append (" = ");  				s.AppendLine (feature.getValue (k));  			}  			item.Tag = s.ToString ();  			item.SubItems [0].Tag = layer;  			feature.classindex = res.classindex;  			item.SubItems [1].Tag = feature;  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (results != null && results.numresults > 0) {  	// extracting the features found  	for (int j = 0; j < results.numresults; j++) {  		res = results.getResult (j);  		feature = layer.getShape (res);  		if (feature != null) {  			if (layerIndex != layer.index || classIndex != res.classindex) {  				layerIndex = layer.index;  				classIndex = res.classindex;  				if (classIndex < 0)  					classIndex = 0;  				// creating the icon for this class  				using (classObj def_class = new classObj (null))// for drawing legend images  				 {  					using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  						// drawing the class icons  						if (layer.numclasses > classIndex)  							layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  						byte[] img = image.getBytes ();  						using (MemoryStream ms = new MemoryStream (img)) {  							imageList.Images.Add (Image.FromStream (ms));  						}  					}  				}  			}  			ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  			item.SubItems.Add (feature.index.ToString ());  			item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  			listView.Items.Add (item);  			StringBuilder s = new StringBuilder ("");  			s.AppendLine ("Feature Properties:");  			for (int k = 0; k < layer.numitems; k++) {  				s.Append (layer.getItem (k));  				s.Append (" = ");  				s.AppendLine (feature.getValue (k));  			}  			item.Tag = s.ToString ();  			item.SubItems [0].Tag = layer;  			feature.classindex = res.classindex;  			item.SubItems [1].Tag = feature;  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int j = 0; j < results.numresults; j++) {  	res = results.getResult (j);  	feature = layer.getShape (res);  	if (feature != null) {  		if (layerIndex != layer.index || classIndex != res.classindex) {  			layerIndex = layer.index;  			classIndex = res.classindex;  			if (classIndex < 0)  				classIndex = 0;  			// creating the icon for this class  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					if (layer.numclasses > classIndex)  						layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						imageList.Images.Add (Image.FromStream (ms));  					}  				}  			}  		}  		ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  		item.SubItems.Add (feature.index.ToString ());  		item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  		listView.Items.Add (item);  		StringBuilder s = new StringBuilder ("");  		s.AppendLine ("Feature Properties:");  		for (int k = 0; k < layer.numitems; k++) {  			s.Append (layer.getItem (k));  			s.Append (" = ");  			s.AppendLine (feature.getValue (k));  		}  		item.Tag = s.ToString ();  		item.SubItems [0].Tag = layer;  		feature.classindex = res.classindex;  		item.SubItems [1].Tag = feature;  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int j = 0; j < results.numresults; j++) {  	res = results.getResult (j);  	feature = layer.getShape (res);  	if (feature != null) {  		if (layerIndex != layer.index || classIndex != res.classindex) {  			layerIndex = layer.index;  			classIndex = res.classindex;  			if (classIndex < 0)  				classIndex = 0;  			// creating the icon for this class  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					if (layer.numclasses > classIndex)  						layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						imageList.Images.Add (Image.FromStream (ms));  					}  				}  			}  		}  		ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  		item.SubItems.Add (feature.index.ToString ());  		item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  		listView.Items.Add (item);  		StringBuilder s = new StringBuilder ("");  		s.AppendLine ("Feature Properties:");  		for (int k = 0; k < layer.numitems; k++) {  			s.Append (layer.getItem (k));  			s.Append (" = ");  			s.AppendLine (feature.getValue (k));  		}  		item.Tag = s.ToString ();  		item.SubItems [0].Tag = layer;  		feature.classindex = res.classindex;  		item.SubItems [1].Tag = feature;  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int j = 0; j < results.numresults; j++) {  	res = results.getResult (j);  	feature = layer.getShape (res);  	if (feature != null) {  		if (layerIndex != layer.index || classIndex != res.classindex) {  			layerIndex = layer.index;  			classIndex = res.classindex;  			if (classIndex < 0)  				classIndex = 0;  			// creating the icon for this class  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					if (layer.numclasses > classIndex)  						layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						imageList.Images.Add (Image.FromStream (ms));  					}  				}  			}  		}  		ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  		item.SubItems.Add (feature.index.ToString ());  		item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  		listView.Items.Add (item);  		StringBuilder s = new StringBuilder ("");  		s.AppendLine ("Feature Properties:");  		for (int k = 0; k < layer.numitems; k++) {  			s.Append (layer.getItem (k));  			s.Append (" = ");  			s.AppendLine (feature.getValue (k));  		}  		item.Tag = s.ToString ();  		item.SubItems [0].Tag = layer;  		feature.classindex = res.classindex;  		item.SubItems [1].Tag = feature;  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int j = 0; j < results.numresults; j++) {  	res = results.getResult (j);  	feature = layer.getShape (res);  	if (feature != null) {  		if (layerIndex != layer.index || classIndex != res.classindex) {  			layerIndex = layer.index;  			classIndex = res.classindex;  			if (classIndex < 0)  				classIndex = 0;  			// creating the icon for this class  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					if (layer.numclasses > classIndex)  						layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						imageList.Images.Add (Image.FromStream (ms));  					}  				}  			}  		}  		ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  		item.SubItems.Add (feature.index.ToString ());  		item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  		listView.Items.Add (item);  		StringBuilder s = new StringBuilder ("");  		s.AppendLine ("Feature Properties:");  		for (int k = 0; k < layer.numitems; k++) {  			s.Append (layer.getItem (k));  			s.Append (" = ");  			s.AppendLine (feature.getValue (k));  		}  		item.Tag = s.ToString ();  		item.SubItems [0].Tag = layer;  		feature.classindex = res.classindex;  		item.SubItems [1].Tag = feature;  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int j = 0; j < results.numresults; j++) {  	res = results.getResult (j);  	feature = layer.getShape (res);  	if (feature != null) {  		if (layerIndex != layer.index || classIndex != res.classindex) {  			layerIndex = layer.index;  			classIndex = res.classindex;  			if (classIndex < 0)  				classIndex = 0;  			// creating the icon for this class  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					if (layer.numclasses > classIndex)  						layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						imageList.Images.Add (Image.FromStream (ms));  					}  				}  			}  		}  		ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  		item.SubItems.Add (feature.index.ToString ());  		item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  		listView.Items.Add (item);  		StringBuilder s = new StringBuilder ("");  		s.AppendLine ("Feature Properties:");  		for (int k = 0; k < layer.numitems; k++) {  			s.Append (layer.getItem (k));  			s.Append (" = ");  			s.AppendLine (feature.getValue (k));  		}  		item.Tag = s.ToString ();  		item.SubItems [0].Tag = layer;  		feature.classindex = res.classindex;  		item.SubItems [1].Tag = feature;  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: for (int j = 0; j < results.numresults; j++) {  	res = results.getResult (j);  	feature = layer.getShape (res);  	if (feature != null) {  		if (layerIndex != layer.index || classIndex != res.classindex) {  			layerIndex = layer.index;  			classIndex = res.classindex;  			if (classIndex < 0)  				classIndex = 0;  			// creating the icon for this class  			using (classObj def_class = new classObj (null))// for drawing legend images  			 {  				using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  					// drawing the class icons  					if (layer.numclasses > classIndex)  						layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  					byte[] img = image.getBytes ();  					using (MemoryStream ms = new MemoryStream (img)) {  						imageList.Images.Add (Image.FromStream (ms));  					}  				}  			}  		}  		ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  		item.SubItems.Add (feature.index.ToString ());  		item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  		listView.Items.Add (item);  		StringBuilder s = new StringBuilder ("");  		s.AppendLine ("Feature Properties:");  		for (int k = 0; k < layer.numitems; k++) {  			s.Append (layer.getItem (k));  			s.Append (" = ");  			s.AppendLine (feature.getValue (k));  		}  		item.Tag = s.ToString ();  		item.SubItems [0].Tag = layer;  		feature.classindex = res.classindex;  		item.SubItems [1].Tag = feature;  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (feature != null) {  	if (layerIndex != layer.index || classIndex != res.classindex) {  		layerIndex = layer.index;  		classIndex = res.classindex;  		if (classIndex < 0)  			classIndex = 0;  		// creating the icon for this class  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				if (layer.numclasses > classIndex)  					layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					imageList.Images.Add (Image.FromStream (ms));  				}  			}  		}  	}  	ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  	item.SubItems.Add (feature.index.ToString ());  	item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  	listView.Items.Add (item);  	StringBuilder s = new StringBuilder ("");  	s.AppendLine ("Feature Properties:");  	for (int k = 0; k < layer.numitems; k++) {  		s.Append (layer.getItem (k));  		s.Append (" = ");  		s.AppendLine (feature.getValue (k));  	}  	item.Tag = s.ToString ();  	item.SubItems [0].Tag = layer;  	feature.classindex = res.classindex;  	item.SubItems [1].Tag = feature;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (feature != null) {  	if (layerIndex != layer.index || classIndex != res.classindex) {  		layerIndex = layer.index;  		classIndex = res.classindex;  		if (classIndex < 0)  			classIndex = 0;  		// creating the icon for this class  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				if (layer.numclasses > classIndex)  					layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					imageList.Images.Add (Image.FromStream (ms));  				}  			}  		}  	}  	ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  	item.SubItems.Add (feature.index.ToString ());  	item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  	listView.Items.Add (item);  	StringBuilder s = new StringBuilder ("");  	s.AppendLine ("Feature Properties:");  	for (int k = 0; k < layer.numitems; k++) {  		s.Append (layer.getItem (k));  		s.Append (" = ");  		s.AppendLine (feature.getValue (k));  	}  	item.Tag = s.ToString ();  	item.SubItems [0].Tag = layer;  	feature.classindex = res.classindex;  	item.SubItems [1].Tag = feature;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (feature != null) {  	if (layerIndex != layer.index || classIndex != res.classindex) {  		layerIndex = layer.index;  		classIndex = res.classindex;  		if (classIndex < 0)  			classIndex = 0;  		// creating the icon for this class  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				if (layer.numclasses > classIndex)  					layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					imageList.Images.Add (Image.FromStream (ms));  				}  			}  		}  	}  	ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  	item.SubItems.Add (feature.index.ToString ());  	item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  	listView.Items.Add (item);  	StringBuilder s = new StringBuilder ("");  	s.AppendLine ("Feature Properties:");  	for (int k = 0; k < layer.numitems; k++) {  		s.Append (layer.getItem (k));  		s.Append (" = ");  		s.AppendLine (feature.getValue (k));  	}  	item.Tag = s.ToString ();  	item.SubItems [0].Tag = layer;  	feature.classindex = res.classindex;  	item.SubItems [1].Tag = feature;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (feature != null) {  	if (layerIndex != layer.index || classIndex != res.classindex) {  		layerIndex = layer.index;  		classIndex = res.classindex;  		if (classIndex < 0)  			classIndex = 0;  		// creating the icon for this class  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				if (layer.numclasses > classIndex)  					layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					imageList.Images.Add (Image.FromStream (ms));  				}  			}  		}  	}  	ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  	item.SubItems.Add (feature.index.ToString ());  	item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  	listView.Items.Add (item);  	StringBuilder s = new StringBuilder ("");  	s.AppendLine ("Feature Properties:");  	for (int k = 0; k < layer.numitems; k++) {  		s.Append (layer.getItem (k));  		s.Append (" = ");  		s.AppendLine (feature.getValue (k));  	}  	item.Tag = s.ToString ();  	item.SubItems [0].Tag = layer;  	feature.classindex = res.classindex;  	item.SubItems [1].Tag = feature;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (feature != null) {  	if (layerIndex != layer.index || classIndex != res.classindex) {  		layerIndex = layer.index;  		classIndex = res.classindex;  		if (classIndex < 0)  			classIndex = 0;  		// creating the icon for this class  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				if (layer.numclasses > classIndex)  					layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					imageList.Images.Add (Image.FromStream (ms));  				}  			}  		}  	}  	ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  	item.SubItems.Add (feature.index.ToString ());  	item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  	listView.Items.Add (item);  	StringBuilder s = new StringBuilder ("");  	s.AppendLine ("Feature Properties:");  	for (int k = 0; k < layer.numitems; k++) {  		s.Append (layer.getItem (k));  		s.Append (" = ");  		s.AppendLine (feature.getValue (k));  	}  	item.Tag = s.ToString ();  	item.SubItems [0].Tag = layer;  	feature.classindex = res.classindex;  	item.SubItems [1].Tag = feature;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (feature != null) {  	if (layerIndex != layer.index || classIndex != res.classindex) {  		layerIndex = layer.index;  		classIndex = res.classindex;  		if (classIndex < 0)  			classIndex = 0;  		// creating the icon for this class  		using (classObj def_class = new classObj (null))// for drawing legend images  		 {  			using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  				// drawing the class icons  				if (layer.numclasses > classIndex)  					layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  				byte[] img = image.getBytes ();  				using (MemoryStream ms = new MemoryStream (img)) {  					imageList.Images.Add (Image.FromStream (ms));  				}  			}  		}  	}  	ListViewItem item = new ListViewItem (layer.name' imageList.Images.Count - 1);  	item.SubItems.Add (feature.index.ToString ());  	item.SubItems.Add (MapUtils.GetShapeTypeName ((MS_SHAPE_TYPE)feature.type));  	listView.Items.Add (item);  	StringBuilder s = new StringBuilder ("");  	s.AppendLine ("Feature Properties:");  	for (int k = 0; k < layer.numitems; k++) {  		s.Append (layer.getItem (k));  		s.Append (" = ");  		s.AppendLine (feature.getValue (k));  	}  	item.Tag = s.ToString ();  	item.SubItems [0].Tag = layer;  	feature.classindex = res.classindex;  	item.SubItems [1].Tag = feature;  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layerIndex != layer.index || classIndex != res.classindex) {  	layerIndex = layer.index;  	classIndex = res.classindex;  	if (classIndex < 0)  		classIndex = 0;  	// creating the icon for this class  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			if (layer.numclasses > classIndex)  				layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				imageList.Images.Add (Image.FromStream (ms));  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layerIndex != layer.index || classIndex != res.classindex) {  	layerIndex = layer.index;  	classIndex = res.classindex;  	if (classIndex < 0)  		classIndex = 0;  	// creating the icon for this class  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			if (layer.numclasses > classIndex)  				layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				imageList.Images.Add (Image.FromStream (ms));  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layerIndex != layer.index || classIndex != res.classindex) {  	layerIndex = layer.index;  	classIndex = res.classindex;  	if (classIndex < 0)  		classIndex = 0;  	// creating the icon for this class  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			if (layer.numclasses > classIndex)  				layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				imageList.Images.Add (Image.FromStream (ms));  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layerIndex != layer.index || classIndex != res.classindex) {  	layerIndex = layer.index;  	classIndex = res.classindex;  	if (classIndex < 0)  		classIndex = 0;  	// creating the icon for this class  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			if (layer.numclasses > classIndex)  				layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				imageList.Images.Add (Image.FromStream (ms));  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layerIndex != layer.index || classIndex != res.classindex) {  	layerIndex = layer.index;  	classIndex = res.classindex;  	if (classIndex < 0)  		classIndex = 0;  	// creating the icon for this class  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			if (layer.numclasses > classIndex)  				layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				imageList.Images.Add (Image.FromStream (ms));  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layerIndex != layer.index || classIndex != res.classindex) {  	layerIndex = layer.index;  	classIndex = res.classindex;  	if (classIndex < 0)  		classIndex = 0;  	// creating the icon for this class  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  			// drawing the class icons  			if (layer.numclasses > classIndex)  				layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  			byte[] img = image.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				imageList.Images.Add (Image.FromStream (ms));  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		if (layer.numclasses > classIndex)  			layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		if (layer.numclasses > classIndex)  			layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		if (layer.numclasses > classIndex)  			layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		if (layer.numclasses > classIndex)  			layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		if (layer.numclasses > classIndex)  			layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  		// drawing the class icons  		if (layer.numclasses > classIndex)  			layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  		byte[] img = image.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	if (layer.numclasses > classIndex)  		layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	if (layer.numclasses > classIndex)  		layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	if (layer.numclasses > classIndex)  		layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	if (layer.numclasses > classIndex)  		layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	if (layer.numclasses > classIndex)  		layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: using (imageObj image = def_class.createLegendIcon (map' layer' 30' 20)) {  	// drawing the class icons  	if (layer.numclasses > classIndex)  		layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  	byte[] img = image.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  }  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.numclasses > classIndex)  	layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.numclasses > classIndex)  	layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.numclasses > classIndex)  	layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: if (layer.numclasses > classIndex)  	layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,SelectList,C:\repos\DMS-Aus_MapManager\MapLibrary\SelectList.cs,RefreshView,The following statement contains a magic number: layer.getClass (classIndex).drawLegendIcon (map' layer' 20' 10' image' 5' 5);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,StylePropertyEditor,The following statement contains a magic number: SetSpacing ((short)(imageList.ImageSize.Width + 10)' (short)(imageList.ImageSize.Height + 30));  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,StylePropertyEditor,The following statement contains a magic number: SetSpacing ((short)(imageList.ImageSize.Width + 10)' (short)(imageList.ImageSize.Height + 30));  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,SetSpacing,The following statement contains a magic number: SendMessage (this.listView.Handle' LVM_SETICONSPACING' 0' y * 65536 + x);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	// apply current settings (opacity) to colors  	colorPickerColor.SetColor (pstyle.color);  	colorPickerBackColor.SetColor (pstyle.backgroundcolor);  	colorPickerOutlineColor.SetColor (pstyle.outlinecolor);  	// select the proper map containing symbols  	mapObj stylemap = map;  	if (listView.SelectedItems.Count > 0 && listView.SelectedItems [0].Text != "Default") {  		if (comboBoxCategory.Text != "Inline Symbols")  			stylemap = StyleLibrary.Styles;  		styleObj classStyle = (styleObj)listView.SelectedItems [0].Tag;  		pstyle.setSymbolByName (stylemap' classStyle.symbolname);  	}  	else {  		pstyle.symbol = 0;  		pstyle.symbolname = null;  	}  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  			MS_LAYER_TYPE type = layer.type;  			try {  				// modify the layer type in certain cases for drawing correct images  				if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  				styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  			}  			finally {  				layer.type = type;  			}  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxSample.Image = Image.FromStream (ms);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	// apply current settings (opacity) to colors  	colorPickerColor.SetColor (pstyle.color);  	colorPickerBackColor.SetColor (pstyle.backgroundcolor);  	colorPickerOutlineColor.SetColor (pstyle.outlinecolor);  	// select the proper map containing symbols  	mapObj stylemap = map;  	if (listView.SelectedItems.Count > 0 && listView.SelectedItems [0].Text != "Default") {  		if (comboBoxCategory.Text != "Inline Symbols")  			stylemap = StyleLibrary.Styles;  		styleObj classStyle = (styleObj)listView.SelectedItems [0].Tag;  		pstyle.setSymbolByName (stylemap' classStyle.symbolname);  	}  	else {  		pstyle.symbol = 0;  		pstyle.symbolname = null;  	}  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  			MS_LAYER_TYPE type = layer.type;  			try {  				// modify the layer type in certain cases for drawing correct images  				if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  				styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  			}  			finally {  				layer.type = type;  			}  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxSample.Image = Image.FromStream (ms);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	// apply current settings (opacity) to colors  	colorPickerColor.SetColor (pstyle.color);  	colorPickerBackColor.SetColor (pstyle.backgroundcolor);  	colorPickerOutlineColor.SetColor (pstyle.outlinecolor);  	// select the proper map containing symbols  	mapObj stylemap = map;  	if (listView.SelectedItems.Count > 0 && listView.SelectedItems [0].Text != "Default") {  		if (comboBoxCategory.Text != "Inline Symbols")  			stylemap = StyleLibrary.Styles;  		styleObj classStyle = (styleObj)listView.SelectedItems [0].Tag;  		pstyle.setSymbolByName (stylemap' classStyle.symbolname);  	}  	else {  		pstyle.symbol = 0;  		pstyle.symbolname = null;  	}  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  			MS_LAYER_TYPE type = layer.type;  			try {  				// modify the layer type in certain cases for drawing correct images  				if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  				styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  			}  			finally {  				layer.type = type;  			}  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxSample.Image = Image.FromStream (ms);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: if (style != null && enablePreview) {  	styleObj pstyle = style.clone ();  	Update (pstyle);  	// apply current settings (opacity) to colors  	colorPickerColor.SetColor (pstyle.color);  	colorPickerBackColor.SetColor (pstyle.backgroundcolor);  	colorPickerOutlineColor.SetColor (pstyle.outlinecolor);  	// select the proper map containing symbols  	mapObj stylemap = map;  	if (listView.SelectedItems.Count > 0 && listView.SelectedItems [0].Text != "Default") {  		if (comboBoxCategory.Text != "Inline Symbols")  			stylemap = StyleLibrary.Styles;  		styleObj classStyle = (styleObj)listView.SelectedItems [0].Tag;  		pstyle.setSymbolByName (stylemap' classStyle.symbolname);  	}  	else {  		pstyle.symbol = 0;  		pstyle.symbolname = null;  	}  	classObj styleclass = new classObj (null);  	styleclass.insertStyle (pstyle' -1);  	using (classObj def_class = new classObj (null))// for drawing legend images  	 {  		using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  			MS_LAYER_TYPE type = layer.type;  			try {  				// modify the layer type in certain cases for drawing correct images  				if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  				else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  				styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  			}  			finally {  				layer.type = type;  			}  			byte[] img = image2.getBytes ();  			using (MemoryStream ms = new MemoryStream (img)) {  				pictureBoxSample.Image = Image.FromStream (ms);  			}  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxSample.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxSample.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxSample.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			// modify the layer type in certain cases for drawing correct images  			if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			pictureBoxSample.Image = Image.FromStream (ms);  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxSample.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxSample.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxSample.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (stylemap' layer' pictureBoxSample.Width' pictureBoxSample.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		// modify the layer type in certain cases for drawing correct images  		if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		pictureBoxSample.Image = Image.FromStream (ms);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: try {  	// modify the layer type in certain cases for drawing correct images  	if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpoly"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	else if (comboBoxGeomTransform.Text.ToLower ().Contains ("labelpnt") || comboBoxGeomTransform.Text.ToLower ().Contains ("centroid"))  		layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdatePreview,The following statement contains a magic number: styleclass.drawLegendIcon (stylemap' layer' pictureBoxSample.Width - 10' pictureBoxSample.Height - 10' image2' 4' 4);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   			//// modify the layer type in certain cases for drawing correct images  			//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		// add new item  		item = new ListViewItem (name' imageList.Images.Count - 1);  		item.ToolTipText = name;  		item.Tag = classStyle;  		listView.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   			//// modify the layer type in certain cases for drawing correct images  			//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		// add new item  		item = new ListViewItem (name' imageList.Images.Count - 1);  		item.ToolTipText = name;  		item.Tag = classStyle;  		listView.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   			//// modify the layer type in certain cases for drawing correct images  			//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		// add new item  		item = new ListViewItem (name' imageList.Images.Count - 1);  		item.ToolTipText = name;  		item.Tag = classStyle;  		listView.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (classObj def_class = new classObj (null))// for drawing legend images   {  	using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  		MS_LAYER_TYPE type = layer.type;  		try {  			//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   			//// modify the layer type in certain cases for drawing correct images  			//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  			//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  			//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  		}  		finally {  			layer.type = type;  		}  		byte[] img = image2.getBytes ();  		using (MemoryStream ms = new MemoryStream (img)) {  			imageList.Images.Add (Image.FromStream (ms));  		}  		// add new item  		item = new ListViewItem (name' imageList.Images.Count - 1);  		item.ToolTipText = name;  		item.Tag = classStyle;  		listView.Items.Add (item);  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   		//// modify the layer type in certain cases for drawing correct images  		//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	// add new item  	item = new ListViewItem (name' imageList.Images.Count - 1);  	item.ToolTipText = name;  	item.Tag = classStyle;  	listView.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   		//// modify the layer type in certain cases for drawing correct images  		//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	// add new item  	item = new ListViewItem (name' imageList.Images.Count - 1);  	item.ToolTipText = name;  	item.Tag = classStyle;  	listView.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   		//// modify the layer type in certain cases for drawing correct images  		//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	// add new item  	item = new ListViewItem (name' imageList.Images.Count - 1);  	item.ToolTipText = name;  	item.Tag = classStyle;  	listView.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: using (imageObj image2 = def_class.createLegendIcon (map2' layer' imageList.ImageSize.Width' imageList.ImageSize.Height)) {  	MS_LAYER_TYPE type = layer.type;  	try {  		//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   		//// modify the layer type in certain cases for drawing correct images  		//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  		//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  		//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  	}  	finally {  		layer.type = type;  	}  	byte[] img = image2.getBytes ();  	using (MemoryStream ms = new MemoryStream (img)) {  		imageList.Images.Add (Image.FromStream (ms));  	}  	// add new item  	item = new ListViewItem (name' imageList.Images.Count - 1);  	item.ToolTipText = name;  	item.Tag = classStyle;  	listView.Items.Add (item);  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: try {  	//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   	//// modify the layer type in certain cases for drawing correct images  	//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: try {  	//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   	//// modify the layer type in certain cases for drawing correct images  	//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: try {  	//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   	//// modify the layer type in certain cases for drawing correct images  	//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: try {  	//SETPH: actually we should not modify the type of the style(point line polygon) for the style category list' only for the preview   	//// modify the layer type in certain cases for drawing correct images  	//if (comboBoxGeomTransform.Text.ToLower().Contains("labelpoly"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POLYGON;  	//else if (comboBoxGeomTransform.Text.ToLower().Contains("labelpnt"))  	//layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  	styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  }  finally {  	layer.type = type;  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,AddListItem,The following statement contains a magic number: styleclass.drawLegendIcon (map2' layer' 44' 44' image2' 2' 2);  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateStyleList,The following statement contains a magic number: if (comboBoxCategory.Text != "") {  	// Create "no symbol" entry  	styleObj nosymbolstyle = new styleObj (null);  	MapUtils.SetDefaultColor (layer.type' nosymbolstyle);  	ListViewItem nosymbolitem = AddListItem (nosymbolstyle' layer' "Default");  	if (selectedName == null)  		selected = nosymbolitem;  	if (comboBoxCategory.Text == "Inline Symbols") {  		for (int i = 0; i < map.symbolset.numsymbols; i++) {  			symbolObj symbol = map.symbolset.getSymbol (i);  			if (symbol.inmapfile == mapscript.MS_TRUE && !StyleLibrary.HasSymbol (symbol.name)) {  				styleObj libstyle = new styleObj (null);  				//if (symbol.type == (int)MS_SYMBOL_TYPE.MS_SYMBOL_PATTERNMAP)  				//    MapUtils.SetDefaultColor(MS_LAYER_TYPE.MS_LAYER_LINE' libstyle);  				//else  				MapUtils.SetDefaultColor (layer.type' libstyle);  				libstyle.setSymbolByName (map' symbol.name);  				libstyle.size = 8;  				MS_LAYER_TYPE type = layer.type;  				try {  					//STEPH: change layer passed to the list view to be consistent with the other symbol categories  					//so that it uses a point layer to display the style in the list  					layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  					ListViewItem item = AddListItem (libstyle' layer' symbol.name);  					if (selectedName == item.Text)  						selected = item;  				}  				finally {  					layer.type = type;  				}  			}  		}  	}  	else {  		// collect all fonts specified in the fontset file  		Hashtable fonts = new Hashtable ();  		string key = null;  		while ((key = map.fontset.fonts.nextKey (key)) != null)  			fonts.Add (key' key);  		mapObj styles = StyleLibrary.Styles;  		layerObj stylelayer = styles.getLayerByName (comboBoxCategory.Text);  		for (int i = 0; i < stylelayer.numclasses; i++) {  			classObj classobj = stylelayer.getClass (i);  			int symbolIndex = classobj.getStyle (0).symbol;  			if (symbolIndex >= 0) {  				string font = styles.symbolset.getSymbol (symbolIndex).font;  				if (font != null && !fonts.ContainsKey (font))  					continue;  				// this font cannot be found in fontset  			}  			ListViewItem item = AddListItem (classobj.getStyle (0)' stylelayer' classobj.name);  			if (selectedName == item.Text)  				selected = item;  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateStyleList,The following statement contains a magic number: if (comboBoxCategory.Text == "Inline Symbols") {  	for (int i = 0; i < map.symbolset.numsymbols; i++) {  		symbolObj symbol = map.symbolset.getSymbol (i);  		if (symbol.inmapfile == mapscript.MS_TRUE && !StyleLibrary.HasSymbol (symbol.name)) {  			styleObj libstyle = new styleObj (null);  			//if (symbol.type == (int)MS_SYMBOL_TYPE.MS_SYMBOL_PATTERNMAP)  			//    MapUtils.SetDefaultColor(MS_LAYER_TYPE.MS_LAYER_LINE' libstyle);  			//else  			MapUtils.SetDefaultColor (layer.type' libstyle);  			libstyle.setSymbolByName (map' symbol.name);  			libstyle.size = 8;  			MS_LAYER_TYPE type = layer.type;  			try {  				//STEPH: change layer passed to the list view to be consistent with the other symbol categories  				//so that it uses a point layer to display the style in the list  				layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  				ListViewItem item = AddListItem (libstyle' layer' symbol.name);  				if (selectedName == item.Text)  					selected = item;  			}  			finally {  				layer.type = type;  			}  		}  	}  }  else {  	// collect all fonts specified in the fontset file  	Hashtable fonts = new Hashtable ();  	string key = null;  	while ((key = map.fontset.fonts.nextKey (key)) != null)  		fonts.Add (key' key);  	mapObj styles = StyleLibrary.Styles;  	layerObj stylelayer = styles.getLayerByName (comboBoxCategory.Text);  	for (int i = 0; i < stylelayer.numclasses; i++) {  		classObj classobj = stylelayer.getClass (i);  		int symbolIndex = classobj.getStyle (0).symbol;  		if (symbolIndex >= 0) {  			string font = styles.symbolset.getSymbol (symbolIndex).font;  			if (font != null && !fonts.ContainsKey (font))  				continue;  			// this font cannot be found in fontset  		}  		ListViewItem item = AddListItem (classobj.getStyle (0)' stylelayer' classobj.name);  		if (selectedName == item.Text)  			selected = item;  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateStyleList,The following statement contains a magic number: for (int i = 0; i < map.symbolset.numsymbols; i++) {  	symbolObj symbol = map.symbolset.getSymbol (i);  	if (symbol.inmapfile == mapscript.MS_TRUE && !StyleLibrary.HasSymbol (symbol.name)) {  		styleObj libstyle = new styleObj (null);  		//if (symbol.type == (int)MS_SYMBOL_TYPE.MS_SYMBOL_PATTERNMAP)  		//    MapUtils.SetDefaultColor(MS_LAYER_TYPE.MS_LAYER_LINE' libstyle);  		//else  		MapUtils.SetDefaultColor (layer.type' libstyle);  		libstyle.setSymbolByName (map' symbol.name);  		libstyle.size = 8;  		MS_LAYER_TYPE type = layer.type;  		try {  			//STEPH: change layer passed to the list view to be consistent with the other symbol categories  			//so that it uses a point layer to display the style in the list  			layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  			ListViewItem item = AddListItem (libstyle' layer' symbol.name);  			if (selectedName == item.Text)  				selected = item;  		}  		finally {  			layer.type = type;  		}  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateStyleList,The following statement contains a magic number: if (symbol.inmapfile == mapscript.MS_TRUE && !StyleLibrary.HasSymbol (symbol.name)) {  	styleObj libstyle = new styleObj (null);  	//if (symbol.type == (int)MS_SYMBOL_TYPE.MS_SYMBOL_PATTERNMAP)  	//    MapUtils.SetDefaultColor(MS_LAYER_TYPE.MS_LAYER_LINE' libstyle);  	//else  	MapUtils.SetDefaultColor (layer.type' libstyle);  	libstyle.setSymbolByName (map' symbol.name);  	libstyle.size = 8;  	MS_LAYER_TYPE type = layer.type;  	try {  		//STEPH: change layer passed to the list view to be consistent with the other symbol categories  		//so that it uses a point layer to display the style in the list  		layer.type = MS_LAYER_TYPE.MS_LAYER_POINT;  		ListViewItem item = AddListItem (libstyle' layer' symbol.name);  		if (selectedName == item.Text)  			selected = item;  	}  	finally {  		layer.type = type;  	}  }  
Magic Number,DMS.MapLibrary,StylePropertyEditor,C:\repos\DMS-Aus_MapManager\MapLibrary\StylePropertyEditor.cs,UpdateStyleList,The following statement contains a magic number: libstyle.size = 8;  
Magic Number,DMS.MapLibrary,SymbolSelectorControl,C:\repos\DMS-Aus_MapManager\MapLibrary\SymbolSelectorControl.cs,SymbolSelectorControl,The following statement contains a magic number: this.mapControl.Gap = 4;  
Magic Number,DMS.MapLibrary,SymbolSelectorControl,C:\repos\DMS-Aus_MapManager\MapLibrary\SymbolSelectorControl.cs,SymbolSelectorControl,The following statement contains a magic number: SetSpacing ((short)(imageSize + 10)' (short)(imageSize + 10));  
Magic Number,DMS.MapLibrary,SymbolSelectorControl,C:\repos\DMS-Aus_MapManager\MapLibrary\SymbolSelectorControl.cs,SymbolSelectorControl,The following statement contains a magic number: SetSpacing ((short)(imageSize + 10)' (short)(imageSize + 10));  
Magic Number,DMS.MapLibrary,SymbolSelectorControl,C:\repos\DMS-Aus_MapManager\MapLibrary\SymbolSelectorControl.cs,SetSpacing,The following statement contains a magic number: SendMessage (this.listView.Handle' LVM_SETICONSPACING' 0' y * 65536 + x);  
Magic Number,DMS.MapLibrary,SymbolSelectorControl,C:\repos\DMS-Aus_MapManager\MapLibrary\SymbolSelectorControl.cs,SetSpacing,The following statement contains a magic number: SendMessage (this.listViewPreview.Handle' LVM_SETICONSPACING' 0' y * 65536 + x);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: if (wizard == null) {  	this.Controls.RemoveAt (this.Controls.Count - 1);  	panelDefault.Visible = true;  	this.wizard = null;  	this.Text = "Create Theme";  	buttonBack.Top = panelDefault.Bottom + 8;  	buttonNext.Top = panelDefault.Bottom + 8;  	buttonCancel.Top = panelDefault.Bottom + 8;  }  else {  	this.Controls.Add (wizard);  	wizard.Visible = true;  	wizard.Location = new System.Drawing.Point (3' 4);  	wizard.TabIndex = 0;  	buttonBack.Top = wizard.Bottom + 8;  	buttonNext.Top = wizard.Bottom + 8;  	buttonCancel.Top = wizard.Bottom + 8;  	this.wizard = (IWizard)wizard;  	((IPropertyEditor)wizard).Target = target;  	this.Text = "Create Theme: Step " + pageIndex + " of " + Convert.ToString (this.wizard.GetPageCount () + 1);  	panelDefault.Visible = false;  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: buttonBack.Top = panelDefault.Bottom + 8;  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: buttonNext.Top = panelDefault.Bottom + 8;  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: buttonCancel.Top = panelDefault.Bottom + 8;  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: wizard.Location = new System.Drawing.Point (3' 4);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: wizard.Location = new System.Drawing.Point (3' 4);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: buttonBack.Top = wizard.Bottom + 8;  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: buttonNext.Top = wizard.Bottom + 8;  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,InitializeWizard,The following statement contains a magic number: buttonCancel.Top = wizard.Bottom + 8;  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (darkPen' 0' buttonCancel.Top - 4' this.Width' buttonCancel.Top - 4);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (darkPen' 0' buttonCancel.Top - 4' this.Width' buttonCancel.Top - 4);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (lightPen' 0' buttonCancel.Top - 3' this.Width' buttonCancel.Top - 3);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawLine (lightPen' 0' buttonCancel.Top - 3' this.Width' buttonCancel.Top - 3);  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,buttonNext_Click,The following statement contains a magic number: if (wizard == null) {  	InitializeWizard ((Control)listViewThemes.SelectedItems [0].Tag);  }  else {  	if (pageIndex == wizard.GetPageCount () + 2) {  		wizard.Finish ();  		this.Close ();  	}  	else {  		if (pageIndex == wizard.GetPageCount () + 1)  			buttonNext.Text = "Finish";  		wizard.SelectPage (pageIndex - 1);  	}  }  
Magic Number,DMS.MapLibrary,ThemeWizardForm,C:\repos\DMS-Aus_MapManager\MapLibrary\ThemeWizardForm.cs,buttonNext_Click,The following statement contains a magic number: if (pageIndex == wizard.GetPageCount () + 2) {  	wizard.Finish ();  	this.Close ();  }  else {  	if (pageIndex == wizard.GetPageCount () + 1)  		buttonNext.Text = "Finish";  	wizard.SelectPage (pageIndex - 1);  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: if (base.ShowLines && base.ImageList != null && e.Node.ImageIndex == NOIMAGE// exclude root nodes' if root lines are disabled  //&& (base.ShowRootLines || e.Node.Level > 0))  ) {  	// Using lines & images' but this node has none: fill up missing treelines  	// Image size  	int imgW = base.ImageList.ImageSize.Width;  	int imgH = base.ImageList.ImageSize.Height;  	// Image center  	int xPos = e.Node.Bounds.Left - SPACE_IL - imgW / 2;  	int yPos = (e.Node.Bounds.Top + e.Node.Bounds.Bottom) / 2;  	// Image rect  	Rectangle imgRect = new Rectangle (xPos' yPos' 0' 0);  	imgRect.Inflate (imgW / 2' imgH / 2);  	using (Pen p = new Pen (base.LineColor' 1)) {  		p.DashStyle = DashStyle.Dot;  		// account uneven Indent for both lines  		p.DashOffset = base.Indent % 2;  		// Horizontal treeline across width of image  		// account uneven half of delta ItemHeight & ImageHeight  		int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  		//if (base.ShowRootLines || e.Node.Level > 0)  		//{  		//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  		//}  		//else  		//{  		//    // for root nodes' if root lines are disabled' start at center  		//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		//}  		e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  		if (!base.CheckBoxes && e.Node.IsExpanded) {  			// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  			// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  			int yVer = yHor + (int)p.DashOffset;  			e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  		}  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: imgRect.Inflate (imgW / 2' imgH / 2);  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: imgRect.Inflate (imgW / 2' imgH / 2);  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: using (Pen p = new Pen (base.LineColor' 1)) {  	p.DashStyle = DashStyle.Dot;  	// account uneven Indent for both lines  	p.DashOffset = base.Indent % 2;  	// Horizontal treeline across width of image  	// account uneven half of delta ItemHeight & ImageHeight  	int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  	//if (base.ShowRootLines || e.Node.Level > 0)  	//{  	//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  	//}  	//else  	//{  	//    // for root nodes' if root lines are disabled' start at center  	//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  	//}  	e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  	if (!base.CheckBoxes && e.Node.IsExpanded) {  		// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  		// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  		int yVer = yHor + (int)p.DashOffset;  		e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: using (Pen p = new Pen (base.LineColor' 1)) {  	p.DashStyle = DashStyle.Dot;  	// account uneven Indent for both lines  	p.DashOffset = base.Indent % 2;  	// Horizontal treeline across width of image  	// account uneven half of delta ItemHeight & ImageHeight  	int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  	//if (base.ShowRootLines || e.Node.Level > 0)  	//{  	//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  	//}  	//else  	//{  	//    // for root nodes' if root lines are disabled' start at center  	//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  	//}  	e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  	if (!base.CheckBoxes && e.Node.IsExpanded) {  		// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  		// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  		int yVer = yHor + (int)p.DashOffset;  		e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: using (Pen p = new Pen (base.LineColor' 1)) {  	p.DashStyle = DashStyle.Dot;  	// account uneven Indent for both lines  	p.DashOffset = base.Indent % 2;  	// Horizontal treeline across width of image  	// account uneven half of delta ItemHeight & ImageHeight  	int yHor = yPos + ((base.ItemHeight - imgRect.Height) / 2) % 2;  	//if (base.ShowRootLines || e.Node.Level > 0)  	//{  	//    e.Graphics.DrawLine(p' imgRect.Left' yHor' imgRect.Right' yHor);  	//}  	//else  	//{  	//    // for root nodes' if root lines are disabled' start at center  	//    e.Graphics.DrawLine(p' xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  	//}  	e.Graphics.DrawLine (p' (base.ShowRootLines || e.Node.Level > 0) ? imgRect.Left : xPos - (int)p.DashOffset' yHor' imgRect.Right' yHor);  	if (!base.CheckBoxes && e.Node.IsExpanded) {  		// Vertical treeline ' offspring from NodeImage center to e.Node.Bounds.Bottom  		// yStartPos: account uneven Indent and uneven half of delta ItemHeight & ImageHeight  		int yVer = yHor + (int)p.DashOffset;  		e.Graphics.DrawLine (p' xPos' yVer' xPos' e.Node.Bounds.Bottom);  	}  }  
Magic Number,DMS.MapLibrary,TreeViewNoImage,C:\repos\DMS-Aus_MapManager\MapLibrary\TreeViewNoImage.cs,OnDrawNode,The following statement contains a magic number: p.DashOffset = base.Indent % 2;  
Duplicate Code,DMS.MapLibrary,MapControl,C:\repos\DMS-Aus_MapManager\MapLibrary\MapControl.cs,RefreshView,The method contains a code clone-set at the following line numbers (starting from the method definition): ((39' 58)' (63' 82))
Missing Default,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetLayerType,The following switch statement is missing a default case: switch (type) {  case wkbGeometryType.wkbLineString:  case wkbGeometryType.wkbLinearRing:  case wkbGeometryType.wkbLineString25D:  case wkbGeometryType.wkbMultiLineString:  case wkbGeometryType.wkbMultiLineString25D:  	return MS_LAYER_TYPE.MS_LAYER_LINE;  case wkbGeometryType.wkbMultiPoint:  case wkbGeometryType.wkbMultiPoint25D:  case wkbGeometryType.wkbPoint:  case wkbGeometryType.wkbPoint25D:  	return MS_LAYER_TYPE.MS_LAYER_POINT;  case wkbGeometryType.wkbMultiPolygon:  case wkbGeometryType.wkbMultiPolygon25D:  case wkbGeometryType.wkbPolygon:  case wkbGeometryType.wkbPolygon25D:  	return MS_LAYER_TYPE.MS_LAYER_POLYGON;  }  
Missing Default,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitName,The following switch statement is missing a default case: switch (unit) {  case MS_UNITS.MS_DD:  	return "�";  case MS_UNITS.MS_FEET:  	return "ft";  case MS_UNITS.MS_INCHES:  	return "in";  case MS_UNITS.MS_KILOMETERS:  	return "km";  case MS_UNITS.MS_METERS:  	return "m";  case MS_UNITS.MS_MILES:  	return "mi";  case MS_UNITS.MS_PERCENTAGES:  	return "%";  case MS_UNITS.MS_PIXELS:  	return "px";  }  
Missing Default,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetShapeTypeName,The following switch statement is missing a default case: switch (type) {  case MS_SHAPE_TYPE.MS_SHAPE_POLYGON:  	return "Polygon";  case MS_SHAPE_TYPE.MS_SHAPE_LINE:  	return "Line";  case MS_SHAPE_TYPE.MS_SHAPE_POINT:  	return "Point";  case MS_SHAPE_TYPE.MS_SHAPE_NULL:  	return "Null";  }  
Missing Default,DMS.MapLibrary,MapUtils,C:\repos\DMS-Aus_MapManager\MapLibrary\MapUtils.cs,GetUnitPrecision,The following switch statement is missing a default case: switch (unit) {  case MS_UNITS.MS_DD:  	return 5;  case MS_UNITS.MS_FEET:  	return 0;  case MS_UNITS.MS_INCHES:  	return 0;  case MS_UNITS.MS_KILOMETERS:  	return 3;  case MS_UNITS.MS_METERS:  	return 0;  case MS_UNITS.MS_MILES:  	return 3;  case MS_UNITS.MS_PERCENTAGES:  	return 2;  case MS_UNITS.MS_PIXELS:  	return 0;  }  
