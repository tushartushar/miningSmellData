Implementation smell,Namespace,Class,File,Method,Description
Long Method,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The method has 124 lines of code.
Long Method,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateDelegate,The method has 133 lines of code.
Long Method,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateMethod,The method has 177 lines of code.
Long Method,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The method has 185 lines of code.
Complex Method,NLua,CheckType,C:\repos\NLua_NLua\Core\NLua\CheckType.cs,CheckLuaType,Cyclomatic complexity of the method is 11
Complex Method,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,Cyclomatic complexity of the method is 10
Complex Method,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateDelegate,Cyclomatic complexity of the method is 16
Complex Method,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateMethod,Cyclomatic complexity of the method is 23
Complex Method,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,Cyclomatic complexity of the method is 22
Long Parameter List,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The method has 5 parameters. Parameters: luaState' objType' obj' methodName' bindingType
Long Parameter List,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TrySetMember,The method has 5 parameters. Parameters: luaState' targetType' target' bindingType' detailMessage
Long Parameter List,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,IsParamsArray,The method has 5 parameters. Parameters: luaState' nLuaParams' currentLuaParam' currentNetParam' extractValue
Long Parameter List,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateMethod,The method has 8 parameters. Parameters: myType' method' attributes' methodIndex' luaTableField' returnTypesField' generateBase' returnTypes
Long Parameter List,NLua.Method,LuaClassHelper,C:\repos\NLua_NLua\Core\NLua\Method\LuaClassHelper.cs,CallFunction,The method has 5 parameters. Parameters: function' args' returnTypes' inArgs' outArgs
Long Statement,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,CallFunction,The length of the statement  "			return returnTypes != null ? translator.PopValues (luaState' oldTop' returnTypes) : translator.PopValues (luaState' oldTop); " is 124.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,DumpStack,The length of the statement  "				// we dump stacks when deep in calls' calling typename while the stack is in flux can fail sometimes' so manually check for key types " is 133.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetExtensionMethod,The length of the statement  "			var wrapper = new LuaNativeFunction ((new LuaMethodWrapper (translator' obj'new ProxyType(type)' methodInfo)).invokeFunction); " is 126.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The length of the statement  "					// If we can't find any suitable instance members' try to find them as statics - but we only want to allow implicit static " is 122.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The length of the statement  "							return GetMember (luaState' new ProxyType(objType.UnderlyingSystemType.GetTypeInfo().BaseType)' obj' methodName' bindingType); " is 126.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The length of the statement  "						var wrapper = new LuaNativeFunction ((new LuaMethodWrapper (translator' objType' methodName' bindingType)).invokeFunction); " is 123.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The length of the statement  "					// If we reach this point we found a static method' but can't use it in this context because the user passed in an instance " is 123.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The length of the statement  "					return GetMember (luaState' new ProxyType(objType.UnderlyingSystemType.GetTypeInfo().BaseType)' obj' methodName' bindingType); " is 126.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The length of the statement  "						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best " is 123.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TableToArray,The length of the statement  "					paramArray.SetValue (Convert.ChangeType (value' paramArrayType' System.Globalization.CultureInfo.InvariantCulture)' paramArrayIndex); " is 133.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,IsTypeCorrect,The length of the statement  "				return (extractValue = translator.typeChecker.CheckLuaType (luaState' currentLuaParam' currentNetParam.ParameterType)) != null; " is 127.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,IsParamsArray,The length of the statement  "						Debug.WriteLine ("An error occurred during an attempt to retrieve a LuaTable extractor while checking for params array status."); " is 129.
Long Statement,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,IsParamsArray,The length of the statement  "						Debug.WriteLine (string.Format ("An error occurred during an attempt to retrieve an extractor ({0}) while checking for params array status."' paramElementType.FullName)); " is 170.
Long Statement,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,GetConstructorSignatureInternal,The length of the statement  "				PushFunction (luaState' new LuaNativeFunction ((new LuaMethodWrapper (this' null' klass' constructor)).invokeFunction)); " is 120.
Long Statement,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushObject,The length of the statement  "			bool found = (!o.GetType().GetTypeInfo().IsValueType || o.GetType().GetTypeInfo().IsEnum) && objectsBackMap.TryGetValue (o' out index); " is 135.
Long Statement,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushObject,The length of the statement  "				// Note: starting with lua5.1 the garbage collector may remove weak reference items (such as our luaNet_objects values) when the initial GC sweep  " is 145.
Long Statement,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushObject,The length of the statement  "				// occurs' but the actual call of the __gc finalizer for that object may not happen until a little while later.  During that window we might call " is 145.
Long Statement,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushObject,The length of the statement  "				// this routine and find the element missing from luaNet_objects' but collectObject() has not yet been called.  In that case' we go ahead and call collect " is 154.
Long Statement,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CollectObject,The length of the statement  "			// The other variant of collectObject might have gotten here first' in that case we will silently ignore the missing entry " is 122.
Long Statement,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateEvent,The length of the statement  "			var handleMethod = myType.DefineMethod ("HandleEvent"' MethodAttributes.Public | MethodAttributes.HideBySig' returnType' paramTypes); " is 133.
Long Statement,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateDelegate,The length of the statement  "			throw new NotImplementedException ("GenerateDelegate is not available on iOS' please register your LuaDelegate type with Lua.RegisterLuaDelegateType( yourDelegate' theLuaDelegateHandler) "); " is 190.
Long Statement,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateDelegate,The length of the statement  "			throw new NotImplementedException("GenerateDelegate is not available on Silverlight' please register your LuaDelegate type with Lua.RegisterLuaDelegateType( yourDelegate' theLuaDelegateHandler) "); " is 197.
Long Statement,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateDelegate,The length of the statement  "			throw new NotImplementedException("GenerateDelegate is not available on Windows Store' please register your LuaDelegate type with Lua.RegisterLuaDelegateType( yourDelegate' theLuaDelegateHandler) "); " is 199.
Long Statement,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The length of the statement  "					int numStackToSkip = isStatic ? 0 : 1; // If this is an instance invoe we will have an extra arg on the stack for the targetObject" is 130.
Long Statement,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The length of the statement  "							if (_Translator.interpreter.UseTraceback) e.GetBaseException().Data["Traceback"] = _Translator.interpreter.GetDebugTraceback();" is 127.
Long Statement,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The length of the statement  "							_Translator.ThrowError (luaState' String.Format ("instance method '{0}' requires a non null target object"' _MethodName));" is 122.
Long Statement,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The length of the statement  "						string msg = (candidateName == null) ? "invalid arguments to method call" : ("invalid arguments to method: " + candidateName);" is 126.
Long Statement,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The length of the statement  "						_Translator.ThrowError (luaState' "unable to invoke method on generic class as the current method is an open generic method");" is 126.
Long Statement,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The length of the statement  "					if (_Translator.interpreter.UseTraceback) e.GetBaseException().Data["Traceback"] = _Translator.interpreter.GetDebugTraceback();" is 127.
Complex Conditional,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,RegisterGlobal,The conditional expression  "(type.IsClass () || type.IsInterface ()) && type != typeof(string) && recursionCounter < 2"  is complex.
Complex Conditional,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,RegisterGlobal,The conditional expression  "(!method.GetCustomAttributes (typeof(LuaHideAttribute)' false).Any ()) &&  						(!method.GetCustomAttributes (typeof(LuaGlobalAttribute)' false).Any ()) &&  					// Exclude some generic .NET methods that wouldn't be very usefull in Lua  						name != "GetType" && name != "GetHashCode" && name != "Equals" &&  						name != "ToString" && name != "Clone" && name != "Dispose" &&  						name != "GetEnumerator" && name != "CopyTo" &&  						!name.StartsWith ("get_"' StringComparison.Ordinal) &&  						!name.StartsWith ("set_"' StringComparison.Ordinal) &&  						!name.StartsWith ("add_"' StringComparison.Ordinal) &&  						!name.StartsWith ("remove_"' StringComparison.Ordinal)"  is complex.
Complex Conditional,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TrySetMember,The conditional expression  "fieldName == null || fieldName.Length < 1 || !(char.IsLetter (fieldName [0]) || fieldName [0] == '_')"  is complex.
Complex Conditional,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,Push,The conditional expression  "o is sbyte || o is byte || o is short || o is ushort ||  			         o is int || o is uint || o is long || o is float ||  			         o is ulong || o is decimal || o is double"  is complex.
Complex Conditional,NLua,ReferenceComparer,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,Equals,The conditional expression  "x != null && y != null && x.GetType() == y.GetType() && x.GetType().IsValueType && y.GetType().IsValueType"  is complex.
Empty Catch Block,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMethodInternal,The method has an empty catch block.
Empty Catch Block,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,LoadAssemblyInternal,The method has an empty catch block.
Magic Number,NLua,CheckType,C:\repos\NLua_NLua\Core\NLua\CheckType.cs,CheckLuaType,The following statement contains a magic number: if (netParamIsNumeric) {  				if (LuaLib.LuaIsNumber (luaState' stackPos) && !netParamIsString)  					return extractValues [extractKey];  			} else if (paramType == typeof(bool)) {  				if (LuaLib.LuaIsBoolean (luaState' stackPos))  					return extractValues [extractKey];  			} else if (netParamIsString) {  				if (LuaLib.LuaNetIsStringStrict (luaState' stackPos))  					return extractValues [extractKey];  				else if (luatype == LuaTypes.Nil)  					return extractNetObject; // kevinh - silently convert nil to a null string pointer  			} else if (paramType == typeof(LuaTable)) {  				if (luatype == LuaTypes.Table || luatype == LuaTypes.Nil)  					return extractValues [extractKey];  			} else if (paramType == typeof(LuaUserData)) {  				if (luatype == LuaTypes.UserData || luatype == LuaTypes.Nil)  					return extractValues [extractKey];  			} else if (paramType == typeof(LuaFunction)) {  				if (luatype == LuaTypes.Function || luatype == LuaTypes.Nil)  					return extractValues [extractKey];  			} else if (typeof(Delegate).IsAssignableFrom (paramType) && luatype == LuaTypes.Function)  				return new ExtractValue (new DelegateGenerator (translator' paramType).ExtractGenerated);  			else if (paramType.IsInterface() && luatype == LuaTypes.Table)  				return new ExtractValue (new ClassGenerator (translator' paramType).ExtractGenerated);  			else if ((paramType.IsInterface() || paramType.IsClass()) && luatype == LuaTypes.Nil) {  				// kevinh - allow nil to be silently converted to null - extractNetObject will return null when the item ain't found  				return extractNetObject;  			} else if (LuaLib.LuaType (luaState' stackPos) == LuaTypes.Table) {  				if (LuaLib.LuaLGetMetafield (luaState' stackPos' "__index")) {  					object obj = translator.GetNetObject (luaState' -1);  					LuaLib.LuaSetTop (luaState' -2);  					if (obj != null && paramType.IsAssignableFrom (obj.GetType ()))  						return extractNetObject;  				} else  					return null;  			} else {  				object obj = translator.GetNetObject (luaState' stackPos);  				if (obj != null && paramType.IsAssignableFrom (obj.GetType ()))  					return extractNetObject;  			}
Magic Number,NLua,CheckType,C:\repos\NLua_NLua\Core\NLua\CheckType.cs,GetAsObject,The following statement contains a magic number: if (LuaLib.LuaType (luaState' stackPos) == LuaTypes.Table) {  				if (LuaLib.LuaLGetMetafield (luaState' stackPos' "__index")) {  					if (LuaLib.LuaLCheckMetatable (luaState' -1)) {  						LuaLib.LuaInsert (luaState' stackPos);  						LuaLib.LuaRemove (luaState' stackPos + 1);  					} else  						LuaLib.LuaSetTop (luaState' -2);  				}  			}
Magic Number,NLua,CheckType,C:\repos\NLua_NLua\Core\NLua\CheckType.cs,GetAsNetObject,The following statement contains a magic number: if (obj == null && LuaLib.LuaType (luaState' stackPos) == LuaTypes.Table) {  				if (LuaLib.LuaLGetMetafield (luaState' stackPos' "__index")) {  					if (LuaLib.LuaLCheckMetatable (luaState' -1)) {  						LuaLib.LuaInsert (luaState' stackPos);  						LuaLib.LuaRemove (luaState' stackPos + 1);  						obj = translator.GetNetObject (luaState' stackPos);  					} else   						LuaLib.LuaSetTop (luaState' -2);  				}  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,Lua,The following statement contains a magic number: if (LuaLib.LuaToBoolean (lState' -1)) {  				LuaLib.LuaSetTop (lState' -2);  				throw new LuaException ("There is already a NLua.Lua instance associated with this Lua state");  			} else {  				luaState = lState;  				_StatePassed = true;  				LuaLib.LuaSetTop (luaState' -2);  				Init ();  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,Lua,The following statement contains a magic number: if (LuaLib.LuaToBoolean (lState' -1)) {  				LuaLib.LuaSetTop (lState' -2);  				throw new LuaException ("There is already a NLua.Lua instance associated with this Lua state");  			} else {  				luaState = lState;  				_StatePassed = true;  				LuaLib.LuaSetTop (luaState' -2);  				Init ();  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,Init,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,PushDebugTraceback,The following statement contains a magic number: LuaLib.LuaRemove(luaState' -2);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,PushDebugTraceback,The following statement contains a magic number: int errindex = -argcount -2;
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,GetDebugTraceback,The following statement contains a magic number: LuaLib.LuaRemove(luaState' -2);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,RegisterGlobal,The following statement contains a magic number: if (type == typeof(LuaNativeFunction)) {  				// Format for easy method invocation  				globals.Add (path + "(");  			}  			// If the type is a class or an interface and recursion hasn't been running too long' list the members  			else if ((type.IsClass () || type.IsInterface ()) && type != typeof(string) && recursionCounter < 2) {  				#region Methods  				foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance)) {  					string name = method.Name;  					if (  						// Check that the LuaHideAttribute and LuaGlobalAttribute were not applied  						(!method.GetCustomAttributes (typeof(LuaHideAttribute)' false).Any ()) &&  						(!method.GetCustomAttributes (typeof(LuaGlobalAttribute)' false).Any ()) &&  					// Exclude some generic .NET methods that wouldn't be very usefull in Lua  						name != "GetType" && name != "GetHashCode" && name != "Equals" &&  						name != "ToString" && name != "Clone" && name != "Dispose" &&  						name != "GetEnumerator" && name != "CopyTo" &&  						!name.StartsWith ("get_"' StringComparison.Ordinal) &&  						!name.StartsWith ("set_"' StringComparison.Ordinal) &&  						!name.StartsWith ("add_"' StringComparison.Ordinal) &&  						!name.StartsWith ("remove_"' StringComparison.Ordinal)) {  						// Format for easy method invocation  						string command = path + ":" + name + "(";    						if (method.GetParameters ().Length == 0)  							command += ")";  						globals.Add (command);  					}  				}  				#endregion    				#region Fields  				foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.Instance)) {  					if (  						// Check that the LuaHideAttribute and LuaGlobalAttribute were not applied  						(!field.GetCustomAttributes (typeof(LuaHideAttribute)' false).Any ()) &&  						(!field.GetCustomAttributes (typeof(LuaGlobalAttribute)' false).Any ())) {  						// Go into recursion for members  						RegisterGlobal (path + "." + field.Name' field.FieldType' recursionCounter + 1);  					}  				}  				#endregion    				#region Properties  				foreach (var property in type.GetProperties (BindingFlags.Public | BindingFlags.Instance)) {  					if (  						// Check that the LuaHideAttribute and LuaGlobalAttribute were not applied  						(!property.GetCustomAttributes (typeof(LuaHideAttribute)' false).Any ()) &&  						(!property.GetCustomAttributes (typeof(LuaGlobalAttribute)' false).Any ())  					// Exclude some generic .NET properties that wouldn't be very useful in Lua  						&& property.Name != "Item") {  						// Go into recursion for members  						RegisterGlobal (path + "." + property.Name' property.PropertyType' recursionCounter + 1);  					}  				}  				#endregion  			} else  				globals.Add (path);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,GetObject,The following statement contains a magic number: for (int i = 0; i < remainingPath.Length; i++) {  				LuaLib.LuaPushString (luaState' remainingPath [i]);  				LuaLib.LuaGetTable (luaState' -2);  				returnValue = translator.GetObject (luaState' -1);    				if (returnValue == null)  					break;	  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,CallFunction,The following statement contains a magic number: if (!LuaLib.LuaCheckStack (luaState' args.Length + 6))  				throw new LuaException ("Lua stack overflow");
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,SetObject,The following statement contains a magic number: for (int i = 0; i < remainingPath.Length-1; i++) {  				LuaLib.LuaPushString (luaState' remainingPath [i]);  				LuaLib.LuaGetTable (luaState' -2);  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,SetObject,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,NewTable,The following statement contains a magic number: if (path.Length == 1) {  				LuaLib.LuaNewTable (luaState);  				LuaLib.LuaSetGlobal (luaState' fullPath);  			} else {  				LuaLib.LuaGetGlobal (luaState' path [0]);    				for (int i = 1; i < path.Length-1; i++) {  					LuaLib.LuaPushString (luaState' path [i]);  					LuaLib.LuaGetTable (luaState' -2);  				}    				LuaLib.LuaPushString (luaState' path [path.Length - 1]);  				LuaLib.LuaNewTable (luaState);  				LuaLib.LuaSetTable (luaState' -3);  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,NewTable,The following statement contains a magic number: if (path.Length == 1) {  				LuaLib.LuaNewTable (luaState);  				LuaLib.LuaSetGlobal (luaState' fullPath);  			} else {  				LuaLib.LuaGetGlobal (luaState' path [0]);    				for (int i = 1; i < path.Length-1; i++) {  					LuaLib.LuaPushString (luaState' path [i]);  					LuaLib.LuaGetTable (luaState' -2);  				}    				LuaLib.LuaPushString (luaState' path [path.Length - 1]);  				LuaLib.LuaNewTable (luaState);  				LuaLib.LuaSetTable (luaState' -3);  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,GetTableDict,The following statement contains a magic number: while (LuaLib.LuaNext(luaState' -2) != 0) {  				dict [translator.GetObject (luaState' -2)] = translator.GetObject (luaState' -1);  				LuaLib.LuaSetTop (luaState' -2);  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,GetTableDict,The following statement contains a magic number: while (LuaLib.LuaNext(luaState' -2) != 0) {  				dict [translator.GetObject (luaState' -2)] = translator.GetObject (luaState' -1);  				LuaLib.LuaSetTop (luaState' -2);  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,GetTableDict,The following statement contains a magic number: while (LuaLib.LuaNext(luaState' -2) != 0) {  				dict [translator.GetObject (luaState' -2)] = translator.GetObject (luaState' -1);  				LuaLib.LuaSetTop (luaState' -2);  			}
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,RawGetObject,The following statement contains a magic number: LuaLib.LuaRawGet (luaState' -2);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,GetObject,The following statement contains a magic number: LuaLib.LuaGetTable (luaState' -2);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,SetObject,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,Lua,C:\repos\NLua_NLua\Core\NLua\Lua.cs,CompareRef,The following statement contains a magic number: int equal = LuaLib.LuaEqual (luaState' -1' -2);
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMethodInternal,The following statement contains a magic number: object index = translator.GetObject (luaState' 2);
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMethodInternal,The following statement contains a magic number: if (objType.IsArray && index is double) {  				int intIndex = (int)((double)index);  #if NETFX_CORE  				Type type = objType;  #else  				Type type = objType.UnderlyingSystemType;  #endif    				if (type == typeof(float[])) {  					float[] arr = ((float[])obj);  					translator.Push (luaState' arr [intIndex]);  				} else if (type == typeof(double[])) {  					double[] arr = ((double[])obj);  					translator.Push (luaState' arr [intIndex]);  				} else if (type == typeof(int[])) {  					int[] arr = ((int[])obj);  					translator.Push (luaState' arr [intIndex]);  				} else {  					object[] arr = (object[])obj;  					translator.Push (luaState' arr [intIndex]);  				}  			} else {    				if (!string.IsNullOrEmpty (methodName) && IsExtensionMethodPresent (objType' methodName)) {  					return GetExtensionMethod (luaState' objType' obj' methodName);  				}  				// Try to use get_Item to index into this .net object  				var methods = objType.GetMethods ();    				foreach (var mInfo in methods) {  					if (mInfo.Name == "get_Item") {  						//check if the signature matches the input  						if (mInfo.GetParameters ().Length == 1) {  							var getter = mInfo;  							var actualParms = (getter != null) ? getter.GetParameters () : null;    							if (actualParms == null || actualParms.Length != 1) {  								translator.ThrowError (luaState' "method not found (or no indexer): " + index);  								LuaLib.LuaPushNil (luaState);  							} else {  								// Get the index in a form acceptable to the getter  								index = translator.GetAsType (luaState' 2' actualParms [0].ParameterType);  								object[] args = new object[1];    								// Just call the indexer - if out of bounds an exception will happen  								args [0] = index;    								try {  									object result = getter.Invoke (obj' args);  									translator.Push (luaState' result);  								} catch (TargetInvocationException e) {  									// Provide a more readable description for the common case of key not found  									if (e.InnerException is KeyNotFoundException)  										translator.ThrowError (luaState' "key '" + index + "' not found ");  									else  										translator.ThrowError (luaState' "exception indexing '" + index + "' " + e.Message);    									LuaLib.LuaPushNil (luaState);  								}  							}  						}  					}  				}  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMethodInternal,The following statement contains a magic number: return 2;
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetBaseMethodInternal,The following statement contains a magic number: if (obj == null) {  				translator.ThrowError (luaState' "trying to index an invalid object reference");  				LuaLib.LuaPushNil (luaState);  				LuaLib.LuaPushBoolean (luaState' false);  				return 2;  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetBaseMethodInternal,The following statement contains a magic number: string methodName = LuaLib.LuaToString (luaState' 2).ToString ();
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetBaseMethodInternal,The following statement contains a magic number: if (string.IsNullOrEmpty(methodName)) {  				LuaLib.LuaPushNil (luaState);  				LuaLib.LuaPushBoolean (luaState' false);  				return 2;  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetBaseMethodInternal,The following statement contains a magic number: LuaLib.LuaSetTop (luaState' -2);
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetBaseMethodInternal,The following statement contains a magic number: if (LuaLib.LuaType (luaState' -1) == LuaTypes.Nil) {  				LuaLib.LuaSetTop (luaState' -2);  				return GetMember (luaState' new ProxyType(obj.GetType ())' obj' methodName' BindingFlags.Instance);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetBaseMethodInternal,The following statement contains a magic number: return 2;
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetExtensionMethod,The following statement contains a magic number: if (cachedMember != null && cachedMember is LuaNativeFunction) {  					translator.PushFunction (luaState' (LuaNativeFunction)cachedMember);  					translator.Push (luaState' true);  					return 2;  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetExtensionMethod,The following statement contains a magic number: return 2;
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The following statement contains a magic number: if (cachedMember is LuaNativeFunction) {  				translator.PushFunction (luaState' (LuaNativeFunction)cachedMember);  				translator.Push (luaState' true);  				return 2;  			} else if (cachedMember != null)  				member = (MemberInfo)cachedMember;  			else {  				var members = objType.GetMember (methodName' bindingType | BindingFlags.Public);    				if (members.Length > 0)  					member = members [0];  				else {  					// If we can't find any suitable instance members' try to find them as statics - but we only want to allow implicit static  					members = objType.GetMember (methodName' bindingType | BindingFlags.Static | BindingFlags.Public);    					if (members.Length > 0) {  						member = members [0];  						implicitStatic = true;  					}  				}  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The following statement contains a magic number: if (member != null) {  #if NETFX_CORE  				if (member is FieldInfo) {  #else  				if (member.MemberType == MemberTypes.Field) {  #endif  					var field = (FieldInfo)member;    					if (cachedMember == null)  						SetMemberCache (memberCache' objType' methodName' member);    					try {  						var value = field.GetValue (obj);  						translator.Push (luaState' value);							  					} catch {  						LuaLib.LuaPushNil (luaState);  					}  #if NETFX_CORE  				} else if (member is PropertyInfo) {  #else  				} else if (member.MemberType == MemberTypes.Property) {  #endif  					var property = (PropertyInfo)member;  					if (cachedMember == null)  						SetMemberCache (memberCache' objType' methodName' member);    					try {  						object value = property.GetValue (obj' null);  						translator.Push (luaState' value);  							  					} catch (ArgumentException) {  						// If we can't find the getter in our class' recurse up to the base class and see  						// if they can help.  						if (objType.UnderlyingSystemType != typeof(object))  #if NETFX_CORE  							return GetMember (luaState' new ProxyType(objType.UnderlyingSystemType.GetTypeInfo().BaseType)' obj' methodName' bindingType);  #else  							return GetMember (luaState' new ProxyType(objType.UnderlyingSystemType.BaseType)' obj' methodName' bindingType);  #endif  						else  							LuaLib.LuaPushNil (luaState);  					} catch (TargetInvocationException e) {  // Convert this exception into a Lua error  						ThrowError (luaState' e);  						LuaLib.LuaPushNil (luaState);  					}  #if NETFX_CORE  				} else if (member is EventInfo) {  #else  				} else if (member.MemberType == MemberTypes.Event) {  #endif  					var eventInfo = (EventInfo)member;  					if (cachedMember == null)  						SetMemberCache (memberCache' objType' methodName' member);    					translator.Push (luaState' new RegisterEventHandler (translator.pendingEvents' obj' eventInfo));  				} else if (!implicitStatic) {  #if NETFX_CORE  					var typeInfo = member as TypeInfo;  					if (typeInfo != null && !typeInfo.IsPublic && !typeInfo.IsNotPublic) {  #else  					if (member.MemberType == MemberTypes.NestedType) {  #endif    						// kevinh - added support for finding nested types-  						// cache us  						if (cachedMember == null)  							SetMemberCache (memberCache' objType' methodName' member);    						// Find the name of our class  						string name = member.Name;  						var dectype = member.DeclaringType;    						// Build a new long name and try to find the type by name  						string longname = dectype.FullName + "+" + name;  						var nestedType = translator.FindType (longname);  						translator.PushType (luaState' nestedType);  					} else {  						// Member type must be 'method'  						var wrapper = new LuaNativeFunction ((new LuaMethodWrapper (translator' objType' methodName' bindingType)).invokeFunction);    						if (cachedMember == null)  							SetMemberCache (memberCache' objType' methodName' wrapper);    						translator.PushFunction (luaState' wrapper);  						translator.Push (luaState' true);  						return 2;  					}  				} else {  					// If we reach this point we found a static method' but can't use it in this context because the user passed in an instance  					translator.ThrowError (luaState' "can't pass instance to static method " + methodName);  					LuaLib.LuaPushNil (luaState);  				}  			} else {    				if (objType.UnderlyingSystemType != typeof(object)) {  					#if NETFX_CORE  					return GetMember (luaState' new ProxyType(objType.UnderlyingSystemType.GetTypeInfo().BaseType)' obj' methodName' bindingType);  					#else  					return GetMember (luaState' new ProxyType(objType.UnderlyingSystemType.BaseType)' obj' methodName' bindingType);  					#endif  				}  				// kevinh - we want to throw an exception because meerly returning 'nil' in this case  				// is not sufficient.  valid data members may return nil and therefore there must be some  				// way to know the member just doesn't exist.  				translator.ThrowError (luaState' "unknown member name " + methodName);  				LuaLib.LuaPushNil (luaState);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetMember,The following statement contains a magic number: return 2;
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The following statement contains a magic number: try {  				if (type.IsArray && LuaLib.LuaIsNumber (luaState' 2)) {  					int index = (int)LuaLib.LuaToNumber (luaState' 2);  					var arr = (Array)target;  					object val = translator.GetAsType (luaState' 3' arr.GetType ().GetElementType ());  					arr.SetValue (val' index);  				} else {  					// Try to see if we have a this[] accessor  					var setter = type.GetMethod ("set_Item");  					if (setter != null) {  						var args = setter.GetParameters ();  						var valueType = args [1].ParameterType;    						// The new val ue the user specified   						object val = translator.GetAsType (luaState' 3' valueType);  						var indexType = args [0].ParameterType;  						object index = translator.GetAsType (luaState' 2' indexType);    						object[] methodArgs = new object[2];    						// Just call the indexer - if out of bounds an exception will happen  						methodArgs [0] = index;  						methodArgs [1] = val;  						setter.Invoke (target' methodArgs);  					} else  						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best  				}  #if !SILVERLIGHT  			} catch (SEHException) {  				// If we are seeing a C++ exception - this must actually be for Lua's private use.  Let it handle it  				throw;  #endif  			} catch (Exception e) {  				ThrowError (luaState' e);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The following statement contains a magic number: try {  				if (type.IsArray && LuaLib.LuaIsNumber (luaState' 2)) {  					int index = (int)LuaLib.LuaToNumber (luaState' 2);  					var arr = (Array)target;  					object val = translator.GetAsType (luaState' 3' arr.GetType ().GetElementType ());  					arr.SetValue (val' index);  				} else {  					// Try to see if we have a this[] accessor  					var setter = type.GetMethod ("set_Item");  					if (setter != null) {  						var args = setter.GetParameters ();  						var valueType = args [1].ParameterType;    						// The new val ue the user specified   						object val = translator.GetAsType (luaState' 3' valueType);  						var indexType = args [0].ParameterType;  						object index = translator.GetAsType (luaState' 2' indexType);    						object[] methodArgs = new object[2];    						// Just call the indexer - if out of bounds an exception will happen  						methodArgs [0] = index;  						methodArgs [1] = val;  						setter.Invoke (target' methodArgs);  					} else  						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best  				}  #if !SILVERLIGHT  			} catch (SEHException) {  				// If we are seeing a C++ exception - this must actually be for Lua's private use.  Let it handle it  				throw;  #endif  			} catch (Exception e) {  				ThrowError (luaState' e);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The following statement contains a magic number: try {  				if (type.IsArray && LuaLib.LuaIsNumber (luaState' 2)) {  					int index = (int)LuaLib.LuaToNumber (luaState' 2);  					var arr = (Array)target;  					object val = translator.GetAsType (luaState' 3' arr.GetType ().GetElementType ());  					arr.SetValue (val' index);  				} else {  					// Try to see if we have a this[] accessor  					var setter = type.GetMethod ("set_Item");  					if (setter != null) {  						var args = setter.GetParameters ();  						var valueType = args [1].ParameterType;    						// The new val ue the user specified   						object val = translator.GetAsType (luaState' 3' valueType);  						var indexType = args [0].ParameterType;  						object index = translator.GetAsType (luaState' 2' indexType);    						object[] methodArgs = new object[2];    						// Just call the indexer - if out of bounds an exception will happen  						methodArgs [0] = index;  						methodArgs [1] = val;  						setter.Invoke (target' methodArgs);  					} else  						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best  				}  #if !SILVERLIGHT  			} catch (SEHException) {  				// If we are seeing a C++ exception - this must actually be for Lua's private use.  Let it handle it  				throw;  #endif  			} catch (Exception e) {  				ThrowError (luaState' e);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The following statement contains a magic number: try {  				if (type.IsArray && LuaLib.LuaIsNumber (luaState' 2)) {  					int index = (int)LuaLib.LuaToNumber (luaState' 2);  					var arr = (Array)target;  					object val = translator.GetAsType (luaState' 3' arr.GetType ().GetElementType ());  					arr.SetValue (val' index);  				} else {  					// Try to see if we have a this[] accessor  					var setter = type.GetMethod ("set_Item");  					if (setter != null) {  						var args = setter.GetParameters ();  						var valueType = args [1].ParameterType;    						// The new val ue the user specified   						object val = translator.GetAsType (luaState' 3' valueType);  						var indexType = args [0].ParameterType;  						object index = translator.GetAsType (luaState' 2' indexType);    						object[] methodArgs = new object[2];    						// Just call the indexer - if out of bounds an exception will happen  						methodArgs [0] = index;  						methodArgs [1] = val;  						setter.Invoke (target' methodArgs);  					} else  						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best  				}  #if !SILVERLIGHT  			} catch (SEHException) {  				// If we are seeing a C++ exception - this must actually be for Lua's private use.  Let it handle it  				throw;  #endif  			} catch (Exception e) {  				ThrowError (luaState' e);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The following statement contains a magic number: try {  				if (type.IsArray && LuaLib.LuaIsNumber (luaState' 2)) {  					int index = (int)LuaLib.LuaToNumber (luaState' 2);  					var arr = (Array)target;  					object val = translator.GetAsType (luaState' 3' arr.GetType ().GetElementType ());  					arr.SetValue (val' index);  				} else {  					// Try to see if we have a this[] accessor  					var setter = type.GetMethod ("set_Item");  					if (setter != null) {  						var args = setter.GetParameters ();  						var valueType = args [1].ParameterType;    						// The new val ue the user specified   						object val = translator.GetAsType (luaState' 3' valueType);  						var indexType = args [0].ParameterType;  						object index = translator.GetAsType (luaState' 2' indexType);    						object[] methodArgs = new object[2];    						// Just call the indexer - if out of bounds an exception will happen  						methodArgs [0] = index;  						methodArgs [1] = val;  						setter.Invoke (target' methodArgs);  					} else  						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best  				}  #if !SILVERLIGHT  			} catch (SEHException) {  				// If we are seeing a C++ exception - this must actually be for Lua's private use.  Let it handle it  				throw;  #endif  			} catch (Exception e) {  				ThrowError (luaState' e);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,SetFieldOrPropertyInternal,The following statement contains a magic number: try {  				if (type.IsArray && LuaLib.LuaIsNumber (luaState' 2)) {  					int index = (int)LuaLib.LuaToNumber (luaState' 2);  					var arr = (Array)target;  					object val = translator.GetAsType (luaState' 3' arr.GetType ().GetElementType ());  					arr.SetValue (val' index);  				} else {  					// Try to see if we have a this[] accessor  					var setter = type.GetMethod ("set_Item");  					if (setter != null) {  						var args = setter.GetParameters ();  						var valueType = args [1].ParameterType;    						// The new val ue the user specified   						object val = translator.GetAsType (luaState' 3' valueType);  						var indexType = args [0].ParameterType;  						object index = translator.GetAsType (luaState' 2' indexType);    						object[] methodArgs = new object[2];    						// Just call the indexer - if out of bounds an exception will happen  						methodArgs [0] = index;  						methodArgs [1] = val;  						setter.Invoke (target' methodArgs);  					} else  						translator.ThrowError (luaState' detailMessage); // Pass the original message from trySetMember because it is probably best  				}  #if !SILVERLIGHT  			} catch (SEHException) {  				// If we are seeing a C++ exception - this must actually be for Lua's private use.  Let it handle it  				throw;  #endif  			} catch (Exception e) {  				ThrowError (luaState' e);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TrySetMember,The following statement contains a magic number: if (LuaLib.LuaType (luaState' 2) != LuaTypes.String) {  				detailMessage = "property names must be strings";  				return false;  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TrySetMember,The following statement contains a magic number: string fieldName = LuaLib.LuaToString (luaState' 2).ToString ();
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TrySetMember,The following statement contains a magic number: if (member.MemberType == MemberTypes.Field) {  #endif    				var field = (FieldInfo)member;  				object val = translator.GetAsType (luaState' 3' field.FieldType);    				try {  					field.SetValue (target' val);  				} catch (Exception e) {  					ThrowError (luaState' e);  				}    				// We did a call  				return true;  #if NETFX_CORE  			} else if (member is PropertyInfo) {  #else  			} else if (member.MemberType == MemberTypes.Property) {  #endif  				var property = (PropertyInfo)member;  				object val = translator.GetAsType (luaState' 3' property.PropertyType);    				try {  					property.SetValue (target' val' null);  				} catch (Exception e) {  					ThrowError (luaState' e);  				}    				// We did a call  				return true;  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,TrySetMember,The following statement contains a magic number: if (member.MemberType == MemberTypes.Field) {  #endif    				var field = (FieldInfo)member;  				object val = translator.GetAsType (luaState' 3' field.FieldType);    				try {  					field.SetValue (target' val);  				} catch (Exception e) {  					ThrowError (luaState' e);  				}    				// We did a call  				return true;  #if NETFX_CORE  			} else if (member is PropertyInfo) {  #else  			} else if (member.MemberType == MemberTypes.Property) {  #endif  				var property = (PropertyInfo)member;  				object val = translator.GetAsType (luaState' 3' property.PropertyType);    				try {  					property.SetValue (target' val' null);  				} catch (Exception e) {  					ThrowError (luaState' e);  				}    				// We did a call  				return true;  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetClassMethodInternal,The following statement contains a magic number: if (LuaLib.LuaIsNumber (luaState' 2)) {  				int size = (int)LuaLib.LuaToNumber (luaState' 2);  				translator.Push (luaState' Array.CreateInstance (klass.UnderlyingSystemType' size));  				return 1;  			} else {  				string methodName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (string.IsNullOrEmpty(methodName)) {  					LuaLib.LuaPushNil (luaState);  					return 1;  				}  				else  					return GetMember (luaState' klass' null' methodName' BindingFlags.Static);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetClassMethodInternal,The following statement contains a magic number: if (LuaLib.LuaIsNumber (luaState' 2)) {  				int size = (int)LuaLib.LuaToNumber (luaState' 2);  				translator.Push (luaState' Array.CreateInstance (klass.UnderlyingSystemType' size));  				return 1;  			} else {  				string methodName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (string.IsNullOrEmpty(methodName)) {  					LuaLib.LuaPushNil (luaState);  					return 1;  				}  				else  					return GetMember (luaState' klass' null' methodName' BindingFlags.Static);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetClassMethodInternal,The following statement contains a magic number: if (LuaLib.LuaIsNumber (luaState' 2)) {  				int size = (int)LuaLib.LuaToNumber (luaState' 2);  				translator.Push (luaState' Array.CreateInstance (klass.UnderlyingSystemType' size));  				return 1;  			} else {  				string methodName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (string.IsNullOrEmpty(methodName)) {  					LuaLib.LuaPushNil (luaState);  					return 1;  				}  				else  					return GetMember (luaState' klass' null' methodName' BindingFlags.Static);  			}
Magic Number,NLua,MetaFunctions,C:\repos\NLua_NLua\Core\NLua\Metatables.cs,GetTargetObject,The following statement contains a magic number: target = translator.GetRawNetObject (luaState' 2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateLuaObjectList,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateLuaObjectList,The following statement contains a magic number: LuaLib.LuaSetMetatable (luaState' -2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateBaseClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateBaseClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateBaseClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateBaseClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateBaseClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTop (luaState' -2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateClassMetatable,The following statement contains a magic number: LuaLib.LuaSetTop (luaState' -2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateFunctionMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateFunctionMetatable,The following statement contains a magic number: LuaLib.LuaSetTable (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,CreateFunctionMetatable,The following statement contains a magic number: LuaLib.LuaSetTop (luaState' -2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterTableInternal,The following statement contains a magic number: if (LuaLib.LuaType (luaState' 1) == LuaTypes.Table) {  				var luaTable = GetTable (luaState' 1);  				string superclassName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (superclassName != null) {  					var klass = FindType (superclassName);    					if (klass != null) {  						// Creates and pushes the object in the stack' setting  						// it as the  metatable of the first argument  						object obj = CodeGeneration.Instance.GetClassInstance (klass' luaTable);  						PushObject (luaState' obj' "luaNet_metatable");  						LuaLib.LuaNewTable (luaState);  						LuaLib.LuaPushString (luaState' "__index");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaPushString (luaState' "__newindex");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaSetMetatable (luaState' 1);  						// Pushes the object again' this time as the base field  						// of the table and with the luaNet_searchbase metatable  						LuaLib.LuaPushString (luaState' "base");  						int index = AddObject (obj);  						PushNewObject (luaState' obj' index' "luaNet_searchbase");  						LuaLib.LuaRawSet (luaState' 1);  					} else  						ThrowError (luaState' "register_table: can not find superclass '" + superclassName + "'");  				} else  					ThrowError (luaState' "register_table: superclass name can not be null");  			} else  				ThrowError (luaState' "register_table: first arg is not a table");
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterTableInternal,The following statement contains a magic number: if (LuaLib.LuaType (luaState' 1) == LuaTypes.Table) {  				var luaTable = GetTable (luaState' 1);  				string superclassName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (superclassName != null) {  					var klass = FindType (superclassName);    					if (klass != null) {  						// Creates and pushes the object in the stack' setting  						// it as the  metatable of the first argument  						object obj = CodeGeneration.Instance.GetClassInstance (klass' luaTable);  						PushObject (luaState' obj' "luaNet_metatable");  						LuaLib.LuaNewTable (luaState);  						LuaLib.LuaPushString (luaState' "__index");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaPushString (luaState' "__newindex");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaSetMetatable (luaState' 1);  						// Pushes the object again' this time as the base field  						// of the table and with the luaNet_searchbase metatable  						LuaLib.LuaPushString (luaState' "base");  						int index = AddObject (obj);  						PushNewObject (luaState' obj' index' "luaNet_searchbase");  						LuaLib.LuaRawSet (luaState' 1);  					} else  						ThrowError (luaState' "register_table: can not find superclass '" + superclassName + "'");  				} else  					ThrowError (luaState' "register_table: superclass name can not be null");  			} else  				ThrowError (luaState' "register_table: first arg is not a table");
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterTableInternal,The following statement contains a magic number: if (LuaLib.LuaType (luaState' 1) == LuaTypes.Table) {  				var luaTable = GetTable (luaState' 1);  				string superclassName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (superclassName != null) {  					var klass = FindType (superclassName);    					if (klass != null) {  						// Creates and pushes the object in the stack' setting  						// it as the  metatable of the first argument  						object obj = CodeGeneration.Instance.GetClassInstance (klass' luaTable);  						PushObject (luaState' obj' "luaNet_metatable");  						LuaLib.LuaNewTable (luaState);  						LuaLib.LuaPushString (luaState' "__index");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaPushString (luaState' "__newindex");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaSetMetatable (luaState' 1);  						// Pushes the object again' this time as the base field  						// of the table and with the luaNet_searchbase metatable  						LuaLib.LuaPushString (luaState' "base");  						int index = AddObject (obj);  						PushNewObject (luaState' obj' index' "luaNet_searchbase");  						LuaLib.LuaRawSet (luaState' 1);  					} else  						ThrowError (luaState' "register_table: can not find superclass '" + superclassName + "'");  				} else  					ThrowError (luaState' "register_table: superclass name can not be null");  			} else  				ThrowError (luaState' "register_table: first arg is not a table");
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterTableInternal,The following statement contains a magic number: if (LuaLib.LuaType (luaState' 1) == LuaTypes.Table) {  				var luaTable = GetTable (luaState' 1);  				string superclassName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (superclassName != null) {  					var klass = FindType (superclassName);    					if (klass != null) {  						// Creates and pushes the object in the stack' setting  						// it as the  metatable of the first argument  						object obj = CodeGeneration.Instance.GetClassInstance (klass' luaTable);  						PushObject (luaState' obj' "luaNet_metatable");  						LuaLib.LuaNewTable (luaState);  						LuaLib.LuaPushString (luaState' "__index");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaPushString (luaState' "__newindex");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaSetMetatable (luaState' 1);  						// Pushes the object again' this time as the base field  						// of the table and with the luaNet_searchbase metatable  						LuaLib.LuaPushString (luaState' "base");  						int index = AddObject (obj);  						PushNewObject (luaState' obj' index' "luaNet_searchbase");  						LuaLib.LuaRawSet (luaState' 1);  					} else  						ThrowError (luaState' "register_table: can not find superclass '" + superclassName + "'");  				} else  					ThrowError (luaState' "register_table: superclass name can not be null");  			} else  				ThrowError (luaState' "register_table: first arg is not a table");
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterTableInternal,The following statement contains a magic number: if (LuaLib.LuaType (luaState' 1) == LuaTypes.Table) {  				var luaTable = GetTable (luaState' 1);  				string superclassName = LuaLib.LuaToString (luaState' 2).ToString ();    				if (superclassName != null) {  					var klass = FindType (superclassName);    					if (klass != null) {  						// Creates and pushes the object in the stack' setting  						// it as the  metatable of the first argument  						object obj = CodeGeneration.Instance.GetClassInstance (klass' luaTable);  						PushObject (luaState' obj' "luaNet_metatable");  						LuaLib.LuaNewTable (luaState);  						LuaLib.LuaPushString (luaState' "__index");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaPushString (luaState' "__newindex");  						LuaLib.LuaPushValue (luaState' -3);  						LuaLib.LuaSetTable (luaState' -3);  						LuaLib.LuaSetMetatable (luaState' 1);  						// Pushes the object again' this time as the base field  						// of the table and with the luaNet_searchbase metatable  						LuaLib.LuaPushString (luaState' "base");  						int index = AddObject (obj);  						PushNewObject (luaState' obj' index' "luaNet_searchbase");  						LuaLib.LuaRawSet (luaState' 1);  					} else  						ThrowError (luaState' "register_table: can not find superclass '" + superclassName + "'");  				} else  					ThrowError (luaState' "register_table: superclass name can not be null");  			} else  				ThrowError (luaState' "register_table: first arg is not a table");
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,UnregisterTableInternal,The following statement contains a magic number: try {  				if (LuaLib.LuaGetMetatable (luaState' 1) != 0) {  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaGetTable (luaState' -2);  					object obj = GetRawNetObject (luaState' -1);    					if (obj == null)  						ThrowError (luaState' "unregister_table: arg is not valid table");    					var luaTableField = obj.GetType ().GetField ("__luaInterface_luaTable");    					if (luaTableField == null)  						ThrowError (luaState' "unregister_table: arg is not valid table");    					luaTableField.SetValue (obj' null);  					LuaLib.LuaPushNil (luaState);  					LuaLib.LuaSetMetatable (luaState' 1);  					LuaLib.LuaPushString (luaState' "base");  					LuaLib.LuaPushNil (luaState);  					LuaLib.LuaSetTable (luaState' 1);  				} else  					ThrowError (luaState' "unregister_table: arg is not valid table");  			} catch (Exception e) {  				ThrowError (luaState' e.Message);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,GetMethodSignatureInternal,The following statement contains a magic number: string methodName = LuaLib.LuaToString (luaState' 2).ToString ();
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,GetMethodSignatureInternal,The following statement contains a magic number: var signature = new Type[LuaLib.LuaGetTop (luaState) - 2];
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,GetMethodSignatureInternal,The following statement contains a magic number: for (int i = 0; i < signature.Length; i++)  				signature [i] = FindType (LuaLib.LuaToString (luaState' i + 3).ToString ());
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,GetConstructorSignatureInternal,The following statement contains a magic number: for (int i = 0; i < signature.Length; i++)  				signature [i] = FindType (LuaLib.LuaToString (luaState' i + 2).ToString ());
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushObject,The following statement contains a magic number: if (found) {  				LuaLib.LuaLGetMetatable (luaState' "luaNet_objects");  				LuaLib.LuaRawGetI (luaState' -1' index);    				// Note: starting with lua5.1 the garbage collector may remove weak reference items (such as our luaNet_objects values) when the initial GC sweep   				// occurs' but the actual call of the __gc finalizer for that object may not happen until a little while later.  During that window we might call  				// this routine and find the element missing from luaNet_objects' but collectObject() has not yet been called.  In that case' we go ahead and call collect  				// object here  				// did we find a non nil object in our table? if not' we need to call collect object  				var type = LuaLib.LuaType (luaState' -1);  				if (type != LuaTypes.Nil) {  					LuaLib.LuaRemove (luaState' -2);	 // drop the metatable - we're going to leave our object on the stack  					return;  				}    				// MetaFunctions.dumpStack(this' luaState);  				LuaLib.LuaRemove (luaState' -1);	// remove the nil object value  				LuaLib.LuaRemove (luaState' -1);	// remove the metatable  				CollectObject (o' index);			// Remove from both our tables and fall out to get a new ID  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: if (metatable == "luaNet_metatable") {  				// Gets or creates the metatable for the object's type  				LuaLib.LuaLGetMetatable (luaState' o.GetType ().AssemblyQualifiedName);    				if (LuaLib.LuaIsNil (luaState' -1)) {  					LuaLib.LuaSetTop (luaState' -2);  					LuaLib.LuaLNewMetatable (luaState' o.GetType ().AssemblyQualifiedName);  					LuaLib.LuaPushString (luaState' "cache");  					LuaLib.LuaNewTable (luaState);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushLightUserData (luaState' LuaLib.LuaNetGetTag ());  					LuaLib.LuaPushNumber (luaState' 1);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__index");  					LuaLib.LuaPushString (luaState' "luaNet_indexfunction");  					LuaLib.LuaRawGet (luaState' (int)LuaIndexes.Registry);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__gc");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.GcFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__tostring");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ToStringFunction);  					LuaLib.LuaRawSet (luaState' -3);  					LuaLib.LuaPushString (luaState' "__newindex");  					LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.NewIndexFunction);  					LuaLib.LuaRawSet (luaState' -3);  					// Bind C# operator with Lua metamethods (__add' __sub' __mul)  					RegisterOperatorsFunctions (luaState' o.GetType ());  					RegisterCallMethodForDelegate (luaState' o);  				}  			} else  				LuaLib.LuaLGetMetatable (luaState' metatable);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: LuaLib.LuaPushValue (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: LuaLib.LuaRemove (luaState' -4);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: LuaLib.LuaSetMetatable (luaState' -2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: LuaLib.LuaRawSetI (luaState' -3' index);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushNewObject,The following statement contains a magic number: LuaLib.LuaRemove (luaState' -2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterCallMethodForDelegate,The following statement contains a magic number: LuaLib.LuaRawSet (luaState' -3);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasAdditionOpertator ()) {  				LuaLib.LuaPushString (luaState' "__add");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.AddFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasSubtractionOpertator ()) {  				LuaLib.LuaPushString (luaState' "__sub");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.SubtractFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasMultiplyOpertator ()) {  				LuaLib.LuaPushString (luaState' "__mul");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.MultiplyFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasDivisionOpertator ()) {  				LuaLib.LuaPushString (luaState' "__div");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.DivisionFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasModulusOpertator ()) {  				LuaLib.LuaPushString (luaState' "__mod");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.ModulosFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasUnaryNegationOpertator ()) {  				LuaLib.LuaPushString (luaState' "__unm");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.UnaryNegationFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasEqualityOpertator ()) {  				LuaLib.LuaPushString (luaState' "__eq");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.EqualFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasLessThanOpertator ()) {  				LuaLib.LuaPushString (luaState' "__lt");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.LessThanFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,RegisterOperatorsFunctions,The following statement contains a magic number: if (type.HasLessThanOrEqualOpertator ()) {  				LuaLib.LuaPushString (luaState' "__le");  				LuaLib.LuaPushStdCallCFunction (luaState' metaFunctions.LessThanOrEqualFunction);  				LuaLib.LuaRawSet (luaState' -3);  			}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,PushError,The following statement contains a magic number: return 2;
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,EnumFromIntInternal,The following statement contains a magic number: LuaTypes lt = LuaLib.LuaType (luaState' 2);
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,EnumFromIntInternal,The following statement contains a magic number: if (lt == LuaTypes.Number) {  				int ival = (int)LuaLib.LuaToNumber (luaState' 2);  				res = Enum.ToObject (t' ival);  			} else  				if (lt == LuaTypes.String) {  					string sflags = LuaLib.LuaToString (luaState' 2);  					string err = null;  					try {  						res = Enum.Parse (t' sflags' true);  					} catch (ArgumentException e) {  						err = e.Message;  					}  					if (err != null)  						return PushError (luaState' err);  				} else {  					return PushError (luaState' "Second argument must be a integer or a string.");  				}
Magic Number,NLua,ObjectTranslator,C:\repos\NLua_NLua\Core\NLua\ObjectTranslator.cs,EnumFromIntInternal,The following statement contains a magic number: if (lt == LuaTypes.Number) {  				int ival = (int)LuaLib.LuaToNumber (luaState' 2);  				res = Enum.ToObject (t' ival);  			} else  				if (lt == LuaTypes.String) {  					string sflags = LuaLib.LuaToString (luaState' 2);  					string err = null;  					try {  						res = Enum.Parse (t' sflags' true);  					} catch (ArgumentException e) {  						err = e.Message;  					}  					if (err != null)  						return PushError (luaState' err);  				} else {  					return PushError (luaState' "Second argument must be a integer or a string.");  				}
Magic Number,NLua,CodeGeneration,C:\repos\NLua_NLua\Core\NLua\GenerateEventAssembly\CodeGeneration.cs,GenerateEvent,The following statement contains a magic number: var paramTypes = new Type[2];
Magic Number,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The following statement contains a magic number: if (!LuaLib.LuaCheckStack (luaState' 5)) 				throw new LuaException ("Lua stack overflow");
Magic Number,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The following statement contains a magic number: if (methodToCall == null) { // Method from name 				if (isStatic) 					targetObject = null; 				else 					targetObject = _ExtractTarget (luaState' 1);  				if (_LastCalledMethod.cachedMethod != null) { // Cached? 					int numStackToSkip = isStatic ? 0 : 1; // If this is an instance invoe we will have an extra arg on the stack for the targetObject 					int numArgsPassed = LuaLib.LuaGetTop (luaState) - numStackToSkip; 					MethodBase method = _LastCalledMethod.cachedMethod;  					if (numArgsPassed == _LastCalledMethod.argTypes.Length) { // No. of args match? 						if (!LuaLib.LuaCheckStack (luaState' _LastCalledMethod.outList.Length + 6)) 							throw new LuaException ("Lua stack overflow");  						object [] args = _LastCalledMethod.args;  						try { 							for (int i = 0; i < _LastCalledMethod.argTypes.Length; i++) {  								MethodArgs type = _LastCalledMethod.argTypes [i];  								int index = i + 1 + numStackToSkip;  								Func<int' object> valueExtractor = (currentParam) => { 									return type.extractValue (luaState' currentParam);							 								};  								if (_LastCalledMethod.argTypes [i].isParamsArray) { 									int count = _LastCalledMethod.argTypes.Length - i; 									Array paramArray = _Translator.TableToArray (valueExtractor' type.paramsArrayType' index' count); 									args [_LastCalledMethod.argTypes [i].index] = paramArray; 								} else { 									args [type.index] = valueExtractor (index); 								}  								if (_LastCalledMethod.args [_LastCalledMethod.argTypes [i].index] == null && 									!LuaLib.LuaIsNil (luaState' i + 1 + numStackToSkip)) 									throw new LuaException (string.Format("argument number {0} is invalid"'(i + 1))); 							}  							if (_IsStatic) 								_Translator.Push (luaState' method.Invoke (null' _LastCalledMethod.args)); 							else { 								if (method.IsConstructor) 									_Translator.Push (luaState' ((ConstructorInfo)method).Invoke (_LastCalledMethod.args)); 								else 									_Translator.Push (luaState' method.Invoke (targetObject' _LastCalledMethod.args)); 							}  							failedCall = false; 						} catch (TargetInvocationException e) {  							// Failure of method invocation  							if (_Translator.interpreter.UseTraceback) e.GetBaseException().Data["Traceback"] = _Translator.interpreter.GetDebugTraceback(); 							return SetPendingException (e.GetBaseException ()); 						} catch (Exception e) { 							if (_Members.Length == 1) // Is the method overloaded? 								// No' throw error 								return SetPendingException (e); 						} 					} 				}  				// Cache miss 				if (failedCall) { 					// System.Diagnostics.Debug.WriteLine("cache miss on " + methodName); 					// If we are running an instance variable' we can now pop the targetObject from the stack 					if (!isStatic) { 						if (targetObject == null) { 							_Translator.ThrowError (luaState' String.Format ("instance method '{0}' requires a non null target object"' _MethodName)); 							LuaLib.LuaPushNil (luaState); 							return 1; 						}  						LuaLib.LuaRemove (luaState' 1); // Pops the receiver 					}  					bool hasMatch = false; 					string candidateName = null;  					foreach (var member in _Members) { #if NETFX_CORE  						candidateName = member.DeclaringType.Name + "." + member.Name; #else 						candidateName = member.ReflectedType.Name + "." + member.Name; #endif  						var m = (MethodInfo)member; 						bool isMethod = _Translator.MatchParameters (luaState' m' ref _LastCalledMethod);  						if (isMethod) { 							hasMatch = true; 							break; 						} 					}  					if (!hasMatch) { 						string msg = (candidateName == null) ? "invalid arguments to method call" : ("invalid arguments to method: " + candidateName); 						_Translator.ThrowError (luaState' msg); 						LuaLib.LuaPushNil (luaState); 						return 1; 					} 				} 			} else { // Method from MethodBase instance 				if (methodToCall.ContainsGenericParameters) { 					 					_Translator.MatchParameters (luaState' methodToCall' ref _LastCalledMethod);  					if (methodToCall.IsGenericMethodDefinition) { 						//need to make a concrete type of the generic method definition 						var typeArgs = new List<Type> ();  						foreach (object arg in _LastCalledMethod.args) 							typeArgs.Add (arg.GetType ());  						var concreteMethod = (methodToCall as MethodInfo).MakeGenericMethod (typeArgs.ToArray ()); 						_Translator.Push (luaState' concreteMethod.Invoke (targetObject' _LastCalledMethod.args)); 						failedCall = false; 					} else if (methodToCall.ContainsGenericParameters) { 						_Translator.ThrowError (luaState' "unable to invoke method on generic class as the current method is an open generic method"); 						LuaLib.LuaPushNil (luaState); 						return 1; 					} 				} else { 					if (!methodToCall.IsStatic && !methodToCall.IsConstructor && targetObject == null) { 						targetObject = _ExtractTarget (luaState' 1); 						LuaLib.LuaRemove (luaState' 1); // Pops the receiver 					}  					if (!_Translator.MatchParameters (luaState' methodToCall' ref _LastCalledMethod)) { 						_Translator.ThrowError (luaState' "invalid arguments to method call"); 						LuaLib.LuaPushNil (luaState); 						return 1; 					} 				} 			}
Magic Number,NLua.Method,LuaMethodWrapper,C:\repos\NLua_NLua\Core\NLua\Method\LuaMethodWrapper.cs,Call,The following statement contains a magic number: if (failedCall) { 				if (!LuaLib.LuaCheckStack (luaState' _LastCalledMethod.outList.Length + 6)) 					throw new LuaException ("Lua stack overflow");  				try { 					if (isStatic) 						_Translator.Push (luaState' _LastCalledMethod.cachedMethod.Invoke (null' _LastCalledMethod.args)); 					else { 						if (_LastCalledMethod.cachedMethod.IsConstructor) 							_Translator.Push (luaState' ((ConstructorInfo)_LastCalledMethod.cachedMethod).Invoke (_LastCalledMethod.args)); 						else 							_Translator.Push (luaState' _LastCalledMethod.cachedMethod.Invoke (targetObject' _LastCalledMethod.args)); 					} 				} catch (TargetInvocationException e) {  					if (_Translator.interpreter.UseTraceback) e.GetBaseException().Data["Traceback"] = _Translator.interpreter.GetDebugTraceback(); 					return SetPendingException (e.GetBaseException ()); 				} catch (Exception e) { 					return SetPendingException (e); 				} 			}
