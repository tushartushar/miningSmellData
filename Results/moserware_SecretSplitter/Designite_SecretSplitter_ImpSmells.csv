Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Moserware.Security.Cryptography,OpenPgp,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,DecryptSingleFile,Cyclomatic complexity of the method is 8
Long Parameter List,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,Moserware.Security.Cryptography,SplitSecret,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\SecretSplitter.cs,SplitSecret,The method has 5 parameters. Parameters: shareType' threshold' irreduciblePolynomial' allCoefficients' passPhrase
Long Parameter List,Moserware.Security.Cryptography.Versioning,SplitSecret,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\SecretSplitter.cs,SplitSecret,The method has 5 parameters. Parameters: shareType' threshold' irreduciblePolynomial' allCoefficients' passPhrase
Long Identifier,Moserware.Security.Cryptography,OpenPgp,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,DecryptSingleFile,The length of the parameter encryptedIntegrityProtectedData is 31.
Long Identifier,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,,The length of the parameter _CurrentEncryptedFeedbackRegisterPosition is 41.
Long Statement,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,ToString,The length of the statement  "            var prefixedPointBytes = Enumerable.Range(0' expectedByteCount - pointBytes.Length).Select(ix => (byte)0).Concat(pointBytes); " is 125.
Long Statement,Moserware.Security.Cryptography,OpenPgpStringToKeySpecifier,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ReadFrom,The length of the statement  "                case OpenPgpStringToKeySpecifierId.IteratedAndSalted: return new IteratedAndSaltedOpenPgpStringToKeySpecifier(inputStream); " is 123.
Long Statement,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,AddCipher,The length of the statement  "            var newCipher = new OpenPgpSymmetricCipher(id' name' () => { var sa = cipherFactory(); sa.KeySize = keySize; return sa; }); " is 123.
Long Statement,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ComputeHash,The length of the statement  "                for (int octectsLeftToHash = octetsToHashCount; (octectsLeftToHash > 0) || !hasDoneFirstIteration; octectsLeftToHash -= maxOctetsPerIteration) { " is 144.
Long Statement,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ComputeHash,The length of the statement  "                        int currentContextBytesToHash = hasDoneFirstIteration ? Math.Min(octectsLeftToHash' maxOctetsPerIteration) : maxOctetsPerIteration; " is 131.
Long Statement,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,GetNextEncryptedFeedbackByte,The length of the statement  "                if (_UnderlyingTransform.TransformBlock(_FeedbackRegister' 0' _FeedbackRegister.Length' _EncryptedFeedbackRegister' 0) != _EncryptedFeedbackRegister.Length) { " is 158.
Long Statement,Moserware.Security.Cryptography,SecretCombiner,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\SecretCombiner.cs,Combine,The length of the statement  "            return Combine(Regex.Matches(allShares' SecretShare.RegexPattern).OfType<Match>().Select(m => SecretShare.Parse(m.Value))' DefaultDiffuser); " is 140.
Long Statement,Moserware.Security.Cryptography,SecretCombiner,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\SecretCombiner.cs,Combine,The length of the statement  "            return Combine(allShares.Select(share => Regex.Match(share' SecretShare.RegexPattern).Value).Select(SecretShare.Parse)' diffuser); " is 130.
Long Statement,Moserware.Security.Cryptography,SecretSplitter,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\SecretSplitter.cs,GetRandomPolynomials,The length of the statement  "                yield return new FiniteFieldPolynomial(irreduciblePolynomial' randomCoefficientBytes.ToBigIntegerFromLittleEndianUnsignedBytes()); " is 130.
Long Statement,Moserware.Security.Cryptography.Versioning,SecretSplitter,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\SecretSplitter.cs,GetRandomPolynomials,The length of the statement  "                yield return new FiniteFieldPolynomial(irreduciblePolynomial' randomCoefficientBytes.ToBigIntegerFromLittleEndianUnsignedBytes()); " is 130.
Virtual Method Call from Constructor,Moserware.Security.Cryptography,CompressedDataOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,CompressedDataOpenPgpPacket,The constructor "CompressedDataOpenPgpPacket" calls a virtual method "Decompress".
Magic Number,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,ToString,The following statement contains a magic number: for (int remainder = totalPoints; remainder > 0; remainder /= 10) {                  sb.Append('0');              }
Magic Number,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,TryParse,The following statement contains a magic number: try {                  var xString = match.Groups["x"].Value.ToLowerInvariant();                  var yString = match.Groups["y"].Value.ToLowerInvariant();                    // get rid of any initial 0's                  while (xString.StartsWith("0"' StringComparison.Ordinal)) {                      xString = xString.Substring(1);                  }                    // Each hex letter makes up 4 bits' so to get the degree in bits                  // we multiply by 4                    int polynomialDegree = yString.Length*4;                    var irp = new IrreduciblePolynomial(polynomialDegree);                    var x = new FiniteFieldPolynomial(irp' BigInteger.Parse(xString));                    // get bytes                  var bigEndianBytes = new byte[yString.Length/2];                  for (int i = 0; i < yString.Length; i += 2) {                      bigEndianBytes[i/2] = Byte.Parse(yString.Substring(i' 2)' NumberStyles.HexNumber);                  }                  var y = new FiniteFieldPolynomial(irp' bigEndianBytes.ToBigIntegerFromBigEndianUnsignedBytes());                    result = new FiniteFieldPoint(x' y);                  return true;              }              catch(Exception exception) {                  result = null;                  return false;              }
Magic Number,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,TryParse,The following statement contains a magic number: try {                  var xString = match.Groups["x"].Value.ToLowerInvariant();                  var yString = match.Groups["y"].Value.ToLowerInvariant();                    // get rid of any initial 0's                  while (xString.StartsWith("0"' StringComparison.Ordinal)) {                      xString = xString.Substring(1);                  }                    // Each hex letter makes up 4 bits' so to get the degree in bits                  // we multiply by 4                    int polynomialDegree = yString.Length*4;                    var irp = new IrreduciblePolynomial(polynomialDegree);                    var x = new FiniteFieldPolynomial(irp' BigInteger.Parse(xString));                    // get bytes                  var bigEndianBytes = new byte[yString.Length/2];                  for (int i = 0; i < yString.Length; i += 2) {                      bigEndianBytes[i/2] = Byte.Parse(yString.Substring(i' 2)' NumberStyles.HexNumber);                  }                  var y = new FiniteFieldPolynomial(irp' bigEndianBytes.ToBigIntegerFromBigEndianUnsignedBytes());                    result = new FiniteFieldPoint(x' y);                  return true;              }              catch(Exception exception) {                  result = null;                  return false;              }
Magic Number,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,TryParse,The following statement contains a magic number: try {                  var xString = match.Groups["x"].Value.ToLowerInvariant();                  var yString = match.Groups["y"].Value.ToLowerInvariant();                    // get rid of any initial 0's                  while (xString.StartsWith("0"' StringComparison.Ordinal)) {                      xString = xString.Substring(1);                  }                    // Each hex letter makes up 4 bits' so to get the degree in bits                  // we multiply by 4                    int polynomialDegree = yString.Length*4;                    var irp = new IrreduciblePolynomial(polynomialDegree);                    var x = new FiniteFieldPolynomial(irp' BigInteger.Parse(xString));                    // get bytes                  var bigEndianBytes = new byte[yString.Length/2];                  for (int i = 0; i < yString.Length; i += 2) {                      bigEndianBytes[i/2] = Byte.Parse(yString.Substring(i' 2)' NumberStyles.HexNumber);                  }                  var y = new FiniteFieldPolynomial(irp' bigEndianBytes.ToBigIntegerFromBigEndianUnsignedBytes());                    result = new FiniteFieldPoint(x' y);                  return true;              }              catch(Exception exception) {                  result = null;                  return false;              }
Magic Number,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,TryParse,The following statement contains a magic number: try {                  var xString = match.Groups["x"].Value.ToLowerInvariant();                  var yString = match.Groups["y"].Value.ToLowerInvariant();                    // get rid of any initial 0's                  while (xString.StartsWith("0"' StringComparison.Ordinal)) {                      xString = xString.Substring(1);                  }                    // Each hex letter makes up 4 bits' so to get the degree in bits                  // we multiply by 4                    int polynomialDegree = yString.Length*4;                    var irp = new IrreduciblePolynomial(polynomialDegree);                    var x = new FiniteFieldPolynomial(irp' BigInteger.Parse(xString));                    // get bytes                  var bigEndianBytes = new byte[yString.Length/2];                  for (int i = 0; i < yString.Length; i += 2) {                      bigEndianBytes[i/2] = Byte.Parse(yString.Substring(i' 2)' NumberStyles.HexNumber);                  }                  var y = new FiniteFieldPolynomial(irp' bigEndianBytes.ToBigIntegerFromBigEndianUnsignedBytes());                    result = new FiniteFieldPoint(x' y);                  return true;              }              catch(Exception exception) {                  result = null;                  return false;              }
Magic Number,Moserware.Algebra,FiniteFieldPoint,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\FiniteFieldPoint.cs,TryParse,The following statement contains a magic number: try {                  var xString = match.Groups["x"].Value.ToLowerInvariant();                  var yString = match.Groups["y"].Value.ToLowerInvariant();                    // get rid of any initial 0's                  while (xString.StartsWith("0"' StringComparison.Ordinal)) {                      xString = xString.Substring(1);                  }                    // Each hex letter makes up 4 bits' so to get the degree in bits                  // we multiply by 4                    int polynomialDegree = yString.Length*4;                    var irp = new IrreduciblePolynomial(polynomialDegree);                    var x = new FiniteFieldPolynomial(irp' BigInteger.Parse(xString));                    // get bytes                  var bigEndianBytes = new byte[yString.Length/2];                  for (int i = 0; i < yString.Length; i += 2) {                      bigEndianBytes[i/2] = Byte.Parse(yString.Substring(i' 2)' NumberStyles.HexNumber);                  }                  var y = new FiniteFieldPolynomial(irp' bigEndianBytes.ToBigIntegerFromBigEndianUnsignedBytes());                    result = new FiniteFieldPoint(x' y);                  return true;              }              catch(Exception exception) {                  result = null;                  return false;              }
Magic Number,Moserware.Algebra,IrreduciblePolynomial,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\IrreduciblePolynomial.cs,IrreduciblePolynomial,The following statement contains a magic number: for (int i = 0; i < InnerTermsPerPolynomial; i++) {                  PolynomialValue =                      PolynomialValue.SetBit(                          _TermPowers[InnerTermsPerPolynomial*((degreeOfIrreduciblePolynomial/8) - 1) + i]);              }
Magic Number,Moserware.Algebra,IrreduciblePolynomial,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\IrreduciblePolynomial.cs,CreateOfByteSize,The following statement contains a magic number: return new IrreduciblePolynomial(byteSize*8);
Magic Number,Moserware.Algebra,IrreduciblePolynomial,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\IrreduciblePolynomial.cs,IsValidDegree,The following statement contains a magic number: return (8 <= degree) && (degree <= MaxDegree) && ((degree%8) == 0);
Magic Number,Moserware.Algebra,IrreduciblePolynomial,C:\repos\moserware_SecretSplitter\SecretSplitter\Algebra\IrreduciblePolynomial.cs,IsValidDegree,The following statement contains a magic number: return (8 <= degree) && (degree <= MaxDegree) && ((degree%8) == 0);
Magic Number,Moserware.Security.Cryptography,HexadecimalPasswordGenerator,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\HexadecimalPasswordGenerator.cs,GeneratePasswordOfBitSize,The following statement contains a magic number: return GeneratePassword(bitSize/4);
Magic Number,Moserware.Security.Cryptography,HexadecimalPasswordGenerator,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\HexadecimalPasswordGenerator.cs,GeneratePassword,The following statement contains a magic number: int byteLength = (length + 1)/2;
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if (firstLengthByte < 192) {                  Length = firstLengthByte;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if((firstLengthByte >= 192) && (firstLengthByte <= 223)) {                  int secondLengthByte = inputStream.ReadByte();                  if (secondLengthByte < 0) {                      throw new EndOfStreamException();                  }                  Length = ((firstLengthByte - 192) << 8) + secondLengthByte + 192;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if((firstLengthByte >= 192) && (firstLengthByte <= 223)) {                  int secondLengthByte = inputStream.ReadByte();                  if (secondLengthByte < 0) {                      throw new EndOfStreamException();                  }                  Length = ((firstLengthByte - 192) << 8) + secondLengthByte + 192;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if((firstLengthByte >= 192) && (firstLengthByte <= 223)) {                  int secondLengthByte = inputStream.ReadByte();                  if (secondLengthByte < 0) {                      throw new EndOfStreamException();                  }                  Length = ((firstLengthByte - 192) << 8) + secondLengthByte + 192;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if((firstLengthByte >= 192) && (firstLengthByte <= 223)) {                  int secondLengthByte = inputStream.ReadByte();                  if (secondLengthByte < 0) {                      throw new EndOfStreamException();                  }                  Length = ((firstLengthByte - 192) << 8) + secondLengthByte + 192;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if((firstLengthByte >= 192) && (firstLengthByte <= 223)) {                  int secondLengthByte = inputStream.ReadByte();                  if (secondLengthByte < 0) {                      throw new EndOfStreamException();                  }                  Length = ((firstLengthByte - 192) << 8) + secondLengthByte + 192;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: if(firstLengthByte != 255) {                  throw new InvalidDataException();              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpPacketHeader,The following statement contains a magic number: Length = OpenPgpScalarNumber.Read(inputStream' 4);
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length <= 191) {                  outputStream.WriteByte((byte)Length);              }              else if(Length <= 8383) {                  int bodyLenRemainder = (int)(Length - 192);                  byte secondLengthByte = (byte) (bodyLenRemainder & 0xFF);                  bodyLenRemainder >>= 8;                  byte firstLengthByte = (byte) (bodyLenRemainder + 192);                  outputStream.WriteByte(firstLengthByte);                  outputStream.WriteByte(secondLengthByte);              }              else {                  outputStream.WriteByte(0xFF);                  OpenPgpScalarNumber.WriteTo((uint)Length' outputStream);              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length <= 191) {                  outputStream.WriteByte((byte)Length);              }              else if(Length <= 8383) {                  int bodyLenRemainder = (int)(Length - 192);                  byte secondLengthByte = (byte) (bodyLenRemainder & 0xFF);                  bodyLenRemainder >>= 8;                  byte firstLengthByte = (byte) (bodyLenRemainder + 192);                  outputStream.WriteByte(firstLengthByte);                  outputStream.WriteByte(secondLengthByte);              }              else {                  outputStream.WriteByte(0xFF);                  OpenPgpScalarNumber.WriteTo((uint)Length' outputStream);              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length <= 191) {                  outputStream.WriteByte((byte)Length);              }              else if(Length <= 8383) {                  int bodyLenRemainder = (int)(Length - 192);                  byte secondLengthByte = (byte) (bodyLenRemainder & 0xFF);                  bodyLenRemainder >>= 8;                  byte firstLengthByte = (byte) (bodyLenRemainder + 192);                  outputStream.WriteByte(firstLengthByte);                  outputStream.WriteByte(secondLengthByte);              }              else {                  outputStream.WriteByte(0xFF);                  OpenPgpScalarNumber.WriteTo((uint)Length' outputStream);              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length <= 191) {                  outputStream.WriteByte((byte)Length);              }              else if(Length <= 8383) {                  int bodyLenRemainder = (int)(Length - 192);                  byte secondLengthByte = (byte) (bodyLenRemainder & 0xFF);                  bodyLenRemainder >>= 8;                  byte firstLengthByte = (byte) (bodyLenRemainder + 192);                  outputStream.WriteByte(firstLengthByte);                  outputStream.WriteByte(secondLengthByte);              }              else {                  outputStream.WriteByte(0xFF);                  OpenPgpScalarNumber.WriteTo((uint)Length' outputStream);              }
Magic Number,Moserware.Security.Cryptography,OpenPgpPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length <= 191) {                  outputStream.WriteByte((byte)Length);              }              else if(Length <= 8383) {                  int bodyLenRemainder = (int)(Length - 192);                  byte secondLengthByte = (byte) (bodyLenRemainder & 0xFF);                  bodyLenRemainder >>= 8;                  byte firstLengthByte = (byte) (bodyLenRemainder + 192);                  outputStream.WriteByte(firstLengthByte);                  outputStream.WriteByte(secondLengthByte);              }              else {                  outputStream.WriteByte(0xFF);                  OpenPgpScalarNumber.WriteTo((uint)Length' outputStream);              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: _TagId = (firstByte & ~OldHeaderHighBits) >> 2;
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: if (lengthType == 3) {                  // 4.2.1 - Indeterminate length                  Length = -1;                  return;              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: if(lengthType == 1) {                  Length = (firstLengthOctet << 16) | secondLengthOctet;              }              else if(lengthType == 2) {                  int thirdLengthOctet = inputStream.ReadByte();                  int fourthLengthOctet = inputStream.ReadByte();                  if(fourthLengthOctet < 0) {                      throw new EndOfStreamException();                  }                  Length = (firstLengthOctet << 24) | (secondLengthOctet << 16) | (thirdLengthOctet << 8) | fourthLengthOctet;              }              else {                  throw new NotSupportedException();              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: if(lengthType == 1) {                  Length = (firstLengthOctet << 16) | secondLengthOctet;              }              else if(lengthType == 2) {                  int thirdLengthOctet = inputStream.ReadByte();                  int fourthLengthOctet = inputStream.ReadByte();                  if(fourthLengthOctet < 0) {                      throw new EndOfStreamException();                  }                  Length = (firstLengthOctet << 24) | (secondLengthOctet << 16) | (thirdLengthOctet << 8) | fourthLengthOctet;              }              else {                  throw new NotSupportedException();              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: if(lengthType == 1) {                  Length = (firstLengthOctet << 16) | secondLengthOctet;              }              else if(lengthType == 2) {                  int thirdLengthOctet = inputStream.ReadByte();                  int fourthLengthOctet = inputStream.ReadByte();                  if(fourthLengthOctet < 0) {                      throw new EndOfStreamException();                  }                  Length = (firstLengthOctet << 24) | (secondLengthOctet << 16) | (thirdLengthOctet << 8) | fourthLengthOctet;              }              else {                  throw new NotSupportedException();              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: if(lengthType == 1) {                  Length = (firstLengthOctet << 16) | secondLengthOctet;              }              else if(lengthType == 2) {                  int thirdLengthOctet = inputStream.ReadByte();                  int fourthLengthOctet = inputStream.ReadByte();                  if(fourthLengthOctet < 0) {                      throw new EndOfStreamException();                  }                  Length = (firstLengthOctet << 24) | (secondLengthOctet << 16) | (thirdLengthOctet << 8) | fourthLengthOctet;              }              else {                  throw new NotSupportedException();              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpOldFormatPacketHeader,The following statement contains a magic number: if(lengthType == 1) {                  Length = (firstLengthOctet << 16) | secondLengthOctet;              }              else if(lengthType == 2) {                  int thirdLengthOctet = inputStream.ReadByte();                  int fourthLengthOctet = inputStream.ReadByte();                  if(fourthLengthOctet < 0) {                      throw new EndOfStreamException();                  }                  Length = (firstLengthOctet << 24) | (secondLengthOctet << 16) | (thirdLengthOctet << 8) | fourthLengthOctet;              }              else {                  throw new NotSupportedException();              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: var firstByte = (byte) (OldHeaderHighBits | (TagId << 2));
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpOldFormatPacketHeader,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: if(Length < 256) {                  outputStream.WriteByte(firstByte);              }              else if(Length < 65536) {                  outputStream.WriteByte((byte)(firstByte | 1));                  outputStream.WriteByte((byte)(Length >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }              else {                  outputStream.WriteByte((byte)(firstByte | 2));                  outputStream.WriteByte((byte)(Length >> 24));                  outputStream.WriteByte((byte)((Length & 0xFF0000) >> 16));                  outputStream.WriteByte((byte)((Length & 0xFF00) >> 8));                  outputStream.WriteByte((byte)(Length & 0xFF));              }
Magic Number,Moserware.Security.Cryptography,OpenPgpTimeField,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,Read,The following statement contains a magic number: return new OpenPgpTimeField(OpenPgpScalarNumber.Read(inputStream' 4));
Magic Number,Moserware.Security.Cryptography,SymmetricallyEncryptedIntegrityProtectedDataOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,GetDecryptedPackets,The following statement contains a magic number: var mdcStart = decrypted.Length - (1 + 1 + 20);
Magic Number,Moserware.Security.Cryptography,SymmetricallyEncryptedIntegrityProtectedDataOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,GetDecryptedPackets,The following statement contains a magic number: decrypted.SetLength(mdcStart + 2);
Magic Number,Moserware.Security.Cryptography,SymmetricallyEncryptedIntegrityProtectedDataOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,GetDecryptedPackets,The following statement contains a magic number: decrypted.SetLength(decrypted.Length - 2);
Magic Number,Moserware.Security.Cryptography,SymmetricallyEncryptedIntegrityProtectedDataOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,EncryptPackets,The following statement contains a magic number: mdcPacket.Header.Length = hasher.HashSize/8;
Magic Number,Moserware.Security.Cryptography,ModificationDetectionCodeOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ModificationDetectionCodeOpenPgpPacket,The following statement contains a magic number: var sha1Value = new byte[20];
Magic Number,Moserware.Security.Cryptography,ModificationDetectionCodeOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ModificationDetectionCodeOpenPgpPacket,The following statement contains a magic number: if(inputStream.Read(sha1Value' 0' 20) != 20) {                  throw new CryptographicException();              }
Magic Number,Moserware.Security.Cryptography,ModificationDetectionCodeOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ModificationDetectionCodeOpenPgpPacket,The following statement contains a magic number: if(inputStream.Read(sha1Value' 0' 20) != 20) {                  throw new CryptographicException();              }
Magic Number,Moserware.Security.Cryptography,LiteralDataOpenPgpPacket,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,WriteTo,The following statement contains a magic number: Header.Length += 4;
Magic Number,Moserware.Security.Cryptography,StreamExtensions,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,CopySubsetTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Moserware.Security.Cryptography,SimpleOpenPgpStringToKeySpecifier,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,HashToKey,The following statement contains a magic number: return HashAlgorithm.ComputeHash(null' passphrase' cipher.KeySizeInBits / 8);
Magic Number,Moserware.Security.Cryptography,SaltedOpenPgpStringToKeySpecifier,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,HashToKey,The following statement contains a magic number: return HashAlgorithm.ComputeHash(Salt' passphrase' cipher.KeySizeInBits/8);
Magic Number,Moserware.Security.Cryptography,IteratedAndSaltedOpenPgpStringToKeySpecifier,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,HashToKey,The following statement contains a magic number: return HashAlgorithm.ComputeHash(Salt' passphrase' cipher.KeySizeInBits / 8' Count);
Magic Number,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpSymmetricCipher,The following statement contains a magic number: AddCipher(7' "AES128"' 128' () => new RijndaelManaged());
Magic Number,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpSymmetricCipher,The following statement contains a magic number: AddCipher(7' "AES128"' 128' () => new RijndaelManaged());
Magic Number,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpSymmetricCipher,The following statement contains a magic number: AddCipher(8' "AES192"' 192' () => new RijndaelManaged());
Magic Number,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpSymmetricCipher,The following statement contains a magic number: AddCipher(8' "AES192"' 192' () => new RijndaelManaged());
Magic Number,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpSymmetricCipher,The following statement contains a magic number: AddCipher(9' "AES256"' 256' () => new RijndaelManaged());
Magic Number,Moserware.Security.Cryptography,OpenPgpSymmetricCipher,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpSymmetricCipher,The following statement contains a magic number: AddCipher(9' "AES256"' 256' () => new RijndaelManaged());
Magic Number,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpHashAlgorithm,The following statement contains a magic number: add(2' () => new SHA1CryptoServiceProvider());
Magic Number,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpHashAlgorithm,The following statement contains a magic number: add(8' () => new SHA256CryptoServiceProvider());
Magic Number,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpHashAlgorithm,The following statement contains a magic number: add(9' () => new SHA384CryptoServiceProvider());
Magic Number,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpHashAlgorithm,The following statement contains a magic number: add(10' () => new SHA512CryptoServiceProvider());
Magic Number,Moserware.Security.Cryptography,OpenPgpHashAlgorithm,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,ComputeHash,The following statement contains a magic number: var hashSizeInOctets = firstHashContext.HashSize/8;
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpCfbTransform,The following statement contains a magic number: int feedbackSizeInBytes = algorithm.BlockSize / 8;
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpCfbTransform,The following statement contains a magic number: _PrefixBytes = new byte[feedbackSizeInBytes + 2];
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpCfbTransform,The following statement contains a magic number: if(encrypt) {                  var rand = RandomNumberGenerator.Create();                  rand.GetBytes(_PrefixBytes);                  // Repeat the bytes                  _PrefixBytes[_PrefixBytes.Length - 2] = _PrefixBytes[_PrefixBytes.Length - 4];                  _PrefixBytes[_PrefixBytes.Length - 1] = _PrefixBytes[_PrefixBytes.Length - 3];              }
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpCfbTransform,The following statement contains a magic number: if(encrypt) {                  var rand = RandomNumberGenerator.Create();                  rand.GetBytes(_PrefixBytes);                  // Repeat the bytes                  _PrefixBytes[_PrefixBytes.Length - 2] = _PrefixBytes[_PrefixBytes.Length - 4];                  _PrefixBytes[_PrefixBytes.Length - 1] = _PrefixBytes[_PrefixBytes.Length - 3];              }
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,OpenPgpCfbTransform,The following statement contains a magic number: if(encrypt) {                  var rand = RandomNumberGenerator.Create();                  rand.GetBytes(_PrefixBytes);                  // Repeat the bytes                  _PrefixBytes[_PrefixBytes.Length - 2] = _PrefixBytes[_PrefixBytes.Length - 4];                  _PrefixBytes[_PrefixBytes.Length - 1] = _PrefixBytes[_PrefixBytes.Length - 3];              }
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,TransformBlock,The following statement contains a magic number: if(_IsEncrypt) {                  for (int ixEncryptedByte = 0; ixEncryptedByte < inputCount; ixEncryptedByte++) {                      var nextCiphertextByte = (byte)(GetNextEncryptedFeedbackByte() ^ inputBuffer[inputOffset + ixEncryptedByte]);                      outputBuffer[outputOffset + ixEncryptedByte] = nextCiphertextByte;                      _FeedbackRegister[_CurrentEncryptedFeedbackRegisterPosition - 1] = nextCiphertextByte;                  }              }              else {                  for (int ixDecryptedByte = 0; ixDecryptedByte < inputCount; ixDecryptedByte++) {                      var ciphertextByte = inputBuffer[inputOffset + ixDecryptedByte];                      var encryptedByte = GetNextEncryptedFeedbackByte();                      outputBuffer[outputOffset + ixDecryptedByte] = (byte)(encryptedByte ^ ciphertextByte);                      _FeedbackRegister[_CurrentEncryptedFeedbackRegisterPosition - 1] = ciphertextByte;                  }                    if (_PrefixBytesUsed < _PrefixBytes.Length) {                      int headerBytesRemaining = _PrefixBytes.Length - _PrefixBytesUsed;                      int headerBytesAvailable = Math.Min(headerBytesRemaining' inputCount);                      for (int ixHeaderByte = 0; ixHeaderByte < headerBytesAvailable; ixHeaderByte++) {                          _PrefixBytes[_PrefixBytesUsed++] = outputBuffer[outputOffset + ixHeaderByte];                      }                        if (_PrefixBytesUsed == _PrefixBytes.Length) {                          // do simple check                          if ((_PrefixBytes[_PrefixBytes.Length - 2] != _PrefixBytes[_PrefixBytes.Length - 4])                             ||                             (_PrefixBytes[_PrefixBytes.Length - 1] != _PrefixBytes[_PrefixBytes.Length - 3])) {                              throw new CryptographicException("Simple check failed");                          }                      }                        int remainingBytesTransformed = inputCount - headerBytesAvailable;                        int ixOutputEnd = (outputOffset + inputCount) - headerBytesAvailable;                      for (int ixOutputByte = outputOffset; ixOutputByte < ixOutputEnd; ixOutputByte++) {                          outputBuffer[ixOutputByte] = outputBuffer[ixOutputByte + headerBytesAvailable];                      }                        return remainingBytesTransformed;                  }              }
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,TransformBlock,The following statement contains a magic number: if(_IsEncrypt) {                  for (int ixEncryptedByte = 0; ixEncryptedByte < inputCount; ixEncryptedByte++) {                      var nextCiphertextByte = (byte)(GetNextEncryptedFeedbackByte() ^ inputBuffer[inputOffset + ixEncryptedByte]);                      outputBuffer[outputOffset + ixEncryptedByte] = nextCiphertextByte;                      _FeedbackRegister[_CurrentEncryptedFeedbackRegisterPosition - 1] = nextCiphertextByte;                  }              }              else {                  for (int ixDecryptedByte = 0; ixDecryptedByte < inputCount; ixDecryptedByte++) {                      var ciphertextByte = inputBuffer[inputOffset + ixDecryptedByte];                      var encryptedByte = GetNextEncryptedFeedbackByte();                      outputBuffer[outputOffset + ixDecryptedByte] = (byte)(encryptedByte ^ ciphertextByte);                      _FeedbackRegister[_CurrentEncryptedFeedbackRegisterPosition - 1] = ciphertextByte;                  }                    if (_PrefixBytesUsed < _PrefixBytes.Length) {                      int headerBytesRemaining = _PrefixBytes.Length - _PrefixBytesUsed;                      int headerBytesAvailable = Math.Min(headerBytesRemaining' inputCount);                      for (int ixHeaderByte = 0; ixHeaderByte < headerBytesAvailable; ixHeaderByte++) {                          _PrefixBytes[_PrefixBytesUsed++] = outputBuffer[outputOffset + ixHeaderByte];                      }                        if (_PrefixBytesUsed == _PrefixBytes.Length) {                          // do simple check                          if ((_PrefixBytes[_PrefixBytes.Length - 2] != _PrefixBytes[_PrefixBytes.Length - 4])                             ||                             (_PrefixBytes[_PrefixBytes.Length - 1] != _PrefixBytes[_PrefixBytes.Length - 3])) {                              throw new CryptographicException("Simple check failed");                          }                      }                        int remainingBytesTransformed = inputCount - headerBytesAvailable;                        int ixOutputEnd = (outputOffset + inputCount) - headerBytesAvailable;                      for (int ixOutputByte = outputOffset; ixOutputByte < ixOutputEnd; ixOutputByte++) {                          outputBuffer[ixOutputByte] = outputBuffer[ixOutputByte + headerBytesAvailable];                      }                        return remainingBytesTransformed;                  }              }
Magic Number,Moserware.Security.Cryptography,OpenPgpCfbTransform,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\OpenPgp.cs,TransformBlock,The following statement contains a magic number: if(_IsEncrypt) {                  for (int ixEncryptedByte = 0; ixEncryptedByte < inputCount; ixEncryptedByte++) {                      var nextCiphertextByte = (byte)(GetNextEncryptedFeedbackByte() ^ inputBuffer[inputOffset + ixEncryptedByte]);                      outputBuffer[outputOffset + ixEncryptedByte] = nextCiphertextByte;                      _FeedbackRegister[_CurrentEncryptedFeedbackRegisterPosition - 1] = nextCiphertextByte;                  }              }              else {                  for (int ixDecryptedByte = 0; ixDecryptedByte < inputCount; ixDecryptedByte++) {                      var ciphertextByte = inputBuffer[inputOffset + ixDecryptedByte];                      var encryptedByte = GetNextEncryptedFeedbackByte();                      outputBuffer[outputOffset + ixDecryptedByte] = (byte)(encryptedByte ^ ciphertextByte);                      _FeedbackRegister[_CurrentEncryptedFeedbackRegisterPosition - 1] = ciphertextByte;                  }                    if (_PrefixBytesUsed < _PrefixBytes.Length) {                      int headerBytesRemaining = _PrefixBytes.Length - _PrefixBytesUsed;                      int headerBytesAvailable = Math.Min(headerBytesRemaining' inputCount);                      for (int ixHeaderByte = 0; ixHeaderByte < headerBytesAvailable; ixHeaderByte++) {                          _PrefixBytes[_PrefixBytesUsed++] = outputBuffer[outputOffset + ixHeaderByte];                      }                        if (_PrefixBytesUsed == _PrefixBytes.Length) {                          // do simple check                          if ((_PrefixBytes[_PrefixBytes.Length - 2] != _PrefixBytes[_PrefixBytes.Length - 4])                             ||                             (_PrefixBytes[_PrefixBytes.Length - 1] != _PrefixBytes[_PrefixBytes.Length - 3])) {                              throw new CryptographicException("Simple check failed");                          }                      }                        int remainingBytesTransformed = inputCount - headerBytesAvailable;                        int ixOutputEnd = (outputOffset + inputCount) - headerBytesAvailable;                      for (int ixOutputByte = outputOffset; ixOutputByte < ixOutputEnd; ixOutputByte++) {                          outputBuffer[ixOutputByte] = outputBuffer[ixOutputByte + headerBytesAvailable];                      }                        return remainingBytesTransformed;                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,Scramble,The following statement contains a magic number: for (int i = 0; i < (OuterRounds * actualByteSize); i += 2) {                  EncodeSlice(integerBytes' i' actualByteSize' EncipherBlock);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,Unscramble,The following statement contains a magic number: for (int i = (OuterRounds * actualByteSize) - 2; i >= 0; i -= 2) {                  EncodeSlice(integerBytes' i' actualByteSize' DecipherBlock);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,Unscramble,The following statement contains a magic number: for (int i = (OuterRounds * actualByteSize) - 2; i >= 0; i -= 2) {                  EncodeSlice(integerBytes' i' actualByteSize' DecipherBlock);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerBytesWithLeastSignificantWordFirstUsing16BitMsbFirstWords,The following statement contains a magic number: bool isOddNumberOfBytes = bigEndianBytes.Length % 2 != 0;
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerBytesWithLeastSignificantWordFirstUsing16BitMsbFirstWords,The following statement contains a magic number: for (int ixWord = bigEndianBytes.Length - 2; ixWord >= 0; ixWord -= 2) {                  for (int wordByteOffset = 0; wordByteOffset < 2; wordByteOffset++) {                      // need to flip individual bytes                      result[ixResultByte++] = bigEndianBytes[ixWord + wordByteOffset];                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerBytesWithLeastSignificantWordFirstUsing16BitMsbFirstWords,The following statement contains a magic number: for (int ixWord = bigEndianBytes.Length - 2; ixWord >= 0; ixWord -= 2) {                  for (int wordByteOffset = 0; wordByteOffset < 2; wordByteOffset++) {                      // need to flip individual bytes                      result[ixResultByte++] = bigEndianBytes[ixWord + wordByteOffset];                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerBytesWithLeastSignificantWordFirstUsing16BitMsbFirstWords,The following statement contains a magic number: for (int ixWord = bigEndianBytes.Length - 2; ixWord >= 0; ixWord -= 2) {                  for (int wordByteOffset = 0; wordByteOffset < 2; wordByteOffset++) {                      // need to flip individual bytes                      result[ixResultByte++] = bigEndianBytes[ixWord + wordByteOffset];                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerBytesWithLeastSignificantWordFirstUsing16BitMsbFirstWords,The following statement contains a magic number: if (hasExtraPaddingByte) {                  result[bigEndianBytes.Length - 2] = result[bigEndianBytes.Length - 1];              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerFromLeastSignificantWordsFirstWith16BitMsbFirstWords,The following statement contains a magic number: bool hasBytePadding = actualBytes % 2 == 1;
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerFromLeastSignificantWordsFirstWith16BitMsbFirstWords,The following statement contains a magic number: if (hasBytePadding) {                  wordBytes[wordBytes.Length - 1] = wordBytes[wordBytes.Length - 2];                  wordBytes[wordBytes.Length - 2] = 0;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerFromLeastSignificantWordsFirstWith16BitMsbFirstWords,The following statement contains a magic number: if (hasBytePadding) {                  wordBytes[wordBytes.Length - 1] = wordBytes[wordBytes.Length - 2];                  wordBytes[wordBytes.Length - 2] = 0;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerFromLeastSignificantWordsFirstWith16BitMsbFirstWords,The following statement contains a magic number: for (int ixWord = wordBytes.Length - 2; ixWord >= 0; ixWord -= 2) {                  for (int ixByteInWord = 0; ixByteInWord < 2; ixByteInWord++) {                      bigEndianBytes[ixResult++] = wordBytes[ixWord + ixByteInWord];                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerFromLeastSignificantWordsFirstWith16BitMsbFirstWords,The following statement contains a magic number: for (int ixWord = wordBytes.Length - 2; ixWord >= 0; ixWord -= 2) {                  for (int ixByteInWord = 0; ixByteInWord < 2; ixByteInWord++) {                      bigEndianBytes[ixResult++] = wordBytes[ixWord + ixByteInWord];                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,GetBigIntegerFromLeastSignificantWordsFirstWith16BitMsbFirstWords,The following statement contains a magic number: for (int ixWord = wordBytes.Length - 2; ixWord >= 0; ixWord -= 2) {                  for (int ixByteInWord = 0; ixByteInWord < 2; ixByteInWord++) {                      bigEndianBytes[ixResult++] = wordBytes[ixWord + ixByteInWord];                  }              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[0] += (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;                  sum += Delta;                  v[1] += (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[0] += (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;                  sum += Delta;                  v[1] += (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[0] += (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;                  sum += Delta;                  v[1] += (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[0] += (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;                  sum += Delta;                  v[1] += (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,DecipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[1] -= (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;                  sum -= Delta;                  v[0] -= (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,DecipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[1] -= (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;                  sum -= Delta;                  v[0] -= (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,DecipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[1] -= (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;                  sum -= Delta;                  v[0] -= (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,DecipherBlock,The following statement contains a magic number: for (int i = 0; i < InnerRounds; i++) {                  v[1] -= (((v[0] << 4) ^ (v[0] >> 5)) + v[0]) ^ sum;                  sum -= Delta;                  v[0] -= (((v[1] << 4) ^ (v[1] >> 5)) + v[1]) ^ sum;              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: UInt32[] v = new UInt32[2];
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: const int wordsPerBlock = 2;
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  v[i] = ((UInt32)data[(idx + (4 * i)) % len]) << 24 |                         ((UInt32)data[(idx + (4 * i) + 1) % len]) << 16 |                         ((UInt32)data[(idx + (4 * i) + 2) % len]) << 8 |                         ((UInt32)data[(idx + (4 * i) + 3) % len]);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
Magic Number,Moserware.Security.Cryptography,XteaDiffuser,C:\repos\moserware_SecretSplitter\SecretSplitter\Security\Cryptography\Diffuser.cs,EncodeSlice,The following statement contains a magic number: for (int i = 0; i < wordsPerBlock; i++) {                  data[(idx + (4 * i) + 0) % len] = (byte)(v[i] >> 24);                  data[(idx + (4 * i) + 1) % len] = (byte)((v[i] >> 16) & 0xff);                  data[(idx + (4 * i) + 2) % len] = (byte)((v[i] >> 8) & 0xff);                  data[(idx + (4 * i) + 3) % len] = (byte)(v[i] & 0xff);              }
