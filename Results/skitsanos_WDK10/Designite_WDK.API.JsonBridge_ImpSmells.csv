Implementation smell,Namespace,Class,File,Method,Description
Long Method,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The method has 271 lines of code.
Complex Method,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,Cyclomatic complexity of the method is 54
Complex Method,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,invokeAssemblyMethod,Cyclomatic complexity of the method is 26
Complex Method,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignatureBase,Cyclomatic complexity of the method is 8
Complex Method,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignature,Cyclomatic complexity of the method is 9
Long Parameter List,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignatureBase,The method has 10 parameters.
Long Parameter List,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignature,The method has 10 parameters.
Long Parameter List,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignature,The method has 11 parameters.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The length of the statement  "	if (bool.Parse (getWebConfigValue ("jsonbridge.AuthEnabled").ToString ()) && String.IsNullOrEmpty (Request.Headers ["Authorization"])) { " is 136.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The length of the statement  "	if (bool.Parse (getWebConfigValue ("jsonbridge.AuthEnabled").ToString ()) && !String.IsNullOrEmpty (Request.Headers ["Authorization"])) { " is 137.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The length of the statement  "		var validateResult = (bool)type.InvokeMember ("validate"' BindingFlags.Default | BindingFlags.InvokeMethod' null' obj' new object[] { " is 133.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The length of the statement  "										//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload " is 121.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The length of the statement  "											else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) { " is 211.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,invokeAssemblyMethod,The length of the statement  "							if (paramType.ParameterType.Namespace == "System.Collections.Generic" && paramType.ParameterType.FullName.Contains ("System.Collections.Generic.List")) { " is 153.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,DynamicCast,The length of the statement  "	var castMethod = targetType.GetMethods (pubStatBinding).Union (originType.GetMethods (pubStatBinding)).FirstOrDefault (itm => itm.ReturnType.Equals (targetType) && itm.GetParameters ().Length == 1 && itm.GetParameters () [0].ParameterType.IsAssignableFrom (originType) && names.Contains (itm.Name)); " is 299.
Long Statement,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,DynamicCast,The length of the statement  "		throw new InvalidOperationException (String.Format ("No matching cast operator found from {0} to {1}."' originType.Name' targetType.Name)); " is 139.
Long Statement,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignature,The length of the statement  "	return GenerateSignature (url' consumerKey' consumerSecret' token' tokenSecret' httpMethod' timeStamp' nonce' SignatureTypes.HMACSHA1' out normalizedUrl' out normalizedRequestParameters); " is 187.
Long Statement,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignature,The length of the statement  "		string signatureBase = GenerateSignatureBase (url' consumerKey' token' tokenSecret' httpMethod' timeStamp' nonce' HMACSHA1SignatureType' out normalizedUrl' out normalizedRequestParameters); " is 189.
Long Statement,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignature,The length of the statement  "		hmacsha1.Key = Encoding.ASCII.GetBytes (string.Format ("{0}&{1}"' UrlEncode (consumerSecret)' string.IsNullOrEmpty (tokenSecret) ? "" : UrlEncode (tokenSecret))); " is 162.
Complex Conditional,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignatureBase,The conditional expression  "!((url.Scheme == "http" && url.Port == 80) || (url.Scheme == "https" && url.Port == 443))"  is complex.
Empty Catch Block,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The method has an empty catch block.
Empty Catch Block,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,isValidClass,The method has an empty catch block.
Empty Catch Block,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,browseClassMethods,The method has an empty catch block.
Empty Catch Block,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,assemblyContainsMethod,The method has an empty catch block.
Empty Catch Block,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,getMethodInfo,The method has an empty catch block.
Empty Catch Block,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,getClassAssemblyQualifiedName,The method has an empty catch block.
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: switch (classpath.ToLower ()) {  case "jquery.jsonbridge.js":  	Response.ContentType = ContentTypes.JAVASCRIPT;  	Response.Write (getEmbeddedContent ("jquery.jsonbridge.js"));  	break;  case "_browse":  	var listOfAssemblies = loaddedAssemblies.Select (assembly => assembly.Value.FullName.Split (''') [0]).ToList ();  	Response.ContentType = ContentTypes.JSON;  	Response.Write (JsonConvert.SerializeObject (new InvokationResultType () {  		result = listOfAssemblies'  		execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)  	}));  	break;  case "_browseclasses":  	var listOfClasses = new List<string> ();  	try {  		foreach (var assembly in loaddedAssemblies) {  			foreach (var type in assembly.Value.GetTypes ()) {  				listOfClasses.Add (type.FullName);  			}  		}  	}  	catch (Exception) {  		//Response.Write(ex.ToString() + "<hr/>");  	}  	Response.ContentType = ContentTypes.JSON;  	Response.Write (JsonConvert.SerializeObject (new InvokationResultType {  		result = listOfClasses'  		execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)  	}));  	break;  default:  	if (!String.IsNullOrEmpty (method)) {  		if (isValidClass (classpath)) {  			if (method.ToLower () == "_methods") {  				// Browse for all methods within a class  				Response.Write (JsonConvert.SerializeObject (browseClassMethods (classpath)));  			}  			else {  				// Class path is valid' check if method is valid  				var possibleMethods = new List<MethodInfo> ();  				possibleMethods = getOverloadsByName (getClassAssemblyQualifiedName (classpath)' method);  				if (possibleMethods.Count == 0) {  					Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  						execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  						message = classpath + " does not contain any method " + method  					}));  					return;  				}  				if (Request.RequestType == "POST") {  					// Check if user actually sent any params by analizyng inout stream  					if (Request.InputStream.Length == 0) {  						Response.Write ("Request body missing");  					}  					else {  						var stream = new StreamReader (Request.InputStream);  						var requestBody = stream.ReadToEnd ();  						var jsonSettings = new JsonSerializerSettings {  							DateTimeZoneHandling = DateTimeZoneHandling.Utc'  							DateFormatHandling = DateFormatHandling.IsoDateFormat'  							DateFormatString = "{0:s}"'  							DateParseHandling = DateParseHandling.DateTime  						};  						var invokeParams = JsonConvert.DeserializeObject<object[]> (requestBody' jsonSettings);  						for (var index = possibleMethods.Count - 1; index >= 0; index--) {  							if (possibleMethods [index].GetParameters ().Length != invokeParams.Length) {  								possibleMethods.RemoveAt (index);  							}  						}  						switch (possibleMethods.Count) {  						case 0:  							Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  								execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  								message = "There is no overload of the method with the specified number of params"  							}));  							return;  						case 1:  							{  								var methodInfo = possibleMethods [0];  								var correctParams = new List<object> ();  								for (var index = 0; index < invokeParams.Length; index++) {  									if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  										correctParams.Add (invokeParams [index]);  									}  									else {  										var paramType = methodInfo.GetParameters () [index].ParameterType;  										var serializer = new JsonSerializer ();  										var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  										correctParams.Add (o);  									}  								}  								var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  								Response.ContentType = ContentTypes.JSON;  								//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  								var converters = new JsonConverterCollection {  									new StringEnumConverter ()'  									new IsoDateTimeConverter ()  								};  								Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  							}  							break;  						default:  							{  								//Response.Write("Before anything else");  								//return;  								//trying to build the possibly correct argument list for each overload  								var correctFinalParams = new List<object> ();  								var debug = "";  								for (var index = possibleMethods.Count - 1; index >= 0; index--) {  									var correctParams = new List<object> ();  									var validParams = true;  									//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  									//Response.Write("Before the loop");  									//return;  									for (var index2 = 0; index2 < invokeParams.Length; index2++) {  										debug += "Front of the loop; ";  										//return;  										if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  											correctParams.Add (invokeParams [index2]);  											debug += "Added normal type to param arr; ";  										}  										else {  											var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  											debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  											var serializer = new JsonSerializer ();  											// Response.Write(debug);  											// return;  											var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  											debug += "Done serializing; ";  											if (o == null) {  												//couldn't deserialize to this type' so it's not the good overload  												validParams = false;  												debug += "Failed serializing; ";  												break;  											}  											correctParams.Add (o);  										}  										debug += "End of the loop; ";  									}  									//Response.Write(debug);  									//return;  									if (!validParams) {  										possibleMethods.RemoveAt (index);  										debug += "Not a valid overload; ";  										continue;  									}  									var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  									var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  									//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  									for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  										debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  										if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  											debug += "equal; ";  										}  										else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  											debug += "Could cast from Int64 to Int32;";  										}  										else {  											debug += "different; ";  											validParams = false;  											break;  										}  									}  									if (!validParams) {  										possibleMethods.RemoveAt (index);  										debug += "Not a valid overload; ";  										continue;  									}  									correctFinalParams = correctParams;  								}  								//Response.Write(debug);  								//return;  								if (possibleMethods.Count == 0) {  									Response.Write ("No valid overload afterall.");  								}  								else if (possibleMethods.Count >= 2) {  									Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  										execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  										message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  									}));  								}  								else {  									var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  									Response.ContentType = ContentTypes.JSON;  									var converters = new JsonConverterCollection {  										new StringEnumConverter ()'  										new IsoDateTimeConverter ()  									};  									Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  								}  							}  							break;  						}  					}  				}  				else {  					var methodInfo = possibleMethods [0];  					if (methodInfo.GetParameters ().Length > 0) {  						Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  							execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  							message = "This method requires " + methodInfo.GetParameters ().Length + " parameter(s)"  						}));  					}  					else {  						var invokeResult = invokeAssemblyMethod (classpath' methodInfo' null);  						var converters = new JsonConverterCollection {  							new StringEnumConverter ()'  							new JavaScriptDateTimeConverter ()  						};  						Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  					}  				}  			}  		}  		else {  			// User specified wrong class path' should be valid type name  			Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  				execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  				message = "Invalid class path: " + classpath  			}));  		}  	}  	else {  		// Class specified but method is missing  		//Response.Write("--not implemented' " + classpath);  		Response.Write (JsonConvert.SerializeObject (browseClassMethods (classpath)));  	}  	break;  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (!String.IsNullOrEmpty (method)) {  	if (isValidClass (classpath)) {  		if (method.ToLower () == "_methods") {  			// Browse for all methods within a class  			Response.Write (JsonConvert.SerializeObject (browseClassMethods (classpath)));  		}  		else {  			// Class path is valid' check if method is valid  			var possibleMethods = new List<MethodInfo> ();  			possibleMethods = getOverloadsByName (getClassAssemblyQualifiedName (classpath)' method);  			if (possibleMethods.Count == 0) {  				Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  					execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  					message = classpath + " does not contain any method " + method  				}));  				return;  			}  			if (Request.RequestType == "POST") {  				// Check if user actually sent any params by analizyng inout stream  				if (Request.InputStream.Length == 0) {  					Response.Write ("Request body missing");  				}  				else {  					var stream = new StreamReader (Request.InputStream);  					var requestBody = stream.ReadToEnd ();  					var jsonSettings = new JsonSerializerSettings {  						DateTimeZoneHandling = DateTimeZoneHandling.Utc'  						DateFormatHandling = DateFormatHandling.IsoDateFormat'  						DateFormatString = "{0:s}"'  						DateParseHandling = DateParseHandling.DateTime  					};  					var invokeParams = JsonConvert.DeserializeObject<object[]> (requestBody' jsonSettings);  					for (var index = possibleMethods.Count - 1; index >= 0; index--) {  						if (possibleMethods [index].GetParameters ().Length != invokeParams.Length) {  							possibleMethods.RemoveAt (index);  						}  					}  					switch (possibleMethods.Count) {  					case 0:  						Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  							execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  							message = "There is no overload of the method with the specified number of params"  						}));  						return;  					case 1:  						{  							var methodInfo = possibleMethods [0];  							var correctParams = new List<object> ();  							for (var index = 0; index < invokeParams.Length; index++) {  								if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  									correctParams.Add (invokeParams [index]);  								}  								else {  									var paramType = methodInfo.GetParameters () [index].ParameterType;  									var serializer = new JsonSerializer ();  									var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  									correctParams.Add (o);  								}  							}  							var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  							Response.ContentType = ContentTypes.JSON;  							//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  							var converters = new JsonConverterCollection {  								new StringEnumConverter ()'  								new IsoDateTimeConverter ()  							};  							Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  						}  						break;  					default:  						{  							//Response.Write("Before anything else");  							//return;  							//trying to build the possibly correct argument list for each overload  							var correctFinalParams = new List<object> ();  							var debug = "";  							for (var index = possibleMethods.Count - 1; index >= 0; index--) {  								var correctParams = new List<object> ();  								var validParams = true;  								//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  								//Response.Write("Before the loop");  								//return;  								for (var index2 = 0; index2 < invokeParams.Length; index2++) {  									debug += "Front of the loop; ";  									//return;  									if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  										correctParams.Add (invokeParams [index2]);  										debug += "Added normal type to param arr; ";  									}  									else {  										var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  										debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  										var serializer = new JsonSerializer ();  										// Response.Write(debug);  										// return;  										var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  										debug += "Done serializing; ";  										if (o == null) {  											//couldn't deserialize to this type' so it's not the good overload  											validParams = false;  											debug += "Failed serializing; ";  											break;  										}  										correctParams.Add (o);  									}  									debug += "End of the loop; ";  								}  								//Response.Write(debug);  								//return;  								if (!validParams) {  									possibleMethods.RemoveAt (index);  									debug += "Not a valid overload; ";  									continue;  								}  								var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  								var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  								//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  								for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  									debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  									if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  										debug += "equal; ";  									}  									else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  										debug += "Could cast from Int64 to Int32;";  									}  									else {  										debug += "different; ";  										validParams = false;  										break;  									}  								}  								if (!validParams) {  									possibleMethods.RemoveAt (index);  									debug += "Not a valid overload; ";  									continue;  								}  								correctFinalParams = correctParams;  							}  							//Response.Write(debug);  							//return;  							if (possibleMethods.Count == 0) {  								Response.Write ("No valid overload afterall.");  							}  							else if (possibleMethods.Count >= 2) {  								Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  									execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  									message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  								}));  							}  							else {  								var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  								Response.ContentType = ContentTypes.JSON;  								var converters = new JsonConverterCollection {  									new StringEnumConverter ()'  									new IsoDateTimeConverter ()  								};  								Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  							}  						}  						break;  					}  				}  			}  			else {  				var methodInfo = possibleMethods [0];  				if (methodInfo.GetParameters ().Length > 0) {  					Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  						execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  						message = "This method requires " + methodInfo.GetParameters ().Length + " parameter(s)"  					}));  				}  				else {  					var invokeResult = invokeAssemblyMethod (classpath' methodInfo' null);  					var converters = new JsonConverterCollection {  						new StringEnumConverter ()'  						new JavaScriptDateTimeConverter ()  					};  					Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  				}  			}  		}  	}  	else {  		// User specified wrong class path' should be valid type name  		Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  			execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  			message = "Invalid class path: " + classpath  		}));  	}  }  else {  	// Class specified but method is missing  	//Response.Write("--not implemented' " + classpath);  	Response.Write (JsonConvert.SerializeObject (browseClassMethods (classpath)));  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (isValidClass (classpath)) {  	if (method.ToLower () == "_methods") {  		// Browse for all methods within a class  		Response.Write (JsonConvert.SerializeObject (browseClassMethods (classpath)));  	}  	else {  		// Class path is valid' check if method is valid  		var possibleMethods = new List<MethodInfo> ();  		possibleMethods = getOverloadsByName (getClassAssemblyQualifiedName (classpath)' method);  		if (possibleMethods.Count == 0) {  			Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  				execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  				message = classpath + " does not contain any method " + method  			}));  			return;  		}  		if (Request.RequestType == "POST") {  			// Check if user actually sent any params by analizyng inout stream  			if (Request.InputStream.Length == 0) {  				Response.Write ("Request body missing");  			}  			else {  				var stream = new StreamReader (Request.InputStream);  				var requestBody = stream.ReadToEnd ();  				var jsonSettings = new JsonSerializerSettings {  					DateTimeZoneHandling = DateTimeZoneHandling.Utc'  					DateFormatHandling = DateFormatHandling.IsoDateFormat'  					DateFormatString = "{0:s}"'  					DateParseHandling = DateParseHandling.DateTime  				};  				var invokeParams = JsonConvert.DeserializeObject<object[]> (requestBody' jsonSettings);  				for (var index = possibleMethods.Count - 1; index >= 0; index--) {  					if (possibleMethods [index].GetParameters ().Length != invokeParams.Length) {  						possibleMethods.RemoveAt (index);  					}  				}  				switch (possibleMethods.Count) {  				case 0:  					Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  						execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  						message = "There is no overload of the method with the specified number of params"  					}));  					return;  				case 1:  					{  						var methodInfo = possibleMethods [0];  						var correctParams = new List<object> ();  						for (var index = 0; index < invokeParams.Length; index++) {  							if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  								correctParams.Add (invokeParams [index]);  							}  							else {  								var paramType = methodInfo.GetParameters () [index].ParameterType;  								var serializer = new JsonSerializer ();  								var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  								correctParams.Add (o);  							}  						}  						var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  						Response.ContentType = ContentTypes.JSON;  						//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  						var converters = new JsonConverterCollection {  							new StringEnumConverter ()'  							new IsoDateTimeConverter ()  						};  						Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  					}  					break;  				default:  					{  						//Response.Write("Before anything else");  						//return;  						//trying to build the possibly correct argument list for each overload  						var correctFinalParams = new List<object> ();  						var debug = "";  						for (var index = possibleMethods.Count - 1; index >= 0; index--) {  							var correctParams = new List<object> ();  							var validParams = true;  							//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  							//Response.Write("Before the loop");  							//return;  							for (var index2 = 0; index2 < invokeParams.Length; index2++) {  								debug += "Front of the loop; ";  								//return;  								if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  									correctParams.Add (invokeParams [index2]);  									debug += "Added normal type to param arr; ";  								}  								else {  									var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  									debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  									var serializer = new JsonSerializer ();  									// Response.Write(debug);  									// return;  									var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  									debug += "Done serializing; ";  									if (o == null) {  										//couldn't deserialize to this type' so it's not the good overload  										validParams = false;  										debug += "Failed serializing; ";  										break;  									}  									correctParams.Add (o);  								}  								debug += "End of the loop; ";  							}  							//Response.Write(debug);  							//return;  							if (!validParams) {  								possibleMethods.RemoveAt (index);  								debug += "Not a valid overload; ";  								continue;  							}  							var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  							var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  							//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  							for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  								debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  								if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  									debug += "equal; ";  								}  								else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  									debug += "Could cast from Int64 to Int32;";  								}  								else {  									debug += "different; ";  									validParams = false;  									break;  								}  							}  							if (!validParams) {  								possibleMethods.RemoveAt (index);  								debug += "Not a valid overload; ";  								continue;  							}  							correctFinalParams = correctParams;  						}  						//Response.Write(debug);  						//return;  						if (possibleMethods.Count == 0) {  							Response.Write ("No valid overload afterall.");  						}  						else if (possibleMethods.Count >= 2) {  							Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  								execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  								message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  							}));  						}  						else {  							var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  							Response.ContentType = ContentTypes.JSON;  							var converters = new JsonConverterCollection {  								new StringEnumConverter ()'  								new IsoDateTimeConverter ()  							};  							Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  						}  					}  					break;  				}  			}  		}  		else {  			var methodInfo = possibleMethods [0];  			if (methodInfo.GetParameters ().Length > 0) {  				Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  					execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  					message = "This method requires " + methodInfo.GetParameters ().Length + " parameter(s)"  				}));  			}  			else {  				var invokeResult = invokeAssemblyMethod (classpath' methodInfo' null);  				var converters = new JsonConverterCollection {  					new StringEnumConverter ()'  					new JavaScriptDateTimeConverter ()  				};  				Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  			}  		}  	}  }  else {  	// User specified wrong class path' should be valid type name  	Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  		execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  		message = "Invalid class path: " + classpath  	}));  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (method.ToLower () == "_methods") {  	// Browse for all methods within a class  	Response.Write (JsonConvert.SerializeObject (browseClassMethods (classpath)));  }  else {  	// Class path is valid' check if method is valid  	var possibleMethods = new List<MethodInfo> ();  	possibleMethods = getOverloadsByName (getClassAssemblyQualifiedName (classpath)' method);  	if (possibleMethods.Count == 0) {  		Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  			execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  			message = classpath + " does not contain any method " + method  		}));  		return;  	}  	if (Request.RequestType == "POST") {  		// Check if user actually sent any params by analizyng inout stream  		if (Request.InputStream.Length == 0) {  			Response.Write ("Request body missing");  		}  		else {  			var stream = new StreamReader (Request.InputStream);  			var requestBody = stream.ReadToEnd ();  			var jsonSettings = new JsonSerializerSettings {  				DateTimeZoneHandling = DateTimeZoneHandling.Utc'  				DateFormatHandling = DateFormatHandling.IsoDateFormat'  				DateFormatString = "{0:s}"'  				DateParseHandling = DateParseHandling.DateTime  			};  			var invokeParams = JsonConvert.DeserializeObject<object[]> (requestBody' jsonSettings);  			for (var index = possibleMethods.Count - 1; index >= 0; index--) {  				if (possibleMethods [index].GetParameters ().Length != invokeParams.Length) {  					possibleMethods.RemoveAt (index);  				}  			}  			switch (possibleMethods.Count) {  			case 0:  				Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  					execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  					message = "There is no overload of the method with the specified number of params"  				}));  				return;  			case 1:  				{  					var methodInfo = possibleMethods [0];  					var correctParams = new List<object> ();  					for (var index = 0; index < invokeParams.Length; index++) {  						if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  							correctParams.Add (invokeParams [index]);  						}  						else {  							var paramType = methodInfo.GetParameters () [index].ParameterType;  							var serializer = new JsonSerializer ();  							var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  							correctParams.Add (o);  						}  					}  					var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  					Response.ContentType = ContentTypes.JSON;  					//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  					var converters = new JsonConverterCollection {  						new StringEnumConverter ()'  						new IsoDateTimeConverter ()  					};  					Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  				}  				break;  			default:  				{  					//Response.Write("Before anything else");  					//return;  					//trying to build the possibly correct argument list for each overload  					var correctFinalParams = new List<object> ();  					var debug = "";  					for (var index = possibleMethods.Count - 1; index >= 0; index--) {  						var correctParams = new List<object> ();  						var validParams = true;  						//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  						//Response.Write("Before the loop");  						//return;  						for (var index2 = 0; index2 < invokeParams.Length; index2++) {  							debug += "Front of the loop; ";  							//return;  							if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  								correctParams.Add (invokeParams [index2]);  								debug += "Added normal type to param arr; ";  							}  							else {  								var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  								debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  								var serializer = new JsonSerializer ();  								// Response.Write(debug);  								// return;  								var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  								debug += "Done serializing; ";  								if (o == null) {  									//couldn't deserialize to this type' so it's not the good overload  									validParams = false;  									debug += "Failed serializing; ";  									break;  								}  								correctParams.Add (o);  							}  							debug += "End of the loop; ";  						}  						//Response.Write(debug);  						//return;  						if (!validParams) {  							possibleMethods.RemoveAt (index);  							debug += "Not a valid overload; ";  							continue;  						}  						var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  						var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  						//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  						for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  							debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  							if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  								debug += "equal; ";  							}  							else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  								debug += "Could cast from Int64 to Int32;";  							}  							else {  								debug += "different; ";  								validParams = false;  								break;  							}  						}  						if (!validParams) {  							possibleMethods.RemoveAt (index);  							debug += "Not a valid overload; ";  							continue;  						}  						correctFinalParams = correctParams;  					}  					//Response.Write(debug);  					//return;  					if (possibleMethods.Count == 0) {  						Response.Write ("No valid overload afterall.");  					}  					else if (possibleMethods.Count >= 2) {  						Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  							execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  							message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  						}));  					}  					else {  						var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  						Response.ContentType = ContentTypes.JSON;  						var converters = new JsonConverterCollection {  							new StringEnumConverter ()'  							new IsoDateTimeConverter ()  						};  						Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  					}  				}  				break;  			}  		}  	}  	else {  		var methodInfo = possibleMethods [0];  		if (methodInfo.GetParameters ().Length > 0) {  			Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  				execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  				message = "This method requires " + methodInfo.GetParameters ().Length + " parameter(s)"  			}));  		}  		else {  			var invokeResult = invokeAssemblyMethod (classpath' methodInfo' null);  			var converters = new JsonConverterCollection {  				new StringEnumConverter ()'  				new JavaScriptDateTimeConverter ()  			};  			Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  		}  	}  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (Request.RequestType == "POST") {  	// Check if user actually sent any params by analizyng inout stream  	if (Request.InputStream.Length == 0) {  		Response.Write ("Request body missing");  	}  	else {  		var stream = new StreamReader (Request.InputStream);  		var requestBody = stream.ReadToEnd ();  		var jsonSettings = new JsonSerializerSettings {  			DateTimeZoneHandling = DateTimeZoneHandling.Utc'  			DateFormatHandling = DateFormatHandling.IsoDateFormat'  			DateFormatString = "{0:s}"'  			DateParseHandling = DateParseHandling.DateTime  		};  		var invokeParams = JsonConvert.DeserializeObject<object[]> (requestBody' jsonSettings);  		for (var index = possibleMethods.Count - 1; index >= 0; index--) {  			if (possibleMethods [index].GetParameters ().Length != invokeParams.Length) {  				possibleMethods.RemoveAt (index);  			}  		}  		switch (possibleMethods.Count) {  		case 0:  			Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  				execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  				message = "There is no overload of the method with the specified number of params"  			}));  			return;  		case 1:  			{  				var methodInfo = possibleMethods [0];  				var correctParams = new List<object> ();  				for (var index = 0; index < invokeParams.Length; index++) {  					if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  						correctParams.Add (invokeParams [index]);  					}  					else {  						var paramType = methodInfo.GetParameters () [index].ParameterType;  						var serializer = new JsonSerializer ();  						var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  						correctParams.Add (o);  					}  				}  				var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  				Response.ContentType = ContentTypes.JSON;  				//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  				var converters = new JsonConverterCollection {  					new StringEnumConverter ()'  					new IsoDateTimeConverter ()  				};  				Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  			}  			break;  		default:  			{  				//Response.Write("Before anything else");  				//return;  				//trying to build the possibly correct argument list for each overload  				var correctFinalParams = new List<object> ();  				var debug = "";  				for (var index = possibleMethods.Count - 1; index >= 0; index--) {  					var correctParams = new List<object> ();  					var validParams = true;  					//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  					//Response.Write("Before the loop");  					//return;  					for (var index2 = 0; index2 < invokeParams.Length; index2++) {  						debug += "Front of the loop; ";  						//return;  						if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  							correctParams.Add (invokeParams [index2]);  							debug += "Added normal type to param arr; ";  						}  						else {  							var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  							debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  							var serializer = new JsonSerializer ();  							// Response.Write(debug);  							// return;  							var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  							debug += "Done serializing; ";  							if (o == null) {  								//couldn't deserialize to this type' so it's not the good overload  								validParams = false;  								debug += "Failed serializing; ";  								break;  							}  							correctParams.Add (o);  						}  						debug += "End of the loop; ";  					}  					//Response.Write(debug);  					//return;  					if (!validParams) {  						possibleMethods.RemoveAt (index);  						debug += "Not a valid overload; ";  						continue;  					}  					var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  					var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  					//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  					for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  						debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  						if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  							debug += "equal; ";  						}  						else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  							debug += "Could cast from Int64 to Int32;";  						}  						else {  							debug += "different; ";  							validParams = false;  							break;  						}  					}  					if (!validParams) {  						possibleMethods.RemoveAt (index);  						debug += "Not a valid overload; ";  						continue;  					}  					correctFinalParams = correctParams;  				}  				//Response.Write(debug);  				//return;  				if (possibleMethods.Count == 0) {  					Response.Write ("No valid overload afterall.");  				}  				else if (possibleMethods.Count >= 2) {  					Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  						execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  						message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  					}));  				}  				else {  					var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  					Response.ContentType = ContentTypes.JSON;  					var converters = new JsonConverterCollection {  						new StringEnumConverter ()'  						new IsoDateTimeConverter ()  					};  					Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  				}  			}  			break;  		}  	}  }  else {  	var methodInfo = possibleMethods [0];  	if (methodInfo.GetParameters ().Length > 0) {  		Response.Write (JsonConvert.SerializeObject (new InvokationErrorType {  			execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  			message = "This method requires " + methodInfo.GetParameters ().Length + " parameter(s)"  		}));  	}  	else {  		var invokeResult = invokeAssemblyMethod (classpath' methodInfo' null);  		var converters = new JsonConverterCollection {  			new StringEnumConverter ()'  			new JavaScriptDateTimeConverter ()  		};  		Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  	}  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (Request.InputStream.Length == 0) {  	Response.Write ("Request body missing");  }  else {  	var stream = new StreamReader (Request.InputStream);  	var requestBody = stream.ReadToEnd ();  	var jsonSettings = new JsonSerializerSettings {  		DateTimeZoneHandling = DateTimeZoneHandling.Utc'  		DateFormatHandling = DateFormatHandling.IsoDateFormat'  		DateFormatString = "{0:s}"'  		DateParseHandling = DateParseHandling.DateTime  	};  	var invokeParams = JsonConvert.DeserializeObject<object[]> (requestBody' jsonSettings);  	for (var index = possibleMethods.Count - 1; index >= 0; index--) {  		if (possibleMethods [index].GetParameters ().Length != invokeParams.Length) {  			possibleMethods.RemoveAt (index);  		}  	}  	switch (possibleMethods.Count) {  	case 0:  		Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  			execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  			message = "There is no overload of the method with the specified number of params"  		}));  		return;  	case 1:  		{  			var methodInfo = possibleMethods [0];  			var correctParams = new List<object> ();  			for (var index = 0; index < invokeParams.Length; index++) {  				if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  					correctParams.Add (invokeParams [index]);  				}  				else {  					var paramType = methodInfo.GetParameters () [index].ParameterType;  					var serializer = new JsonSerializer ();  					var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  					correctParams.Add (o);  				}  			}  			var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  			Response.ContentType = ContentTypes.JSON;  			//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  			var converters = new JsonConverterCollection {  				new StringEnumConverter ()'  				new IsoDateTimeConverter ()  			};  			Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  		}  		break;  	default:  		{  			//Response.Write("Before anything else");  			//return;  			//trying to build the possibly correct argument list for each overload  			var correctFinalParams = new List<object> ();  			var debug = "";  			for (var index = possibleMethods.Count - 1; index >= 0; index--) {  				var correctParams = new List<object> ();  				var validParams = true;  				//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  				//Response.Write("Before the loop");  				//return;  				for (var index2 = 0; index2 < invokeParams.Length; index2++) {  					debug += "Front of the loop; ";  					//return;  					if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  						correctParams.Add (invokeParams [index2]);  						debug += "Added normal type to param arr; ";  					}  					else {  						var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  						debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  						var serializer = new JsonSerializer ();  						// Response.Write(debug);  						// return;  						var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  						debug += "Done serializing; ";  						if (o == null) {  							//couldn't deserialize to this type' so it's not the good overload  							validParams = false;  							debug += "Failed serializing; ";  							break;  						}  						correctParams.Add (o);  					}  					debug += "End of the loop; ";  				}  				//Response.Write(debug);  				//return;  				if (!validParams) {  					possibleMethods.RemoveAt (index);  					debug += "Not a valid overload; ";  					continue;  				}  				var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  				var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  				//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  				for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  					debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  					if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  						debug += "equal; ";  					}  					else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  						debug += "Could cast from Int64 to Int32;";  					}  					else {  						debug += "different; ";  						validParams = false;  						break;  					}  				}  				if (!validParams) {  					possibleMethods.RemoveAt (index);  					debug += "Not a valid overload; ";  					continue;  				}  				correctFinalParams = correctParams;  			}  			//Response.Write(debug);  			//return;  			if (possibleMethods.Count == 0) {  				Response.Write ("No valid overload afterall.");  			}  			else if (possibleMethods.Count >= 2) {  				Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  					execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  					message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  				}));  			}  			else {  				var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  				Response.ContentType = ContentTypes.JSON;  				var converters = new JsonConverterCollection {  					new StringEnumConverter ()'  					new IsoDateTimeConverter ()  				};  				Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  			}  		}  		break;  	}  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: switch (possibleMethods.Count) {  case 0:  	Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  		execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  		message = "There is no overload of the method with the specified number of params"  	}));  	return;  case 1:  	{  		var methodInfo = possibleMethods [0];  		var correctParams = new List<object> ();  		for (var index = 0; index < invokeParams.Length; index++) {  			if (invokeParams [index].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  				correctParams.Add (invokeParams [index]);  			}  			else {  				var paramType = methodInfo.GetParameters () [index].ParameterType;  				var serializer = new JsonSerializer ();  				var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index])' paramType);  				correctParams.Add (o);  			}  		}  		var invokeResult = invokeAssemblyMethod (classpath' methodInfo' correctParams.ToArray ());  		Response.ContentType = ContentTypes.JSON;  		//Response.Write(JsonConvert.SerializeObject(invokeResult' new JavaScriptDateTimeConverter()));  		var converters = new JsonConverterCollection {  			new StringEnumConverter ()'  			new IsoDateTimeConverter ()  		};  		Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  	}  	break;  default:  	{  		//Response.Write("Before anything else");  		//return;  		//trying to build the possibly correct argument list for each overload  		var correctFinalParams = new List<object> ();  		var debug = "";  		for (var index = possibleMethods.Count - 1; index >= 0; index--) {  			var correctParams = new List<object> ();  			var validParams = true;  			//try to deserialize each possible type. if it fucks up' it's clearly not the overload we're looking for  			//Response.Write("Before the loop");  			//return;  			for (var index2 = 0; index2 < invokeParams.Length; index2++) {  				debug += "Front of the loop; ";  				//return;  				if (invokeParams [index2].GetType ().FullName != "Newtonsoft.Json.Linq.JObject") {  					correctParams.Add (invokeParams [index2]);  					debug += "Added normal type to param arr; ";  				}  				else {  					var paramType = possibleMethods [index].GetParameters () [index2].ParameterType;  					debug += "Proceeding to deserialize from " + paramType.ToString () + "; ";  					var serializer = new JsonSerializer ();  					// Response.Write(debug);  					// return;  					var o = serializer.Deserialize (new JTokenReader ((JObject)invokeParams [index2])' paramType);  					debug += "Done serializing; ";  					if (o == null) {  						//couldn't deserialize to this type' so it's not the good overload  						validParams = false;  						debug += "Failed serializing; ";  						break;  					}  					correctParams.Add (o);  				}  				debug += "End of the loop; ";  			}  			//Response.Write(debug);  			//return;  			if (!validParams) {  				possibleMethods.RemoveAt (index);  				debug += "Not a valid overload; ";  				continue;  			}  			var curMethodParamInfoArr = possibleMethods [index].GetParameters ();  			var curMethodTypeArr = curMethodParamInfoArr.Select (param => param.ParameterType).ToList ();  			//since all complex types are ok now' we've gotta check whether all types are matching. If they do' it's a valid overload  			for (var index2 = 0; index2 < curMethodTypeArr.Count; index2++) {  				debug += "Checking " + correctParams [index2].GetType () + " and " + curMethodTypeArr [index2] + ": ";  				if (correctParams [index2].GetType () == curMethodTypeArr [index2]) {  					debug += "equal; ";  				}  				else if ((correctParams [index2].GetType () == Type.GetType ("System.Int64")) && isValidInt32 (Int64.Parse (correctParams [index2].ToString ())) && (curMethodTypeArr [index2] == Type.GetType ("System.Int32"))) {  					debug += "Could cast from Int64 to Int32;";  				}  				else {  					debug += "different; ";  					validParams = false;  					break;  				}  			}  			if (!validParams) {  				possibleMethods.RemoveAt (index);  				debug += "Not a valid overload; ";  				continue;  			}  			correctFinalParams = correctParams;  		}  		//Response.Write(debug);  		//return;  		if (possibleMethods.Count == 0) {  			Response.Write ("No valid overload afterall.");  		}  		else if (possibleMethods.Count >= 2) {  			Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  				execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  				message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  			}));  		}  		else {  			var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  			Response.ContentType = ContentTypes.JSON;  			var converters = new JsonConverterCollection {  				new StringEnumConverter ()'  				new IsoDateTimeConverter ()  			};  			Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  		}  	}  	break;  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (possibleMethods.Count == 0) {  	Response.Write ("No valid overload afterall.");  }  else if (possibleMethods.Count >= 2) {  	Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  		execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  		message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  	}));  }  else {  	var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  	Response.ContentType = ContentTypes.JSON;  	var converters = new JsonConverterCollection {  		new StringEnumConverter ()'  		new IsoDateTimeConverter ()  	};  	Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  }  
Magic Number,WDK.API.JsonBridge,HttpHandler,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\HttpHandler.cs,ProcessRequest,The following statement contains a magic number: if (possibleMethods.Count >= 2) {  	Response.Write (JsonConvert.SerializeObject (new InvokationErrorType () {  		execTime = (new TimeSpan (DateTime.Now.Ticks - execTimeNow.Ticks).TotalSeconds)'  		message = "Ambiguous call: " + possibleMethods.Count + " valid overloads"  	}));  }  else {  	var invokeResult = invokeAssemblyMethod (classpath' possibleMethods [0]' correctFinalParams.ToArray ());  	Response.ContentType = ContentTypes.JSON;  	var converters = new JsonConverterCollection {  		new StringEnumConverter ()'  		new IsoDateTimeConverter ()  	};  	Response.Write (JsonConvert.SerializeObject (invokeResult' converters.ToArray ()));  }  
Magic Number,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignatureBase,The following statement contains a magic number: if (!((url.Scheme == "http" && url.Port == 80) || (url.Scheme == "https" && url.Port == 443))) {  	normalizedUrl += ":" + url.Port;  }  
Magic Number,WDK.API.JsonBridge,OAuthBase,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\OAuthBase.cs,GenerateSignatureBase,The following statement contains a magic number: if (!((url.Scheme == "http" && url.Port == 80) || (url.Scheme == "https" && url.Port == 443))) {  	normalizedUrl += ":" + url.Port;  }  
Magic Number,WDK.API.JsonBridge,Test,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\Test.cs,executeDate,The following statement contains a magic number: return date.AddDays (22);  
Magic Number,WDK.API.JsonBridge,Test,C:\repos\skitsanos_WDK10\WDK.API.JsonBridge\Test.cs,executeNumber,The following statement contains a magic number: return data + 2000;  
