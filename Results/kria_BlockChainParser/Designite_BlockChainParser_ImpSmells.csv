Implementation smell,Namespace,Class,File,Method,Description
Long Statement,BlockChainParser,Program,C:\repos\kria_BlockChainParser\BlockChainParser\Program.cs,Main,The length of the statement  "		string datadir = opts.Value.DataDir ?? Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' @"Bitcoin\blocks"); " is 143.
Magic Number,BlockChainParser,BlockChain,C:\repos\kria_BlockChainParser\BlockChainParser\BlockChain.cs,ParseBlockFile,The following statement contains a magic number: using (FileStream fs = File.OpenRead (path)) {  	var rdr = new BinaryReader (fs);  	while (fs.Position < fs.Length) {  		uint magic = rdr.ReadUInt32 ();  		if (magic != magicId)  			throw new Exception ("Expected magic' bailing file!");  		uint headerLength = rdr.ReadUInt32 ();  		uint versionNumber = rdr.ReadUInt32 ();  		byte[] hashBuf = rdr.ReadBytes (32);  		BigInteger prevHash = new BigInteger (hashBuf);  		Array.Reverse (hashBuf);  		// to big endian from little  		string hashstr = Utils.ToHexString (hashBuf);  		double blockDiff = Math.Round (trueDiffOne / (double)prevHash);  		callback (hashstr' blockDiff);  		blockCount++;  		fs.Seek (headerLength - 36' SeekOrigin.Current);  	}  }  
Magic Number,BlockChainParser,BlockChain,C:\repos\kria_BlockChainParser\BlockChainParser\BlockChain.cs,ParseBlockFile,The following statement contains a magic number: using (FileStream fs = File.OpenRead (path)) {  	var rdr = new BinaryReader (fs);  	while (fs.Position < fs.Length) {  		uint magic = rdr.ReadUInt32 ();  		if (magic != magicId)  			throw new Exception ("Expected magic' bailing file!");  		uint headerLength = rdr.ReadUInt32 ();  		uint versionNumber = rdr.ReadUInt32 ();  		byte[] hashBuf = rdr.ReadBytes (32);  		BigInteger prevHash = new BigInteger (hashBuf);  		Array.Reverse (hashBuf);  		// to big endian from little  		string hashstr = Utils.ToHexString (hashBuf);  		double blockDiff = Math.Round (trueDiffOne / (double)prevHash);  		callback (hashstr' blockDiff);  		blockCount++;  		fs.Seek (headerLength - 36' SeekOrigin.Current);  	}  }  
Magic Number,BlockChainParser,BlockChain,C:\repos\kria_BlockChainParser\BlockChainParser\BlockChain.cs,ParseBlockFile,The following statement contains a magic number: while (fs.Position < fs.Length) {  	uint magic = rdr.ReadUInt32 ();  	if (magic != magicId)  		throw new Exception ("Expected magic' bailing file!");  	uint headerLength = rdr.ReadUInt32 ();  	uint versionNumber = rdr.ReadUInt32 ();  	byte[] hashBuf = rdr.ReadBytes (32);  	BigInteger prevHash = new BigInteger (hashBuf);  	Array.Reverse (hashBuf);  	// to big endian from little  	string hashstr = Utils.ToHexString (hashBuf);  	double blockDiff = Math.Round (trueDiffOne / (double)prevHash);  	callback (hashstr' blockDiff);  	blockCount++;  	fs.Seek (headerLength - 36' SeekOrigin.Current);  }  
Magic Number,BlockChainParser,BlockChain,C:\repos\kria_BlockChainParser\BlockChainParser\BlockChain.cs,ParseBlockFile,The following statement contains a magic number: while (fs.Position < fs.Length) {  	uint magic = rdr.ReadUInt32 ();  	if (magic != magicId)  		throw new Exception ("Expected magic' bailing file!");  	uint headerLength = rdr.ReadUInt32 ();  	uint versionNumber = rdr.ReadUInt32 ();  	byte[] hashBuf = rdr.ReadBytes (32);  	BigInteger prevHash = new BigInteger (hashBuf);  	Array.Reverse (hashBuf);  	// to big endian from little  	string hashstr = Utils.ToHexString (hashBuf);  	double blockDiff = Math.Round (trueDiffOne / (double)prevHash);  	callback (hashstr' blockDiff);  	blockCount++;  	fs.Seek (headerLength - 36' SeekOrigin.Current);  }  
Magic Number,BlockChainParser,BlockChain,C:\repos\kria_BlockChainParser\BlockChainParser\BlockChain.cs,ParseBlockFile,The following statement contains a magic number: fs.Seek (headerLength - 36' SeekOrigin.Current);  
