Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Griffin.Networking.Protocol.Http.Services.BodyDecoders,MultipartDecoder,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\MultipartDecoder.cs,Decode,Cyclomatic complexity of the method is 9
Long Parameter List,Griffin.Networking.Protocol.Http.Services.Authentication,DigestAuthenticator,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\Authentication\DigestAuthenticator.cs,Encrypt,The method has 9 parameters. Parameters: realm' userName' password' method' uri' qop' nonce' nc' cnonce
Long Parameter List,Griffin.Networking.Protocol.Http.Services.Authentication,DigestAuthenticator,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\Authentication\DigestAuthenticator.cs,Encrypt,The method has 6 parameters. Parameters: ha1' ha2' qop' nonce' nc' cnonce
Long Statement,Griffin.Networking.Protocol.Http.Implementation,ByteRangeStream,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\ByteRangeStream.cs,Read,The length of the statement  "                throw new ArgumentOutOfRangeException("count"' offset+count' string.Format("Offset+Count larger than the buffer size ({0} bytes)."' buffer.Length)); " is 148.
Long Statement,Griffin.Networking.Protocol.Http.Implementation,ByteRangeStream,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\ByteRangeStream.cs,Read,The length of the statement  "                throw new ArgumentOutOfRangeException("count"' count' string.Format("Trying to read more then is left in the ranges ({0} bytes)."' (_ranges.TotalLength - _bytesRead))); " is 168.
Long Statement,Griffin.Networking.Protocol.Http.Implementation,HttpHeaderSerializer,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\HttpHeaderSerializer.cs,SerializeCookies,The length of the statement  "            //Set-Cookie: <name>=<value>[; <name>=<value>][; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; httponly] " is 130.
Long Statement,Griffin.Networking.Protocol.Http.Pipeline.Handlers,BodyDecoder,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Pipeline\Handlers\BodyDecoder.cs,HandleUpstream,The length of the statement  "                    throw new InvalidOperationException("Current message is not set. We have no way of knowing when to stop decoding the body."); " is 125.
Empty Catch Block,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,ReadBoundary,The method has an empty catch block.
Magic Number,Griffin.Networking.Protocol.Http,HttpMessageFactory,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\HttpMessageFactory.cs,HttpMessageFactory,The following statement contains a magic number: _stack = new BufferSliceStack(100' 65535);
Magic Number,Griffin.Networking.Protocol.Http,HttpMessageFactory,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\HttpMessageFactory.cs,HttpMessageFactory,The following statement contains a magic number: _stack = new BufferSliceStack(100' 65535);
Magic Number,Griffin.Networking.Protocol.Http.Implementation,HttpHeaderParser,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\HttpHeaderParser.cs,FirstLine,The following statement contains a magic number: if (ch == '\n')              {                  var line = _headerName.ToString().Split(' ');                  if (line.Length != 3)                      throw new BadRequestException("First line is not a valid REQUEST/RESPONSE line: " + _headerName);                    if (line[2].ToLower().StartsWith("http"))                      RequestLineParsed(this' new RequestLineEventArgs(line[0]' line[1]' line[2]));                  else                  {                      throw new NotSupportedException("Not supporting response parsing yet.");                  }                    _headerName.Clear();                  _parserMethod = Name_StripWhiteSpacesBefore;                  return;              }
Magic Number,Griffin.Networking.Protocol.Http.Implementation,HttpHeaderParser,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\HttpHeaderParser.cs,FirstLine,The following statement contains a magic number: if (ch == '\n')              {                  var line = _headerName.ToString().Split(' ');                  if (line.Length != 3)                      throw new BadRequestException("First line is not a valid REQUEST/RESPONSE line: " + _headerName);                    if (line[2].ToLower().StartsWith("http"))                      RequestLineParsed(this' new RequestLineEventArgs(line[0]' line[1]' line[2]));                  else                  {                      throw new NotSupportedException("Not supporting response parsing yet.");                  }                    _headerName.Clear();                  _parserMethod = Name_StripWhiteSpacesBefore;                  return;              }
Magic Number,Griffin.Networking.Protocol.Http.Implementation,HttpHeaderParser,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\HttpHeaderParser.cs,FirstLine,The following statement contains a magic number: if (ch == '\n')              {                  var line = _headerName.ToString().Split(' ');                  if (line.Length != 3)                      throw new BadRequestException("First line is not a valid REQUEST/RESPONSE line: " + _headerName);                    if (line[2].ToLower().StartsWith("http"))                      RequestLineParsed(this' new RequestLineEventArgs(line[0]' line[1]' line[2]));                  else                  {                      throw new NotSupportedException("Not supporting response parsing yet.");                  }                    _headerName.Clear();                  _parserMethod = Name_StripWhiteSpacesBefore;                  return;              }
Magic Number,Griffin.Networking.Protocol.Http.Implementation,HttpMessage,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\HttpMessage.cs,ParseContentEncoding,The following statement contains a magic number: if (pos != -1)              {                  pos += 8;                  var endPos = value.IndexOf(";"' pos + 1);                  var encoding = endPos == -1 ? value.Substring(pos) : value.Substring(pos' endPos - pos);                  encoding = encoding.ToUpper();                  ContentEncoding = Encoding.GetEncoding(encoding.ToUpper());              }
Magic Number,Griffin.Networking.Protocol.Http.Pipeline.Handlers,BodyDecoder,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Pipeline\Handlers\BodyDecoder.cs,BodyDecoder,The following statement contains a magic number: _bufferPool = new BufferSliceStack(1000' bufferSize);
Magic Number,Griffin.Networking.Protocol.Http.Services.Authentication,BasicAuthentication,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\Authentication\BasicAuthentication.cs,CreateChallenge,The following statement contains a magic number: response.StatusCode = 401;
Magic Number,Griffin.Networking.Protocol.Http.Services.Authentication,DigestAuthenticator,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\Authentication\DigestAuthenticator.cs,CreateChallenge,The following statement contains a magic number: response.StatusCode = 401;
Magic Number,Griffin.Networking.Protocol.Http.Services.Authentication.Digest,Nonce,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\Authentication\Digest\Nonce.cs,Validate,The following statement contains a magic number: if (_counts.Count <= 5 || value > 5)                  return false;
Magic Number,Griffin.Networking.Protocol.Http.Services.Authentication.Digest,Nonce,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\Authentication\Digest\Nonce.cs,Validate,The following statement contains a magic number: if (_counts.Count <= 5 || value > 5)                  return false;
Magic Number,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,HttpMultipart,The following statement contains a magic number: buffer = new byte[boundary_bytes.Length + 2];
Magic Number,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,MoveToNextBoundary,The following statement contains a magic number: while (true)              {                  if (c == -1)                      return -1;                    if (state == 0 && c == LF)                  {                      retval = data.Position - 1;                      if (got_cr)                          retval--;                      state = 1;                      c = data.ReadByte();                  }                  else if (state == 0)                  {                      got_cr = (c == CR);                      c = data.ReadByte();                  }                  else if (state == 1 && c == '-')                  {                      c = data.ReadByte();                      if (c == -1)                          return -1;                        if (c != '-')                      {                          state = 0;                          got_cr = false;                          continue; // no ReadByte() here                      }                        var nread = data.Read(buffer' 0' buffer.Length);                      var bl = buffer.Length;                      if (nread != bl)                          return -1;                        if (!CompareBytes(boundary_bytes' buffer))                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                        if (buffer[bl - 2] == '-' && buffer[bl - 1] == '-')                      {                          _atEof = true;                      }                      else if (buffer[bl - 2] != CR || buffer[bl - 1] != LF)                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                      data.Position = retval + 2;                      if (got_cr)                          data.Position++;                      break;                  }                  else                  {                      // state == 1                      state = 0; // no ReadByte() here                  }              }
Magic Number,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,MoveToNextBoundary,The following statement contains a magic number: while (true)              {                  if (c == -1)                      return -1;                    if (state == 0 && c == LF)                  {                      retval = data.Position - 1;                      if (got_cr)                          retval--;                      state = 1;                      c = data.ReadByte();                  }                  else if (state == 0)                  {                      got_cr = (c == CR);                      c = data.ReadByte();                  }                  else if (state == 1 && c == '-')                  {                      c = data.ReadByte();                      if (c == -1)                          return -1;                        if (c != '-')                      {                          state = 0;                          got_cr = false;                          continue; // no ReadByte() here                      }                        var nread = data.Read(buffer' 0' buffer.Length);                      var bl = buffer.Length;                      if (nread != bl)                          return -1;                        if (!CompareBytes(boundary_bytes' buffer))                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                        if (buffer[bl - 2] == '-' && buffer[bl - 1] == '-')                      {                          _atEof = true;                      }                      else if (buffer[bl - 2] != CR || buffer[bl - 1] != LF)                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                      data.Position = retval + 2;                      if (got_cr)                          data.Position++;                      break;                  }                  else                  {                      // state == 1                      state = 0; // no ReadByte() here                  }              }
Magic Number,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,MoveToNextBoundary,The following statement contains a magic number: while (true)              {                  if (c == -1)                      return -1;                    if (state == 0 && c == LF)                  {                      retval = data.Position - 1;                      if (got_cr)                          retval--;                      state = 1;                      c = data.ReadByte();                  }                  else if (state == 0)                  {                      got_cr = (c == CR);                      c = data.ReadByte();                  }                  else if (state == 1 && c == '-')                  {                      c = data.ReadByte();                      if (c == -1)                          return -1;                        if (c != '-')                      {                          state = 0;                          got_cr = false;                          continue; // no ReadByte() here                      }                        var nread = data.Read(buffer' 0' buffer.Length);                      var bl = buffer.Length;                      if (nread != bl)                          return -1;                        if (!CompareBytes(boundary_bytes' buffer))                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                        if (buffer[bl - 2] == '-' && buffer[bl - 1] == '-')                      {                          _atEof = true;                      }                      else if (buffer[bl - 2] != CR || buffer[bl - 1] != LF)                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                      data.Position = retval + 2;                      if (got_cr)                          data.Position++;                      break;                  }                  else                  {                      // state == 1                      state = 0; // no ReadByte() here                  }              }
Magic Number,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,MoveToNextBoundary,The following statement contains a magic number: while (true)              {                  if (c == -1)                      return -1;                    if (state == 0 && c == LF)                  {                      retval = data.Position - 1;                      if (got_cr)                          retval--;                      state = 1;                      c = data.ReadByte();                  }                  else if (state == 0)                  {                      got_cr = (c == CR);                      c = data.ReadByte();                  }                  else if (state == 1 && c == '-')                  {                      c = data.ReadByte();                      if (c == -1)                          return -1;                        if (c != '-')                      {                          state = 0;                          got_cr = false;                          continue; // no ReadByte() here                      }                        var nread = data.Read(buffer' 0' buffer.Length);                      var bl = buffer.Length;                      if (nread != bl)                          return -1;                        if (!CompareBytes(boundary_bytes' buffer))                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                        if (buffer[bl - 2] == '-' && buffer[bl - 1] == '-')                      {                          _atEof = true;                      }                      else if (buffer[bl - 2] != CR || buffer[bl - 1] != LF)                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                      data.Position = retval + 2;                      if (got_cr)                          data.Position++;                      break;                  }                  else                  {                      // state == 1                      state = 0; // no ReadByte() here                  }              }
Magic Number,Griffin.Networking.Protocol.Http.Services.BodyDecoders.Mono,HttpMultipart,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Services\BodyDecoders\Mono\MultiPartParser.cs,MoveToNextBoundary,The following statement contains a magic number: while (true)              {                  if (c == -1)                      return -1;                    if (state == 0 && c == LF)                  {                      retval = data.Position - 1;                      if (got_cr)                          retval--;                      state = 1;                      c = data.ReadByte();                  }                  else if (state == 0)                  {                      got_cr = (c == CR);                      c = data.ReadByte();                  }                  else if (state == 1 && c == '-')                  {                      c = data.ReadByte();                      if (c == -1)                          return -1;                        if (c != '-')                      {                          state = 0;                          got_cr = false;                          continue; // no ReadByte() here                      }                        var nread = data.Read(buffer' 0' buffer.Length);                      var bl = buffer.Length;                      if (nread != bl)                          return -1;                        if (!CompareBytes(boundary_bytes' buffer))                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                        if (buffer[bl - 2] == '-' && buffer[bl - 1] == '-')                      {                          _atEof = true;                      }                      else if (buffer[bl - 2] != CR || buffer[bl - 1] != LF)                      {                          state = 0;                          data.Position = retval + 2;                          if (got_cr)                          {                              data.Position++;                              got_cr = false;                          }                          c = data.ReadByte();                          continue;                      }                      data.Position = retval + 2;                      if (got_cr)                          data.Position++;                      break;                  }                  else                  {                      // state == 1                      state = 0; // no ReadByte() here                  }              }
Missing Default,Griffin.Networking.Protocol.Http,NameValueParser,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\NameValueParser.cs,Parse,The following switch statement is missing a default case: switch (ch)                  {                      case '=':                          if (lastCh != '\\')                          {                              name = value.Substring(oldPos' index - oldPos).Trim(' ');                              oldPos = index + 1;                          }                          break;                      case ''':                          if (lastCh != '\\')                          {                              target.Add(name' value.Substring(oldPos' index - oldPos).Trim(' '' '"'));                              name = "";                              oldPos = index + 1;                          }                          break;                  }
Missing Default,Griffin.Networking.Protocol.Http.Implementation.Infrastructure,UrlDecoder,C:\repos\jgauffin_griffin.networking\Source\Protocols\Http\Griffin.Networking.Protocol.Http\Implementation\Infrastructure\UrlDecoder.cs,Parse,The following switch statement is missing a default case: switch (result.Delimiter)                  {                      case '&':                          parameters.Add(name' string.Empty);                          break;                      case '=':                          result = reader.ReadToEnd("&");                          parameters.Add(name' Uri.UnescapeDataString(result.Value));                          break;                      case char.MinValue:                          // EOF = no delimiter && no value                          if (!string.IsNullOrEmpty(name))                              parameters.Add(name' string.Empty);                          break;                  }
