Implementation smell,Namespace,Class,File,Method,Description
Long Method,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The method has 475 lines of code.
Complex Method,Kayak.Http,ParserToTransactionTransform,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Parsing\ParserToTransactionTransform.cs,Commit,Cyclomatic complexity of the method is 11
Complex Method,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,Cyclomatic complexity of the method is 167
Long Statement,Kayak,Trace,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Extensions\Trace.cs,Write,The length of the statement  "	Console.WriteLine ("[thread " + System.Threading.Thread.CurrentThread.ManagedThreadId + "' " + methodBase.DeclaringType.Name + "." + methodBase.Name + "] " + string.Format (format' args)); " is 188.
Long Statement,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,Write,The length of the statement  "	Debug.WriteLine ("KayakSocket: added " + data.Count + " bytes to buffer' buffer size was " + bufferSize + "' buffer size is " + buffer.Size); " is 141.
Long Statement,Kayak,KayakSocketState,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocketState.cs,CanShutdownAndClose,The length of the statement  "	Debug.WriteLine ("KayakSocketState: CanShutdownAndClose (readEnded = " + readEnded + "' writeEnded = " + writeEnded + "' bufferIsEmpty = " + bufferIsEmpty + ")"); " is 162.
Long Statement,Kayak.Http,Extensions,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Extensions\Request.cs,IsContinueExpected,The length of the statement  "	return request.Version != null && request.Version.Major == 1 && request.Version.Minor == 1 && request.Headers != null && request.Headers.ContainsKey ("expect") && request.Headers ["expect"] == "100-continue"; " is 208.
Long Statement,Kayak.Http,Extensions,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Extensions\Request.cs,IsContinueProhibited,The length of the statement  "	return (request.Version != null && request.Version.Major == 1 && request.Version.Minor == 0) || !request.Headers.ContainsKey ("expect") || request.Headers ["expect"] != "100-continue"; " is 184.
Long Statement,Kayak.Http,Extensions,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Extensions\Request.cs,HasBody,The length of the statement  "	return request.Headers.ContainsKey ("Content-Length") || (request.Headers.ContainsKey ("Transfer-Encoding") && request.Headers ["Transfer-Encoding"] == "chunked"); " is 163.
Long Statement,Kayak.Http,HttpRequestHead,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Http.cs,ToString,The length of the statement  "	return string.Format ("{0} {1}\r\n{2}\r\n"' Method' Uri' Headers != null ? Headers.Aggregate (""' (acc' kv) => acc += string.Format ("{0}: {1}\r\n"' kv.Key' kv.Value)) : ""); " is 174.
Long Statement,Kayak.Http,HttpResponseHead,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Http.cs,ToString,The length of the statement  "	return string.Format ("{0}\r\n{1}\r\n"' Status' Headers != null ? Headers.Aggregate (""' (acc' kv) => acc += string.Format ("{0}: {1}\r\n"' kv.Key' kv.Value)) : ""); " is 165.
Complex Conditional,Kayak.Http,ResponseSegment,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\OutputQueue.cs,HandOffTransactionIfPossible,The conditional expression  "gotResponse && (body == null || (body != null && bodyFinished)) && transaction != null && next != null"  is complex.
Empty Catch Block,Kayak,DefaultKayakServer,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Server\KayakServer.cs,HandleAcceptError,The method has an empty catch block.
Magic Number,Kayak,DefaultKayakServer,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Server\KayakServer.cs,Listen,The following statement contains a magic number: listener.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 10000);  
Magic Number,Kayak,DefaultKayakServer,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Server\KayakServer.cs,Listen,The following statement contains a magic number: listener.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.SendTimeout' 10000);  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,BeginRead,The following statement contains a magic number: if (inputBuffer == null)  	inputBuffer = new byte[1024 * 4];  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,BeginRead,The following statement contains a magic number: if (inputBuffer == null)  	inputBuffer = new byte[1024 * 4];  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,BeginRead,The following statement contains a magic number: inputBuffer = new byte[1024 * 4];  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,BeginRead,The following statement contains a magic number: inputBuffer = new byte[1024 * 4];  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,HandleReadError,The following statement contains a magic number: if (e is SocketException) {  	var socketException = e as SocketException;  	if (socketException.ErrorCode == 10053 || socketException.ErrorCode == 10054) {  		Debug.WriteLine ("KayakSocket: peer reset (" + socketException.ErrorCode + ")");  		PeerHungUp ();  		return;  	}  }  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,HandleReadError,The following statement contains a magic number: if (e is SocketException) {  	var socketException = e as SocketException;  	if (socketException.ErrorCode == 10053 || socketException.ErrorCode == 10054) {  		Debug.WriteLine ("KayakSocket: peer reset (" + socketException.ErrorCode + ")");  		PeerHungUp ();  		return;  	}  }  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,HandleReadError,The following statement contains a magic number: if (socketException.ErrorCode == 10053 || socketException.ErrorCode == 10054) {  	Debug.WriteLine ("KayakSocket: peer reset (" + socketException.ErrorCode + ")");  	PeerHungUp ();  	return;  }  
Magic Number,Kayak,DefaultKayakSocket,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Net\Socket\KayakSocket.cs,HandleReadError,The following statement contains a magic number: if (socketException.ErrorCode == 10053 || socketException.ErrorCode == 10054) {  	Debug.WriteLine ("KayakSocket: peer reset (" + socketException.ErrorCode + ")");  	PeerHungUp ();  	return;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 31:  		#line  		{  			throw new Exception ("Parser is dead; there shouldn't be more data. Client is bogus? fpc =" + p);  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 31:  	#line  	{  		throw new Exception ("Parser is dead; there shouldn't be more data. Client is bogus? fpc =" + p);  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (_klen > 0) {  	short _lower = _keys;  	short _mid;  	short _upper = (short)(_keys + (_klen << 1) - 2);  	while (true) {  		if (_upper < _lower)  			break;  		_mid = (short)(_lower + (((_upper - _lower) >> 1) & ~1));  		if (data [p] < _http_parser_trans_keys [_mid])  			_upper = (short)(_mid - 2);  		else if (data [p] > _http_parser_trans_keys [_mid + 1])  			_lower = (short)(_mid + 2);  		else {  			_trans += (short)((_mid - _keys) >> 1);  			goto _match;  		}  	}  	_trans += (short)_klen;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (_klen > 0) {  	short _lower = _keys;  	short _mid;  	short _upper = (short)(_keys + (_klen << 1) - 2);  	while (true) {  		if (_upper < _lower)  			break;  		_mid = (short)(_lower + (((_upper - _lower) >> 1) & ~1));  		if (data [p] < _http_parser_trans_keys [_mid])  			_upper = (short)(_mid - 2);  		else if (data [p] > _http_parser_trans_keys [_mid + 1])  			_lower = (short)(_mid + 2);  		else {  			_trans += (short)((_mid - _keys) >> 1);  			goto _match;  		}  	}  	_trans += (short)_klen;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (_klen > 0) {  	short _lower = _keys;  	short _mid;  	short _upper = (short)(_keys + (_klen << 1) - 2);  	while (true) {  		if (_upper < _lower)  			break;  		_mid = (short)(_lower + (((_upper - _lower) >> 1) & ~1));  		if (data [p] < _http_parser_trans_keys [_mid])  			_upper = (short)(_mid - 2);  		else if (data [p] > _http_parser_trans_keys [_mid + 1])  			_lower = (short)(_mid + 2);  		else {  			_trans += (short)((_mid - _keys) >> 1);  			goto _match;  		}  	}  	_trans += (short)_klen;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (true) {  	if (_upper < _lower)  		break;  	_mid = (short)(_lower + (((_upper - _lower) >> 1) & ~1));  	if (data [p] < _http_parser_trans_keys [_mid])  		_upper = (short)(_mid - 2);  	else if (data [p] > _http_parser_trans_keys [_mid + 1])  		_lower = (short)(_mid + 2);  	else {  		_trans += (short)((_mid - _keys) >> 1);  		goto _match;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (true) {  	if (_upper < _lower)  		break;  	_mid = (short)(_lower + (((_upper - _lower) >> 1) & ~1));  	if (data [p] < _http_parser_trans_keys [_mid])  		_upper = (short)(_mid - 2);  	else if (data [p] > _http_parser_trans_keys [_mid + 1])  		_lower = (short)(_mid + 2);  	else {  		_trans += (short)((_mid - _keys) >> 1);  		goto _match;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (data [p] < _http_parser_trans_keys [_mid])  	_upper = (short)(_mid - 2);  else if (data [p] > _http_parser_trans_keys [_mid + 1])  	_lower = (short)(_mid + 2);  else {  	_trans += (short)((_mid - _keys) >> 1);  	goto _match;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (data [p] < _http_parser_trans_keys [_mid])  	_upper = (short)(_mid - 2);  else if (data [p] > _http_parser_trans_keys [_mid + 1])  	_lower = (short)(_mid + 2);  else {  	_trans += (short)((_mid - _keys) >> 1);  	goto _match;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: _upper = (short)(_mid - 2);  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (data [p] > _http_parser_trans_keys [_mid + 1])  	_lower = (short)(_mid + 2);  else {  	_trans += (short)((_mid - _keys) >> 1);  	goto _match;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: _lower = (short)(_mid + 2);  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (_nacts-- > 0) {  	switch (_http_parser_actions [_acts++]) {  	case 0:  		#line  		{  			sb.Append ((char)data [p]);  		}  		break;  	case 1:  		#line  		{  			sb.Length = 0;  		}  		break;  	case 2:  		#line  		{  			sb2.Append ((char)data [p]);  		}  		break;  	case 3:  		#line  		{  			if (sb2 == null)  				sb2 = new StringBuilder ();  			sb2.Length = 0;  		}  		break;  	case 4:  		#line  		{  			//Console.WriteLine("message_begin");  			versionMajor = 0;  			versionMinor = 9;  			contentLength = -1;  			inContentLengthHeader = false;  			inConnectionHeader = false;  			inTransferEncodingHeader = false;  			inUpgradeHeader = false;  			gotConnectionClose = false;  			gotConnectionKeepAlive = false;  			gotTransferEncodingChunked = false;  			gotUpgradeValue = false;  			del.OnMessageBegin (this);  		}  		break;  	case 5:  		#line  		{  			//Console.WriteLine("matched absolute_uri");  		}  		break;  	case 6:  		#line  		{  			//Console.WriteLine("matched abs_path");  		}  		break;  	case 7:  		#line  		{  			//Console.WriteLine("matched authority");  		}  		break;  	case 8:  		#line  		{  			//Console.WriteLine("matched first space");  		}  		break;  	case 9:  		#line  		{  			//Console.WriteLine("leave_first_space");  		}  		break;  	case 11:  		#line  		{  			//Console.WriteLine("matched_leading_crlf");  		}  		break;  	case 12:  		#line  		{  			del.OnMethod (this' sb.ToString ());  		}  		break;  	case 13:  		#line  		{  			del.OnRequestUri (this' sb.ToString ());  		}  		break;  	case 14:  		#line  		{  			del.OnPath (this' sb2.ToString ());  		}  		break;  	case 15:  		#line  		{  			del.OnQueryString (this' sb2.ToString ());  		}  		break;  	case 16:  		#line  		{  			del.OnFragment (this' sb2.ToString ());  		}  		break;  	case 17:  		#line  		{  			versionMajor = (char)data [p] - '0';  		}  		break;  	case 18:  		#line  		{  			versionMinor = (char)data [p] - '0';  		}  		break;  	case 19:  		#line  		{  			if (contentLength != -1)  				throw new Exception ("Already got Content-Length. Possible attack?");  			//Console.WriteLine("Saw content length");  			contentLength = 0;  			inContentLengthHeader = true;  		}  		break;  	case 20:  		#line  		{  			//Console.WriteLine("header_connection");  			inConnectionHeader = true;  		}  		break;  	case 21:  		#line  		{  			//Console.WriteLine("header_connection_close");  			if (inConnectionHeader)  				gotConnectionClose = true;  		}  		break;  	case 22:  		#line  		{  			//Console.WriteLine("header_connection_keepalive");  			if (inConnectionHeader)  				gotConnectionKeepAlive = true;  		}  		break;  	case 23:  		#line  		{  			//Console.WriteLine("Saw transfer encoding");  			inTransferEncodingHeader = true;  		}  		break;  	case 24:  		#line  		{  			if (inTransferEncodingHeader)  				gotTransferEncodingChunked = true;  		}  		break;  	case 25:  		#line  		{  			inUpgradeHeader = true;  		}  		break;  	case 26:  		#line  		{  			del.OnHeaderName (this' sb.ToString ());  		}  		break;  	case 27:  		#line  		{  			var str = sb.ToString ();  			//Console.WriteLine("on_header_value '" + str + "'");  			//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  			if (inContentLengthHeader)  				contentLength = int.Parse (str);  			inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  			del.OnHeaderValue (this' str);  		}  		break;  	case 28:  		#line  		{  			if (data [p] == 10) {  				//Console.WriteLine("leave_headers contentLength = " + contentLength);  				del.OnHeadersEnd (this);  				// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  				// if content length given but zero' read next request  				// if content length is given and non-zero' we should read that many bytes  				// if content length is not given  				//   if should keep alive' assume next request is coming and read it  				//   else read body until EOF  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else if (contentLength > 0) {  					//fhold;  					{  						cs = 129;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Request had no content length.");  					if (ShouldKeepAlive) {  						del.OnMessageEnd (this);  						//Console.WriteLine("Should keep alive' will read next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  						//fhold;  						{  							cs = 133;  							if (true)  								goto _again;  						}  					}  				}  			}  		}  		break;  	case 29:  		#line  		{  			var toRead = Math.Min (pe - p' contentLength);  			//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				contentLength -= toRead;  				//Console.WriteLine("content length is now " + contentLength);  				if (contentLength == 0) {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						//Console.WriteLine("Transitioning from identity body to next message.");  						//fhold;  						{  							cs = 1;  							if (true)  								goto _again;  						}  					} else {  						//fhold;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				} else {  					{  						p++;  						if (true)  							goto _out;  					}  				}  			}  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [_acts++]) {  case 0:  	#line  	{  		sb.Append ((char)data [p]);  	}  	break;  case 1:  	#line  	{  		sb.Length = 0;  	}  	break;  case 2:  	#line  	{  		sb2.Append ((char)data [p]);  	}  	break;  case 3:  	#line  	{  		if (sb2 == null)  			sb2 = new StringBuilder ();  		sb2.Length = 0;  	}  	break;  case 4:  	#line  	{  		//Console.WriteLine("message_begin");  		versionMajor = 0;  		versionMinor = 9;  		contentLength = -1;  		inContentLengthHeader = false;  		inConnectionHeader = false;  		inTransferEncodingHeader = false;  		inUpgradeHeader = false;  		gotConnectionClose = false;  		gotConnectionKeepAlive = false;  		gotTransferEncodingChunked = false;  		gotUpgradeValue = false;  		del.OnMessageBegin (this);  	}  	break;  case 5:  	#line  	{  		//Console.WriteLine("matched absolute_uri");  	}  	break;  case 6:  	#line  	{  		//Console.WriteLine("matched abs_path");  	}  	break;  case 7:  	#line  	{  		//Console.WriteLine("matched authority");  	}  	break;  case 8:  	#line  	{  		//Console.WriteLine("matched first space");  	}  	break;  case 9:  	#line  	{  		//Console.WriteLine("leave_first_space");  	}  	break;  case 11:  	#line  	{  		//Console.WriteLine("matched_leading_crlf");  	}  	break;  case 12:  	#line  	{  		del.OnMethod (this' sb.ToString ());  	}  	break;  case 13:  	#line  	{  		del.OnRequestUri (this' sb.ToString ());  	}  	break;  case 14:  	#line  	{  		del.OnPath (this' sb2.ToString ());  	}  	break;  case 15:  	#line  	{  		del.OnQueryString (this' sb2.ToString ());  	}  	break;  case 16:  	#line  	{  		del.OnFragment (this' sb2.ToString ());  	}  	break;  case 17:  	#line  	{  		versionMajor = (char)data [p] - '0';  	}  	break;  case 18:  	#line  	{  		versionMinor = (char)data [p] - '0';  	}  	break;  case 19:  	#line  	{  		if (contentLength != -1)  			throw new Exception ("Already got Content-Length. Possible attack?");  		//Console.WriteLine("Saw content length");  		contentLength = 0;  		inContentLengthHeader = true;  	}  	break;  case 20:  	#line  	{  		//Console.WriteLine("header_connection");  		inConnectionHeader = true;  	}  	break;  case 21:  	#line  	{  		//Console.WriteLine("header_connection_close");  		if (inConnectionHeader)  			gotConnectionClose = true;  	}  	break;  case 22:  	#line  	{  		//Console.WriteLine("header_connection_keepalive");  		if (inConnectionHeader)  			gotConnectionKeepAlive = true;  	}  	break;  case 23:  	#line  	{  		//Console.WriteLine("Saw transfer encoding");  		inTransferEncodingHeader = true;  	}  	break;  case 24:  	#line  	{  		if (inTransferEncodingHeader)  			gotTransferEncodingChunked = true;  	}  	break;  case 25:  	#line  	{  		inUpgradeHeader = true;  	}  	break;  case 26:  	#line  	{  		del.OnHeaderName (this' sb.ToString ());  	}  	break;  case 27:  	#line  	{  		var str = sb.ToString ();  		//Console.WriteLine("on_header_value '" + str + "'");  		//Console.WriteLine("inContentLengthHeader " + inContentLengthHeader);  		if (inContentLengthHeader)  			contentLength = int.Parse (str);  		inConnectionHeader = inTransferEncodingHeader = inContentLengthHeader = false;  		del.OnHeaderValue (this' str);  	}  	break;  case 28:  	#line  	{  		if (data [p] == 10) {  			//Console.WriteLine("leave_headers contentLength = " + contentLength);  			del.OnHeadersEnd (this);  			// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  			// if content length given but zero' read next request  			// if content length is given and non-zero' we should read that many bytes  			// if content length is not given  			//   if should keep alive' assume next request is coming and read it  			//   else read body until EOF  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				//fhold;  				{  					cs = 1;  					if (true)  						goto _again;  				}  			} else if (contentLength > 0) {  				//fhold;  				{  					cs = 129;  					if (true)  						goto _again;  				}  			} else {  				//Console.WriteLine("Request had no content length.");  				if (ShouldKeepAlive) {  					del.OnMessageEnd (this);  					//Console.WriteLine("Should keep alive' will read next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  					//fhold;  					{  						cs = 133;  						if (true)  							goto _again;  					}  				}  			}  		}  	}  	break;  case 29:  	#line  	{  		var toRead = Math.Min (pe - p' contentLength);  		//Console.WriteLine("body_identity: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			contentLength -= toRead;  			//Console.WriteLine("content length is now " + contentLength);  			if (contentLength == 0) {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					//Console.WriteLine("Transitioning from identity body to next message.");  					//fhold;  					{  						cs = 1;  						if (true)  							goto _again;  					}  				} else {  					//fhold;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			} else {  				{  					p++;  					if (true)  						goto _out;  				}  			}  		}  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: versionMinor = 9;  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (data [p] == 10) {  	//Console.WriteLine("leave_headers contentLength = " + contentLength);  	del.OnHeadersEnd (this);  	// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  	// if content length given but zero' read next request  	// if content length is given and non-zero' we should read that many bytes  	// if content length is not given  	//   if should keep alive' assume next request is coming and read it  	//   else read body until EOF  	if (contentLength == 0) {  		del.OnMessageEnd (this);  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else if (contentLength > 0) {  		//fhold;  		{  			cs = 129;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Request had no content length.");  		if (ShouldKeepAlive) {  			del.OnMessageEnd (this);  			//Console.WriteLine("Should keep alive' will read next message.");  			//fhold;  			{  				cs = 1;  				if (true)  					goto _again;  			}  		} else {  			//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  			//fhold;  			{  				cs = 133;  				if (true)  					goto _again;  			}  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (data [p] == 10) {  	//Console.WriteLine("leave_headers contentLength = " + contentLength);  	del.OnHeadersEnd (this);  	// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  	// if content length given but zero' read next request  	// if content length is given and non-zero' we should read that many bytes  	// if content length is not given  	//   if should keep alive' assume next request is coming and read it  	//   else read body until EOF  	if (contentLength == 0) {  		del.OnMessageEnd (this);  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else if (contentLength > 0) {  		//fhold;  		{  			cs = 129;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Request had no content length.");  		if (ShouldKeepAlive) {  			del.OnMessageEnd (this);  			//Console.WriteLine("Should keep alive' will read next message.");  			//fhold;  			{  				cs = 1;  				if (true)  					goto _again;  			}  		} else {  			//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  			//fhold;  			{  				cs = 133;  				if (true)  					goto _again;  			}  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (data [p] == 10) {  	//Console.WriteLine("leave_headers contentLength = " + contentLength);  	del.OnHeadersEnd (this);  	// if chunked transfer' ignore content length and parse chunked (but we can't yet so bail)  	// if content length given but zero' read next request  	// if content length is given and non-zero' we should read that many bytes  	// if content length is not given  	//   if should keep alive' assume next request is coming and read it  	//   else read body until EOF  	if (contentLength == 0) {  		del.OnMessageEnd (this);  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else if (contentLength > 0) {  		//fhold;  		{  			cs = 129;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Request had no content length.");  		if (ShouldKeepAlive) {  			del.OnMessageEnd (this);  			//Console.WriteLine("Should keep alive' will read next message.");  			//fhold;  			{  				cs = 1;  				if (true)  					goto _again;  			}  		} else {  			//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  			//fhold;  			{  				cs = 133;  				if (true)  					goto _again;  			}  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (contentLength == 0) {  	del.OnMessageEnd (this);  	//fhold;  	{  		cs = 1;  		if (true)  			goto _again;  	}  } else if (contentLength > 0) {  	//fhold;  	{  		cs = 129;  		if (true)  			goto _again;  	}  } else {  	//Console.WriteLine("Request had no content length.");  	if (ShouldKeepAlive) {  		del.OnMessageEnd (this);  		//Console.WriteLine("Should keep alive' will read next message.");  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  		//fhold;  		{  			cs = 133;  			if (true)  				goto _again;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (contentLength == 0) {  	del.OnMessageEnd (this);  	//fhold;  	{  		cs = 1;  		if (true)  			goto _again;  	}  } else if (contentLength > 0) {  	//fhold;  	{  		cs = 129;  		if (true)  			goto _again;  	}  } else {  	//Console.WriteLine("Request had no content length.");  	if (ShouldKeepAlive) {  		del.OnMessageEnd (this);  		//Console.WriteLine("Should keep alive' will read next message.");  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  		//fhold;  		{  			cs = 133;  			if (true)  				goto _again;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (contentLength > 0) {  	//fhold;  	{  		cs = 129;  		if (true)  			goto _again;  	}  } else {  	//Console.WriteLine("Request had no content length.");  	if (ShouldKeepAlive) {  		del.OnMessageEnd (this);  		//Console.WriteLine("Should keep alive' will read next message.");  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  		//fhold;  		{  			cs = 133;  			if (true)  				goto _again;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (contentLength > 0) {  	//fhold;  	{  		cs = 129;  		if (true)  			goto _again;  	}  } else {  	//Console.WriteLine("Request had no content length.");  	if (ShouldKeepAlive) {  		del.OnMessageEnd (this);  		//Console.WriteLine("Should keep alive' will read next message.");  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else {  		//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  		//fhold;  		{  			cs = 133;  			if (true)  				goto _again;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: cs = 129;  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (ShouldKeepAlive) {  	del.OnMessageEnd (this);  	//Console.WriteLine("Should keep alive' will read next message.");  	//fhold;  	{  		cs = 1;  		if (true)  			goto _again;  	}  } else {  	//Console.WriteLine("Not keeping alive' will read until eof. Will hold' but currently fpc = " + fpc);  	//fhold;  	{  		cs = 133;  		if (true)  			goto _again;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: cs = 133;  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (toRead > 0) {  	del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  	p += toRead - 1;  	contentLength -= toRead;  	//Console.WriteLine("content length is now " + contentLength);  	if (contentLength == 0) {  		del.OnMessageEnd (this);  		if (ShouldKeepAlive) {  			//Console.WriteLine("Transitioning from identity body to next message.");  			//fhold;  			{  				cs = 1;  				if (true)  					goto _again;  			}  		} else {  			//fhold;  			{  				cs = 130;  				if (true)  					goto _again;  			}  		}  	} else {  		{  			p++;  			if (true)  				goto _out;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (contentLength == 0) {  	del.OnMessageEnd (this);  	if (ShouldKeepAlive) {  		//Console.WriteLine("Transitioning from identity body to next message.");  		//fhold;  		{  			cs = 1;  			if (true)  				goto _again;  		}  	} else {  		//fhold;  		{  			cs = 130;  			if (true)  				goto _again;  		}  	}  } else {  	{  		p++;  		if (true)  			goto _out;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (ShouldKeepAlive) {  	//Console.WriteLine("Transitioning from identity body to next message.");  	//fhold;  	{  		cs = 1;  		if (true)  			goto _again;  	}  } else {  	//fhold;  	{  		cs = 130;  		if (true)  			goto _again;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: cs = 130;  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (toRead > 0) {  	del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  	p += toRead - 1;  	{  		p++;  		if (true)  			goto _out;  	}  } else {  	del.OnMessageEnd (this);  	if (ShouldKeepAlive) {  		cs = 1;  		if (true)  			goto _again;  	} else {  		//Console.WriteLine("body_identity_eof: going to dead");  		p--;  		{  			cs = 130;  			if (true)  				goto _again;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (ShouldKeepAlive) {  	cs = 1;  	if (true)  		goto _again;  } else {  	//Console.WriteLine("body_identity_eof: going to dead");  	p--;  	{  		cs = 130;  		if (true)  			goto _again;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: cs = 130;  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (p == eof) {  	int __acts = _http_parser_eof_actions [cs];  	int __nacts = _http_parser_actions [__acts++];  	while (__nacts-- > 0) {  		switch (_http_parser_actions [__acts++]) {  		case 10:  			#line  			{  				//Console.WriteLine("eof_leave_first_space");  			}  			break;  		case 30:  			#line  			{  				var toRead = pe - p;  				//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  				if (toRead > 0) {  					del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  					p += toRead - 1;  					{  						p++;  						if (true)  							goto _out;  					}  				} else {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						cs = 1;  						if (true)  							goto _again;  					} else {  						//Console.WriteLine("body_identity_eof: going to dead");  						p--;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				}  			}  			break;  		#line  		default:  			break;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (p == eof) {  	int __acts = _http_parser_eof_actions [cs];  	int __nacts = _http_parser_actions [__acts++];  	while (__nacts-- > 0) {  		switch (_http_parser_actions [__acts++]) {  		case 10:  			#line  			{  				//Console.WriteLine("eof_leave_first_space");  			}  			break;  		case 30:  			#line  			{  				var toRead = pe - p;  				//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  				if (toRead > 0) {  					del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  					p += toRead - 1;  					{  						p++;  						if (true)  							goto _out;  					}  				} else {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						cs = 1;  						if (true)  							goto _again;  					} else {  						//Console.WriteLine("body_identity_eof: going to dead");  						p--;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				}  			}  			break;  		#line  		default:  			break;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (p == eof) {  	int __acts = _http_parser_eof_actions [cs];  	int __nacts = _http_parser_actions [__acts++];  	while (__nacts-- > 0) {  		switch (_http_parser_actions [__acts++]) {  		case 10:  			#line  			{  				//Console.WriteLine("eof_leave_first_space");  			}  			break;  		case 30:  			#line  			{  				var toRead = pe - p;  				//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  				if (toRead > 0) {  					del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  					p += toRead - 1;  					{  						p++;  						if (true)  							goto _out;  					}  				} else {  					del.OnMessageEnd (this);  					if (ShouldKeepAlive) {  						cs = 1;  						if (true)  							goto _again;  					} else {  						//Console.WriteLine("body_identity_eof: going to dead");  						p--;  						{  							cs = 130;  							if (true)  								goto _again;  						}  					}  				}  			}  			break;  		#line  		default:  			break;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (__nacts-- > 0) {  	switch (_http_parser_actions [__acts++]) {  	case 10:  		#line  		{  			//Console.WriteLine("eof_leave_first_space");  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (__nacts-- > 0) {  	switch (_http_parser_actions [__acts++]) {  	case 10:  		#line  		{  			//Console.WriteLine("eof_leave_first_space");  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: while (__nacts-- > 0) {  	switch (_http_parser_actions [__acts++]) {  	case 10:  		#line  		{  			//Console.WriteLine("eof_leave_first_space");  		}  		break;  	case 30:  		#line  		{  			var toRead = pe - p;  			//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  			if (toRead > 0) {  				del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  				p += toRead - 1;  				{  					p++;  					if (true)  						goto _out;  				}  			} else {  				del.OnMessageEnd (this);  				if (ShouldKeepAlive) {  					cs = 1;  					if (true)  						goto _again;  				} else {  					//Console.WriteLine("body_identity_eof: going to dead");  					p--;  					{  						cs = 130;  						if (true)  							goto _again;  					}  				}  			}  		}  		break;  	#line  	default:  		break;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [__acts++]) {  case 10:  	#line  	{  		//Console.WriteLine("eof_leave_first_space");  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [__acts++]) {  case 10:  	#line  	{  		//Console.WriteLine("eof_leave_first_space");  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: switch (_http_parser_actions [__acts++]) {  case 10:  	#line  	{  		//Console.WriteLine("eof_leave_first_space");  	}  	break;  case 30:  	#line  	{  		var toRead = pe - p;  		//Console.WriteLine("body_identity_eof: reading " + toRead + " bytes from body.");  		if (toRead > 0) {  			del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  			p += toRead - 1;  			{  				p++;  				if (true)  					goto _out;  			}  		} else {  			del.OnMessageEnd (this);  			if (ShouldKeepAlive) {  				cs = 1;  				if (true)  					goto _again;  			} else {  				//Console.WriteLine("body_identity_eof: going to dead");  				p--;  				{  					cs = 130;  					if (true)  						goto _again;  				}  			}  		}  	}  	break;  #line  default:  	break;  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (toRead > 0) {  	del.OnBody (this' new ArraySegment<byte> (data' p' toRead));  	p += toRead - 1;  	{  		p++;  		if (true)  			goto _out;  	}  } else {  	del.OnMessageEnd (this);  	if (ShouldKeepAlive) {  		cs = 1;  		if (true)  			goto _again;  	} else {  		//Console.WriteLine("body_identity_eof: going to dead");  		p--;  		{  			cs = 130;  			if (true)  				goto _again;  		}  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: if (ShouldKeepAlive) {  	cs = 1;  	if (true)  		goto _again;  } else {  	//Console.WriteLine("body_identity_eof: going to dead");  	p--;  	{  		cs = 130;  		if (true)  			goto _again;  	}  }  
Magic Number,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The following statement contains a magic number: cs = 130;  
Duplicate Code,HttpMachine,HttpParser,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\..\lib\httpmachine\src\HttpMachine\HttpParser.cs,Execute,The method contains a code clone-set at the following line numbers (starting from the method definition): ((369' 406)' (424' 461))
Missing Default,Kayak.Http,ParserToTransactionTransform,F:\newReposMay17\adammhaile_Elpis\Libs\kayak\Kayak\Http\Parsing\ParserToTransactionTransform.cs,Commit,The following switch statement is missing a default case: switch (e.Type) {  case ParserEventType.RequestHeaders:  	transactionDelegate.OnRequest (transaction' new HttpRequestHead () {  		Method = e.Request.Method'  		Uri = e.Request.Uri'  		Path = e.Request.Path'  		Fragment = e.Request.Fragment'  		QueryString = e.Request.QueryString'  		Version = e.Request.Version'  		Headers = e.Request.Headers  	}' e.KeepAlive);  	break;  case ParserEventType.RequestBody:  	if (!queue.HasEvents)  		return transactionDelegate.OnRequestData (transaction' e.Data' continuation);  	transactionDelegate.OnRequestData (transaction' e.Data' null);  	break;  case ParserEventType.RequestEnded:  	transactionDelegate.OnRequestEnd (transaction);  	break;  }  
