Implementation smell,Namespace,Class,File,Method,Description
Long Method,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The method has 106 lines of code.
Long Method,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,TryGetHeader,The method has 135 lines of code.
Long Method,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The method has 128 lines of code.
Long Method,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,The method has 118 lines of code.
Complex Method,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,Cyclomatic complexity of the method is 9
Complex Method,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,SendConnectionlessMessageAsync,Cyclomatic complexity of the method is 8
Complex Method,Tempest.Providers.Network,UdpServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnConnectMessage,Cyclomatic complexity of the method is 10
Complex Method,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,TryGetHeader,Cyclomatic complexity of the method is 10
Complex Method,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,Cyclomatic complexity of the method is 15
Complex Method,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,Cyclomatic complexity of the method is 9
Long Parameter List,Tempest.Providers.Network,ClientMessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ClientMessageSerializer.cs,VerifyMessage,The method has 6 parameters. Parameters: hashAlg' message' signature' data' moffset' length
Long Parameter List,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The method has 5 parameters. Parameters: message' dontSetId' responseRequested' timeout' responseTask
Long Parameter List,Tempest.Providers.Network,UdpServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,UdpServerConnection,The method has 6 parameters. Parameters: connectionId' remoteEndpoint' provider' remoteCrypto' localCrypto' key
Long Parameter List,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The method has 7 parameters. Parameters: buffer' bufferOffset' messageOffset' remainingData' header' reader' messageIdCallback
Long Parameter List,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,VerifyMessage,The method has 6 parameters. Parameters: hashAlg' message' signature' data' moffset' length
Long Parameter List,Tempest.Providers.Network,ServerMessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ServerMessageSerializer.cs,VerifyMessage,The method has 6 parameters. Parameters: hashAlg' message' signature' data' moffset' length
Long Parameter List,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,The method has 5 parameters. Parameters: message' isResponse' requestingResponse' responseTimeout' responseTask
Long Parameter List,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,NetworkConnectionProvider,The method has 5 parameters. Parameters: protocols' target' maxConnections' authKey' enabledHashAlgorithms
Long Statement,Tempest,BufferValueWriter,C:\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,WriteBytes,The length of the statement  "				throw new ArgumentOutOfRangeException ("length"' "length can not be negative or combined with offset longer than the array"); " is 125.
Long Statement,Tempest,BufferValueWriter,C:\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,InsertBytes,The length of the statement  "				throw new ArgumentOutOfRangeException ("length"' "length can not be negative or combined with offset longer than the array"); " is 125.
Long Statement,Tempest,TargetExtensions,C:\repos\ermau_Tempest\Desktop\Tempest\TargetExtensions.cs,ToIPEndPointAsync,The length of the statement  "			var addresses = await Task<IEnumerable<IPAddress>>.Factory.FromAsync (result' helper.EndGetHostEntry).ConfigureAwait (false); " is 125.
Long Statement,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,ResendPending,The length of the statement  "				foreach (Tuple<DateTime' Message> pending in this.pendingAck.Values.Where (pending => now - pending.Item1 > span).ToArray()) { " is 126.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,SendConnectionlessMessageAsync,The length of the statement  "			else if (endPoint.AddressFamily != AddressFamily.InterNetwork && endPoint.AddressFamily != AddressFamily.InterNetworkV6) " is 120.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,Receive,The length of the statement  "			if (!this.connectionlessSerializer.TryGetHeader (reader' args.BytesTransferred' ref header) || header.Message == null) { " is 120.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,HandleConnectionMessage,The length of the statement  "			List<Message> messages = serializer.BufferMessages (ref buffer' ref offset' ref moffset' ref remaining' ref header' ref reader); " is 128.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,HandleConnectionlessMessage,The length of the statement  "			List<Message> messages = this.connectionlessSerializer.BufferMessages (ref buffer' ref bufferOffset' ref messageOffset' ref remaining' ref header' ref reader); " is 159.
Long Statement,Tempest.Providers.Network,UdpConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionProvider.cs,OnConnectionlessTempestMessage,The length of the statement  "					connection = new UdpServerConnection (GetConnectionId()' target.ToEndPoint()' this' new RSACrypto()' this.crypto' this.authKey); " is 128.
Long Statement,Tempest.Providers.Network,UdpServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnConnectMessage,The length of the statement  "					this.provider.SendConnectionlessMessageAsync (new DisconnectMessage { Reason = ConnectionResult.IncompatibleVersion }' RemoteTarget); " is 133.
Long Statement,Tempest.Providers.Network,UdpServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnConnectMessage,The length of the statement  "					this.provider.SendConnectionlessMessageAsync (new DisconnectMessage { Reason = ConnectionResult.IncompatibleVersion }' RemoteTarget); " is 133.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,TryGetHeader,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Entering {0}"' (header == null) ? "without existing header" : "with existing header")' callCategory); " is 157.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "			callCategory = String.Format ("{0} {1}:BufferMessages({2}'{3}'{4}'{5}'{6})"' this.connectionType' c' buffer.Length' bufferOffset' messageOffset' remainingData' reader.Position); " is 177.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Message not fully received (boffset={0})"' bufferOffset)' callCategory); " is 128.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Reading payload for message {0}"' header.Message)' callCategory); " is 121.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "						if (!VerifyMessage (this.signingHashAlgorithm' header.Message' signature' buffer' messageOffset' payloadLength - messageOffset)) " is 128.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("EOL: moffset={0}'boffest={1}'rdata={2}'rpos={3}"' messageOffset' bufferOffset' remainingData' reader.Position)' callCategory); " is 182.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' (remainingData > 0) ? String.Format ("Data remaining: {0:N0}"' remainingData) : "Insufficient room for a header"' callCategory); " is 168.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Exiting (sufficient room; boffest={0}'rpos={1})"' bufferOffset' pos)' callCategory); " is 140.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Exiting (moved message to front' moffset={1}'boffset={2}'rpos={0})"' reader.Position' messageOffset' bufferOffset)' callCategory); " is 186.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,EncryptMessage,The length of the statement  "			byte[] payload = encryptor.TransformFinalBlock (writer.Buffer' workingHeaderLength' writer.Length - workingHeaderLength); " is 121.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,DecryptMessage,The length of the statement  "			//Trace.WriteLineIf (NTrace.TraceVerbose' "Entering"' String.Format ("{0}:{2} {1}:DecryptMessage({3}'{4})"' this.typeName' c' connectionId' header.IV.Length' r.Position)); " is 171.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,DecryptMessage,The length of the statement  "			//Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting"' String.Format ("{0}:{2} {1}:DecryptMessage({3}'{4}'{5})"' this.typeName' c' connectionId' header.IV.Length' r.Position' message.Length)); " is 190.
Long Statement,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,VerifyMessage,The length of the statement  "			callCategory = String.Format ("{0} {1}:VerifyMessage({2}'{3}'{4}'{5}'{6}'{7})"' this.connectionType' c' hashAlg' message' signature.Length' data.Length' moffset' length); " is 170.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectAsync,The length of the statement  "			string category = String.Format ("{2}:{3} {4}:ConnectAsync({0}'{1})"' target' messageTypes' this.typeName' connectionId' c); " is 124.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectAsync,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for pending ({0}) async.."' this.pendingAsync)' category); " is 122.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Entering"' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 176.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 209.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' "Already disconnected"' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 188.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 209.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "				//Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 211.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "			//Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 211.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting"' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 175.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Dispose,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for {0} pending asyncs"' this.pendingAsync)' String.Format ("{0}:{1} Dispose()"' this.typeName' connectionId)); " is 175.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableReceiveCompleted,The length of the statement  "			callCategory = String.Format ("{2}:{4} {3}:ReliableReceiveCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' this.connectionId); " is 151.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableReceiveCompleted,The length of the statement  "				List<Message> messages = slzr.BufferMessages (ref this.rmessageBuffer' ref bufferOffset' ref this.rmessageOffset' ref this.rmessageLoaded' ref this.currentHeader' ref this.rreader' CheckMessageId); " is 197.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableReceiveCompleted,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Exited BufferMessages with new values: {0}'{1}'{2}'{3}'{4}"' this.rmessageBuffer.Length' bufferOffset' this.rmessageOffset' this.rmessageLoaded' this.rreader.Position)' callCategory); " is 239.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,CheckMessageId,The length of the statement  "				this.lastMessageId = (header.MessageId != MaxMessageId) ? header.MessageId : 0; // BUG: Skipped messages will break this " is 120.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Disconnect,The length of the statement  "						Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Async DC waiting for pending ({0}) async."' pendingAsync)' category); " is 125.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Entering"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 181.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' "Got state lock"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 187.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Raising Disconnected"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 193.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 214.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 180.
Long Statement,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableSendCompleted,The length of the statement  "			callCategory = String.Format ("{2}:{4} {3}:ReliableSendCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' con.typeName' c' con.connectionId); " is 146.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Stop,The length of the statement  "				Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Closing unreliable socket"' "NetworkConnectionProvider Stop"); " is 121.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Connect,The length of the statement  "				Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Connection rejected"' "NetworkConnectionProvider ConnectAsync"); " is 123.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Accept,The length of the statement  "			Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Entering"' String.Format ("NetworkConnectionProvider Accept({0}'{1})"' e.BytesTransferred' e.SocketError)); " is 166.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Accept,The length of the statement  "				Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Exiting"' String.Format ("NetworkConnectionProvider Accept({0}'{1})"' e.BytesTransferred' e.SocketError)); " is 165.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Accept,The length of the statement  "					Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' String.Format ("At MaxConnections ({0})' disconnecting"' MaxConnections)' String.Format ("NetworkConnectionProvider Accept({0}'{1})"' e.BytesTransferred' e.SocketError)); " is 228.
Complex Conditional,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The conditional expression  "sock == null || mserialzier == null || (!IsConnected && !IsConnecting)"  is complex.
Complex Conditional,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,Receive,The conditional expression  "!fromPartials && message.Header.MessageId != 0 && (args.Message.MustBeReliable || args.Message.PreferReliable)"  is complex.
Empty Catch Block,Tempest,RSACrypto,C:\repos\ermau_Tempest\Desktop\Tempest\RSACrypto.cs,RSACrypto,The method has an empty catch block.
Empty Catch Block,Tempest,RSACrypto,C:\repos\ermau_Tempest\Desktop\Tempest\RSACrypto.cs,RSACrypto,The method has an empty catch block.
Magic Number,Tempest,RSAAsymmetricKey,C:\repos\ermau_Tempest\Desktop\Tempest\RSAAsymmetricKey.cs,Serialize,The following statement contains a magic number: int first = this.Modulus.Length / 2;
Magic Number,Tempest,BufferValueReader,C:\repos\ermau_Tempest\Desktop\Tempest\BufferValueReader.cs,ReadInt16,The following statement contains a magic number: this.ptr += 2;
Magic Number,Tempest,BufferValueReader,C:\repos\ermau_Tempest\Desktop\Tempest\BufferValueReader.cs,ReadDecimal,The following statement contains a magic number: int[] parts = new int[4];
Magic Number,Tempest,BufferValueWriter,C:\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,EnsureAdditionalCapacity,The following statement contains a magic number: int newLength = curLength * 2;
Magic Number,Tempest,BufferValueWriter,C:\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,EnsureAdditionalCapacity,The following statement contains a magic number: while (newLength <= curLength + additionalCapacity)  				newLength *= 2;
Magic Number,Tempest,Timer,C:\repos\ermau_Tempest\Desktop\Tempest\Timer.cs,TimerProcess,The following statement contains a magic number: while (this.alive)  			{  				Thread.Sleep (this.interval / 4);  				if (!this.running)  					last = DateTime.Now;  				else if (DateTime.Now.Subtract (last).TotalMilliseconds > this.interval)  				{  					var timeup = TimesUp;  					if (timeup != null)  						timeup (this' EventArgs.Empty);    					last = DateTime.Now;    					if (!this.autoReset)  						this.running = false;  				}  			}
Magic Number,Tempest.Providers.Network,BufferPool,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\BufferPool.cs,BufferPool,The following statement contains a magic number: AutoSizeFactor = 2;
Magic Number,Tempest.Providers.Network,UdpClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,ConnectAsync,The following statement contains a magic number: ThreadPool.QueueUserWorkItem (s =>  			{  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for pending ({0}) async.."' this.pendingAsync));    				while (this.pendingAsync > 0 || Interlocked.CompareExchange (ref this.connectTcs' ntcs' null) != null)  					Thread.Sleep (0);    				int p = Interlocked.Increment (ref this.pendingAsync);  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p));    				this.serializer = new ClientMessageSerializer (this' this.originalProtocols);    				IEnumerable<string> hashAlgs = null;  				if (this.localCrypto != null)  					hashAlgs = this.localCrypto.SupportedHashAlgs;    				Start (messageTypes);    				this.socket = this.listener.GetSocket (IPEndPoint);    				Timer dtimer = new Timer (100);  				dtimer.TimesUp += OnDeliveryTimer;  				dtimer.Start();  				this.deliveryTimer = dtimer;    				Timer t = new Timer (30000);  				Timer previousTimer = Interlocked.Exchange (ref this.connectTimer' t);  				if (previousTimer != null)  					previousTimer.Dispose();    				t.AutoReset = false;  				t.TimesUp += (sender' args) =>  				{  					var tcs = this.connectTcs;  					if (tcs != null)  						tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.ConnectionFailed' null));    					Disconnect (ConnectionResult.ConnectionFailed);  					t.Dispose();  				};  				t.Start();    				RemoteTarget = target;  				SendAsync (new ConnectMessage  				{  					Protocols = Protocols'  					SignatureHashAlgorithms = hashAlgs  				}).ContinueWith (st =>  				{  					int pa = Interlocked.Decrement (ref this.pendingAsync);  					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' pa));  				});  			});
Magic Number,Tempest.Providers.Network,UdpClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,ConnectAsync,The following statement contains a magic number: ThreadPool.QueueUserWorkItem (s =>  			{  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for pending ({0}) async.."' this.pendingAsync));    				while (this.pendingAsync > 0 || Interlocked.CompareExchange (ref this.connectTcs' ntcs' null) != null)  					Thread.Sleep (0);    				int p = Interlocked.Increment (ref this.pendingAsync);  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p));    				this.serializer = new ClientMessageSerializer (this' this.originalProtocols);    				IEnumerable<string> hashAlgs = null;  				if (this.localCrypto != null)  					hashAlgs = this.localCrypto.SupportedHashAlgs;    				Start (messageTypes);    				this.socket = this.listener.GetSocket (IPEndPoint);    				Timer dtimer = new Timer (100);  				dtimer.TimesUp += OnDeliveryTimer;  				dtimer.Start();  				this.deliveryTimer = dtimer;    				Timer t = new Timer (30000);  				Timer previousTimer = Interlocked.Exchange (ref this.connectTimer' t);  				if (previousTimer != null)  					previousTimer.Dispose();    				t.AutoReset = false;  				t.TimesUp += (sender' args) =>  				{  					var tcs = this.connectTcs;  					if (tcs != null)  						tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.ConnectionFailed' null));    					Disconnect (ConnectionResult.ConnectionFailed);  					t.Dispose();  				};  				t.Start();    				RemoteTarget = target;  				SendAsync (new ConnectMessage  				{  					Protocols = Protocols'  					SignatureHashAlgorithms = hashAlgs  				}).ContinueWith (st =>  				{  					int pa = Interlocked.Decrement (ref this.pendingAsync);  					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' pa));  				});  			});
Magic Number,Tempest.Providers.Network,UdpClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,OnTempestMessage,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.AcknowledgeConnect:  				{  					var msg = (AcknowledgeConnectMessage)e.Message;    					this.serializer.Protocols = this.serializer.Protocols.Intersect (msg.EnabledProtocols);  					ConnectionId = msg.ConnectionId;    					this.remoteEncryption = new RSACrypto();  					this.remoteEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();    					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					LocalKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.remoteEncryption);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.remoteEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = LocalKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					break;  				}    				case (ushort)TempestMessageType.Connected:  				{  					var msg = (ConnectedMessage)e.Message;  					  					ConnectionId = msg.ConnectionId;    					this.formallyConnected = true;    					Timer t = Interlocked.Exchange (ref this.connectTimer' null);  					if (t != null)  						t.Dispose();    					var tcs = Interlocked.Exchange (ref this.connectTcs' null);  					if (tcs != null)  					{  						if (tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.Success' RemoteKey)))  							OnConnected();  					}    					break;  				}    				default:  					base.OnTempestMessage (e);  					break;  			}
Magic Number,Tempest.Providers.Network,UdpClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,OnTempestMessage,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.AcknowledgeConnect:  				{  					var msg = (AcknowledgeConnectMessage)e.Message;    					this.serializer.Protocols = this.serializer.Protocols.Intersect (msg.EnabledProtocols);  					ConnectionId = msg.ConnectionId;    					this.remoteEncryption = new RSACrypto();  					this.remoteEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();    					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					LocalKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.remoteEncryption);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.remoteEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = LocalKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					break;  				}    				case (ushort)TempestMessageType.Connected:  				{  					var msg = (ConnectedMessage)e.Message;  					  					ConnectionId = msg.ConnectionId;    					this.formallyConnected = true;    					Timer t = Interlocked.Exchange (ref this.connectTimer' null);  					if (t != null)  						t.Dispose();    					var tcs = Interlocked.Exchange (ref this.connectTcs' null);  					if (tcs != null)  					{  						if (tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.Success' RemoteKey)))  							OnConnected();  					}    					break;  				}    				default:  					base.OnTempestMessage (e);  					break;  			}
Magic Number,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,UdpConnection,The following statement contains a magic number: BufferPool = new BufferPool (512) {  				AutoSizeLimit = true'  				AutoSizeFactor = 2  			};
Magic Number,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,UdpConnection,The following statement contains a magic number: BufferPool = new BufferPool (512) {  				AutoSizeLimit = true'  				AutoSizeFactor = 2  			};
Magic Number,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The following statement contains a magic number: if (!(message is PartialMessage) && length > 490)  			{  				byte count = (byte)Math.Ceiling ((length / 490f));    				int i = 0;  				  				int remaining = length;  				do  				{  					int payloadLen = Math.Min (490' remaining);    					var partial = new PartialMessage  					{  						OriginalMessageId = (ushort)message.Header.MessageId'  						Count = count'  						Header = new MessageHeader()  					};    					partial.SetPayload (buffer' i' payloadLen);  					if (i == 0) // We have to fill the gap the original id uses for reliability  						partial.Header.MessageId = message.Header.MessageId;  					else  						SetMessageId (partial);    					lock (this.pendingAck)  						this.pendingAck.Add (partial.Header.MessageId' new Tuple<DateTime' Message> (DateTime.UtcNow' partial));    					mserialzier.GetBytes (partial' out length' e.Buffer);    					e.SetBuffer (0' length);  					e.RemoteEndPoint = endPoint;    					remaining -= payloadLen;  					i += payloadLen;    					if (remaining == 0) {  						e.Completed += OnSendCompleted;  						e.UserToken = tcs;  					} else  						e.Completed += OnPartialSendCompleted;    					try {  						this.lastReliableSendActivity = Stopwatch.GetTimestamp();  						if (!sock.SendToAsync (e)) {  							if (remaining == 0)  								OnSendCompleted (this' e);  							else  								OnPartialSendCompleted (this' e);  						}  					} catch (ObjectDisposedException) {  						BufferPool.PushBuffer (e);    						if (remaining == 0)  							CleanupSend (e);  						else  							CleanupPartialSend (e);    						tcs.TrySetResult (false);  					}    					if (remaining > 0)  						BufferPool.TryGetBuffer (out e);  				} while (remaining > 0);  			}  			else  			{  				e.SetBuffer (0' length);  				e.RemoteEndPoint = endPoint;  				e.Completed += OnSendCompleted;  				e.UserToken = tcs;    				if (message.PreferReliable || message.MustBeReliable) {  					this.lastReliableSendActivity = Stopwatch.GetTimestamp();    					lock (this.pendingAck)  						this.pendingAck.Add (message.Header.MessageId' new Tuple<DateTime' Message> (DateTime.UtcNow' message));  				}    				try {  					if (!sock.SendToAsync (e))  						OnSendCompleted (this' e);  				} catch (ObjectDisposedException) {  					CleanupSend (e);  					tcs.TrySetResult (false);  				}  			}
Magic Number,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The following statement contains a magic number: if (!(message is PartialMessage) && length > 490)  			{  				byte count = (byte)Math.Ceiling ((length / 490f));    				int i = 0;  				  				int remaining = length;  				do  				{  					int payloadLen = Math.Min (490' remaining);    					var partial = new PartialMessage  					{  						OriginalMessageId = (ushort)message.Header.MessageId'  						Count = count'  						Header = new MessageHeader()  					};    					partial.SetPayload (buffer' i' payloadLen);  					if (i == 0) // We have to fill the gap the original id uses for reliability  						partial.Header.MessageId = message.Header.MessageId;  					else  						SetMessageId (partial);    					lock (this.pendingAck)  						this.pendingAck.Add (partial.Header.MessageId' new Tuple<DateTime' Message> (DateTime.UtcNow' partial));    					mserialzier.GetBytes (partial' out length' e.Buffer);    					e.SetBuffer (0' length);  					e.RemoteEndPoint = endPoint;    					remaining -= payloadLen;  					i += payloadLen;    					if (remaining == 0) {  						e.Completed += OnSendCompleted;  						e.UserToken = tcs;  					} else  						e.Completed += OnPartialSendCompleted;    					try {  						this.lastReliableSendActivity = Stopwatch.GetTimestamp();  						if (!sock.SendToAsync (e)) {  							if (remaining == 0)  								OnSendCompleted (this' e);  							else  								OnPartialSendCompleted (this' e);  						}  					} catch (ObjectDisposedException) {  						BufferPool.PushBuffer (e);    						if (remaining == 0)  							CleanupSend (e);  						else  							CleanupPartialSend (e);    						tcs.TrySetResult (false);  					}    					if (remaining > 0)  						BufferPool.TryGetBuffer (out e);  				} while (remaining > 0);  			}  			else  			{  				e.SetBuffer (0' length);  				e.RemoteEndPoint = endPoint;  				e.Completed += OnSendCompleted;  				e.UserToken = tcs;    				if (message.PreferReliable || message.MustBeReliable) {  					this.lastReliableSendActivity = Stopwatch.GetTimestamp();    					lock (this.pendingAck)  						this.pendingAck.Add (message.Header.MessageId' new Tuple<DateTime' Message> (DateTime.UtcNow' message));  				}    				try {  					if (!sock.SendToAsync (e))  						OnSendCompleted (this' e);  				} catch (ObjectDisposedException) {  					CleanupSend (e);  					tcs.TrySetResult (false);  				}  			}
Magic Number,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,ResendPending,The following statement contains a magic number: TimeSpan span = TimeSpan.FromMilliseconds (600);
Magic Number,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,Start,The following statement contains a magic number: {  				this.socket4 = new Socket (AddressFamily.InterNetwork' SocketType.Dgram' ProtocolType.Udp);  				#if !WINDOWS_PHONE  				this.socket4.EnableBroadcast = true;  				#endif  				this.socket4.Bind (new IPEndPoint (IPAddress.Any' this.port));    				var args = new SocketAsyncEventArgs();  				byte[] buffer = new byte[65507];  				args.SetBuffer (buffer' 0' buffer.Length);  				args.UserToken = new Tuple<Socket' BufferValueReader> (this.socket4' new BufferValueReader (buffer));  				args.Completed += Receive;  				args.RemoteEndPoint = new IPEndPoint (IPAddress.Any' this.port);    				while (!this.socket4.ReceiveFromAsync (args))  					Receive (this' args);  			}
Magic Number,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,Start,The following statement contains a magic number: if (Socket.OSSupportsIPv6)  			{  				this.socket6 = new Socket (AddressFamily.InterNetworkV6' SocketType.Dgram' ProtocolType.Udp);  				#if !WINDOWS_PHONE  				this.socket6.EnableBroadcast = true;  				#endif  				this.socket6.Bind (new IPEndPoint (IPAddress.IPv6Any' this.port));    				var args = new SocketAsyncEventArgs();  				byte[] buffer = new byte[65507];  				args.SetBuffer (buffer' 0' buffer.Length);  				args.UserToken = new Tuple<Socket' BufferValueReader> (this.socket6' new BufferValueReader (buffer));  				args.Completed += Receive;  				args.RemoteEndPoint = new IPEndPoint (IPAddress.IPv6Any' this.port);    				while (!this.socket6.ReceiveFromAsync (args))  					Receive (this' args);  			}
Magic Number,Tempest.Providers.Network,UdpConnectionlessListener,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,SendConnectionlessMessageAsync,The following statement contains a magic number: byte[] buffer = new byte[512];
Magic Number,Tempest.Providers.Network,UdpConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionProvider.cs,Start,The following statement contains a magic number: Timer timer = new Timer (100);
Magic Number,Tempest.Providers.Network,UdpServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnFinalConnectMessage,The following statement contains a magic number: try  			{  				byte[] aeskey = this.provider.pkEncryption.Decrypt (msg.AESKey);    				this.serializer.HMAC = new HMACSHA256 (aeskey);  				this.serializer.AES = new AesManaged { KeySize = 256' Key = aeskey };  			}  			catch  			{  				Disconnect (ConnectionResult.FailedHandshake);  				return;  			}
Magic Number,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,GetBytes,The following statement contains a magic number: writer.EnsureAdditionalCapacity (15);
Magic Number,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,GetBytes,The following statement contains a magic number: fixed (byte* bptr = writer.Buffer) {  				*bptr = message.Protocol.id;  				*((int*) (bptr + 1)) = cid;  				*((ushort*) (bptr + 5)) = message.MessageType;  				*((int*) (bptr + 11)) = messageId;    				if (message.Header.IsResponse) {  					*((int*) (bptr + 15)) = message.Header.ResponseMessageId;  					headerLength += sizeof(int);  				}  			}
Magic Number,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,GetBytes,The following statement contains a magic number: fixed (byte* bptr = writer.Buffer) {  				*bptr = message.Protocol.id;  				*((int*) (bptr + 1)) = cid;  				*((ushort*) (bptr + 5)) = message.MessageType;  				*((int*) (bptr + 11)) = messageId;    				if (message.Header.IsResponse) {  					*((int*) (bptr + 15)) = message.Header.ResponseMessageId;  					headerLength += sizeof(int);  				}  			}
Magic Number,Tempest.Providers.Network,MessageSerializer,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,GetBytes,The following statement contains a magic number: fixed (byte* bptr = writer.Buffer) {  				*bptr = message.Protocol.id;  				*((int*) (bptr + 1)) = cid;  				*((ushort*) (bptr + 5)) = message.MessageType;  				*((int*) (bptr + 11)) = messageId;    				if (message.Header.IsResponse) {  					*((int*) (bptr + 15)) = message.Header.ResponseMessageId;  					headerLength += sizeof(int);  				}  			}
Magic Number,Tempest.Providers.Network,ReliableQueue,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ReliableQueue.cs,TryEnqueue,The following statement contains a magic number: if (mid <= this.lastMessageInOrder || mid > (this.lastMessageInOrder + 2000))  				return false;
Magic Number,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					if (PingFrequency == 0 || this.activityTimer == null)  					{  						if (this.activityTimer != null)  							this.activityTimer.Dispose();    						if (ping.Interval != 0)  						{  							this.activityTimer = new Tempest.Timer (100);  							this.activityTimer.TimesUp += OnActivityTimer;  							this.activityTimer.Start();  						}  					}  					else if (ping.Interval != PingFrequency)  						this.activityTimer.Interval = ping.Interval;    					base.OnTempestMessageReceived (e);  					break;    				case (ushort)TempestMessageType.AcknowledgeConnect:  				    var msg = (AcknowledgeConnectMessage)e.Message;    				    this.protocols = this.protocols.Values.Intersect (msg.EnabledProtocols).ToDictionary (pr => pr.id);  					ConnectionId = msg.ConnectionId;    					this.serverEncryption = new RSACrypto();  					this.serverEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);  					this.serverEncryptionKey = (RSAAsymmetricKey) msg.PublicEncryptionKey;    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();  					  					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					this.publicAuthenticationKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.serverEncryption);    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.serverEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = this.publicAuthenticationKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    				    break;    				case (ushort)TempestMessageType.Connected:  					var connected = (ConnectedMessage) e.Message;  					ConnectionId = connected.ConnectionId;    					OnConnected (new ClientConnectionEventArgs (this));    					var tcs = Interlocked.Exchange (ref this.connectCompletion' null);  					if (tcs != null)  						tcs.SetResult (new ClientConnectionResult (ConnectionResult.Success' this.serverAuthenticationKey));    					break;    				default:  					base.OnTempestMessageReceived(e);  					break;  			}
Magic Number,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					if (PingFrequency == 0 || this.activityTimer == null)  					{  						if (this.activityTimer != null)  							this.activityTimer.Dispose();    						if (ping.Interval != 0)  						{  							this.activityTimer = new Tempest.Timer (100);  							this.activityTimer.TimesUp += OnActivityTimer;  							this.activityTimer.Start();  						}  					}  					else if (ping.Interval != PingFrequency)  						this.activityTimer.Interval = ping.Interval;    					base.OnTempestMessageReceived (e);  					break;    				case (ushort)TempestMessageType.AcknowledgeConnect:  				    var msg = (AcknowledgeConnectMessage)e.Message;    				    this.protocols = this.protocols.Values.Intersect (msg.EnabledProtocols).ToDictionary (pr => pr.id);  					ConnectionId = msg.ConnectionId;    					this.serverEncryption = new RSACrypto();  					this.serverEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);  					this.serverEncryptionKey = (RSAAsymmetricKey) msg.PublicEncryptionKey;    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();  					  					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					this.publicAuthenticationKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.serverEncryption);    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.serverEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = this.publicAuthenticationKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    				    break;    				case (ushort)TempestMessageType.Connected:  					var connected = (ConnectedMessage) e.Message;  					ConnectionId = connected.ConnectionId;    					OnConnected (new ClientConnectionEventArgs (this));    					var tcs = Interlocked.Exchange (ref this.connectCompletion' null);  					if (tcs != null)  						tcs.SetResult (new ClientConnectionResult (ConnectionResult.Success' this.serverAuthenticationKey));    					break;    				default:  					base.OnTempestMessageReceived(e);  					break;  			}
Magic Number,Tempest.Providers.Network,NetworkClientConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					if (PingFrequency == 0 || this.activityTimer == null)  					{  						if (this.activityTimer != null)  							this.activityTimer.Dispose();    						if (ping.Interval != 0)  						{  							this.activityTimer = new Tempest.Timer (100);  							this.activityTimer.TimesUp += OnActivityTimer;  							this.activityTimer.Start();  						}  					}  					else if (ping.Interval != PingFrequency)  						this.activityTimer.Interval = ping.Interval;    					base.OnTempestMessageReceived (e);  					break;    				case (ushort)TempestMessageType.AcknowledgeConnect:  				    var msg = (AcknowledgeConnectMessage)e.Message;    				    this.protocols = this.protocols.Values.Intersect (msg.EnabledProtocols).ToDictionary (pr => pr.id);  					ConnectionId = msg.ConnectionId;    					this.serverEncryption = new RSACrypto();  					this.serverEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);  					this.serverEncryptionKey = (RSAAsymmetricKey) msg.PublicEncryptionKey;    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();  					  					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					this.publicAuthenticationKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.serverEncryption);    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.serverEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = this.publicAuthenticationKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    				    break;    				case (ushort)TempestMessageType.Connected:  					var connected = (ConnectedMessage) e.Message;  					ConnectionId = connected.ConnectionId;    					OnConnected (new ClientConnectionEventArgs (this));    					var tcs = Interlocked.Exchange (ref this.connectCompletion' null);  					if (tcs != null)  						tcs.SetResult (new ClientConnectionResult (ConnectionResult.Success' this.serverAuthenticationKey));    					break;    				default:  					base.OnTempestMessageReceived(e);  					break;  			}
Magic Number,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,NetworkConnection,The following statement contains a magic number: MaxMessageSize = 1048576;
Magic Number,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Ping,The following statement contains a magic number: if (this.pingsOut >= 2)  			{  				// Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting (" + this.pingsOut + " pings out)"' callCategory);  				Disconnect (ConnectionResult.TimedOut); // Connection timed out  				return;  			}
Magic Number,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,The following statement contains a magic number: if (!writerAsyncArgs.TryPop (out eargs))  			{  				while (eargs == null)  				{  					int count = bufferCount;  					if (count == sendBufferLimit)  					{  						Trace.WriteLineIf (NTrace.TraceVerbose' "Waiting for writer args"' callCategory);    						SpinWait wait = new SpinWait();  						while (!writerAsyncArgs.TryPop (out eargs))  							wait.SpinOnce();  					}  					else if (count == Interlocked.CompareExchange (ref bufferCount' count + 1' count))  					{  						Trace.WriteLineIf (NTrace.TraceVerbose' "Creating new writer args"' callCategory);    						eargs = new SocketAsyncEventArgs();  						eargs.SetBuffer (new byte[1024]' 0' 1024);  						eargs.Completed += ReliableSendCompleted;  					}  				}  			}
Magic Number,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,The following statement contains a magic number: if (!writerAsyncArgs.TryPop (out eargs))  			{  				while (eargs == null)  				{  					int count = bufferCount;  					if (count == sendBufferLimit)  					{  						Trace.WriteLineIf (NTrace.TraceVerbose' "Waiting for writer args"' callCategory);    						SpinWait wait = new SpinWait();  						while (!writerAsyncArgs.TryPop (out eargs))  							wait.SpinOnce();  					}  					else if (count == Interlocked.CompareExchange (ref bufferCount' count + 1' count))  					{  						Trace.WriteLineIf (NTrace.TraceVerbose' "Creating new writer args"' callCategory);    						eargs = new SocketAsyncEventArgs();  						eargs.SetBuffer (new byte[1024]' 0' 1024);  						eargs.Completed += ReliableSendCompleted;  					}  				}  			}
Magic Number,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Disconnect,The following statement contains a magic number: lock (this.stateSync)  			{  				Trace.WriteLineIf (NTrace.TraceVerbose' "Shutting down socket"' category);    				if (this.disconnecting || this.reliableSocket == null)  				{  					Trace.WriteLineIf (NTrace.TraceVerbose' "Already disconnected' exiting"' category);  					tcs.SetResult (true);  					return tcs.Task;  				}    				this.disconnecting = true;  				this.disconnectingReason = reason;  				this.disconnectingCustomReason = customReason;    				int p = Interlocked.Increment (ref this.pendingAsync);  					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p)' category);    				if (!this.reliableSocket.Connected)  				{  					Trace.WriteLineIf (NTrace.TraceVerbose' "Socket not connected' finishing cleanup."' category);    					while (this.pendingAsync > 2) // If called from *Completed' there'll be a pending' plus our own.  						Thread.Sleep (0);    					tcs.SetResult (true);  				}  				else  				{  					Trace.WriteLineIf (NTrace.TraceVerbose' "Disconnecting asynchronously."' category);    					ThreadPool.QueueUserWorkItem (s =>  					{  						Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Async DC waiting for pending ({0}) async."' pendingAsync)' category);    						while (this.pendingAsync > 2) // Disconnect is pending.  							Thread.Sleep (0);    						Trace.WriteLineIf (NTrace.TraceVerbose' "Finished waiting' disconnecting async."' category);  						args.Completed += OnDisconnectCompleted;  						  						if (!this.reliableSocket.DisconnectAsync (args))				  							OnDisconnectCompleted (this.reliableSocket' args);    						tcs.SetResult (true);  					});    					return tcs.Task;  				}  			}
Magic Number,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Disconnect,The following statement contains a magic number: lock (this.stateSync)  			{  				Trace.WriteLineIf (NTrace.TraceVerbose' "Shutting down socket"' category);    				if (this.disconnecting || this.reliableSocket == null)  				{  					Trace.WriteLineIf (NTrace.TraceVerbose' "Already disconnected' exiting"' category);  					tcs.SetResult (true);  					return tcs.Task;  				}    				this.disconnecting = true;  				this.disconnectingReason = reason;  				this.disconnectingCustomReason = customReason;    				int p = Interlocked.Increment (ref this.pendingAsync);  					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p)' category);    				if (!this.reliableSocket.Connected)  				{  					Trace.WriteLineIf (NTrace.TraceVerbose' "Socket not connected' finishing cleanup."' category);    					while (this.pendingAsync > 2) // If called from *Completed' there'll be a pending' plus our own.  						Thread.Sleep (0);    					tcs.SetResult (true);  				}  				else  				{  					Trace.WriteLineIf (NTrace.TraceVerbose' "Disconnecting asynchronously."' category);    					ThreadPool.QueueUserWorkItem (s =>  					{  						Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Async DC waiting for pending ({0}) async."' pendingAsync)' category);    						while (this.pendingAsync > 2) // Disconnect is pending.  							Thread.Sleep (0);    						Trace.WriteLineIf (NTrace.TraceVerbose' "Finished waiting' disconnecting async."' category);  						args.Completed += OnDisconnectCompleted;  						  						if (!this.reliableSocket.DisconnectAsync (args))				  							OnDisconnectCompleted (this.reliableSocket' args);    						tcs.SetResult (true);  					});    					return tcs.Task;  				}  			}
Magic Number,Tempest.Providers.Network,NetworkConnectionProvider,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Start,The following statement contains a magic number: this.pingTimer = new Timer (100);
Magic Number,Tempest.Providers.Network,NetworkServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,NetworkServerConnection,The following statement contains a magic number: asyncArgs.SetBuffer (this.rmessageBuffer' 0' 20480);
Magic Number,Tempest.Providers.Network,NetworkServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  		    {  		        case (ushort)TempestMessageType.Connect:  		            var msg = (ConnectMessage)e.Message;    					if (!IsConnected)  						return;    					if (!msg.Protocols.Any())  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					if (this.requiresHandshake)  					{  						bool foundHashAlg = false;  						foreach (string hashAlg in this.signatureHashAlgs)  						{  							if (msg.SignatureHashAlgorithms.Contains (hashAlg))  							{  								this.serializer.SigningHashAlgorithm = hashAlg;  								foundHashAlg = true;  								break;  							}  						}    						if (!foundHashAlg)  						{  							DisconnectAsync (ConnectionResult.FailedHandshake);  							return;  						}  					}    					ConnectionId = this.provider.GetConnectionId();    					foreach (Protocol ip in msg.Protocols)  					{  						Protocol lp;  						if (!this.protocols.TryGetValue (ip.id' out lp) || !lp.CompatibleWith (ip))  						{  							DisconnectAsync (ConnectionResult.IncompatibleVersion);  							return;  						}  					}    					this.protocols = this.protocols.Values.Intersect (msg.Protocols).ToDictionary (p => p.id);  					this.receivedProtocols = true;    					if (!this.requiresHandshake)  					{  						this.formallyConnected = true;  						this.provider.Connect (this);  						e.Connection.SendAsync (new ConnectedMessage());  					}  					else  					{  						while (!this.authReady)  							Thread.Sleep(0);    						MessageSerializer s = this.serializer;  						if (s == null)  							return;    						e.Connection.SendAsync (new AcknowledgeConnectMessage  						{  							SignatureHashAlgorithm = s.SigningHashAlgorithm'  							EnabledProtocols = this.protocols.Values'  							ConnectionId = ConnectionId'  							PublicAuthenticationKey = this.provider.PublicAuthenticationKey'  							PublicEncryptionKey = this.provider.PublicEncryptionKey  						});  					}  		    		break;    				case (ushort)TempestMessageType.FinalConnect:  					if (!this.receivedProtocols)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					var finalConnect = (FinalConnectMessage)e.Message;    					if (finalConnect.AESKey == null || finalConnect.AESKey.Length == 0 || finalConnect.PublicAuthenticationKey == null)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					try  					{  						byte[] aeskey = this.provider.pkEncryption.Decrypt (finalConnect.AESKey);    						this.serializer.HMAC = new HMACSHA256 (aeskey);  						this.serializer.AES = new AesManaged { KeySize = 256' Key = aeskey };  					}  					catch  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					this.formallyConnected = true;  					this.provider.Connect (this);    					SendAsync (new ConnectedMessage { ConnectionId = ConnectionId });    					break;  		    }
Missing Default,Tempest.Providers.Network,UdpConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,OnTempestMessage,The following switch statement is missing a default case: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Partial:  					ReceivePartialMessage ((PartialMessage)e.Message);  					break;    				case (ushort)TempestMessageType.Acknowledge:  					lock (this.pendingAck)  					{  						int[] msgIds = ((AcknowledgeMessage)e.Message).MessageIds;  						foreach (int id in msgIds)  							this.pendingAck.Remove (id);  					}  					break;    				case (ushort)TempestMessageType.Disconnect:  					var msg = (DisconnectMessage)e.Message;  					Disconnect (msg.Reason' msg.CustomReason);  					break;  			}
Missing Default,Tempest.Providers.Network,NetworkConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnTempestMessageReceived,The following switch statement is missing a default case: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					this.pingFrequency = ping.Interval;  					SendResponseAsync (e.Message' new PongMessage());  					break;    				case (ushort)TempestMessageType.Pong:  					this.pingsOut = 0;  					break;    				case (ushort)TempestMessageType.Disconnect:  					var msg = (DisconnectMessage)e.Message;  					Disconnect (msg.Reason' msg.CustomReason' notify: false);  					break;  			}
Missing Default,Tempest.Providers.Network,NetworkServerConnection,C:\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,OnTempestMessageReceived,The following switch statement is missing a default case: switch (e.Message.MessageType)  		    {  		        case (ushort)TempestMessageType.Connect:  		            var msg = (ConnectMessage)e.Message;    					if (!IsConnected)  						return;    					if (!msg.Protocols.Any())  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					if (this.requiresHandshake)  					{  						bool foundHashAlg = false;  						foreach (string hashAlg in this.signatureHashAlgs)  						{  							if (msg.SignatureHashAlgorithms.Contains (hashAlg))  							{  								this.serializer.SigningHashAlgorithm = hashAlg;  								foundHashAlg = true;  								break;  							}  						}    						if (!foundHashAlg)  						{  							DisconnectAsync (ConnectionResult.FailedHandshake);  							return;  						}  					}    					ConnectionId = this.provider.GetConnectionId();    					foreach (Protocol ip in msg.Protocols)  					{  						Protocol lp;  						if (!this.protocols.TryGetValue (ip.id' out lp) || !lp.CompatibleWith (ip))  						{  							DisconnectAsync (ConnectionResult.IncompatibleVersion);  							return;  						}  					}    					this.protocols = this.protocols.Values.Intersect (msg.Protocols).ToDictionary (p => p.id);  					this.receivedProtocols = true;    					if (!this.requiresHandshake)  					{  						this.formallyConnected = true;  						this.provider.Connect (this);  						e.Connection.SendAsync (new ConnectedMessage());  					}  					else  					{  						while (!this.authReady)  							Thread.Sleep(0);    						MessageSerializer s = this.serializer;  						if (s == null)  							return;    						e.Connection.SendAsync (new AcknowledgeConnectMessage  						{  							SignatureHashAlgorithm = s.SigningHashAlgorithm'  							EnabledProtocols = this.protocols.Values'  							ConnectionId = ConnectionId'  							PublicAuthenticationKey = this.provider.PublicAuthenticationKey'  							PublicEncryptionKey = this.provider.PublicEncryptionKey  						});  					}  		    		break;    				case (ushort)TempestMessageType.FinalConnect:  					if (!this.receivedProtocols)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					var finalConnect = (FinalConnectMessage)e.Message;    					if (finalConnect.AESKey == null || finalConnect.AESKey.Length == 0 || finalConnect.PublicAuthenticationKey == null)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					try  					{  						byte[] aeskey = this.provider.pkEncryption.Decrypt (finalConnect.AESKey);    						this.serializer.HMAC = new HMACSHA256 (aeskey);  						this.serializer.AES = new AesManaged { KeySize = 256' Key = aeskey };  					}  					catch  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					this.formallyConnected = true;  					this.provider.Connect (this);    					SendAsync (new ConnectedMessage { ConnectionId = ConnectionId });    					break;  		    }
