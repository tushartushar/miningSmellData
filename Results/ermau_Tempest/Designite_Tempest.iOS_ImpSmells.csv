Implementation smell,Namespace,Class,File,Method,Description
Long Method,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,TryGetHeader,The method has 135 lines of code.
Long Method,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The method has 128 lines of code.
Long Method,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,The method has 118 lines of code.
Long Method,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The method has 106 lines of code.
Complex Method,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,GetBytes,Cyclomatic complexity of the method is 8
Complex Method,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,TryGetHeader,Cyclomatic complexity of the method is 22
Complex Method,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,Cyclomatic complexity of the method is 16
Complex Method,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,Cyclomatic complexity of the method is 9
Complex Method,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,Cyclomatic complexity of the method is 14
Complex Method,Tempest.Providers.Network,NetworkServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,OnTempestMessageReceived,Cyclomatic complexity of the method is 15
Complex Method,Tempest.Providers.Network,ReliableQueue,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ReliableQueue.cs,TryEnqueue,Cyclomatic complexity of the method is 9
Complex Method,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,Cyclomatic complexity of the method is 11
Complex Method,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,SendConnectionlessMessageAsync,Cyclomatic complexity of the method is 9
Complex Method,Tempest.Providers.Network,UdpServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnConnectMessage,Cyclomatic complexity of the method is 10
Long Parameter List,Tempest.Providers.Network,ClientMessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ClientMessageSerializer.cs,VerifyMessage,The method has 6 parameters. Parameters: hashAlg' message' signature' data' moffset' length
Long Parameter List,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The method has 7 parameters. Parameters: buffer' bufferOffset' messageOffset' remainingData' header' reader' messageIdCallback
Long Parameter List,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,VerifyMessage,The method has 6 parameters. Parameters: hashAlg' message' signature' data' moffset' length
Long Parameter List,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,SendMessage,The method has 5 parameters. Parameters: message' isResponse' requestingResponse' responseTimeout' responseTask
Long Parameter List,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,NetworkConnectionProvider,The method has 5 parameters. Parameters: protocols' target' maxConnections' authKey' enabledHashAlgorithms
Long Parameter List,Tempest.Providers.Network,ServerMessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ServerMessageSerializer.cs,VerifyMessage,The method has 6 parameters. Parameters: hashAlg' message' signature' data' moffset' length
Long Parameter List,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The method has 5 parameters. Parameters: message' dontSetId' responseRequested' timeout' responseTask
Long Parameter List,Tempest.Providers.Network,UdpServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,UdpServerConnection,The method has 6 parameters. Parameters: connectionId' remoteEndpoint' provider' remoteCrypto' localCrypto' key
Long Statement,Tempest,BufferValueWriter,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,WriteBytes,The length of the statement  "				throw new ArgumentOutOfRangeException ("length"' "length can not be negative or combined with offset longer than the array"); " is 125.
Long Statement,Tempest,BufferValueWriter,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,InsertBytes,The length of the statement  "				throw new ArgumentOutOfRangeException ("length"' "length can not be negative or combined with offset longer than the array"); " is 125.
Long Statement,Tempest,TargetExtensions,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\TargetExtensions.cs,ToIPEndPointAsync,The length of the statement  "			var addresses = await Task<IEnumerable<IPAddress>>.Factory.FromAsync (result' helper.EndGetHostEntry).ConfigureAwait (false); " is 125.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,TryGetHeader,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Entering {0}"' (header == null) ? "without existing header" : "with existing header")' callCategory); " is 157.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "			callCategory = String.Format ("{0} {1}:BufferMessages({2}'{3}'{4}'{5}'{6})"' this.connectionType' c' buffer.Length' bufferOffset' messageOffset' remainingData' reader.Position); " is 177.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Message not fully received (boffset={0})"' bufferOffset)' callCategory); " is 128.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Reading payload for message {0}"' header.Message)' callCategory); " is 121.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "						if (!VerifyMessage (this.signingHashAlgorithm' header.Message' signature' buffer' messageOffset' payloadLength - messageOffset)) " is 128.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("EOL: moffset={0}'boffest={1}'rdata={2}'rpos={3}"' messageOffset' bufferOffset' remainingData' reader.Position)' callCategory); " is 182.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' (remainingData > 0) ? String.Format ("Data remaining: {0:N0}"' remainingData) : "Insufficient room for a header"' callCategory); " is 168.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Exiting (sufficient room; boffest={0}'rpos={1})"' bufferOffset' pos)' callCategory); " is 140.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,BufferMessages,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Exiting (moved message to front' moffset={1}'boffset={2}'rpos={0})"' reader.Position' messageOffset' bufferOffset)' callCategory); " is 186.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,EncryptMessage,The length of the statement  "			byte[] payload = encryptor.TransformFinalBlock (writer.Buffer' workingHeaderLength' writer.Length - workingHeaderLength); " is 121.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,DecryptMessage,The length of the statement  "			//Trace.WriteLineIf (NTrace.TraceVerbose' "Entering"' String.Format ("{0}:{2} {1}:DecryptMessage({3}'{4})"' this.typeName' c' connectionId' header.IV.Length' r.Position)); " is 171.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,DecryptMessage,The length of the statement  "			//Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting"' String.Format ("{0}:{2} {1}:DecryptMessage({3}'{4}'{5})"' this.typeName' c' connectionId' header.IV.Length' r.Position' message.Length)); " is 190.
Long Statement,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,VerifyMessage,The length of the statement  "			callCategory = String.Format ("{0} {1}:VerifyMessage({2}'{3}'{4}'{5}'{6}'{7})"' this.connectionType' c' hashAlg' message' signature.Length' data.Length' moffset' length); " is 170.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectAsync,The length of the statement  "			string category = String.Format ("{2}:{3} {4}:ConnectAsync({0}'{1})"' target' messageTypes' this.typeName' connectionId' c); " is 124.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectAsync,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for pending ({0}) async.."' this.pendingAsync)' category); " is 122.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Entering"' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 176.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 209.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' "Already disconnected"' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 188.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 209.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "				//Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 211.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "			//Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 211.
Long Statement,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,ConnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting"' String.Format ("{2}:{3} {4}:ConnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' connectionId' c)); " is 175.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Dispose,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for {0} pending asyncs"' this.pendingAsync)' String.Format ("{0}:{1} Dispose()"' this.typeName' connectionId)); " is 175.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableReceiveCompleted,The length of the statement  "			callCategory = String.Format ("{2}:{4} {3}:ReliableReceiveCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' this.connectionId); " is 151.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableReceiveCompleted,The length of the statement  "				List<Message> messages = slzr.BufferMessages (ref this.rmessageBuffer' ref bufferOffset' ref this.rmessageOffset' ref this.rmessageLoaded' ref this.currentHeader' ref this.rreader' CheckMessageId); " is 197.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableReceiveCompleted,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Exited BufferMessages with new values: {0}'{1}'{2}'{3}'{4}"' this.rmessageBuffer.Length' bufferOffset' this.rmessageOffset' this.rmessageLoaded' this.rreader.Position)' callCategory); " is 239.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,CheckMessageId,The length of the statement  "				this.lastMessageId = (header.MessageId != MaxMessageId) ? header.MessageId : 0; // BUG: Skipped messages will break this " is 120.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Disconnect,The length of the statement  "						Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Async DC waiting for pending ({0}) async."' pendingAsync)' category); " is 125.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Entering"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 181.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "				Trace.WriteLineIf (NTrace.TraceVerbose' "Got state lock"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 187.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Raising Disconnected"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 193.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' p)' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 214.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnDisconnectCompleted,The length of the statement  "			Trace.WriteLineIf (NTrace.TraceVerbose' "Exiting"' String.Format ("{2}:{4} {3}:OnDisconnectCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' this.typeName' c' connectionId)); " is 180.
Long Statement,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,ReliableSendCompleted,The length of the statement  "			callCategory = String.Format ("{2}:{4} {3}:ReliableSendCompleted({0}'{1})"' e.BytesTransferred' e.SocketError' con.typeName' c' con.connectionId); " is 146.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Stop,The length of the statement  "				Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Closing unreliable socket"' "NetworkConnectionProvider Stop"); " is 121.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Connect,The length of the statement  "				Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Connection rejected"' "NetworkConnectionProvider ConnectAsync"); " is 123.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Accept,The length of the statement  "			Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Entering"' String.Format ("NetworkConnectionProvider Accept({0}'{1})"' e.BytesTransferred' e.SocketError)); " is 166.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Accept,The length of the statement  "				Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' "Exiting"' String.Format ("NetworkConnectionProvider Accept({0}'{1})"' e.BytesTransferred' e.SocketError)); " is 165.
Long Statement,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Accept,The length of the statement  "					Trace.WriteLineIf (NetworkConnection.NTrace.TraceVerbose' String.Format ("At MaxConnections ({0})' disconnecting"' MaxConnections)' String.Format ("NetworkConnectionProvider Accept({0}'{1})"' e.BytesTransferred' e.SocketError)); " is 228.
Long Statement,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,ResendPending,The length of the statement  "				foreach (Tuple<DateTime' Message> pending in this.pendingAck.Values.Where (pending => now - pending.Item1 > span).ToArray()) { " is 126.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,SendConnectionlessMessageAsync,The length of the statement  "			else if (endPoint.AddressFamily != AddressFamily.InterNetwork && endPoint.AddressFamily != AddressFamily.InterNetworkV6) " is 120.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,Receive,The length of the statement  "			if (!this.connectionlessSerializer.TryGetHeader (reader' args.BytesTransferred' ref header) || header.Message == null) { " is 120.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,HandleConnectionMessage,The length of the statement  "			List<Message> messages = serializer.BufferMessages (ref buffer' ref offset' ref moffset' ref remaining' ref header' ref reader); " is 128.
Long Statement,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,HandleConnectionlessMessage,The length of the statement  "			List<Message> messages = this.connectionlessSerializer.BufferMessages (ref buffer' ref bufferOffset' ref messageOffset' ref remaining' ref header' ref reader); " is 159.
Long Statement,Tempest.Providers.Network,UdpConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionProvider.cs,OnConnectionlessTempestMessage,The length of the statement  "					connection = new UdpServerConnection (GetConnectionId()' target.ToEndPoint()' this' new RSACrypto()' this.crypto' this.authKey); " is 128.
Long Statement,Tempest.Providers.Network,UdpServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnConnectMessage,The length of the statement  "					this.provider.SendConnectionlessMessageAsync (new DisconnectMessage { Reason = ConnectionResult.IncompatibleVersion }' RemoteTarget); " is 133.
Long Statement,Tempest.Providers.Network,UdpServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnConnectMessage,The length of the statement  "					this.provider.SendConnectionlessMessageAsync (new DisconnectMessage { Reason = ConnectionResult.IncompatibleVersion }' RemoteTarget); " is 133.
Complex Conditional,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The conditional expression  "sock == null || mserialzier == null || (!IsConnected && !IsConnecting)"  is complex.
Complex Conditional,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,Receive,The conditional expression  "!fromPartials && message.Header.MessageId != 0 && (args.Message.MustBeReliable || args.Message.PreferReliable)"  is complex.
Empty Catch Block,Tempest,RSACrypto,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\RSACrypto.cs,RSACrypto,The method has an empty catch block.
Empty Catch Block,Tempest,RSACrypto,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\RSACrypto.cs,RSACrypto,The method has an empty catch block.
Magic Number,Tempest,BufferValueReader,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\BufferValueReader.cs,ReadDecimal,The following statement contains a magic number: int[] parts = new int[4];
Magic Number,Tempest,BufferValueWriter,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,EnsureAdditionalCapacity,The following statement contains a magic number: int newLength = curLength * 2;
Magic Number,Tempest,BufferValueWriter,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\BufferValueWriter.cs,EnsureAdditionalCapacity,The following statement contains a magic number: newLength *= 2;
Magic Number,Tempest,RSAAsymmetricKey,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\RSAAsymmetricKey.cs,Serialize,The following statement contains a magic number: int first = this.Modulus.Length / 2;
Magic Number,Tempest,Timer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Timer.cs,TimerProcess,The following statement contains a magic number: Thread.Sleep (this.interval / 4);
Magic Number,Tempest.Providers.Network,BufferPool,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\BufferPool.cs,BufferPool,The following statement contains a magic number: AutoSizeFactor = 2;
Magic Number,Tempest.Providers.Network,MessageSerializer,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\MessageSerializer.cs,GetBytes,The following statement contains a magic number: writer.EnsureAdditionalCapacity (15);
Magic Number,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					if (PingFrequency == 0 || this.activityTimer == null)  					{  						if (this.activityTimer != null)  							this.activityTimer.Dispose();    						if (ping.Interval != 0)  						{  							this.activityTimer = new Tempest.Timer (100);  							this.activityTimer.TimesUp += OnActivityTimer;  							this.activityTimer.Start();  						}  					}  					else if (ping.Interval != PingFrequency)  						this.activityTimer.Interval = ping.Interval;    					base.OnTempestMessageReceived (e);  					break;    				case (ushort)TempestMessageType.AcknowledgeConnect:  				    var msg = (AcknowledgeConnectMessage)e.Message;    				    this.protocols = this.protocols.Values.Intersect (msg.EnabledProtocols).ToDictionary (pr => pr.id);  					ConnectionId = msg.ConnectionId;    					this.serverEncryption = new RSACrypto();  					this.serverEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);  					this.serverEncryptionKey = (RSAAsymmetricKey) msg.PublicEncryptionKey;    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();  					  					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					this.publicAuthenticationKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.serverEncryption);    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.serverEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = this.publicAuthenticationKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    				    break;    				case (ushort)TempestMessageType.Connected:  					var connected = (ConnectedMessage) e.Message;  					ConnectionId = connected.ConnectionId;    					OnConnected (new ClientConnectionEventArgs (this));    					var tcs = Interlocked.Exchange (ref this.connectCompletion' null);  					if (tcs != null)  						tcs.SetResult (new ClientConnectionResult (ConnectionResult.Success' this.serverAuthenticationKey));    					break;    				default:  					base.OnTempestMessageReceived(e);  					break;  			}
Magic Number,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					if (PingFrequency == 0 || this.activityTimer == null)  					{  						if (this.activityTimer != null)  							this.activityTimer.Dispose();    						if (ping.Interval != 0)  						{  							this.activityTimer = new Tempest.Timer (100);  							this.activityTimer.TimesUp += OnActivityTimer;  							this.activityTimer.Start();  						}  					}  					else if (ping.Interval != PingFrequency)  						this.activityTimer.Interval = ping.Interval;    					base.OnTempestMessageReceived (e);  					break;    				case (ushort)TempestMessageType.AcknowledgeConnect:  				    var msg = (AcknowledgeConnectMessage)e.Message;    				    this.protocols = this.protocols.Values.Intersect (msg.EnabledProtocols).ToDictionary (pr => pr.id);  					ConnectionId = msg.ConnectionId;    					this.serverEncryption = new RSACrypto();  					this.serverEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);  					this.serverEncryptionKey = (RSAAsymmetricKey) msg.PublicEncryptionKey;    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();  					  					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					this.publicAuthenticationKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.serverEncryption);    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.serverEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = this.publicAuthenticationKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    				    break;    				case (ushort)TempestMessageType.Connected:  					var connected = (ConnectedMessage) e.Message;  					ConnectionId = connected.ConnectionId;    					OnConnected (new ClientConnectionEventArgs (this));    					var tcs = Interlocked.Exchange (ref this.connectCompletion' null);  					if (tcs != null)  						tcs.SetResult (new ClientConnectionResult (ConnectionResult.Success' this.serverAuthenticationKey));    					break;    				default:  					base.OnTempestMessageReceived(e);  					break;  			}
Magic Number,Tempest.Providers.Network,NetworkClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkClientConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					if (PingFrequency == 0 || this.activityTimer == null)  					{  						if (this.activityTimer != null)  							this.activityTimer.Dispose();    						if (ping.Interval != 0)  						{  							this.activityTimer = new Tempest.Timer (100);  							this.activityTimer.TimesUp += OnActivityTimer;  							this.activityTimer.Start();  						}  					}  					else if (ping.Interval != PingFrequency)  						this.activityTimer.Interval = ping.Interval;    					base.OnTempestMessageReceived (e);  					break;    				case (ushort)TempestMessageType.AcknowledgeConnect:  				    var msg = (AcknowledgeConnectMessage)e.Message;    				    this.protocols = this.protocols.Values.Intersect (msg.EnabledProtocols).ToDictionary (pr => pr.id);  					ConnectionId = msg.ConnectionId;    					this.serverEncryption = new RSACrypto();  					this.serverEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);  					this.serverEncryptionKey = (RSAAsymmetricKey) msg.PublicEncryptionKey;    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();  					  					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					this.publicAuthenticationKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.serverEncryption);    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.serverEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = this.publicAuthenticationKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    				    break;    				case (ushort)TempestMessageType.Connected:  					var connected = (ConnectedMessage) e.Message;  					ConnectionId = connected.ConnectionId;    					OnConnected (new ClientConnectionEventArgs (this));    					var tcs = Interlocked.Exchange (ref this.connectCompletion' null);  					if (tcs != null)  						tcs.SetResult (new ClientConnectionResult (ConnectionResult.Success' this.serverAuthenticationKey));    					break;    				default:  					base.OnTempestMessageReceived(e);  					break;  			}
Magic Number,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,NetworkConnection,The following statement contains a magic number: MaxMessageSize = 1048576;
Magic Number,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Ping,The following statement contains a magic number: this.pingsOut >= 2
Magic Number,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,Disconnect,The following statement contains a magic number: this.pendingAsync > 2
Magic Number,Tempest.Providers.Network,NetworkConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnectionProvider.cs,Start,The following statement contains a magic number: this.pingTimer = new Timer (100);
Magic Number,Tempest.Providers.Network,NetworkServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,NetworkServerConnection,The following statement contains a magic number: asyncArgs.SetBuffer (this.rmessageBuffer' 0' 20480);
Magic Number,Tempest.Providers.Network,NetworkServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,OnTempestMessageReceived,The following statement contains a magic number: switch (e.Message.MessageType)  		    {  		        case (ushort)TempestMessageType.Connect:  		            var msg = (ConnectMessage)e.Message;    					if (!IsConnected)  						return;    					if (!msg.Protocols.Any())  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					if (this.requiresHandshake)  					{  						bool foundHashAlg = false;  						foreach (string hashAlg in this.signatureHashAlgs)  						{  							if (msg.SignatureHashAlgorithms.Contains (hashAlg))  							{  								this.serializer.SigningHashAlgorithm = hashAlg;  								foundHashAlg = true;  								break;  							}  						}    						if (!foundHashAlg)  						{  							DisconnectAsync (ConnectionResult.FailedHandshake);  							return;  						}  					}    					ConnectionId = this.provider.GetConnectionId();    					foreach (Protocol ip in msg.Protocols)  					{  						Protocol lp;  						if (!this.protocols.TryGetValue (ip.id' out lp) || !lp.CompatibleWith (ip))  						{  							DisconnectAsync (ConnectionResult.IncompatibleVersion);  							return;  						}  					}    					this.protocols = this.protocols.Values.Intersect (msg.Protocols).ToDictionary (p => p.id);  					this.receivedProtocols = true;    					if (!this.requiresHandshake)  					{  						this.formallyConnected = true;  						this.provider.Connect (this);  						e.Connection.SendAsync (new ConnectedMessage());  					}  					else  					{  						while (!this.authReady)  							Thread.Sleep(0);    						MessageSerializer s = this.serializer;  						if (s == null)  							return;    						e.Connection.SendAsync (new AcknowledgeConnectMessage  						{  							SignatureHashAlgorithm = s.SigningHashAlgorithm'  							EnabledProtocols = this.protocols.Values'  							ConnectionId = ConnectionId'  							PublicAuthenticationKey = this.provider.PublicAuthenticationKey'  							PublicEncryptionKey = this.provider.PublicEncryptionKey  						});  					}  		    		break;    				case (ushort)TempestMessageType.FinalConnect:  					if (!this.receivedProtocols)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					var finalConnect = (FinalConnectMessage)e.Message;    					if (finalConnect.AESKey == null || finalConnect.AESKey.Length == 0 || finalConnect.PublicAuthenticationKey == null)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					try  					{  						byte[] aeskey = this.provider.pkEncryption.Decrypt (finalConnect.AESKey);    						this.serializer.HMAC = new HMACSHA256 (aeskey);  						this.serializer.AES = new AesManaged { KeySize = 256' Key = aeskey };  					}  					catch  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					this.formallyConnected = true;  					this.provider.Connect (this);    					SendAsync (new ConnectedMessage { ConnectionId = ConnectionId });    					break;  		    }
Magic Number,Tempest.Providers.Network,ReliableQueue,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\ReliableQueue.cs,TryEnqueue,The following statement contains a magic number: mid <= this.lastMessageInOrder || mid > (this.lastMessageInOrder + 2000)
Magic Number,Tempest.Providers.Network,UdpClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,ConnectAsync,The following statement contains a magic number: ThreadPool.QueueUserWorkItem (s =>  			{  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for pending ({0}) async.."' this.pendingAsync));    				while (this.pendingAsync > 0 || Interlocked.CompareExchange (ref this.connectTcs' ntcs' null) != null)  					Thread.Sleep (0);    				int p = Interlocked.Increment (ref this.pendingAsync);  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p));    				this.serializer = new ClientMessageSerializer (this' this.originalProtocols);    				IEnumerable<string> hashAlgs = null;  				if (this.localCrypto != null)  					hashAlgs = this.localCrypto.SupportedHashAlgs;    				Start (messageTypes);    				this.socket = this.listener.GetSocket (IPEndPoint);    				Timer dtimer = new Timer (100);  				dtimer.TimesUp += OnDeliveryTimer;  				dtimer.Start();  				this.deliveryTimer = dtimer;    				Timer t = new Timer (30000);  				Timer previousTimer = Interlocked.Exchange (ref this.connectTimer' t);  				if (previousTimer != null)  					previousTimer.Dispose();    				t.AutoReset = false;  				t.TimesUp += (sender' args) =>  				{  					var tcs = this.connectTcs;  					if (tcs != null)  						tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.ConnectionFailed' null));    					Disconnect (ConnectionResult.ConnectionFailed);  					t.Dispose();  				};  				t.Start();    				RemoteTarget = target;  				SendAsync (new ConnectMessage  				{  					Protocols = Protocols'  					SignatureHashAlgorithms = hashAlgs  				}).ContinueWith (st =>  				{  					int pa = Interlocked.Decrement (ref this.pendingAsync);  					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' pa));  				});  			});
Magic Number,Tempest.Providers.Network,UdpClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,ConnectAsync,The following statement contains a magic number: ThreadPool.QueueUserWorkItem (s =>  			{  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Waiting for pending ({0}) async.."' this.pendingAsync));    				while (this.pendingAsync > 0 || Interlocked.CompareExchange (ref this.connectTcs' ntcs' null) != null)  					Thread.Sleep (0);    				int p = Interlocked.Increment (ref this.pendingAsync);  				Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Increment pending: {0}"' p));    				this.serializer = new ClientMessageSerializer (this' this.originalProtocols);    				IEnumerable<string> hashAlgs = null;  				if (this.localCrypto != null)  					hashAlgs = this.localCrypto.SupportedHashAlgs;    				Start (messageTypes);    				this.socket = this.listener.GetSocket (IPEndPoint);    				Timer dtimer = new Timer (100);  				dtimer.TimesUp += OnDeliveryTimer;  				dtimer.Start();  				this.deliveryTimer = dtimer;    				Timer t = new Timer (30000);  				Timer previousTimer = Interlocked.Exchange (ref this.connectTimer' t);  				if (previousTimer != null)  					previousTimer.Dispose();    				t.AutoReset = false;  				t.TimesUp += (sender' args) =>  				{  					var tcs = this.connectTcs;  					if (tcs != null)  						tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.ConnectionFailed' null));    					Disconnect (ConnectionResult.ConnectionFailed);  					t.Dispose();  				};  				t.Start();    				RemoteTarget = target;  				SendAsync (new ConnectMessage  				{  					Protocols = Protocols'  					SignatureHashAlgorithms = hashAlgs  				}).ContinueWith (st =>  				{  					int pa = Interlocked.Decrement (ref this.pendingAsync);  					Trace.WriteLineIf (NTrace.TraceVerbose' String.Format ("Decrement pending: {0}"' pa));  				});  			});
Magic Number,Tempest.Providers.Network,UdpClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,OnTempestMessage,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.AcknowledgeConnect:  				{  					var msg = (AcknowledgeConnectMessage)e.Message;    					this.serializer.Protocols = this.serializer.Protocols.Intersect (msg.EnabledProtocols);  					ConnectionId = msg.ConnectionId;    					this.remoteEncryption = new RSACrypto();  					this.remoteEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();    					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					LocalKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.remoteEncryption);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.remoteEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = LocalKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					break;  				}    				case (ushort)TempestMessageType.Connected:  				{  					var msg = (ConnectedMessage)e.Message;  					  					ConnectionId = msg.ConnectionId;    					this.formallyConnected = true;    					Timer t = Interlocked.Exchange (ref this.connectTimer' null);  					if (t != null)  						t.Dispose();    					var tcs = Interlocked.Exchange (ref this.connectTcs' null);  					if (tcs != null)  					{  						if (tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.Success' RemoteKey)))  							OnConnected();  					}    					break;  				}    				default:  					base.OnTempestMessage (e);  					break;  			}
Magic Number,Tempest.Providers.Network,UdpClientConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpClientConnection.cs,OnTempestMessage,The following statement contains a magic number: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.AcknowledgeConnect:  				{  					var msg = (AcknowledgeConnectMessage)e.Message;    					this.serializer.Protocols = this.serializer.Protocols.Intersect (msg.EnabledProtocols);  					ConnectionId = msg.ConnectionId;    					this.remoteEncryption = new RSACrypto();  					this.remoteEncryption.ImportKey ((RSAAsymmetricKey) msg.PublicEncryptionKey);    					var encryption = new AesManaged { KeySize = 256 };  					encryption.GenerateKey();    					BufferValueWriter authKeyWriter = new BufferValueWriter (new byte[1600]);  					LocalKey.Serialize (this.serializer.SerializationContext' authKeyWriter' this.remoteEncryption);    					SendAsync (new FinalConnectMessage  					{  						AESKey = this.remoteEncryption.Encrypt (encryption.Key)'  						PublicAuthenticationKeyType = LocalKey.GetType()'  						PublicAuthenticationKey = authKeyWriter.ToArray()  					});    					this.serializer.AES = encryption;  					this.serializer.HMAC = new HMACSHA256 (encryption.Key);    					break;  				}    				case (ushort)TempestMessageType.Connected:  				{  					var msg = (ConnectedMessage)e.Message;  					  					ConnectionId = msg.ConnectionId;    					this.formallyConnected = true;    					Timer t = Interlocked.Exchange (ref this.connectTimer' null);  					if (t != null)  						t.Dispose();    					var tcs = Interlocked.Exchange (ref this.connectTcs' null);  					if (tcs != null)  					{  						if (tcs.TrySetResult (new ClientConnectionResult (ConnectionResult.Success' RemoteKey)))  							OnConnected();  					}    					break;  				}    				default:  					base.OnTempestMessage (e);  					break;  			}
Magic Number,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,UdpConnection,The following statement contains a magic number: BufferPool = new BufferPool (512) {  				AutoSizeLimit = true'  				AutoSizeFactor = 2  			};
Magic Number,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,UdpConnection,The following statement contains a magic number: BufferPool = new BufferPool (512) {  				AutoSizeLimit = true'  				AutoSizeFactor = 2  			};
Magic Number,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The following statement contains a magic number: byte count = (byte)Math.Ceiling ((length / 490f));
Magic Number,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The following statement contains a magic number: int payloadLen = Math.Min (490' remaining);
Magic Number,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,SendCore,The following statement contains a magic number: !(message is PartialMessage) && length > 490
Magic Number,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,ResendPending,The following statement contains a magic number: TimeSpan span = TimeSpan.FromMilliseconds (600);
Magic Number,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,Start,The following statement contains a magic number: byte[] buffer = new byte[65507];
Magic Number,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,Start,The following statement contains a magic number: byte[] buffer = new byte[65507];
Magic Number,Tempest.Providers.Network,UdpConnectionlessListener,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionlessListener.cs,SendConnectionlessMessageAsync,The following statement contains a magic number: byte[] buffer = new byte[512];
Magic Number,Tempest.Providers.Network,UdpConnectionProvider,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnectionProvider.cs,Start,The following statement contains a magic number: Timer timer = new Timer (100);
Magic Number,Tempest.Providers.Network,UdpServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpServerConnection.cs,OnFinalConnectMessage,The following statement contains a magic number: this.serializer.AES = new AesManaged { KeySize = 256' Key = aeskey };
Missing Default,Tempest.Providers.Network,NetworkConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkConnection.cs,OnTempestMessageReceived,The following switch statement is missing a default case: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Ping:  					var ping = (PingMessage)e.Message;  					this.pingFrequency = ping.Interval;  					SendResponseAsync (e.Message' new PongMessage());  					break;    				case (ushort)TempestMessageType.Pong:  					this.pingsOut = 0;  					break;    				case (ushort)TempestMessageType.Disconnect:  					var msg = (DisconnectMessage)e.Message;  					Disconnect (msg.Reason' msg.CustomReason' notify: false);  					break;  			}
Missing Default,Tempest.Providers.Network,NetworkServerConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\NetworkServerConnection.cs,OnTempestMessageReceived,The following switch statement is missing a default case: switch (e.Message.MessageType)  		    {  		        case (ushort)TempestMessageType.Connect:  		            var msg = (ConnectMessage)e.Message;    					if (!IsConnected)  						return;    					if (!msg.Protocols.Any())  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					if (this.requiresHandshake)  					{  						bool foundHashAlg = false;  						foreach (string hashAlg in this.signatureHashAlgs)  						{  							if (msg.SignatureHashAlgorithms.Contains (hashAlg))  							{  								this.serializer.SigningHashAlgorithm = hashAlg;  								foundHashAlg = true;  								break;  							}  						}    						if (!foundHashAlg)  						{  							DisconnectAsync (ConnectionResult.FailedHandshake);  							return;  						}  					}    					ConnectionId = this.provider.GetConnectionId();    					foreach (Protocol ip in msg.Protocols)  					{  						Protocol lp;  						if (!this.protocols.TryGetValue (ip.id' out lp) || !lp.CompatibleWith (ip))  						{  							DisconnectAsync (ConnectionResult.IncompatibleVersion);  							return;  						}  					}    					this.protocols = this.protocols.Values.Intersect (msg.Protocols).ToDictionary (p => p.id);  					this.receivedProtocols = true;    					if (!this.requiresHandshake)  					{  						this.formallyConnected = true;  						this.provider.Connect (this);  						e.Connection.SendAsync (new ConnectedMessage());  					}  					else  					{  						while (!this.authReady)  							Thread.Sleep(0);    						MessageSerializer s = this.serializer;  						if (s == null)  							return;    						e.Connection.SendAsync (new AcknowledgeConnectMessage  						{  							SignatureHashAlgorithm = s.SigningHashAlgorithm'  							EnabledProtocols = this.protocols.Values'  							ConnectionId = ConnectionId'  							PublicAuthenticationKey = this.provider.PublicAuthenticationKey'  							PublicEncryptionKey = this.provider.PublicEncryptionKey  						});  					}  		    		break;    				case (ushort)TempestMessageType.FinalConnect:  					if (!this.receivedProtocols)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					var finalConnect = (FinalConnectMessage)e.Message;    					if (finalConnect.AESKey == null || finalConnect.AESKey.Length == 0 || finalConnect.PublicAuthenticationKey == null)  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					try  					{  						byte[] aeskey = this.provider.pkEncryption.Decrypt (finalConnect.AESKey);    						this.serializer.HMAC = new HMACSHA256 (aeskey);  						this.serializer.AES = new AesManaged { KeySize = 256' Key = aeskey };  					}  					catch  					{  						DisconnectAsync (ConnectionResult.FailedHandshake);  						return;  					}    					this.formallyConnected = true;  					this.provider.Connect (this);    					SendAsync (new ConnectedMessage { ConnectionId = ConnectionId });    					break;  		    }
Missing Default,Tempest.Providers.Network,UdpConnection,D:\research\architectureSmells\repos\ermau_Tempest\Desktop\Tempest\Providers\Network\UdpConnection.cs,OnTempestMessage,The following switch statement is missing a default case: switch (e.Message.MessageType)  			{  				case (ushort)TempestMessageType.Partial:  					ReceivePartialMessage ((PartialMessage)e.Message);  					break;    				case (ushort)TempestMessageType.Acknowledge:  					lock (this.pendingAck)  					{  						int[] msgIds = ((AcknowledgeMessage)e.Message).MessageIds;  						foreach (int id in msgIds)  							this.pendingAck.Remove (id);  					}  					break;    				case (ushort)TempestMessageType.Disconnect:  					var msg = (DisconnectMessage)e.Message;  					Disconnect (msg.Reason' msg.CustomReason);  					break;  			}
