Implementation smell,Namespace,Class,File,Method,Description
Complex Method,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,Cyclomatic complexity of the method is 14
Long Parameter List,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The method has 6 parameters. Parameters: fx' fy' fz' ux' uy' uz
Long Parameter List,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetProperties,The method has 6 parameters. Parameters: x' y' z' vx' vy' vz
Long Statement,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The length of the statement  "            sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]); " is 147.
Long Statement,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The length of the statement  "                    Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture); " is 170.
Long Statement,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The length of the statement  "                Gl.glTexImage2D(Gl.GL_TEXTURE_2D' 0' Gl.GL_RGB8' textureData.Width' textureData.Height' 0' Gl.GL_BGR' Gl.GL_UNSIGNED_BYTE' textureData.Scan0); " is 142.
Long Statement,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The length of the statement  "                    Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture); " is 170.
Magic Number,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: float[] vec = new float[6];
Magic Number,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[2] = fz;
Magic Number,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[3] = ux;
Magic Number,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[4] = uy;
Magic Number,OpenAlExamples,Sound,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[5] = uz;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: double[] matrix = new double[16];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sceneRotationY = 360.0f - yRotation;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,DrawLevel,The following statement contains a magic number: j < 4
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,DrawWater,The following statement contains a magic number: j < 4
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Idle,The following statement contains a magic number: secondsPerFrame = timeElapsed / 1000.0f;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Idle,The following statement contains a magic number: waterOffset += secondsPerFrame / 2.0f;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Idle,The following statement contains a magic number: movementValue = (float) desiredDistance * secondsPerFrame + 0.2f;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: Glut.glutInitWindowSize(640' 480);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: Glut.glutInitWindowSize(640' 480);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: xPosition = 3.0f;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: zPosition = 5.0f;
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: Gl.glClearColor(0.0f' 0.8f' 1.0f' 0.0f);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: polygons[i].X = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: polygons[i].Y = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: polygons[i].Z = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: polygons[i].U = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: polygons[i].V = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: j < 4
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadSounds,The following statement contains a magic number: sound.SetProperties(8.5f' 0.0f' 15.0f' 0.0f' 0.0f' 0.0f);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadSounds,The following statement contains a magic number: sound.SetProperties(8.5f' 0.0f' 15.0f' 0.0f' 0.0f' 0.0f);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: Bitmap[] textureImage = new Bitmap[6];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[2] = LoadBmp("OpenAlExamples.Waterfall.Rocks.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[3] = LoadBmp("OpenAlExamples.Waterfall.Water.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[4] = LoadBmp("OpenAlExamples.Waterfall.Dirt.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[5] = LoadBmp("OpenAlExamples.Waterfall.Wood.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: Gl.glGenTextures(6' texture);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: i < 6
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: waterPolygons[i].X = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: waterPolygons[i].Y = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: waterPolygons[i].Z = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: waterPolygons[i].U = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: waterPolygons[i].V = new float[4];
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: j < 4
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Reshape,The following statement contains a magic number: Glu.gluPerspective(45.0' (float) w / (float) h' 0.1' 2000.0);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Reshape,The following statement contains a magic number: Glu.gluPerspective(45.0' (float) w / (float) h' 0.1' 2000.0);
Magic Number,OpenAlExamples,Waterfall,C:\research\architectureSmells\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Reshape,The following statement contains a magic number: Glu.gluPerspective(45.0' (float) w / (float) h' 0.1' 2000.0);
