Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The method has 6 parameters. Parameters: fx' fy' fz' ux' uy' uz
Long Parameter List,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetProperties,The method has 6 parameters. Parameters: x' y' z' vx' vy' vz
Long Statement,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The length of the statement  "            sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]); " is 147.
Long Statement,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The length of the statement  "                    Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture); " is 170.
Long Statement,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The length of the statement  "                Gl.glTexImage2D(Gl.GL_TEXTURE_2D' 0' Gl.GL_RGB8' textureData.Width' textureData.Height' 0' Gl.GL_BGR' Gl.GL_UNSIGNED_BYTE' textureData.Scan0); " is 142.
Long Statement,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The length of the statement  "                    Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture); " is 170.
Magic Number,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: float[] vec = new float[6];
Magic Number,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[2] = fz;
Magic Number,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[3] = ux;
Magic Number,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[4] = uy;
Magic Number,OpenAlExamples,Sound,C:\repos\mono_tao\examples\OpenAlExamples\Sound.cs,SetListenerOrientation,The following statement contains a magic number: vec[5] = uz;
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: double[] matrix = new double[16];
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Display,The following statement contains a magic number: sound.SetListenerOrientation(-(float) matrix[2]' -(float) matrix[6]' -(float) matrix[10]' (float) matrix[1]' (float) matrix[5]' (float) matrix[9]);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,DrawLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                         // Draw The Level Polygons                  Gl.glBindTexture(Gl.GL_TEXTURE_2D' texture[polygons[i].TextureId]);                  Gl.glBegin(Gl.GL_QUADS);                      for(int j = 0; j < 4; j++) {                          Gl.glTexCoord2f(polygons[i].U[j]' polygons[i].V[j]);                          Gl.glVertex3f(polygons[i].X[j]' polygons[i].Y[j]' polygons[i].Z[j]);                      }                  Gl.glEnd();              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,DrawWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                    // Now Draw The Water Polygons                  Gl.glBindTexture(Gl.GL_TEXTURE_2D' texture[waterPolygons[i].TextureId]);                    Gl.glBegin(Gl.GL_QUADS);                      for(int j = 0; j < 4; j++) {                          Gl.glTexCoord2f(waterPolygons[i].U[j]' waterPolygons[i].V[j] + waterOffset);                          Gl.glVertex3f(waterPolygons[i].X[j]' waterPolygons[i].Y[j]' waterPolygons[i].Z[j]);                      }                  Gl.glEnd();              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: Glut.glutInitWindowSize(640' 480);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Initialize,The following statement contains a magic number: Glut.glutInitWindowSize(640' 480);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Keyboard,The following statement contains a magic number: switch(key) {                  case (byte) 'w':                  case (byte) 'W':                      newX = xPosition - (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition -= (float) (Math.Sin(heading * PI_OVER_180) * movementValue);                      }                        newZ = zPosition - (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition -= (float) (Math.Cos(heading * PI_OVER_180) * movementValue);                      }                      break;                  case (byte) 's':                  case (byte) 'S':                      newX = xPosition + (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin(heading * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos(heading * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'a':                  case (byte) 'A':                      newX = xPosition + (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading - 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading - 90) * PI_OVER_180) * movementValue;                      }                      break;                  case (byte) 'd':                  case (byte) 'D':                      newX = xPosition + (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      newZ = zPosition;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newX = xPosition;                      }                      else {                          xPosition += (float) Math.Sin((heading + 90) * PI_OVER_180) * movementValue;                      }                        newZ = zPosition + (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      xp = RoundUp(newX);                      zp = RoundUp(newZ);                      if(collisionArray[zp' xp] == 1) {                          newZ = zPosition;                      }                      else {                          zPosition += (float) Math.Cos((heading + 90) * PI_OVER_180) * movementValue;                      }                      break;                  case 27:                      Environment.Exit(0);                      break;                  default:                      break;              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadCollision,The following statement contains a magic number: for(int i = 17; i >= 0; i--) {                  ReadStr(reader' out line);                  line = line.Trim();                  split = line.Split();                  for(int j = 18; j >= 0; j--) {                      collisionArray[i' j] = Int32.Parse(split[j]);                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadCollision,The following statement contains a magic number: for(int i = 17; i >= 0; i--) {                  ReadStr(reader' out line);                  line = line.Trim();                  split = line.Split();                  for(int j = 18; j >= 0; j--) {                      collisionArray[i' j] = Int32.Parse(split[j]);                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                  polygons[i].X = new float[4];                  polygons[i].Y = new float[4];                  polygons[i].Z = new float[4];                  polygons[i].U = new float[4];                  polygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      polygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      polygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      polygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      polygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      polygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      polygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                  polygons[i].X = new float[4];                  polygons[i].Y = new float[4];                  polygons[i].Z = new float[4];                  polygons[i].U = new float[4];                  polygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      polygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      polygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      polygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      polygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      polygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      polygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                  polygons[i].X = new float[4];                  polygons[i].Y = new float[4];                  polygons[i].Z = new float[4];                  polygons[i].U = new float[4];                  polygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      polygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      polygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      polygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      polygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      polygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      polygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                  polygons[i].X = new float[4];                  polygons[i].Y = new float[4];                  polygons[i].Z = new float[4];                  polygons[i].U = new float[4];                  polygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      polygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      polygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      polygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      polygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      polygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      polygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                  polygons[i].X = new float[4];                  polygons[i].Y = new float[4];                  polygons[i].Z = new float[4];                  polygons[i].U = new float[4];                  polygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      polygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      polygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      polygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      polygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      polygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      polygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadLevel,The following statement contains a magic number: for(int i = 0; i < polygonCount; i++) {                  polygons[i].X = new float[4];                  polygons[i].Y = new float[4];                  polygons[i].Z = new float[4];                  polygons[i].U = new float[4];                  polygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      polygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      polygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      polygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      polygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      polygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      polygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: Bitmap[] textureImage = new Bitmap[6];
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[2] = LoadBmp("OpenAlExamples.Waterfall.Rocks.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[3] = LoadBmp("OpenAlExamples.Waterfall.Water.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[4] = LoadBmp("OpenAlExamples.Waterfall.Dirt.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: textureImage[5] = LoadBmp("OpenAlExamples.Waterfall.Wood.bmp");
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: Gl.glGenTextures(6' texture);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadTextures,The following statement contains a magic number: for(int i = 0; i < 6; i++) {                  // Select The Whole Bitmap                  rectangle = new Rectangle(0' 0' textureImage[i].Width' textureImage[i].Height);                  // Get The Pixel Data From The Locked Bitmap                  textureData = textureImage[i].LockBits(rectangle' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb);                    // Create Linear Filtered Texture                  Gl.glBindTexture(Gl.GL_TEXTURE_2D' texture[i]);                  Gl.glTexParameteri(Gl.GL_TEXTURE_2D' Gl.GL_TEXTURE_MAG_FILTER' Gl.GL_LINEAR);                  Gl.glTexParameteri(Gl.GL_TEXTURE_2D' Gl.GL_TEXTURE_MIN_FILTER' Gl.GL_LINEAR);                  Gl.glTexImage2D(Gl.GL_TEXTURE_2D' 0' Gl.GL_RGB8' textureData.Width' textureData.Height' 0' Gl.GL_BGR' Gl.GL_UNSIGNED_BYTE' textureData.Scan0);                    if(textureImage[i] != null) {                               // If Texture Exists                      textureImage[i].UnlockBits(textureData);                // Unlock The Pixel Data From Memory                      textureImage[i].Dispose();                              // Free The Texture Image                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                  waterPolygons[i].X = new float[4];                  waterPolygons[i].Y = new float[4];                  waterPolygons[i].Z = new float[4];                  waterPolygons[i].U = new float[4];                  waterPolygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      waterPolygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      waterPolygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      waterPolygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      waterPolygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      waterPolygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      waterPolygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                  waterPolygons[i].X = new float[4];                  waterPolygons[i].Y = new float[4];                  waterPolygons[i].Z = new float[4];                  waterPolygons[i].U = new float[4];                  waterPolygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      waterPolygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      waterPolygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      waterPolygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      waterPolygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      waterPolygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      waterPolygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                  waterPolygons[i].X = new float[4];                  waterPolygons[i].Y = new float[4];                  waterPolygons[i].Z = new float[4];                  waterPolygons[i].U = new float[4];                  waterPolygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      waterPolygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      waterPolygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      waterPolygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      waterPolygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      waterPolygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      waterPolygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                  waterPolygons[i].X = new float[4];                  waterPolygons[i].Y = new float[4];                  waterPolygons[i].Z = new float[4];                  waterPolygons[i].U = new float[4];                  waterPolygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      waterPolygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      waterPolygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      waterPolygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      waterPolygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      waterPolygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      waterPolygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                  waterPolygons[i].X = new float[4];                  waterPolygons[i].Y = new float[4];                  waterPolygons[i].Z = new float[4];                  waterPolygons[i].U = new float[4];                  waterPolygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      waterPolygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      waterPolygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      waterPolygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      waterPolygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      waterPolygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      waterPolygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,LoadWater,The following statement contains a magic number: for(int i = 0; i < waterPolygonCount; i++) {                  waterPolygons[i].X = new float[4];                  waterPolygons[i].Y = new float[4];                  waterPolygons[i].Z = new float[4];                  waterPolygons[i].U = new float[4];                  waterPolygons[i].V = new float[4];                  for(int j = 0; j < 4; j++) {                      ReadStr(reader' out line);                      Match match = Regex.Match(line' @"(?<X>-?\d+.\d+)\s*(?<Y>-?\d+.\d+)\s*(?<Z>-?\d+.\d+)\s*(?<U>-?\d+.\d+)\s*(?<V>-?\d+.\d+)\s*(?<TexId>\d+)"' RegexOptions.ExplicitCapture);                      waterPolygons[i].X[j] = Single.Parse(match.Groups["X"].ToString());                      waterPolygons[i].Y[j] = Single.Parse(match.Groups["Y"].ToString());                      waterPolygons[i].Z[j] = Single.Parse(match.Groups["Z"].ToString());                      waterPolygons[i].U[j] = Single.Parse(match.Groups["U"].ToString());                      waterPolygons[i].V[j] = Single.Parse(match.Groups["V"].ToString());                      waterPolygons[i].TextureId = Int32.Parse(match.Groups["TexId"].ToString());                  }              }
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Reshape,The following statement contains a magic number: Glu.gluPerspective(45.0' (float) w / (float) h' 0.1' 2000.0);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Reshape,The following statement contains a magic number: Glu.gluPerspective(45.0' (float) w / (float) h' 0.1' 2000.0);
Magic Number,OpenAlExamples,Waterfall,C:\repos\mono_tao\examples\OpenAlExamples\Waterfall.cs,Reshape,The following statement contains a magic number: Glu.gluPerspective(45.0' (float) w / (float) h' 0.1' 2000.0);
