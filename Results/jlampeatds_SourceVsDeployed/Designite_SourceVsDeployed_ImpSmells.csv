Implementation smell,Namespace,Class,File,Method,Description
Long Method,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,The method has 112 lines of code.
Long Method,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The method has 110 lines of code.
Complex Method,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,Cyclomatic complexity of the method is 18
Complex Method,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,DownloadManifest,Cyclomatic complexity of the method is 9
Complex Method,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,Cyclomatic complexity of the method is 11
Complex Method,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,Cyclomatic complexity of the method is 13
Complex Method,SourceVsDeployed,Utility,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Utility.cs,ResolveDateMacro,Cyclomatic complexity of the method is 8
Long Statement,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,The length of the statement  "	throw new Exception_JobComplete (resultCode.ToString (CultureInfo.InvariantCulture)' "Job #" + jobNumber + "|" + url + "|" + finalMessage); " is 139.
Long Statement,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,GetEntry,The length of the statement  "			return new ManifestEntry (Utility.LesserExpectation (Arguments.Action' _saManifest [index' 0])' _saManifest [index' 1]' _saManifest [index' 2]); " is 144.
Long Statement,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ValidateAndParseDownloadedManifest,The length of the statement  "			Log.Error ("Manifest file failed hash check! (Got " + manifestActualChecksum + "' expected " + manifestChecksum + ".)"); " is 120.
Long Statement,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The length of the statement  "								Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")"); " is 139.
Long Statement,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The length of the statement  "		Log.Info (string.Format ("Parsed {0} entries from a {1} line manifest with {2} errors."' LinesParsed' LinesTotal' linesErrored)); " is 129.
Long Statement,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,RetainCorruptFolder,The length of the statement  "			Log.Warn ("Could not rename temp folder from " + Arguments.TemporaryFolder + " to " + sCorruptFolderPath + "! (" + e.Message + ")"); " is 132.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "		IJobDetail job = JobBuilder.Create (typeof(Job_CheckWebFile)).WithIdentity (jobkey).UsingJobData ("URL"' Arguments.Target + ma.RelativePath).UsingJobData ("Hash"' ma.Md5).UsingJobData ("Expectation"' ma.Expectation).UsingJobData ("JobNumber"' iJob.ToString (CultureInfo.InvariantCulture)).Build (); " is 298.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "		ITrigger trigger = TriggerBuilder.Create ().WithSchedule (ssb.WithRepeatCount (0)).StartNow ().WithIdentity ("Trigger_" + iJob' "Trigger_CheckWebFile").Build (); " is 161.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "		// Code from http://stackoverflow.com/questions/14517563/quartz-schedulers-job-fired-but-joblistener-not-picking-up-event?rq=1 " is 126.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "			Log.Debug ("...scheduler has room (at " + scheduler.GetCurrentlyExecutingJobs ().Count + ")' adding job #" + iJob + " now."); " is 125.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "			IJobDetail job = JobBuilder.Create (typeof(Job_CheckWebFile)).WithIdentity ("Job_" + iJob' "Job_CheckWebFile").UsingJobData ("URL"' Arguments.Target + ma.RelativePath).UsingJobData ("Hash"' ma.Md5).UsingJobData ("Expectation"' ma.Expectation).UsingJobData ("JobNumber"' iJob.ToString (CultureInfo.InvariantCulture)).Build (); " is 325.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "			ITrigger trigger = TriggerBuilder.Create ().WithSchedule (ssb.WithRepeatCount (0)).StartNow ().WithIdentity ("Trigger_" + iJob' "Trigger_CheckWebFile").Build (); " is 161.
Long Statement,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The length of the statement  "	Log.Info ("Checked " + CountChecked + " URLs. OK: " + CountOk + "' Corrupt: " + CountCorrupt + "' Missing: " + CountMissing + "' Other Error: " + CountOtherError); " is 163.
Empty Catch Block,SourceVsDeployed,CLI,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\CLI.cs,DisplayHelp,The method has an empty catch block.
Empty Catch Block,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,TemporaryFolderHasBeenCreatedOrExists,The method has an empty catch block.
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,Populate,The following statement contains a magic number: if (args.Length < 2) {  	Log.Debug ("Displaying help and exiting.");  	CLI.DisplayHelp ();  	ReturnCode = 0;  	return;  }  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: if (args.Length > 2) {  	Log.Info ("Target " + args [2] + " was explicitly provided.");  	return Utility.EnsureHasTrailingSlash (args [2]);  }  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: if (args.Length > 2) {  	Log.Info ("Target " + args [2] + " was explicitly provided.");  	return Utility.EnsureHasTrailingSlash (args [2]);  }  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: if (args.Length > 2) {  	Log.Info ("Target " + args [2] + " was explicitly provided.");  	return Utility.EnsureHasTrailingSlash (args [2]);  }  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: Log.Info ("Target " + args [2] + " was explicitly provided.");  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: return Utility.EnsureHasTrailingSlash (args [2]);  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: if (Utility.IsAValidUrl (manifestArg)) {  	// Parse protocol' host and port from the incoming URL  	try {  		string[] urlSplit = manifestArg.Split ('/');  		string urlBase = urlSplit [0] + "/" + urlSplit [1] + "/" + urlSplit [2] + "/";  		Log.Info ("Target " + urlBase + " was derived from manifest.");  		return Utility.EnsureHasTrailingSlash (urlBase);  	}  	catch {  		Log.Error ("Attempted but failed to derive Target from manifest.");  		return "";  	}  }  
Magic Number,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,MakeTarget,The following statement contains a magic number: try {  	string[] urlSplit = manifestArg.Split ('/');  	string urlBase = urlSplit [0] + "/" + urlSplit [1] + "/" + urlSplit [2] + "/";  	Log.Info ("Target " + urlBase + " was derived from manifest.");  	return Utility.EnsureHasTrailingSlash (urlBase);  }  catch {  	Log.Error ("Attempted but failed to derive Target from manifest.");  	return "";  }  
Magic Number,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,The following statement contains a magic number: try {  	// Attempt to download  	Log.Debug ("Trying to download url: " + url);  	using (var client = new WebClient ()) {  		client.DownloadFile (url' temporaryPath);  	}  	if (File.Exists (temporaryPath)) {  		Log.Debug ("Download of " + url + " was successful.");  		if (expectation == "md5") {  			// Attempt to calculate hash  			Log.Debug ("Calculating hash of " + temporaryPath);  			string testHash;  			using (var md5 = MD5.Create ()) {  				using (var stream = File.OpenRead (temporaryPath)) {  					testHash = BitConverter.ToString (md5.ComputeHash (stream)).Replace ("-"' "").ToLower ();  					// Log.Debug("Hash of " + temporaryPath + " is " + testHash + ".");  				}  			}  			// Compare hashes  			if (testHash == hash) {  				finalMessage = "Hashes match!";  				resultCode = 0;  			}  			else {  				finalMessage = "Failed hash check! (Got " + testHash + "' expected " + hash + ".)";  				resultCode = 1;  				if (Arguments.KeepCorruptFiles) {  					keepFile = true;  				}  			}  		}  		else if (expectation == "exist") {  			finalMessage = "File exists!";  			resultCode = 0;  		}  		else if (expectation == "missing") {  			finalMessage = "File is not missing!";  			resultCode = 1;  		}  		// Delete the local file  		// UNLESS the file is corrupt and we decided to keep a copy  		if (keepFile) {  			string sLocalFileName = Arguments.TemporaryFolder + "\\" + Utility.PrepareLocalFilename (url' Arguments.Target);  			Log.Debug ("Renaming local file from " + temporaryPath + " to " + sLocalFileName + "...");  			try {  				File.Move (temporaryPath' sLocalFileName);  				Log.Debug ("Renamed local file from " + temporaryPath + " to " + sLocalFileName + " OK.");  			}  			catch (Exception e) {  				Log.Warn ("Could not rename local file from " + temporaryPath + " to " + sLocalFileName + ". (" + e.Message + ")");  			}  		}  		else {  			Log.Debug ("Deleting local file.");  			File.Delete (temporaryPath);  		}  	}  	else {  		finalMessage = "Download of url happened but local file does not exist.";  	}  }  catch (WebException webException) {  	if (webException.Status == WebExceptionStatus.ProtocolError && webException.Response != null) {  		var resp = (HttpWebResponse)webException.Response;  		if (resp.StatusCode == HttpStatusCode.NotFound) {  			finalMessage = "Cannot be downloaded! (404)";  		}  		else {  			finalMessage = "Cannot be downloaded! (" + resp.StatusCode + ")";  		}  	}  	else {  		finalMessage = "Cannot be downloaded! " + webException;  	}  	// This is OK if a file is supposed to be missing.  Else return a code of "2"  	resultCode = expectation == "missing" ? 0 : 2;  }  catch (Exception exception) {  	finalMessage = "Encountered exception during download of url: " + exception;  	resultCode = 4;  }  
Magic Number,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,The following statement contains a magic number: try {  	// Attempt to download  	Log.Debug ("Trying to download url: " + url);  	using (var client = new WebClient ()) {  		client.DownloadFile (url' temporaryPath);  	}  	if (File.Exists (temporaryPath)) {  		Log.Debug ("Download of " + url + " was successful.");  		if (expectation == "md5") {  			// Attempt to calculate hash  			Log.Debug ("Calculating hash of " + temporaryPath);  			string testHash;  			using (var md5 = MD5.Create ()) {  				using (var stream = File.OpenRead (temporaryPath)) {  					testHash = BitConverter.ToString (md5.ComputeHash (stream)).Replace ("-"' "").ToLower ();  					// Log.Debug("Hash of " + temporaryPath + " is " + testHash + ".");  				}  			}  			// Compare hashes  			if (testHash == hash) {  				finalMessage = "Hashes match!";  				resultCode = 0;  			}  			else {  				finalMessage = "Failed hash check! (Got " + testHash + "' expected " + hash + ".)";  				resultCode = 1;  				if (Arguments.KeepCorruptFiles) {  					keepFile = true;  				}  			}  		}  		else if (expectation == "exist") {  			finalMessage = "File exists!";  			resultCode = 0;  		}  		else if (expectation == "missing") {  			finalMessage = "File is not missing!";  			resultCode = 1;  		}  		// Delete the local file  		// UNLESS the file is corrupt and we decided to keep a copy  		if (keepFile) {  			string sLocalFileName = Arguments.TemporaryFolder + "\\" + Utility.PrepareLocalFilename (url' Arguments.Target);  			Log.Debug ("Renaming local file from " + temporaryPath + " to " + sLocalFileName + "...");  			try {  				File.Move (temporaryPath' sLocalFileName);  				Log.Debug ("Renamed local file from " + temporaryPath + " to " + sLocalFileName + " OK.");  			}  			catch (Exception e) {  				Log.Warn ("Could not rename local file from " + temporaryPath + " to " + sLocalFileName + ". (" + e.Message + ")");  			}  		}  		else {  			Log.Debug ("Deleting local file.");  			File.Delete (temporaryPath);  		}  	}  	else {  		finalMessage = "Download of url happened but local file does not exist.";  	}  }  catch (WebException webException) {  	if (webException.Status == WebExceptionStatus.ProtocolError && webException.Response != null) {  		var resp = (HttpWebResponse)webException.Response;  		if (resp.StatusCode == HttpStatusCode.NotFound) {  			finalMessage = "Cannot be downloaded! (404)";  		}  		else {  			finalMessage = "Cannot be downloaded! (" + resp.StatusCode + ")";  		}  	}  	else {  		finalMessage = "Cannot be downloaded! " + webException;  	}  	// This is OK if a file is supposed to be missing.  Else return a code of "2"  	resultCode = expectation == "missing" ? 0 : 2;  }  catch (Exception exception) {  	finalMessage = "Encountered exception during download of url: " + exception;  	resultCode = 4;  }  
Magic Number,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,The following statement contains a magic number: resultCode = expectation == "missing" ? 0 : 2;  
Magic Number,SourceVsDeployed,Job_CheckWebFile,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Job_CheckWebFile.cs,Execute,The following statement contains a magic number: resultCode = 4;  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,GetEntry,The following statement contains a magic number: if (_saManifest != null) {  	if (index > -1 && index < _saManifest.GetLength (0)) {  		return new ManifestEntry (Utility.LesserExpectation (Arguments.Action' _saManifest [index' 0])' _saManifest [index' 1]' _saManifest [index' 2]);  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,GetEntry,The following statement contains a magic number: if (index > -1 && index < _saManifest.GetLength (0)) {  	return new ManifestEntry (Utility.LesserExpectation (Arguments.Action' _saManifest [index' 0])' _saManifest [index' 1]' _saManifest [index' 2]);  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,GetEntry,The following statement contains a magic number: return new ManifestEntry (Utility.LesserExpectation (Arguments.Action' _saManifest [index' 0])' _saManifest [index' 1]' _saManifest [index' 2]);  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,MakeChecksumPath,The following statement contains a magic number: if (saPath.Length > 1) {  	for (int i = 0; i < saPath.Length; i++) {  		// Second-to-last segment gets the checksum name appended to it  		if (i == saPath.Length - 2) {  			saPath [i] += "_md5";  		}  		// If this is the first segment' do not prepend a period.  Otherwise' DO prepend it.  		if (i == 0) {  			sFinalPath += saPath [i];  		}  		else {  			sFinalPath += "." + saPath [i];  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,MakeChecksumPath,The following statement contains a magic number: for (int i = 0; i < saPath.Length; i++) {  	// Second-to-last segment gets the checksum name appended to it  	if (i == saPath.Length - 2) {  		saPath [i] += "_md5";  	}  	// If this is the first segment' do not prepend a period.  Otherwise' DO prepend it.  	if (i == 0) {  		sFinalPath += saPath [i];  	}  	else {  		sFinalPath += "." + saPath [i];  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,MakeChecksumPath,The following statement contains a magic number: if (i == saPath.Length - 2) {  	saPath [i] += "_md5";  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ValidateAndParseDownloadedManifest,The following statement contains a magic number: try {  	// Validate the contents of the manifest file  	string manifestChecksumPath = MakeChecksumPath (manifestPath);  	string manifestChecksum = File.ReadAllText (manifestChecksumPath).Substring (0' 32);  	// Quick way to ignore training linefeeds  	//const string manifestChecksumSalt = ";4Mw4{~/*twEs8'<3Pred";  	string manifestChecksumPrepend = ConfigurationManager.AppSettings ["ManifestMD5Prepend"];  	// Attempt to calculate hash  	Log.Debug ("Calculating salted hash of manifest.");  	string manifestActualChecksum;  	using (var md5 = MD5.Create ()) {  		var manifestText = File.ReadAllText (manifestPath);  		// [system.Text.Encoding]::UTF8 in Powershell  		var utf8 = new System.Text.UTF8Encoding ();  		byte[] manifestTextBuffer = utf8.GetBytes (manifestChecksumPrepend + manifestText);  		manifestActualChecksum = BitConverter.ToString (md5.ComputeHash (manifestTextBuffer)).Replace ("-"' "").ToLower ();  		// Log.Debug("Hash of " + temporaryPath + " is " + testHash + ".");  	}  	// Compare hashes  	if (manifestActualChecksum != manifestChecksum) {  		Log.Error ("Manifest file failed hash check! (Got " + manifestActualChecksum + "' expected " + manifestChecksum + ".)");  		_linesTotal = _linesComments = _linesIgnored = _linesBlank = _linesParsed = 0;  		return false;  	}  	Log.Debug ("Manifest hash is OK - proceeding!");  	string['] saManifest = ParseFileToArray (manifestPath);  	Log.Debug ("Deleting temporary manifest and checksum.");  	File.Delete (manifestPath);  	File.Delete (manifestChecksumPath);  	if (saManifest == null) {  		return false;  	}  	_saManifest = saManifest;  	return true;  }  catch (Exception e) {  	Log.Debug ("Caught exception in ValidateAndParseDownloadedManifest: " + e.Message);  	Log.Warn ("Could not open local manifest or checksum file(s).");  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	int linesTotal = 0;  	int linesComments = 0;  	int linesIgnored = 0;  	int linesBlank = 0;  	int linesParsed = 0;  	int linesErrored = 0;  	string line;  	const string commentChar = "'";  	var saManifest = new string[_manifestLengthMax' 3];  	// Read the file and parse it line by line.  	Log.Debug ("Starting read of " + manifestPath);  	var file = new StreamReader (manifestPath);  	while ((line = file.ReadLine ()) != null) {  		linesTotal++;  		line = line.Trim ();  		// Blank line  		if (line.Length == 0) {  			linesBlank++;  		}  		else {  			// Comment line  			if (line.StartsWith (commentChar)) {  				linesComments++;  			}  			else {  				// Line format:   				//   Expectation[tab]RelativePath[tab]MD5(optional)  				// Example:  				//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  				// Parse line  				try {  					if (!line.Contains ("\t")) {  						Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  						linesErrored++;  					}  					else {  						// Check to see if we have too many entries  						if (linesParsed >= _manifestLengthMax) {  							Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  							linesIgnored++;  						}  						else {  							// All seems to be OK' so parse the line  							string[] saLine = line.Split ('\t');  							saManifest [linesParsed' 0] = saLine [0];  							saManifest [linesParsed' 1] = saLine [1];  							// Check for MD5  							if (saLine.Length > 2) {  								saManifest [linesParsed' 2] = saLine [2];  							}  							linesParsed++;  						}  					}  				}  				catch (Exception exception) {  					Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  					linesErrored++;  				}  			}  		}  	}  	file.Close ();  	// Pass all parameters up' print a little trace message and leave  	_linesTotal = linesTotal;  	_linesComments = linesComments;  	_linesIgnored = linesIgnored;  	_linesErrored = linesErrored;  	_linesBlank = linesBlank;  	_linesParsed = linesParsed;  	Log.Info (string.Format ("Parsed {0} entries from a {1} line manifest with {2} errors."' LinesParsed' LinesTotal' linesErrored));  	// All done.  Was it good enough?  (At least one line parsed and no parse errors.)    	if (_linesIgnored > 0) {  		Log.Warn (string.Format ("Ignored {0} lines."' LinesIgnored));  	}  	return linesParsed > 0 && linesErrored == 0 ? saManifest : null;  }  catch (Exception e) {  	Log.Error ("Failed to parse manifest file " + manifestPath + "! (" + e.Message + ")");  	return null;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	int linesTotal = 0;  	int linesComments = 0;  	int linesIgnored = 0;  	int linesBlank = 0;  	int linesParsed = 0;  	int linesErrored = 0;  	string line;  	const string commentChar = "'";  	var saManifest = new string[_manifestLengthMax' 3];  	// Read the file and parse it line by line.  	Log.Debug ("Starting read of " + manifestPath);  	var file = new StreamReader (manifestPath);  	while ((line = file.ReadLine ()) != null) {  		linesTotal++;  		line = line.Trim ();  		// Blank line  		if (line.Length == 0) {  			linesBlank++;  		}  		else {  			// Comment line  			if (line.StartsWith (commentChar)) {  				linesComments++;  			}  			else {  				// Line format:   				//   Expectation[tab]RelativePath[tab]MD5(optional)  				// Example:  				//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  				// Parse line  				try {  					if (!line.Contains ("\t")) {  						Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  						linesErrored++;  					}  					else {  						// Check to see if we have too many entries  						if (linesParsed >= _manifestLengthMax) {  							Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  							linesIgnored++;  						}  						else {  							// All seems to be OK' so parse the line  							string[] saLine = line.Split ('\t');  							saManifest [linesParsed' 0] = saLine [0];  							saManifest [linesParsed' 1] = saLine [1];  							// Check for MD5  							if (saLine.Length > 2) {  								saManifest [linesParsed' 2] = saLine [2];  							}  							linesParsed++;  						}  					}  				}  				catch (Exception exception) {  					Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  					linesErrored++;  				}  			}  		}  	}  	file.Close ();  	// Pass all parameters up' print a little trace message and leave  	_linesTotal = linesTotal;  	_linesComments = linesComments;  	_linesIgnored = linesIgnored;  	_linesErrored = linesErrored;  	_linesBlank = linesBlank;  	_linesParsed = linesParsed;  	Log.Info (string.Format ("Parsed {0} entries from a {1} line manifest with {2} errors."' LinesParsed' LinesTotal' linesErrored));  	// All done.  Was it good enough?  (At least one line parsed and no parse errors.)    	if (_linesIgnored > 0) {  		Log.Warn (string.Format ("Ignored {0} lines."' LinesIgnored));  	}  	return linesParsed > 0 && linesErrored == 0 ? saManifest : null;  }  catch (Exception e) {  	Log.Error ("Failed to parse manifest file " + manifestPath + "! (" + e.Message + ")");  	return null;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	int linesTotal = 0;  	int linesComments = 0;  	int linesIgnored = 0;  	int linesBlank = 0;  	int linesParsed = 0;  	int linesErrored = 0;  	string line;  	const string commentChar = "'";  	var saManifest = new string[_manifestLengthMax' 3];  	// Read the file and parse it line by line.  	Log.Debug ("Starting read of " + manifestPath);  	var file = new StreamReader (manifestPath);  	while ((line = file.ReadLine ()) != null) {  		linesTotal++;  		line = line.Trim ();  		// Blank line  		if (line.Length == 0) {  			linesBlank++;  		}  		else {  			// Comment line  			if (line.StartsWith (commentChar)) {  				linesComments++;  			}  			else {  				// Line format:   				//   Expectation[tab]RelativePath[tab]MD5(optional)  				// Example:  				//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  				// Parse line  				try {  					if (!line.Contains ("\t")) {  						Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  						linesErrored++;  					}  					else {  						// Check to see if we have too many entries  						if (linesParsed >= _manifestLengthMax) {  							Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  							linesIgnored++;  						}  						else {  							// All seems to be OK' so parse the line  							string[] saLine = line.Split ('\t');  							saManifest [linesParsed' 0] = saLine [0];  							saManifest [linesParsed' 1] = saLine [1];  							// Check for MD5  							if (saLine.Length > 2) {  								saManifest [linesParsed' 2] = saLine [2];  							}  							linesParsed++;  						}  					}  				}  				catch (Exception exception) {  					Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  					linesErrored++;  				}  			}  		}  	}  	file.Close ();  	// Pass all parameters up' print a little trace message and leave  	_linesTotal = linesTotal;  	_linesComments = linesComments;  	_linesIgnored = linesIgnored;  	_linesErrored = linesErrored;  	_linesBlank = linesBlank;  	_linesParsed = linesParsed;  	Log.Info (string.Format ("Parsed {0} entries from a {1} line manifest with {2} errors."' LinesParsed' LinesTotal' linesErrored));  	// All done.  Was it good enough?  (At least one line parsed and no parse errors.)    	if (_linesIgnored > 0) {  		Log.Warn (string.Format ("Ignored {0} lines."' LinesIgnored));  	}  	return linesParsed > 0 && linesErrored == 0 ? saManifest : null;  }  catch (Exception e) {  	Log.Error ("Failed to parse manifest file " + manifestPath + "! (" + e.Message + ")");  	return null;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	int linesTotal = 0;  	int linesComments = 0;  	int linesIgnored = 0;  	int linesBlank = 0;  	int linesParsed = 0;  	int linesErrored = 0;  	string line;  	const string commentChar = "'";  	var saManifest = new string[_manifestLengthMax' 3];  	// Read the file and parse it line by line.  	Log.Debug ("Starting read of " + manifestPath);  	var file = new StreamReader (manifestPath);  	while ((line = file.ReadLine ()) != null) {  		linesTotal++;  		line = line.Trim ();  		// Blank line  		if (line.Length == 0) {  			linesBlank++;  		}  		else {  			// Comment line  			if (line.StartsWith (commentChar)) {  				linesComments++;  			}  			else {  				// Line format:   				//   Expectation[tab]RelativePath[tab]MD5(optional)  				// Example:  				//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  				// Parse line  				try {  					if (!line.Contains ("\t")) {  						Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  						linesErrored++;  					}  					else {  						// Check to see if we have too many entries  						if (linesParsed >= _manifestLengthMax) {  							Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  							linesIgnored++;  						}  						else {  							// All seems to be OK' so parse the line  							string[] saLine = line.Split ('\t');  							saManifest [linesParsed' 0] = saLine [0];  							saManifest [linesParsed' 1] = saLine [1];  							// Check for MD5  							if (saLine.Length > 2) {  								saManifest [linesParsed' 2] = saLine [2];  							}  							linesParsed++;  						}  					}  				}  				catch (Exception exception) {  					Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  					linesErrored++;  				}  			}  		}  	}  	file.Close ();  	// Pass all parameters up' print a little trace message and leave  	_linesTotal = linesTotal;  	_linesComments = linesComments;  	_linesIgnored = linesIgnored;  	_linesErrored = linesErrored;  	_linesBlank = linesBlank;  	_linesParsed = linesParsed;  	Log.Info (string.Format ("Parsed {0} entries from a {1} line manifest with {2} errors."' LinesParsed' LinesTotal' linesErrored));  	// All done.  Was it good enough?  (At least one line parsed and no parse errors.)    	if (_linesIgnored > 0) {  		Log.Warn (string.Format ("Ignored {0} lines."' LinesIgnored));  	}  	return linesParsed > 0 && linesErrored == 0 ? saManifest : null;  }  catch (Exception e) {  	Log.Error ("Failed to parse manifest file " + manifestPath + "! (" + e.Message + ")");  	return null;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: while ((line = file.ReadLine ()) != null) {  	linesTotal++;  	line = line.Trim ();  	// Blank line  	if (line.Length == 0) {  		linesBlank++;  	}  	else {  		// Comment line  		if (line.StartsWith (commentChar)) {  			linesComments++;  		}  		else {  			// Line format:   			//   Expectation[tab]RelativePath[tab]MD5(optional)  			// Example:  			//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  			// Parse line  			try {  				if (!line.Contains ("\t")) {  					Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  					linesErrored++;  				}  				else {  					// Check to see if we have too many entries  					if (linesParsed >= _manifestLengthMax) {  						Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  						linesIgnored++;  					}  					else {  						// All seems to be OK' so parse the line  						string[] saLine = line.Split ('\t');  						saManifest [linesParsed' 0] = saLine [0];  						saManifest [linesParsed' 1] = saLine [1];  						// Check for MD5  						if (saLine.Length > 2) {  							saManifest [linesParsed' 2] = saLine [2];  						}  						linesParsed++;  					}  				}  			}  			catch (Exception exception) {  				Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  				linesErrored++;  			}  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: while ((line = file.ReadLine ()) != null) {  	linesTotal++;  	line = line.Trim ();  	// Blank line  	if (line.Length == 0) {  		linesBlank++;  	}  	else {  		// Comment line  		if (line.StartsWith (commentChar)) {  			linesComments++;  		}  		else {  			// Line format:   			//   Expectation[tab]RelativePath[tab]MD5(optional)  			// Example:  			//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  			// Parse line  			try {  				if (!line.Contains ("\t")) {  					Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  					linesErrored++;  				}  				else {  					// Check to see if we have too many entries  					if (linesParsed >= _manifestLengthMax) {  						Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  						linesIgnored++;  					}  					else {  						// All seems to be OK' so parse the line  						string[] saLine = line.Split ('\t');  						saManifest [linesParsed' 0] = saLine [0];  						saManifest [linesParsed' 1] = saLine [1];  						// Check for MD5  						if (saLine.Length > 2) {  							saManifest [linesParsed' 2] = saLine [2];  						}  						linesParsed++;  					}  				}  			}  			catch (Exception exception) {  				Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  				linesErrored++;  			}  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: while ((line = file.ReadLine ()) != null) {  	linesTotal++;  	line = line.Trim ();  	// Blank line  	if (line.Length == 0) {  		linesBlank++;  	}  	else {  		// Comment line  		if (line.StartsWith (commentChar)) {  			linesComments++;  		}  		else {  			// Line format:   			//   Expectation[tab]RelativePath[tab]MD5(optional)  			// Example:  			//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  			// Parse line  			try {  				if (!line.Contains ("\t")) {  					Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  					linesErrored++;  				}  				else {  					// Check to see if we have too many entries  					if (linesParsed >= _manifestLengthMax) {  						Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  						linesIgnored++;  					}  					else {  						// All seems to be OK' so parse the line  						string[] saLine = line.Split ('\t');  						saManifest [linesParsed' 0] = saLine [0];  						saManifest [linesParsed' 1] = saLine [1];  						// Check for MD5  						if (saLine.Length > 2) {  							saManifest [linesParsed' 2] = saLine [2];  						}  						linesParsed++;  					}  				}  			}  			catch (Exception exception) {  				Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  				linesErrored++;  			}  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (line.Length == 0) {  	linesBlank++;  }  else {  	// Comment line  	if (line.StartsWith (commentChar)) {  		linesComments++;  	}  	else {  		// Line format:   		//   Expectation[tab]RelativePath[tab]MD5(optional)  		// Example:  		//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  		// Parse line  		try {  			if (!line.Contains ("\t")) {  				Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  				linesErrored++;  			}  			else {  				// Check to see if we have too many entries  				if (linesParsed >= _manifestLengthMax) {  					Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  					linesIgnored++;  				}  				else {  					// All seems to be OK' so parse the line  					string[] saLine = line.Split ('\t');  					saManifest [linesParsed' 0] = saLine [0];  					saManifest [linesParsed' 1] = saLine [1];  					// Check for MD5  					if (saLine.Length > 2) {  						saManifest [linesParsed' 2] = saLine [2];  					}  					linesParsed++;  				}  			}  		}  		catch (Exception exception) {  			Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  			linesErrored++;  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (line.Length == 0) {  	linesBlank++;  }  else {  	// Comment line  	if (line.StartsWith (commentChar)) {  		linesComments++;  	}  	else {  		// Line format:   		//   Expectation[tab]RelativePath[tab]MD5(optional)  		// Example:  		//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  		// Parse line  		try {  			if (!line.Contains ("\t")) {  				Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  				linesErrored++;  			}  			else {  				// Check to see if we have too many entries  				if (linesParsed >= _manifestLengthMax) {  					Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  					linesIgnored++;  				}  				else {  					// All seems to be OK' so parse the line  					string[] saLine = line.Split ('\t');  					saManifest [linesParsed' 0] = saLine [0];  					saManifest [linesParsed' 1] = saLine [1];  					// Check for MD5  					if (saLine.Length > 2) {  						saManifest [linesParsed' 2] = saLine [2];  					}  					linesParsed++;  				}  			}  		}  		catch (Exception exception) {  			Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  			linesErrored++;  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (line.Length == 0) {  	linesBlank++;  }  else {  	// Comment line  	if (line.StartsWith (commentChar)) {  		linesComments++;  	}  	else {  		// Line format:   		//   Expectation[tab]RelativePath[tab]MD5(optional)  		// Example:  		//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  		// Parse line  		try {  			if (!line.Contains ("\t")) {  				Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  				linesErrored++;  			}  			else {  				// Check to see if we have too many entries  				if (linesParsed >= _manifestLengthMax) {  					Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  					linesIgnored++;  				}  				else {  					// All seems to be OK' so parse the line  					string[] saLine = line.Split ('\t');  					saManifest [linesParsed' 0] = saLine [0];  					saManifest [linesParsed' 1] = saLine [1];  					// Check for MD5  					if (saLine.Length > 2) {  						saManifest [linesParsed' 2] = saLine [2];  					}  					linesParsed++;  				}  			}  		}  		catch (Exception exception) {  			Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  			linesErrored++;  		}  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (line.StartsWith (commentChar)) {  	linesComments++;  }  else {  	// Line format:   	//   Expectation[tab]RelativePath[tab]MD5(optional)  	// Example:  	//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  	// Parse line  	try {  		if (!line.Contains ("\t")) {  			Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  			linesErrored++;  		}  		else {  			// Check to see if we have too many entries  			if (linesParsed >= _manifestLengthMax) {  				Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  				linesIgnored++;  			}  			else {  				// All seems to be OK' so parse the line  				string[] saLine = line.Split ('\t');  				saManifest [linesParsed' 0] = saLine [0];  				saManifest [linesParsed' 1] = saLine [1];  				// Check for MD5  				if (saLine.Length > 2) {  					saManifest [linesParsed' 2] = saLine [2];  				}  				linesParsed++;  			}  		}  	}  	catch (Exception exception) {  		Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  		linesErrored++;  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (line.StartsWith (commentChar)) {  	linesComments++;  }  else {  	// Line format:   	//   Expectation[tab]RelativePath[tab]MD5(optional)  	// Example:  	//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  	// Parse line  	try {  		if (!line.Contains ("\t")) {  			Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  			linesErrored++;  		}  		else {  			// Check to see if we have too many entries  			if (linesParsed >= _manifestLengthMax) {  				Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  				linesIgnored++;  			}  			else {  				// All seems to be OK' so parse the line  				string[] saLine = line.Split ('\t');  				saManifest [linesParsed' 0] = saLine [0];  				saManifest [linesParsed' 1] = saLine [1];  				// Check for MD5  				if (saLine.Length > 2) {  					saManifest [linesParsed' 2] = saLine [2];  				}  				linesParsed++;  			}  		}  	}  	catch (Exception exception) {  		Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  		linesErrored++;  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (line.StartsWith (commentChar)) {  	linesComments++;  }  else {  	// Line format:   	//   Expectation[tab]RelativePath[tab]MD5(optional)  	// Example:  	//   ignore root/sub/file.txt c36ee71a9dd26d6f3fea9531b48ff140  	// Parse line  	try {  		if (!line.Contains ("\t")) {  			Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  			linesErrored++;  		}  		else {  			// Check to see if we have too many entries  			if (linesParsed >= _manifestLengthMax) {  				Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  				linesIgnored++;  			}  			else {  				// All seems to be OK' so parse the line  				string[] saLine = line.Split ('\t');  				saManifest [linesParsed' 0] = saLine [0];  				saManifest [linesParsed' 1] = saLine [1];  				// Check for MD5  				if (saLine.Length > 2) {  					saManifest [linesParsed' 2] = saLine [2];  				}  				linesParsed++;  			}  		}  	}  	catch (Exception exception) {  		Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  		linesErrored++;  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	if (!line.Contains ("\t")) {  		Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  		linesErrored++;  	}  	else {  		// Check to see if we have too many entries  		if (linesParsed >= _manifestLengthMax) {  			Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  			linesIgnored++;  		}  		else {  			// All seems to be OK' so parse the line  			string[] saLine = line.Split ('\t');  			saManifest [linesParsed' 0] = saLine [0];  			saManifest [linesParsed' 1] = saLine [1];  			// Check for MD5  			if (saLine.Length > 2) {  				saManifest [linesParsed' 2] = saLine [2];  			}  			linesParsed++;  		}  	}  }  catch (Exception exception) {  	Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  	linesErrored++;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	if (!line.Contains ("\t")) {  		Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  		linesErrored++;  	}  	else {  		// Check to see if we have too many entries  		if (linesParsed >= _manifestLengthMax) {  			Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  			linesIgnored++;  		}  		else {  			// All seems to be OK' so parse the line  			string[] saLine = line.Split ('\t');  			saManifest [linesParsed' 0] = saLine [0];  			saManifest [linesParsed' 1] = saLine [1];  			// Check for MD5  			if (saLine.Length > 2) {  				saManifest [linesParsed' 2] = saLine [2];  			}  			linesParsed++;  		}  	}  }  catch (Exception exception) {  	Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  	linesErrored++;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: try {  	if (!line.Contains ("\t")) {  		Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  		linesErrored++;  	}  	else {  		// Check to see if we have too many entries  		if (linesParsed >= _manifestLengthMax) {  			Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  			linesIgnored++;  		}  		else {  			// All seems to be OK' so parse the line  			string[] saLine = line.Split ('\t');  			saManifest [linesParsed' 0] = saLine [0];  			saManifest [linesParsed' 1] = saLine [1];  			// Check for MD5  			if (saLine.Length > 2) {  				saManifest [linesParsed' 2] = saLine [2];  			}  			linesParsed++;  		}  	}  }  catch (Exception exception) {  	Log.Warn ("Caught exception parsing line #" + linesTotal + " (" + exception + ").");  	linesErrored++;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (!line.Contains ("\t")) {  	Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  	linesErrored++;  }  else {  	// Check to see if we have too many entries  	if (linesParsed >= _manifestLengthMax) {  		Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  		linesIgnored++;  	}  	else {  		// All seems to be OK' so parse the line  		string[] saLine = line.Split ('\t');  		saManifest [linesParsed' 0] = saLine [0];  		saManifest [linesParsed' 1] = saLine [1];  		// Check for MD5  		if (saLine.Length > 2) {  			saManifest [linesParsed' 2] = saLine [2];  		}  		linesParsed++;  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (!line.Contains ("\t")) {  	Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  	linesErrored++;  }  else {  	// Check to see if we have too many entries  	if (linesParsed >= _manifestLengthMax) {  		Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  		linesIgnored++;  	}  	else {  		// All seems to be OK' so parse the line  		string[] saLine = line.Split ('\t');  		saManifest [linesParsed' 0] = saLine [0];  		saManifest [linesParsed' 1] = saLine [1];  		// Check for MD5  		if (saLine.Length > 2) {  			saManifest [linesParsed' 2] = saLine [2];  		}  		linesParsed++;  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (!line.Contains ("\t")) {  	Log.Warn ("Could not find delimiter in line #" + linesTotal + ".");  	linesErrored++;  }  else {  	// Check to see if we have too many entries  	if (linesParsed >= _manifestLengthMax) {  		Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  		linesIgnored++;  	}  	else {  		// All seems to be OK' so parse the line  		string[] saLine = line.Split ('\t');  		saManifest [linesParsed' 0] = saLine [0];  		saManifest [linesParsed' 1] = saLine [1];  		// Check for MD5  		if (saLine.Length > 2) {  			saManifest [linesParsed' 2] = saLine [2];  		}  		linesParsed++;  	}  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (linesParsed >= _manifestLengthMax) {  	Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  	linesIgnored++;  }  else {  	// All seems to be OK' so parse the line  	string[] saLine = line.Split ('\t');  	saManifest [linesParsed' 0] = saLine [0];  	saManifest [linesParsed' 1] = saLine [1];  	// Check for MD5  	if (saLine.Length > 2) {  		saManifest [linesParsed' 2] = saLine [2];  	}  	linesParsed++;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (linesParsed >= _manifestLengthMax) {  	Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  	linesIgnored++;  }  else {  	// All seems to be OK' so parse the line  	string[] saLine = line.Split ('\t');  	saManifest [linesParsed' 0] = saLine [0];  	saManifest [linesParsed' 1] = saLine [1];  	// Check for MD5  	if (saLine.Length > 2) {  		saManifest [linesParsed' 2] = saLine [2];  	}  	linesParsed++;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (linesParsed >= _manifestLengthMax) {  	Log.Debug ("Ignoring line #" + linesTotal + " because it would exceed the maximum number of allowed checks! (" + _manifestLengthMax + ")");  	linesIgnored++;  }  else {  	// All seems to be OK' so parse the line  	string[] saLine = line.Split ('\t');  	saManifest [linesParsed' 0] = saLine [0];  	saManifest [linesParsed' 1] = saLine [1];  	// Check for MD5  	if (saLine.Length > 2) {  		saManifest [linesParsed' 2] = saLine [2];  	}  	linesParsed++;  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (saLine.Length > 2) {  	saManifest [linesParsed' 2] = saLine [2];  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (saLine.Length > 2) {  	saManifest [linesParsed' 2] = saLine [2];  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: if (saLine.Length > 2) {  	saManifest [linesParsed' 2] = saLine [2];  }  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: saManifest [linesParsed' 2] = saLine [2];  
Magic Number,SourceVsDeployed,Manifest,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Manifest.cs,ParseFileToArray,The following statement contains a magic number: saManifest [linesParsed' 2] = saLine [2];  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The following statement contains a magic number: while (iJob < manifest.LinesParsed) {  	if (scheduler.GetCurrentlyExecutingJobs ().Count < threadCount) {  		Log.Debug ("...scheduler has room (at " + scheduler.GetCurrentlyExecutingJobs ().Count + ")' adding job #" + iJob + " now.");  		var ssb = SimpleScheduleBuilder.Create ();  		var ma = manifest.GetEntry (iJob);  		IJobDetail job = JobBuilder.Create (typeof(Job_CheckWebFile)).WithIdentity ("Job_" + iJob' "Job_CheckWebFile").UsingJobData ("URL"' Arguments.Target + ma.RelativePath).UsingJobData ("Hash"' ma.Md5).UsingJobData ("Expectation"' ma.Expectation).UsingJobData ("JobNumber"' iJob.ToString (CultureInfo.InvariantCulture)).Build ();  		ITrigger trigger = TriggerBuilder.Create ().WithSchedule (ssb.WithRepeatCount (0)).StartNow ().WithIdentity ("Trigger_" + iJob' "Trigger_CheckWebFile").Build ();  		scheduler.ScheduleJob (job' trigger);  		iJob++;  	}  	Thread.Sleep (20);  }  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (20);  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (5000);  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The following statement contains a magic number: while (scheduler.GetCurrentlyExecutingJobs ().Count > 0) {  	Thread.Sleep (500);  	Log.Debug ("...waiting for " + scheduler.GetCurrentlyExecutingJobs ().Count + " jobs to complete.");  }  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,HandleGlobalJobEvents,The following statement contains a magic number: lock (thisLock) {  	// Log.Debug("HandleGlobalJobEvents(" + sender + "'" + e + ")");  	if (e != null) {  		var eventArgsJobListener = (EventArgs_JobListener)e;  		int code = Int32.Parse (eventArgsJobListener.Code);  		string[] message = eventArgsJobListener.Message.Split ('|');  		CountChecked++;  		if (code == 0) {  			Log.Debug (message [1] + " - OK.");  			CountOk++;  		}  		else if (code == 1) {  			Log.Warn (message [1] + " - Corrupt!");  			CountCorrupt++;  		}  		else if (code == 2) {  			Log.Warn (message [1] + " - Missing!");  			CountMissing++;  		}  		else {  			Log.Warn (message [1] + " - OTHER ERROR! (see log)");  			CountOtherError++;  		}  	}  }  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,HandleGlobalJobEvents,The following statement contains a magic number: if (e != null) {  	var eventArgsJobListener = (EventArgs_JobListener)e;  	int code = Int32.Parse (eventArgsJobListener.Code);  	string[] message = eventArgsJobListener.Message.Split ('|');  	CountChecked++;  	if (code == 0) {  		Log.Debug (message [1] + " - OK.");  		CountOk++;  	}  	else if (code == 1) {  		Log.Warn (message [1] + " - Corrupt!");  		CountCorrupt++;  	}  	else if (code == 2) {  		Log.Warn (message [1] + " - Missing!");  		CountMissing++;  	}  	else {  		Log.Warn (message [1] + " - OTHER ERROR! (see log)");  		CountOtherError++;  	}  }  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,HandleGlobalJobEvents,The following statement contains a magic number: if (code == 0) {  	Log.Debug (message [1] + " - OK.");  	CountOk++;  }  else if (code == 1) {  	Log.Warn (message [1] + " - Corrupt!");  	CountCorrupt++;  }  else if (code == 2) {  	Log.Warn (message [1] + " - Missing!");  	CountMissing++;  }  else {  	Log.Warn (message [1] + " - OTHER ERROR! (see log)");  	CountOtherError++;  }  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,HandleGlobalJobEvents,The following statement contains a magic number: if (code == 1) {  	Log.Warn (message [1] + " - Corrupt!");  	CountCorrupt++;  }  else if (code == 2) {  	Log.Warn (message [1] + " - Missing!");  	CountMissing++;  }  else {  	Log.Warn (message [1] + " - OTHER ERROR! (see log)");  	CountOtherError++;  }  
Magic Number,SourceVsDeployed,Program,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Program.cs,HandleGlobalJobEvents,The following statement contains a magic number: if (code == 2) {  	Log.Warn (message [1] + " - Missing!");  	CountMissing++;  }  else {  	Log.Warn (message [1] + " - OTHER ERROR! (see log)");  	CountOtherError++;  }  
Missing Default,SourceVsDeployed,Arguments,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Arguments.cs,IsAValidAction,The following switch statement is missing a default case: switch (action) {  case "parse":  case "list":  case "validate":  	return true;  }  
Missing Default,SourceVsDeployed,Utility,C:\repos\jlampeatds_SourceVsDeployed\SourceVsDeployed\Utility.cs,ResolveDateMacro,The following switch statement is missing a default case: switch (macro.ToUpper ()) {  case "YYYY":  	return dateTime.ToString ("yyyy");  case "MM":  	return dateTime.ToString ("MM");  case "DD":  	return dateTime.ToString ("dd");  case "HH":  	return dateTime.ToString ("HH");  case "TT":  	return dateTime.ToString ("mm");  case "SS":  	return dateTime.ToString ("ss");  }  
