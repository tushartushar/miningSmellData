Implementation smell,Namespace,Class,File,Method,Description
Long Method,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The method has 144 lines of code.
Complex Method,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,Cyclomatic complexity of the method is 16
Long Statement,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The length of the statement  "            this.lHeader.Font = new System.Drawing.Font("Consolas"' 36F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 140.
Long Statement,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The length of the statement  "            this.lHeader.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0))))); " is 125.
Long Statement,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The length of the statement  "            this.lSubheader.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 157.
Long Statement,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The length of the statement  "            this.linkLabel2.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabel2_LinkClicked_1); " is 120.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The length of the statement  "            int pos = ( x + ( Rot == 1 || Rot == 3 ? offsetY : offsetX ) ) * isoX + ( y + ( Rot == 1 || Rot == 3 ? offsetX : offsetY ) ) * isoY + z * isoH + isoOffset; " is 155.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The length of the statement  "                image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor ); " is 137.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The length of the statement  "                image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor ); " is 149.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The length of the statement  "                image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor ); " is 149.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The length of the statement  "                image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 ); " is 128.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The length of the statement  "                image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 ); " is 140.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The length of the statement  "                image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 ); " is 140.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The length of the statement  "            } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) { " is 169.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The length of the statement  "            } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) { " is 136.
Long Statement,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The length of the statement  "            } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) { " is 194.
Complex Conditional,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The conditional expression  "blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40"  is complex.
Complex Conditional,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The conditional expression  "Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 )"  is complex.
Complex Conditional,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The conditional expression  "Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 )"  is complex.
Complex Conditional,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The conditional expression  "Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] )"  is complex.
Empty Catch Block,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,linkLabel1_LinkClicked,The method has an empty catch block.
Empty Catch Block,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,linkLabel2_LinkClicked,The method has an empty catch block.
Empty Catch Block,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,linkLabel2_LinkClicked_1,The method has an empty catch block.
Empty Catch Block,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The method has an empty catch block.
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lHeader.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0)))));
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lHeader.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0)))));
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lHeader.Location = new System.Drawing.Point(12' 9);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lHeader.Location = new System.Drawing.Point(12' 9);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lHeader.Size = new System.Drawing.Size(232' 56);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lHeader.Size = new System.Drawing.Size(232' 56);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lSubheader.Location = new System.Drawing.Point(12' 75);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lSubheader.Location = new System.Drawing.Point(12' 75);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lSubheader.Size = new System.Drawing.Size(276' 78);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lSubheader.Size = new System.Drawing.Size(276' 78);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.lSubheader.TabIndex = 2;
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(271' 75);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(271' 75);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(77' 13);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(77' 13);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.TabIndex = 3;
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Location = new System.Drawing.Point(213' 140);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Location = new System.Drawing.Point(213' 140);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Size = new System.Drawing.Size(92' 13);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Size = new System.Drawing.Size(92' 13);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.TabIndex = 4;
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(492' 404);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(492' 404);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(500' 440);
Magic Number,fCraft.GUI,AboutWindow,C:\repos\GlennMR_800craft\fCraftGUI\AboutWindow.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(500' 440);
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap tilesBmp = Resources.Tileset ) {                  TileX = tilesBmp.Width / 50;                  TileY = tilesBmp.Height;                  TileStride = TileX * TileY * 4;                  Tiles = new byte[50 * TileStride];                    MaxTileDim = Math.Max( TileX' TileY );                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = tilesBmp.GetPixel( x + i * TileX' y );                              Tiles[p] = c.B;                              Tiles[p + 1] = c.G;                              Tiles[p + 2] = c.R;                              Tiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap stilesBmp = Resources.TilesetShadowed ) {                  ShadowTiles = new byte[50 * TileStride];                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = stilesBmp.GetPixel( x + i * TileX' y );                              ShadowTiles[p] = c.B;                              ShadowTiles[p + 1] = c.G;                              ShadowTiles[p + 2] = c.R;                              ShadowTiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap stilesBmp = Resources.TilesetShadowed ) {                  ShadowTiles = new byte[50 * TileStride];                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = stilesBmp.GetPixel( x + i * TileX' y );                              ShadowTiles[p] = c.B;                              ShadowTiles[p + 1] = c.G;                              ShadowTiles[p + 2] = c.R;                              ShadowTiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap stilesBmp = Resources.TilesetShadowed ) {                  ShadowTiles = new byte[50 * TileStride];                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = stilesBmp.GetPixel( x + i * TileX' y );                              ShadowTiles[p] = c.B;                              ShadowTiles[p + 1] = c.G;                              ShadowTiles[p + 2] = c.R;                              ShadowTiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap stilesBmp = Resources.TilesetShadowed ) {                  ShadowTiles = new byte[50 * TileStride];                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = stilesBmp.GetPixel( x + i * TileX' y );                              ShadowTiles[p] = c.B;                              ShadowTiles[p + 1] = c.G;                              ShadowTiles[p + 2] = c.R;                              ShadowTiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: using ( Bitmap stilesBmp = Resources.TilesetShadowed ) {                  ShadowTiles = new byte[50 * TileStride];                    for ( int i = 0; i < 50; i++ ) {                      for ( int y = 0; y < TileY; y++ ) {                          for ( int x = 0; x < TileX; x++ ) {                              int p = i * TileStride + ( y * TileX + x ) * 4;                              System.Drawing.Color c = stilesBmp.GetPixel( x + i * TileX' y );                              ShadowTiles[p] = c.B;                              ShadowTiles[p + 1] = c.G;                              ShadowTiles[p + 2] = c.R;                              ShadowTiles[p + 3] = c.A;                          }                      }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: dimX2 = dimX / 2 - 1;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: dimY2 = dimY / 2 - 1;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: blendDivisor = 255 * Map.Height;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: imageWidth = TileX * Math.Max( dimX' dimY ) + TileY / 2 * Map.Height + TileX * 2;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: imageWidth = TileX * Math.Max( dimX' dimY ) + TileY / 2 * Map.Height + TileX * 2;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: imageHeight = TileY / 2 * Map.Height + MaxTileDim / 2 * Math.Max( Math.Max( dimX' dimY )' Map.Height ) + TileY * 2;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: imageHeight = TileY / 2 * Map.Height + MaxTileDim / 2 * Math.Max( Math.Max( dimX' dimY )' Map.Height ) + TileY * 2;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: imageHeight = TileY / 2 * Map.Height + MaxTileDim / 2 * Math.Max( Math.Max( dimX' dimY )' Map.Height ) + TileY * 2;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoOffset = ( Map.Height * TileY / 2 * imageStride + imageStride / 2 + TileX * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoOffset = ( Map.Height * TileY / 2 * imageStride + imageStride / 2 + TileX * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoOffset = ( Map.Height * TileY / 2 * imageStride + imageStride / 2 + TileX * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoX = ( TileX / 4 * imageStride + TileX * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoX = ( TileX / 4 * imageStride + TileX * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoY = ( TileY / 4 * imageStride - TileY * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoY = ( TileY / 4 * imageStride - TileY * 2 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: isoH = ( -TileY / 2 * imageStride );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: mh34 = Map.Height * 3 / 4;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,IsoCat,The following statement contains a magic number: mh34 = Map.Height * 3 / 4;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following statement contains a magic number: try {                  fixed ( byte* bpx = Map.Blocks ) {                      fixed ( byte* tp = Tiles ) {                          fixed ( byte* stp = ShadowTiles ) {                              bp = bpx;                              while ( z < Map.Height ) {                                  block = GetBlock( x' y' z );                                  if ( block != 0 ) {                                      switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }                                        int blockRight' blockLeft' blockUp;                                        if ( x != ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) )                                          blockRight = GetBlock( x + 1' y' z );                                      else                                          blockRight = 0;                                      if ( y != ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) )                                          blockLeft = GetBlock( x' y + 1' z );                                      else                                          blockLeft = 0;                                      if ( z != Map.Height - 1 )                                          blockUp = GetBlock( x' y' z + 1 );                                      else                                          blockUp = 0;                                        if ( blockUp == 0 || blockLeft == 0 || blockRight == 0 || // air                                          blockUp == 8 || blockLeft == 8 || blockRight == 8 || // water                                          blockUp == 9 || blockLeft == 9 || blockRight == 9 || // water                                          ( block != 20 && ( blockUp == 20 || blockLeft == 20 || blockRight == 20 ) ) || // glass                                          blockUp == 18 || blockLeft == 18 || blockRight == 18 || // foliage                                          blockLeft == 44 || blockRight == 44 || // step                                            blockUp == 10 || blockLeft == 10 || blockRight == 10 || // lava                                          blockUp == 11 || blockLeft == 11 || blockRight == 11 || // lava                                            blockUp == 37 || blockLeft == 37 || blockRight == 37 || // flower                                          blockUp == 38 || blockLeft == 38 || blockRight == 38 || // flower                                          blockUp == 6 || blockLeft == 6 || blockRight == 6 || // tree                                          blockUp == 39 || blockLeft == 39 || blockRight == 39 || // mushroom                                          blockUp == 40 || blockLeft == 40 || blockRight == 40 ) // mushroom                                          BlendTile();                                  }                                    x++;                                  if ( x == ( Rot == 1 || Rot == 3 ? dimY : dimX ) ) {                                      y++;                                      x = 0;                                  }                                  if ( y == ( Rot == 1 || Rot == 3 ? dimX : dimY ) ) {                                      z++;                                      y = 0;                                      if ( worker != null && z % 4 == 0 ) {                                          if ( worker.CancellationPending )                                              return null;                                          worker.ReportProgress( ( z * 100 ) / Map.Height );                                      }                                  }                              }                          }                      }                  }                    int xMin = 0' xMax = imageWidth - 1' yMin = 0' yMax = imageHeight - 1;                  bool cont = true;                  int offset;                    // find left bound (xMin)                  for ( x = 0; cont && x < imageWidth; x++ ) {                      offset = x * 4 + 3;                      for ( y = 0; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMin = x;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find top bound (yMin)                  cont = true;                  for ( y = 0; cont && y < imageHeight; y++ ) {                      offset = imageStride * y + xMin * 4 + 3;                      for ( x = xMin; x < imageWidth; x++ ) {                          if ( image[offset] > 0 ) {                              yMin = y;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find right bound (xMax)                  cont = true;                  for ( x = imageWidth - 1; cont && x >= xMin; x-- ) {                      offset = x * 4 + 3 + yMin * imageStride;                      for ( y = yMin; y < imageHeight; y++ ) {                          if ( image[offset] > 0 ) {                              xMax = x + 1;                              cont = false;                              break;                          }                          offset += imageStride;                      }                  }                    if ( worker != null && worker.CancellationPending )                      return null;                    // find bottom bound (yMax)                  cont = true;                  for ( y = imageHeight - 1; cont && y >= yMin; y-- ) {                      offset = imageStride * y + 3 + xMin * 4;                      for ( x = xMin; x < xMax; x++ ) {                          if ( image[offset] > 0 ) {                              yMax = y + 1;                              cont = false;                              break;                          }                          offset += 4;                      }                  }                    cropRectangle = new Rectangle( Math.Max( 0' xMin - 2 )'                                                 Math.Max( 0' yMin - 2 )'                                                 Math.Min( imageBmp.Width' xMax - xMin + 4 )'                                                 Math.Min( imageBmp.Height' yMax - yMin + 4 ) );                  return imageBmp;              } finally {                  imageBmp.UnlockBits( imageData );                  if ( worker != null && worker.CancellationPending && imageBmp != null ) {                      try {                          imageBmp.Dispose();                      } catch ( ObjectDisposedException ) { }                  }              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: int pos = ( x + ( Rot == 1 || Rot == 3 ? offsetY : offsetX ) ) * isoX + ( y + ( Rot == 1 || Rot == 3 ? offsetX : offsetY ) ) * isoY + z * isoH + isoOffset;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: int pos = ( x + ( Rot == 1 || Rot == 3 ? offsetY : offsetX ) ) * isoX + ( y + ( Rot == 1 || Rot == 3 ? offsetX : offsetY ) ) * isoY + z * isoH + isoOffset;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: if ( block > 49 )                  return;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 4 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 4 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 8 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 8 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 12' tileOffset + 12 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 12' tileOffset + 12 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos' tileOffset + 16 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 20 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 20 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 24 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 24 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 12' tileOffset + 28 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 12' tileOffset + 28 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos' tileOffset + 32 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 36 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 36 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 40 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 40 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 12' tileOffset + 44 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 12' tileOffset + 44 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 52 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 4' tileOffset + 52 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 56 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendTile,The following statement contains a magic number: BlendPixel( pos + 8' tileOffset + 56 );
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( ctp[tileOffset + 3] == 0 )                  return;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: byte tA = ctp[tileOffset + 3];
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: int finalAlpha = tA + ( ( 255 - tA ) * image[imageOffset + 3] ) / 255;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: int finalAlpha = tA + ( ( 255 - tA ) * image[imageOffset + 3] ) / 255;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: int finalAlpha = tA + ( ( 255 - tA ) * image[imageOffset + 3] ) / 255;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( finalAlpha == 0 ) {                  sourceAlpha = 0;              } else {                  sourceAlpha = tA * 255 / finalAlpha;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: int destAlpha = 255 - sourceAlpha;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: if ( z < ( Map.Height >> 1 ) ) {                  int shadow = ( z >> 1 ) + mh34;                  image[imageOffset] = ( byte )( ( ctp[tileOffset] * sourceAlpha * shadow + image[imageOffset] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 1] = ( byte )( ( ctp[tileOffset + 1] * sourceAlpha * shadow + image[imageOffset + 1] * destAlpha * Map.Height ) / blendDivisor );                  image[imageOffset + 2] = ( byte )( ( ctp[tileOffset + 2] * sourceAlpha * shadow + image[imageOffset + 2] * destAlpha * Map.Height ) / blendDivisor );              } else {                  int shadow = ( z - ( Map.Height >> 1 ) ) * ShadingStrength;                  image[imageOffset] = ( byte )Math.Min( 255' ( ctp[tileOffset] * sourceAlpha + shadow + image[imageOffset] * destAlpha ) / 255 );                  image[imageOffset + 1] = ( byte )Math.Min( 255' ( ctp[tileOffset + 1] * sourceAlpha + shadow + image[imageOffset + 1] * destAlpha ) / 255 );                  image[imageOffset + 2] = ( byte )Math.Min( 255' ( ctp[tileOffset + 2] * sourceAlpha + shadow + image[imageOffset + 2] * destAlpha ) / 255 );              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,BlendPixel,The following statement contains a magic number: image[imageOffset + 3] = ( byte )finalAlpha;
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: switch ( Rot ) {                  case 0:                      realx = xx;                      realy = yy;                      break;                    case 1:                      realx = dimX1 - yy;                      realy = xx;                      break;                    case 2:                      realx = dimX1 - xx;                      realy = dimY1 - yy;                      break;                    default:                      realx = yy;                      realy = dimY1 - xx;                      break;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Magic Number,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,GetBlock,The following statement contains a magic number: if ( Mode == IsoCatMode.Normal ) {                  return bp[pos];              } else if ( Mode == IsoCatMode.Peeled && ( xx == ( Rot == 1 || Rot == 3 ? dimY1 : dimX1 ) || yy == ( Rot == 1 || Rot == 3 ? dimX1 : dimY1 ) || zz == Map.Height - 1 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Cut && xx > ( Rot == 1 || Rot == 3 ? dimY2 : dimX2 ) && yy > ( Rot == 1 || Rot == 3 ? dimX2 : dimY2 ) ) {                  return 0;              } else if ( Mode == IsoCatMode.Chunk && ( realx < ChunkCoords[0] || realy < ChunkCoords[1] || zz < ChunkCoords[2] || realx > ChunkCoords[3] || realy > ChunkCoords[4] || zz > ChunkCoords[5] ) ) {                  return 0;              }
Missing Default,fCraft.GUI,IsoCat,C:\repos\GlennMR_800craft\fCraftGUI\IsoCat.cs,Draw,The following switch statement is missing a default case: switch ( Rot ) {                                          case 0:                                              ctp = ( z >= Map.Shadows[x' y] ? tp : stp );                                              break;                                            case 1:                                              ctp = ( z >= Map.Shadows[dimX1 - y' x] ? tp : stp );                                              break;                                            case 2:                                              ctp = ( z >= Map.Shadows[dimX1 - x' dimY1 - y] ? tp : stp );                                              break;                                            case 3:                                              ctp = ( z >= Map.Shadows[y' dimY1 - x] ? tp : stp );                                              break;                                      }
