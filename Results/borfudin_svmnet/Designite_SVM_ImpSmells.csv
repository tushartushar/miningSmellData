Implementation smell,Namespace,Class,File,Method,Description
Long Method,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The method has 117 lines of code.
Long Method,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The method has 207 lines of code.
Long Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The method has 105 lines of code.
Long Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The method has 179 lines of code.
Complex Method,SVM,Cache,C:\repos\borfudin_svmnet\SVM\SVM\Cache.cs,SwapIndex,Cyclomatic complexity of the method is 9
Complex Method,SVM,GaussianTransform,C:\repos\borfudin_svmnet\SVM\SVM\GaussianTransform.cs,Compute,Cyclomatic complexity of the method is 9
Complex Method,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,dot,Cyclomatic complexity of the method is 9
Complex Method,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,computeSquaredDistance,Cyclomatic complexity of the method is 11
Complex Method,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,Cyclomatic complexity of the method is 75
Complex Method,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,Cyclomatic complexity of the method is 26
Complex Method,SVM,PrecomputedKernel,C:\repos\borfudin_svmnet\SVM\SVM\PrecomputedKernel.cs,Compute,Cyclomatic complexity of the method is 8
Complex Method,SVM,Prediction,C:\repos\borfudin_svmnet\SVM\SVM\Prediction.cs,Predict,Cyclomatic complexity of the method is 11
Complex Method,SVM,Prediction,C:\repos\borfudin_svmnet\SVM\SVM\Prediction.cs,Predict,Cyclomatic complexity of the method is 8
Complex Method,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,swap_index,Cyclomatic complexity of the method is 8
Complex Method,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,reconstruct_gradient,Cyclomatic complexity of the method is 17
Complex Method,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,Cyclomatic complexity of the method is 59
Complex Method,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,Cyclomatic complexity of the method is 21
Complex Method,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,do_shrinking,Cyclomatic complexity of the method is 17
Complex Method,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,Cyclomatic complexity of the method is 23
Complex Method,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,do_shrinking,Cyclomatic complexity of the method is 16
Complex Method,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,Cyclomatic complexity of the method is 9
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,solve_c_svc,Cyclomatic complexity of the method is 8
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,solve_nu_svc,Cyclomatic complexity of the method is 11
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train_one,Cyclomatic complexity of the method is 20
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,Cyclomatic complexity of the method is 17
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,multiclass_probability,Cyclomatic complexity of the method is 14
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_binary_svc_probability,Cyclomatic complexity of the method is 21
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,Cyclomatic complexity of the method is 16
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,Cyclomatic complexity of the method is 57
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_cross_validation,Cyclomatic complexity of the method is 33
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_values,Cyclomatic complexity of the method is 20
Complex Method,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,Cyclomatic complexity of the method is 13
Complex Method,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,Cyclomatic complexity of the method is 52
Long Parameter List,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The method has 5 parameters.
Long Parameter List,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The method has 7 parameters.
Long Parameter List,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The method has 12 parameters.
Long Parameter List,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The method has 6 parameters.
Long Parameter List,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The method has 12 parameters.
Long Parameter List,SVM,RangeTransform,C:\repos\borfudin_svmnet\SVM\SVM\RangeTransform.cs,RangeTransform,The method has 5 parameters.
Long Parameter List,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The method has 10 parameters.
Long Parameter List,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The method has 10 parameters.
Long Parameter List,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,be_shrunk,The method has 5 parameters.
Long Parameter List,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,solve_c_svc,The method has 6 parameters.
Long Parameter List,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_binary_svc_probability,The method has 5 parameters.
Long Parameter List,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,The method has 6 parameters.
Long Parameter List,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The method has 6 parameters.
Long Statement,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,GetHashCode,The length of the statement  "	return ClassLabels.ComputeHashcode () + NumberOfClasses.GetHashCode () + NumberOfSVPerClass.ComputeHashcode () + PairwiseProbabilityA.ComputeHashcode () + PairwiseProbabilityB.ComputeHashcode () + Parameter.GetHashCode () + Rho.ComputeHashcode () + SupportVectorCoefficients.ComputeHashcode () + SupportVectorCount.GetHashCode () + SupportVectors.ComputeHashcode (); " is 366.
Long Statement,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,The length of the statement  "	if (param.KernelType == KernelType.POLY || param.KernelType == KernelType.RBF || param.KernelType == KernelType.SIGMOID) " is 120.
Long Statement,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,Equals,The length of the statement  "	return other.C == C && other.CacheSize == CacheSize && other.Coefficient0 == Coefficient0 && other.Degree == Degree && other.EPS == EPS && other.Gamma == Gamma && other.KernelType == KernelType && other.Nu == Nu && other.P == P && other.Probability == Probability && other.Shrinking == Shrinking && other.SvmType == SvmType && other.Weights.ToArray ().IsEqual (Weights.ToArray ()); " is 381.
Long Statement,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,GetHashCode,The length of the statement  "	return C.GetHashCode () + CacheSize.GetHashCode () + Coefficient0.GetHashCode () + Degree.GetHashCode () + EPS.GetHashCode () + Gamma.GetHashCode () + KernelType.GetHashCode () + Nu.GetHashCode () + P.GetHashCode () + Probability.GetHashCode () + Shrinking.GetHashCode () + SvmType.GetHashCode () + Weights.ToArray ().ComputeHashcode (); " is 337.
Long Statement,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The length of the statement  "	return Grid (problem' createParams' GetList (MIN_C' MAX_C' C_STEP)' GetList (MIN_G' MAX_G' G_STEP)' report' NFOLD' out C' out Gamma); " is 133.
Long Statement,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,Grid,The length of the statement  "	return Grid (problem' validation' createParams' GetList (MIN_C' MAX_C' C_STEP)' GetList (MIN_G' MAX_G' G_STEP)' report' out C' out Gamma); " is 138.
Long Statement,SVM,Prediction,C:\repos\borfudin_svmnet\SVM\SVM\Prediction.cs,Predict,The length of the statement  "			Console.WriteLine ("Prob. model for test data: target value = predicted value + z'\nz: Laplace distribution e^(-|z|/sigma)/(2sigma)'sigma=" + Procedures.svm_get_svr_probability (model)); " is 186.
Long Statement,SVM,Prediction,C:\repos\borfudin_svmnet\SVM\SVM\Prediction.cs,exit_with_help,The length of the statement  "	Debug.Write ("usage: svm_predict [options] test_file model_file output_file\n" + "options:\n" + "-b probability_estimates: whether to predict probability estimates' 0 or 1 (default 0); one-class SVM not supported yet\n"); " is 221.
Long Statement,SVM,Scaling,C:\repos\borfudin_svmnet\SVM\SVM\Scaling.cs,Scale,The length of the statement  "			scaledProblem.X [i] [j] = new Node (prob.X [i] [j].Index' range.Transform (prob.X [i] [j].Value' prob.X [i] [j].Index)); " is 120.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_svr_probability,The length of the statement  "	info ("Prob. model for test data: target value = predicted value + z'\nz: Laplace distribution e^(-|z|/sigma)/(2sigma)'sigma=" + mae + "\n"); " is 141.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_get_svr_probability,The length of the statement  "	if ((model.Parameter.SvmType == SvmType.EPSILON_SVR || model.Parameter.SvmType == SvmType.NU_SVR) && model.PairwiseProbabilityA != null) " is 136.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_values,The length of the statement  "	if (model.Parameter.SvmType == SvmType.ONE_CLASS || model.Parameter.SvmType == SvmType.EPSILON_SVR || model.Parameter.SvmType == SvmType.NU_SVR) { " is 146.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict,The length of the statement  "	if (model.Parameter.SvmType == SvmType.ONE_CLASS || model.Parameter.SvmType == SvmType.EPSILON_SVR || model.Parameter.SvmType == SvmType.NU_SVR) " is 144.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_probability,The length of the statement  "	if ((model.Parameter.SvmType == SvmType.C_SVC || model.Parameter.SvmType == SvmType.NU_SVC) && model.PairwiseProbabilityA != null && model.PairwiseProbabilityB != null) { " is 170.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_probability,The length of the statement  "				pairwise_prob [i' j] = Math.Min (Math.Max (sigmoid_predict (dec_values [k]' model.PairwiseProbabilityA [k]' model.PairwiseProbabilityB [k])' min_prob)' 1 - min_prob); " is 166.
Long Statement,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_probability_model,The length of the statement  "	if (((model.Parameter.SvmType == SvmType.C_SVC || model.Parameter.SvmType == SvmType.NU_SVC) && model.PairwiseProbabilityA != null && model.PairwiseProbabilityB != null) || ((model.Parameter.SvmType == SvmType.EPSILON_SVR || model.Parameter.SvmType == SvmType.NU_SVR) && model.PairwiseProbabilityA != null)) " is 307.
Long Statement,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,doCrossValidation,The length of the statement  "		return (problem.Count * sumvy - sumv * sumy) / (Math.Sqrt (problem.Count * sumvv - sumv * sumv) * Math.Sqrt (problem.Count * sumyy - sumy * sumy)); " is 147.
Complex Conditional,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_probability,The conditional expression  "(model.Parameter.SvmType == SvmType.C_SVC || model.Parameter.SvmType == SvmType.NU_SVC) && model.PairwiseProbabilityA != null && model.PairwiseProbabilityB != null"  is complex.
Complex Conditional,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_probability_model,The conditional expression  "((model.Parameter.SvmType == SvmType.C_SVC || model.Parameter.SvmType == SvmType.NU_SVC) && model.PairwiseProbabilityA != null && model.PairwiseProbabilityB != null) || ((model.Parameter.SvmType == SvmType.EPSILON_SVR || model.Parameter.SvmType == SvmType.NU_SVR) && model.PairwiseProbabilityA != null)"  is complex.
Magic Number,SVM,Cache,C:\repos\borfudin_svmnet\SVM\SVM\Cache.cs,Cache,The following statement contains a magic number: _size /= 4;  
Magic Number,SVM,Cache,C:\repos\borfudin_svmnet\SVM\SVM\Cache.cs,Cache,The following statement contains a magic number: _size -= _count * (16 / 4);  
Magic Number,SVM,Cache,C:\repos\borfudin_svmnet\SVM\SVM\Cache.cs,Cache,The following statement contains a magic number: _size -= _count * (16 / 4);  
Magic Number,SVM,GaussianTransform,C:\repos\borfudin_svmnet\SVM\SVM\GaussianTransform.cs,Compute,The following statement contains a magic number: for (int i = 0; i < prob.MaxIndex; i++) {  	if (counts [i] == 0)  		counts [i] = 2;  	means [i] /= counts [i];  }  
Magic Number,SVM,GaussianTransform,C:\repos\borfudin_svmnet\SVM\SVM\GaussianTransform.cs,Compute,The following statement contains a magic number: if (counts [i] == 0)  	counts [i] = 2;  
Magic Number,SVM,GaussianTransform,C:\repos\borfudin_svmnet\SVM\SVM\GaussianTransform.cs,Compute,The following statement contains a magic number: counts [i] = 2;  
Magic Number,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,powi,The following statement contains a magic number: for (int t = times; t > 0; t /= 2) {  	if (t % 2 == 1)  		ret *= tmp;  	tmp = tmp * tmp;  }  
Magic Number,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,powi,The following statement contains a magic number: for (int t = times; t > 0; t /= 2) {  	if (t % 2 == 1)  		ret *= tmp;  	tmp = tmp * tmp;  }  
Magic Number,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,powi,The following statement contains a magic number: t /= 2
Magic Number,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,powi,The following statement contains a magic number: if (t % 2 == 1)  	ret *= tmp;  
Magic Number,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,KernelFunction,The following statement contains a magic number: switch (_kernelType) {  case KernelType.LINEAR:  	return dot (_x [i]' _x [j]);  case KernelType.POLY:  	return powi (_gamma * dot (_x [i]' _x [j]) + _coef0' _degree);  case KernelType.RBF:  	return Math.Exp (-_gamma * (_xSquare [i] + _xSquare [j] - 2 * dot (_x [i]' _x [j])));  case KernelType.SIGMOID:  	return Math.Tanh (_gamma * dot (_x [i]' _x [j]) + _coef0);  case KernelType.PRECOMPUTED:  	return _x [i] [(int)(_x [j] [0].Value)].Value;  default:  	return 0;  }  
Magic Number,SVM,Kernel,C:\repos\borfudin_svmnet\SVM\SVM\Kernel.cs,KernelFunction,The following statement contains a magic number: return Math.Exp (-_gamma * (_xSquare [i] + _xSquare [j] - 2 * dot (_x [i]' _x [j])));  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: while (!headerFinished) {  	string line = input.ReadLine ();  	string cmd' arg;  	int splitIndex = line.IndexOf (' ');  	if (splitIndex >= 0) {  		cmd = line.Substring (0' splitIndex);  		arg = line.Substring (splitIndex + 1);  	}  	else {  		cmd = line;  		arg = "";  	}  	arg = arg.ToLower ();  	int i' n;  	switch (cmd) {  	case "svm_type":  		param.SvmType = (SvmType)Enum.Parse (typeof(SvmType)' arg.ToUpper ());  		break;  	case "kernel_type":  		if (arg == "polynomial")  			arg = "poly";  		param.KernelType = (KernelType)Enum.Parse (typeof(KernelType)' arg.ToUpper ());  		break;  	case "degree":  		param.Degree = int.Parse (arg);  		break;  	case "gamma":  		param.Gamma = double.Parse (arg);  		break;  	case "coef0":  		param.Coefficient0 = double.Parse (arg);  		break;  	case "nr_class":  		model.NumberOfClasses = int.Parse (arg);  		break;  	case "total_sv":  		model.SupportVectorCount = int.Parse (arg);  		break;  	case "rho":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.Rho = new double[n];  		string[] rhoParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.Rho [i] = double.Parse (rhoParts [i]);  		break;  	case "label":  		n = model.NumberOfClasses;  		model.ClassLabels = new int[n];  		string[] labelParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.ClassLabels [i] = int.Parse (labelParts [i]);  		break;  	case "probA":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.PairwiseProbabilityA = new double[n];  		string[] probAParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.PairwiseProbabilityA [i] = double.Parse (probAParts [i]);  		break;  	case "probB":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.PairwiseProbabilityB = new double[n];  		string[] probBParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.PairwiseProbabilityB [i] = double.Parse (probBParts [i]);  		break;  	case "nr_sv":  		n = model.NumberOfClasses;  		model.NumberOfSVPerClass = new int[n];  		string[] nrsvParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.NumberOfSVPerClass [i] = int.Parse (nrsvParts [i]);  		break;  	case "SV":  		headerFinished = true;  		break;  	default:  		throw new Exception ("Unknown text in model file");  	}  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: while (!headerFinished) {  	string line = input.ReadLine ();  	string cmd' arg;  	int splitIndex = line.IndexOf (' ');  	if (splitIndex >= 0) {  		cmd = line.Substring (0' splitIndex);  		arg = line.Substring (splitIndex + 1);  	}  	else {  		cmd = line;  		arg = "";  	}  	arg = arg.ToLower ();  	int i' n;  	switch (cmd) {  	case "svm_type":  		param.SvmType = (SvmType)Enum.Parse (typeof(SvmType)' arg.ToUpper ());  		break;  	case "kernel_type":  		if (arg == "polynomial")  			arg = "poly";  		param.KernelType = (KernelType)Enum.Parse (typeof(KernelType)' arg.ToUpper ());  		break;  	case "degree":  		param.Degree = int.Parse (arg);  		break;  	case "gamma":  		param.Gamma = double.Parse (arg);  		break;  	case "coef0":  		param.Coefficient0 = double.Parse (arg);  		break;  	case "nr_class":  		model.NumberOfClasses = int.Parse (arg);  		break;  	case "total_sv":  		model.SupportVectorCount = int.Parse (arg);  		break;  	case "rho":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.Rho = new double[n];  		string[] rhoParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.Rho [i] = double.Parse (rhoParts [i]);  		break;  	case "label":  		n = model.NumberOfClasses;  		model.ClassLabels = new int[n];  		string[] labelParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.ClassLabels [i] = int.Parse (labelParts [i]);  		break;  	case "probA":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.PairwiseProbabilityA = new double[n];  		string[] probAParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.PairwiseProbabilityA [i] = double.Parse (probAParts [i]);  		break;  	case "probB":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.PairwiseProbabilityB = new double[n];  		string[] probBParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.PairwiseProbabilityB [i] = double.Parse (probBParts [i]);  		break;  	case "nr_sv":  		n = model.NumberOfClasses;  		model.NumberOfSVPerClass = new int[n];  		string[] nrsvParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.NumberOfSVPerClass [i] = int.Parse (nrsvParts [i]);  		break;  	case "SV":  		headerFinished = true;  		break;  	default:  		throw new Exception ("Unknown text in model file");  	}  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: while (!headerFinished) {  	string line = input.ReadLine ();  	string cmd' arg;  	int splitIndex = line.IndexOf (' ');  	if (splitIndex >= 0) {  		cmd = line.Substring (0' splitIndex);  		arg = line.Substring (splitIndex + 1);  	}  	else {  		cmd = line;  		arg = "";  	}  	arg = arg.ToLower ();  	int i' n;  	switch (cmd) {  	case "svm_type":  		param.SvmType = (SvmType)Enum.Parse (typeof(SvmType)' arg.ToUpper ());  		break;  	case "kernel_type":  		if (arg == "polynomial")  			arg = "poly";  		param.KernelType = (KernelType)Enum.Parse (typeof(KernelType)' arg.ToUpper ());  		break;  	case "degree":  		param.Degree = int.Parse (arg);  		break;  	case "gamma":  		param.Gamma = double.Parse (arg);  		break;  	case "coef0":  		param.Coefficient0 = double.Parse (arg);  		break;  	case "nr_class":  		model.NumberOfClasses = int.Parse (arg);  		break;  	case "total_sv":  		model.SupportVectorCount = int.Parse (arg);  		break;  	case "rho":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.Rho = new double[n];  		string[] rhoParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.Rho [i] = double.Parse (rhoParts [i]);  		break;  	case "label":  		n = model.NumberOfClasses;  		model.ClassLabels = new int[n];  		string[] labelParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.ClassLabels [i] = int.Parse (labelParts [i]);  		break;  	case "probA":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.PairwiseProbabilityA = new double[n];  		string[] probAParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.PairwiseProbabilityA [i] = double.Parse (probAParts [i]);  		break;  	case "probB":  		n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  		model.PairwiseProbabilityB = new double[n];  		string[] probBParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.PairwiseProbabilityB [i] = double.Parse (probBParts [i]);  		break;  	case "nr_sv":  		n = model.NumberOfClasses;  		model.NumberOfSVPerClass = new int[n];  		string[] nrsvParts = arg.Split ();  		for (i = 0; i < n; i++)  			model.NumberOfSVPerClass [i] = int.Parse (nrsvParts [i]);  		break;  	case "SV":  		headerFinished = true;  		break;  	default:  		throw new Exception ("Unknown text in model file");  	}  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: switch (cmd) {  case "svm_type":  	param.SvmType = (SvmType)Enum.Parse (typeof(SvmType)' arg.ToUpper ());  	break;  case "kernel_type":  	if (arg == "polynomial")  		arg = "poly";  	param.KernelType = (KernelType)Enum.Parse (typeof(KernelType)' arg.ToUpper ());  	break;  case "degree":  	param.Degree = int.Parse (arg);  	break;  case "gamma":  	param.Gamma = double.Parse (arg);  	break;  case "coef0":  	param.Coefficient0 = double.Parse (arg);  	break;  case "nr_class":  	model.NumberOfClasses = int.Parse (arg);  	break;  case "total_sv":  	model.SupportVectorCount = int.Parse (arg);  	break;  case "rho":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.Rho = new double[n];  	string[] rhoParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.Rho [i] = double.Parse (rhoParts [i]);  	break;  case "label":  	n = model.NumberOfClasses;  	model.ClassLabels = new int[n];  	string[] labelParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.ClassLabels [i] = int.Parse (labelParts [i]);  	break;  case "probA":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.PairwiseProbabilityA = new double[n];  	string[] probAParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.PairwiseProbabilityA [i] = double.Parse (probAParts [i]);  	break;  case "probB":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.PairwiseProbabilityB = new double[n];  	string[] probBParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.PairwiseProbabilityB [i] = double.Parse (probBParts [i]);  	break;  case "nr_sv":  	n = model.NumberOfClasses;  	model.NumberOfSVPerClass = new int[n];  	string[] nrsvParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.NumberOfSVPerClass [i] = int.Parse (nrsvParts [i]);  	break;  case "SV":  	headerFinished = true;  	break;  default:  	throw new Exception ("Unknown text in model file");  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: switch (cmd) {  case "svm_type":  	param.SvmType = (SvmType)Enum.Parse (typeof(SvmType)' arg.ToUpper ());  	break;  case "kernel_type":  	if (arg == "polynomial")  		arg = "poly";  	param.KernelType = (KernelType)Enum.Parse (typeof(KernelType)' arg.ToUpper ());  	break;  case "degree":  	param.Degree = int.Parse (arg);  	break;  case "gamma":  	param.Gamma = double.Parse (arg);  	break;  case "coef0":  	param.Coefficient0 = double.Parse (arg);  	break;  case "nr_class":  	model.NumberOfClasses = int.Parse (arg);  	break;  case "total_sv":  	model.SupportVectorCount = int.Parse (arg);  	break;  case "rho":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.Rho = new double[n];  	string[] rhoParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.Rho [i] = double.Parse (rhoParts [i]);  	break;  case "label":  	n = model.NumberOfClasses;  	model.ClassLabels = new int[n];  	string[] labelParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.ClassLabels [i] = int.Parse (labelParts [i]);  	break;  case "probA":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.PairwiseProbabilityA = new double[n];  	string[] probAParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.PairwiseProbabilityA [i] = double.Parse (probAParts [i]);  	break;  case "probB":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.PairwiseProbabilityB = new double[n];  	string[] probBParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.PairwiseProbabilityB [i] = double.Parse (probBParts [i]);  	break;  case "nr_sv":  	n = model.NumberOfClasses;  	model.NumberOfSVPerClass = new int[n];  	string[] nrsvParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.NumberOfSVPerClass [i] = int.Parse (nrsvParts [i]);  	break;  case "SV":  	headerFinished = true;  	break;  default:  	throw new Exception ("Unknown text in model file");  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: switch (cmd) {  case "svm_type":  	param.SvmType = (SvmType)Enum.Parse (typeof(SvmType)' arg.ToUpper ());  	break;  case "kernel_type":  	if (arg == "polynomial")  		arg = "poly";  	param.KernelType = (KernelType)Enum.Parse (typeof(KernelType)' arg.ToUpper ());  	break;  case "degree":  	param.Degree = int.Parse (arg);  	break;  case "gamma":  	param.Gamma = double.Parse (arg);  	break;  case "coef0":  	param.Coefficient0 = double.Parse (arg);  	break;  case "nr_class":  	model.NumberOfClasses = int.Parse (arg);  	break;  case "total_sv":  	model.SupportVectorCount = int.Parse (arg);  	break;  case "rho":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.Rho = new double[n];  	string[] rhoParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.Rho [i] = double.Parse (rhoParts [i]);  	break;  case "label":  	n = model.NumberOfClasses;  	model.ClassLabels = new int[n];  	string[] labelParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.ClassLabels [i] = int.Parse (labelParts [i]);  	break;  case "probA":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.PairwiseProbabilityA = new double[n];  	string[] probAParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.PairwiseProbabilityA [i] = double.Parse (probAParts [i]);  	break;  case "probB":  	n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  	model.PairwiseProbabilityB = new double[n];  	string[] probBParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.PairwiseProbabilityB [i] = double.Parse (probBParts [i]);  	break;  case "nr_sv":  	n = model.NumberOfClasses;  	model.NumberOfSVPerClass = new int[n];  	string[] nrsvParts = arg.Split ();  	for (i = 0; i < n; i++)  		model.NumberOfSVPerClass [i] = int.Parse (nrsvParts [i]);  	break;  case "SV":  	headerFinished = true;  	break;  default:  	throw new Exception ("Unknown text in model file");  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Read,The following statement contains a magic number: n = model.NumberOfClasses * (model.NumberOfClasses - 1) / 2;  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,The following statement contains a magic number: for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	output.Write (" {0:0.000000}"' model.Rho [i]);  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,The following statement contains a magic number: if (model.PairwiseProbabilityA != null)// regression has probA only   {  	output.Write ("probA");  	for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		output.Write (" {0:0.000000}"' model.PairwiseProbabilityA [i]);  	output.Write ("\n");  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,The following statement contains a magic number: for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	output.Write (" {0:0.000000}"' model.PairwiseProbabilityA [i]);  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,The following statement contains a magic number: if (model.PairwiseProbabilityB != null) {  	output.Write ("probB");  	for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		output.Write (" {0:0.000000}"' model.PairwiseProbabilityB [i]);  	output.Write ("\n");  }  
Magic Number,SVM,Model,C:\repos\borfudin_svmnet\SVM\SVM\Model.cs,Write,The following statement contains a magic number: for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	output.Write (" {0:0.000000}"' model.PairwiseProbabilityB [i]);  
Magic Number,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,Parameter,The following statement contains a magic number: Degree = 3;  
Magic Number,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,Parameter,The following statement contains a magic number: Nu = 0.5;  
Magic Number,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,Parameter,The following statement contains a magic number: CacheSize = 40;  
Magic Number,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,Parameter,The following statement contains a magic number: EPS = 1e-3;  
Magic Number,SVM,Parameter,C:\repos\borfudin_svmnet\SVM\SVM\Parameter.cs,Parameter,The following statement contains a magic number: P = 0.1;  
Magic Number,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,GetList,The following statement contains a magic number: for (double d = minPower; d <= maxPower; d += iteration)  	list.Add (Math.Pow (2' d));  
Magic Number,SVM,ParameterSelection,C:\repos\borfudin_svmnet\SVM\SVM\ParameterSelection.cs,GetList,The following statement contains a magic number: list.Add (Math.Pow (2' d));  
Magic Number,SVM,PerformanceEvaluator,C:\repos\borfudin_svmnet\SVM\SVM\PerformanceEvaluator.cs,computeRoC,The following statement contains a magic number: for (int i = 1; i < _changes.Count; i++) {  	float newTPR = computeTPR (_changes [i]);  	float newFPR = computeFPR (_changes [i]);  	if (_changes [i].TP > _changes [i - 1].TP) {  		_auc += tpr * (newFPR - fpr) + .5 * (newTPR - tpr) * (newFPR - fpr);  		tpr = newTPR;  		fpr = newFPR;  		_rocCurve.Add (new CurvePoint (fpr' tpr));  	}  }  
Magic Number,SVM,PerformanceEvaluator,C:\repos\borfudin_svmnet\SVM\SVM\PerformanceEvaluator.cs,computeRoC,The following statement contains a magic number: if (_changes [i].TP > _changes [i - 1].TP) {  	_auc += tpr * (newFPR - fpr) + .5 * (newTPR - tpr) * (newFPR - fpr);  	tpr = newTPR;  	fpr = newFPR;  	_rocCurve.Add (new CurvePoint (fpr' tpr));  }  
Magic Number,SVM,PerformanceEvaluator,C:\repos\borfudin_svmnet\SVM\SVM\PerformanceEvaluator.cs,computeRoC,The following statement contains a magic number: _auc += tpr * (newFPR - fpr) + .5 * (newTPR - tpr) * (newFPR - fpr);  
Magic Number,SVM,PerformanceEvaluator,C:\repos\borfudin_svmnet\SVM\SVM\PerformanceEvaluator.cs,computeRoC,The following statement contains a magic number: _auc += tpr * (1 - fpr) + .5 * (1 - tpr) * (1 - fpr);  
Magic Number,SVM,Prediction,C:\repos\borfudin_svmnet\SVM\SVM\Prediction.cs,Predict,The following statement contains a magic number: Predict (problem' args [i + 2]' model' predictProbability);  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,reconstruct_gradient,The following statement contains a magic number: if (2 * nr_free < active_size)  	Procedures.info ("\nWARNING: using -h 0 may be faster\n");  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,reconstruct_gradient,The following statement contains a magic number: if (nr_free * l > 2 * active_size * (l - active_size)) {  	for (i = active_size; i < l; i++) {  		float[] Q_i = Q.GetQ (i' active_size);  		for (j = 0; j < active_size; j++)  			if (is_free (j))  				G [i] += alpha [j] * Q_i [j];  	}  }  else {  	for (i = 0; i < active_size; i++)  		if (is_free (i)) {  			float[] Q_i = Q.GetQ (i' l);  			double alpha_i = alpha [i];  			for (j = active_size; j < l; j++)  				G [j] += alpha_i * Q_i [j];  		}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: while (iter < max_iter) {  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking)  			do_shrinking ();  		Procedures.info (".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		Procedures.info ("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.GetQ (i' active_size);  	float[] Q_j = Q.GetQ (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (-G [i] - G [j]) / quad_coef;  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (G [i] - G [j]) / quad_coef;  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.GetQ (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.GetQ (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: while (iter < max_iter) {  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking)  			do_shrinking ();  		Procedures.info (".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		Procedures.info ("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.GetQ (i' active_size);  	float[] Q_j = Q.GetQ (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (-G [i] - G [j]) / quad_coef;  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (G [i] - G [j]) / quad_coef;  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.GetQ (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.GetQ (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: while (iter < max_iter) {  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking)  			do_shrinking ();  		Procedures.info (".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		Procedures.info ("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.GetQ (i' active_size);  	float[] Q_j = Q.GetQ (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (-G [i] - G [j]) / quad_coef;  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (G [i] - G [j]) / quad_coef;  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.GetQ (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.GetQ (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: while (iter < max_iter) {  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking)  			do_shrinking ();  		Procedures.info (".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		Procedures.info ("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.GetQ (i' active_size);  	float[] Q_j = Q.GetQ (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (-G [i] - G [j]) / quad_coef;  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (G [i] - G [j]) / quad_coef;  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.GetQ (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.GetQ (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: while (iter < max_iter) {  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking)  			do_shrinking ();  		Procedures.info (".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		Procedures.info ("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.GetQ (i' active_size);  	float[] Q_j = Q.GetQ (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (-G [i] - G [j]) / quad_coef;  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  		if (quad_coef <= 0)  			quad_coef = 1e-12;  		double delta = (G [i] - G [j]) / quad_coef;  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.GetQ (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.GetQ (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (--counter == 0) {  	counter = Math.Min (l' 1000);  	if (shrinking)  		do_shrinking ();  	Procedures.info (".");  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: counter = Math.Min (l' 1000);  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (y [i] != y [j]) {  	double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (-G [i] - G [j]) / quad_coef;  	double diff = alpha [i] - alpha [j];  	alpha [i] += delta;  	alpha [j] += delta;  	if (diff > 0) {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = diff;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = -diff;  		}  	}  	if (diff > C_i - C_j) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = C_i - diff;  		}  	}  	else {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = C_j + diff;  		}  	}  }  else {  	double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (G [i] - G [j]) / quad_coef;  	double sum = alpha [i] + alpha [j];  	alpha [i] -= delta;  	alpha [j] += delta;  	if (sum > C_i) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = sum - C_i;  		}  	}  	else {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = sum;  		}  	}  	if (sum > C_j) {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = sum - C_j;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = sum;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (y [i] != y [j]) {  	double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (-G [i] - G [j]) / quad_coef;  	double diff = alpha [i] - alpha [j];  	alpha [i] += delta;  	alpha [j] += delta;  	if (diff > 0) {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = diff;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = -diff;  		}  	}  	if (diff > C_i - C_j) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = C_i - diff;  		}  	}  	else {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = C_j + diff;  		}  	}  }  else {  	double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (G [i] - G [j]) / quad_coef;  	double sum = alpha [i] + alpha [j];  	alpha [i] -= delta;  	alpha [j] += delta;  	if (sum > C_i) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = sum - C_i;  		}  	}  	else {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = sum;  		}  	}  	if (sum > C_j) {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = sum - C_j;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = sum;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (y [i] != y [j]) {  	double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (-G [i] - G [j]) / quad_coef;  	double diff = alpha [i] - alpha [j];  	alpha [i] += delta;  	alpha [j] += delta;  	if (diff > 0) {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = diff;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = -diff;  		}  	}  	if (diff > C_i - C_j) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = C_i - diff;  		}  	}  	else {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = C_j + diff;  		}  	}  }  else {  	double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (G [i] - G [j]) / quad_coef;  	double sum = alpha [i] + alpha [j];  	alpha [i] -= delta;  	alpha [j] += delta;  	if (sum > C_i) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = sum - C_i;  		}  	}  	else {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = sum;  		}  	}  	if (sum > C_j) {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = sum - C_j;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = sum;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (y [i] != y [j]) {  	double quad_coef = QD [i] + QD [j] + 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (-G [i] - G [j]) / quad_coef;  	double diff = alpha [i] - alpha [j];  	alpha [i] += delta;  	alpha [j] += delta;  	if (diff > 0) {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = diff;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = -diff;  		}  	}  	if (diff > C_i - C_j) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = C_i - diff;  		}  	}  	else {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = C_j + diff;  		}  	}  }  else {  	double quad_coef = QD [i] + QD [j] - 2 * Q_i [j];  	if (quad_coef <= 0)  		quad_coef = 1e-12;  	double delta = (G [i] - G [j]) / quad_coef;  	double sum = alpha [i] + alpha [j];  	alpha [i] -= delta;  	alpha [j] += delta;  	if (sum > C_i) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = sum - C_i;  		}  	}  	else {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = sum;  		}  	}  	if (sum > C_j) {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = sum - C_j;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = sum;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (quad_coef <= 0)  	quad_coef = 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: if (quad_coef <= 0)  	quad_coef = 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: quad_coef = 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmax + G [j];  			if (G [j] >= Gmax2)  				Gmax2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmax - G [j];  			if (-G [j] >= Gmax2)  				Gmax2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmax + G [j];  			if (G [j] >= Gmax2)  				Gmax2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmax - G [j];  			if (-G [j] >= Gmax2)  				Gmax2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmax + G [j];  			if (G [j] >= Gmax2)  				Gmax2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmax - G [j];  			if (-G [j] >= Gmax2)  				Gmax2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmax + G [j];  			if (G [j] >= Gmax2)  				Gmax2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmax - G [j];  			if (-G [j] >= Gmax2)  				Gmax2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmax + G [j];  		if (G [j] >= Gmax2)  			Gmax2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmax - G [j];  		if (-G [j] >= Gmax2)  			Gmax2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmax + G [j];  		if (G [j] >= Gmax2)  			Gmax2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmax - G [j];  		if (-G [j] >= Gmax2)  			Gmax2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmax + G [j];  		if (G [j] >= Gmax2)  			Gmax2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmax - G [j];  		if (-G [j] >= Gmax2)  			Gmax2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmax + G [j];  		if (G [j] >= Gmax2)  			Gmax2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmax - G [j];  		if (-G [j] >= Gmax2)  			Gmax2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_lower_bound (j)) {  	double grad_diff = Gmax + G [j];  	if (G [j] >= Gmax2)  		Gmax2 = G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_lower_bound (j)) {  	double grad_diff = Gmax + G [j];  	if (G [j] >= Gmax2)  		Gmax2 = G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [i] + QD [j] - 2.0 * y [i] * Q_i [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (quad_coef > 0)  	obj_diff = -(grad_diff * grad_diff) / quad_coef;  else  	obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_upper_bound (j)) {  	double grad_diff = Gmax - G [j];  	if (-G [j] >= Gmax2)  		Gmax2 = -G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_upper_bound (j)) {  	double grad_diff = Gmax - G [j];  	if (-G [j] >= Gmax2)  		Gmax2 = -G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [i] + QD [j] + 2.0 * y [i] * Q_i [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (quad_coef > 0)  	obj_diff = -(grad_diff * grad_diff) / quad_coef;  else  	obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && Gmax1 + Gmax2 <= eps * 10) {  	unshrink = true;  	reconstruct_gradient ();  	active_size = l;  }  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)  	r = sum_free / nr_free;  else  	r = (ub + lb) / 2;  
Magic Number,SVM,Solver,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: r = (ub + lb) / 2;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmaxp + G [j];  			if (G [j] >= Gmaxp2)  				Gmaxp2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmaxn - G [j];  			if (-G [j] >= Gmaxn2)  				Gmaxn2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmaxp + G [j];  			if (G [j] >= Gmaxp2)  				Gmaxp2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmaxn - G [j];  			if (-G [j] >= Gmaxn2)  				Gmaxn2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmaxp + G [j];  			if (G [j] >= Gmaxp2)  				Gmaxp2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmaxn - G [j];  			if (-G [j] >= Gmaxn2)  				Gmaxn2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: for (int j = 0; j < active_size; j++) {  	if (y [j] == +1) {  		if (!is_lower_bound (j)) {  			double grad_diff = Gmaxp + G [j];  			if (G [j] >= Gmaxp2)  				Gmaxp2 = G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  	else {  		if (!is_upper_bound (j)) {  			double grad_diff = Gmaxn - G [j];  			if (-G [j] >= Gmaxn2)  				Gmaxn2 = -G [j];  			if (grad_diff > 0) {  				double obj_diff;  				double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  				if (quad_coef > 0)  					obj_diff = -(grad_diff * grad_diff) / quad_coef;  				else  					obj_diff = -(grad_diff * grad_diff) / 1e-12;  				if (obj_diff <= obj_diff_min) {  					Gmin_idx = j;  					obj_diff_min = obj_diff;  				}  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmaxp + G [j];  		if (G [j] >= Gmaxp2)  			Gmaxp2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmaxn - G [j];  		if (-G [j] >= Gmaxn2)  			Gmaxn2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmaxp + G [j];  		if (G [j] >= Gmaxp2)  			Gmaxp2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmaxn - G [j];  		if (-G [j] >= Gmaxn2)  			Gmaxn2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmaxp + G [j];  		if (G [j] >= Gmaxp2)  			Gmaxp2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmaxn - G [j];  		if (-G [j] >= Gmaxn2)  			Gmaxn2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (y [j] == +1) {  	if (!is_lower_bound (j)) {  		double grad_diff = Gmaxp + G [j];  		if (G [j] >= Gmaxp2)  			Gmaxp2 = G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  else {  	if (!is_upper_bound (j)) {  		double grad_diff = Gmaxn - G [j];  		if (-G [j] >= Gmaxn2)  			Gmaxn2 = -G [j];  		if (grad_diff > 0) {  			double obj_diff;  			double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  			if (quad_coef > 0)  				obj_diff = -(grad_diff * grad_diff) / quad_coef;  			else  				obj_diff = -(grad_diff * grad_diff) / 1e-12;  			if (obj_diff <= obj_diff_min) {  				Gmin_idx = j;  				obj_diff_min = obj_diff;  			}  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_lower_bound (j)) {  	double grad_diff = Gmaxp + G [j];  	if (G [j] >= Gmaxp2)  		Gmaxp2 = G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_lower_bound (j)) {  	double grad_diff = Gmaxp + G [j];  	if (G [j] >= Gmaxp2)  		Gmaxp2 = G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [ip] + QD [j] - 2 * Q_ip [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (quad_coef > 0)  	obj_diff = -(grad_diff * grad_diff) / quad_coef;  else  	obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_upper_bound (j)) {  	double grad_diff = Gmaxn - G [j];  	if (-G [j] >= Gmaxn2)  		Gmaxn2 = -G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (!is_upper_bound (j)) {  	double grad_diff = Gmaxn - G [j];  	if (-G [j] >= Gmaxn2)  		Gmaxn2 = -G [j];  	if (grad_diff > 0) {  		double obj_diff;  		double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  		if (quad_coef > 0)  			obj_diff = -(grad_diff * grad_diff) / quad_coef;  		else  			obj_diff = -(grad_diff * grad_diff) / 1e-12;  		if (obj_diff <= obj_diff_min) {  			Gmin_idx = j;  			obj_diff_min = obj_diff;  		}  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (grad_diff > 0) {  	double obj_diff;  	double quad_coef = QD [iN] + QD [j] - 2 * Q_in [j];  	if (quad_coef > 0)  		obj_diff = -(grad_diff * grad_diff) / quad_coef;  	else  		obj_diff = -(grad_diff * grad_diff) / 1e-12;  	if (obj_diff <= obj_diff_min) {  		Gmin_idx = j;  		obj_diff_min = obj_diff;  	}  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: if (quad_coef > 0)  	obj_diff = -(grad_diff * grad_diff) / quad_coef;  else  	obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,select_working_set,The following statement contains a magic number: obj_diff = -(grad_diff * grad_diff) / 1e-12;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,do_shrinking,The following statement contains a magic number: if (unshrink == false && Math.Max (Gmax1 + Gmax2' Gmax3 + Gmax4) <= eps * 10) {  	unshrink = true;  	reconstruct_gradient ();  	active_size = l;  }  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: if (nr_free1 > 0)  	r1 = sum_free1 / nr_free1;  else  	r1 = (ub1 + lb1) / 2;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: r1 = (ub1 + lb1) / 2;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: if (nr_free2 > 0)  	r2 = sum_free2 / nr_free2;  else  	r2 = (ub2 + lb2) / 2;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: r2 = (ub2 + lb2) / 2;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: si.r = (r1 + r2) / 2;  
Magic Number,SVM,Solver_NU,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,calculate_rho,The following statement contains a magic number: return (r1 - r2) / 2;  
Magic Number,SVM,SVC_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVC_Q,The following statement contains a magic number: cache = new Cache (prob.Count' (long)(param.CacheSize * (1 << 20)));  
Magic Number,SVM,ONE_CLASS_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,ONE_CLASS_Q,The following statement contains a magic number: cache = new Cache (prob.Count' (long)(param.CacheSize * (1 << 20)));  
Magic Number,SVM,SVR_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVR_Q,The following statement contains a magic number: cache = new Cache (l' (long)(param.CacheSize * (1 << 20)));  
Magic Number,SVM,SVR_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVR_Q,The following statement contains a magic number: QD = new double[2 * l];  
Magic Number,SVM,SVR_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVR_Q,The following statement contains a magic number: sign = new sbyte[2 * l];  
Magic Number,SVM,SVR_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVR_Q,The following statement contains a magic number: index = new int[2 * l];  
Magic Number,SVM,SVR_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVR_Q,The following statement contains a magic number: buffer = new float[][] {  	new float[2 * l]'  	new float[2 * l]  };  
Magic Number,SVM,SVR_Q,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,SVR_Q,The following statement contains a magic number: buffer = new float[][] {  	new float[2 * l]'  	new float[2 * l]  };  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,solve_epsilon_svr,The following statement contains a magic number: s.Solve (2 * l' new SVR_Q (prob' param)' linear_term' y' alpha2' param.C' param.C' param.EPS' si' param.Shrinking);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,solve_nu_svr,The following statement contains a magic number: s.Solve (2 * l' new SVR_Q (prob' param)' linear_term' y' alpha2' C' C' param.EPS' si' param.Shrinking);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++) {  	// Update Gradient and Hessian (use H' = H + sigma I)  	h11 = sigma;  	// numerically ensures strict PD  	h22 = sigma;  	h21 = 0.0;  	g1 = 0.0;  	g2 = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * A + B;  		if (fApB >= 0) {  			p = Math.Exp (-fApB) / (1.0 + Math.Exp (-fApB));  			q = 1.0 / (1.0 + Math.Exp (-fApB));  		}  		else {  			p = 1.0 / (1.0 + Math.Exp (fApB));  			q = Math.Exp (fApB) / (1.0 + Math.Exp (fApB));  		}  		d2 = p * q;  		h11 += dec_values [i] * dec_values [i] * d2;  		h22 += d2;  		h21 += dec_values [i] * d2;  		d1 = t [i] - p;  		g1 += dec_values [i] * d1;  		g2 += d1;  	}  	// Stopping Criteria  	if (Math.Abs (g1) < eps && Math.Abs (g2) < eps)  		break;  	// Finding Newton direction: -inv(H') * g  	det = h11 * h22 - h21 * h21;  	dA = -(h22 * g1 - h21 * g2) / det;  	dB = -(-h21 * g1 + h11 * g2) / det;  	gd = g1 * dA + g2 * dB;  	stepsize = 1;  	// Line Search  	while (stepsize >= min_step) {  		newA = A + stepsize * dA;  		newB = B + stepsize * dB;  		// New function value  		newf = 0.0;  		for (i = 0; i < l; i++) {  			fApB = dec_values [i] * newA + newB;  			if (fApB >= 0)  				newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  			else  				newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  		}  		// Check sufficient decrease  		if (newf < fval + 0.0001 * stepsize * gd) {  			A = newA;  			B = newB;  			fval = newf;  			break;  		}  		else  			stepsize = stepsize / 2.0;  	}  	if (stepsize < min_step) {  		info ("Line search fails in two-class probability estimates\n");  		break;  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++) {  	// Update Gradient and Hessian (use H' = H + sigma I)  	h11 = sigma;  	// numerically ensures strict PD  	h22 = sigma;  	h21 = 0.0;  	g1 = 0.0;  	g2 = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * A + B;  		if (fApB >= 0) {  			p = Math.Exp (-fApB) / (1.0 + Math.Exp (-fApB));  			q = 1.0 / (1.0 + Math.Exp (-fApB));  		}  		else {  			p = 1.0 / (1.0 + Math.Exp (fApB));  			q = Math.Exp (fApB) / (1.0 + Math.Exp (fApB));  		}  		d2 = p * q;  		h11 += dec_values [i] * dec_values [i] * d2;  		h22 += d2;  		h21 += dec_values [i] * d2;  		d1 = t [i] - p;  		g1 += dec_values [i] * d1;  		g2 += d1;  	}  	// Stopping Criteria  	if (Math.Abs (g1) < eps && Math.Abs (g2) < eps)  		break;  	// Finding Newton direction: -inv(H') * g  	det = h11 * h22 - h21 * h21;  	dA = -(h22 * g1 - h21 * g2) / det;  	dB = -(-h21 * g1 + h11 * g2) / det;  	gd = g1 * dA + g2 * dB;  	stepsize = 1;  	// Line Search  	while (stepsize >= min_step) {  		newA = A + stepsize * dA;  		newB = B + stepsize * dB;  		// New function value  		newf = 0.0;  		for (i = 0; i < l; i++) {  			fApB = dec_values [i] * newA + newB;  			if (fApB >= 0)  				newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  			else  				newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  		}  		// Check sufficient decrease  		if (newf < fval + 0.0001 * stepsize * gd) {  			A = newA;  			B = newB;  			fval = newf;  			break;  		}  		else  			stepsize = stepsize / 2.0;  	}  	if (stepsize < min_step) {  		info ("Line search fails in two-class probability estimates\n");  		break;  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: while (stepsize >= min_step) {  	newA = A + stepsize * dA;  	newB = B + stepsize * dB;  	// New function value  	newf = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * newA + newB;  		if (fApB >= 0)  			newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  		else  			newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  	}  	// Check sufficient decrease  	if (newf < fval + 0.0001 * stepsize * gd) {  		A = newA;  		B = newB;  		fval = newf;  		break;  	}  	else  		stepsize = stepsize / 2.0;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: while (stepsize >= min_step) {  	newA = A + stepsize * dA;  	newB = B + stepsize * dB;  	// New function value  	newf = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * newA + newB;  		if (fApB >= 0)  			newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  		else  			newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  	}  	// Check sufficient decrease  	if (newf < fval + 0.0001 * stepsize * gd) {  		A = newA;  		B = newB;  		fval = newf;  		break;  	}  	else  		stepsize = stepsize / 2.0;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: if (newf < fval + 0.0001 * stepsize * gd) {  	A = newA;  	B = newB;  	fval = newf;  	break;  }  else  	stepsize = stepsize / 2.0;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: if (newf < fval + 0.0001 * stepsize * gd) {  	A = newA;  	B = newB;  	fval = newf;  	break;  }  else  	stepsize = stepsize / 2.0;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,sigmoid_train,The following statement contains a magic number: stepsize = stepsize / 2.0;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,multiclass_probability,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++) {  	// stopping condition' recalculate QP'pQP for numerical accuracy  	pQp = 0;  	for (t = 0; t < k; t++) {  		Qp [t] = 0;  		for (j = 0; j < k; j++)  			Qp [t] += Q [t' j] * p [j];  		pQp += p [t] * Qp [t];  	}  	double max_error = 0;  	for (t = 0; t < k; t++) {  		double error = Math.Abs (Qp [t] - pQp);  		if (error > max_error)  			max_error = error;  	}  	if (max_error < eps)  		break;  	for (t = 0; t < k; t++) {  		double diff = (-Qp [t] + pQp) / Q [t' t];  		p [t] += diff;  		pQp = (pQp + diff * (diff * Q [t' t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);  		for (j = 0; j < k; j++) {  			Qp [j] = (Qp [j] + diff * Q [t' j]) / (1 + diff);  			p [j] /= (1 + diff);  		}  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,multiclass_probability,The following statement contains a magic number: for (t = 0; t < k; t++) {  	double diff = (-Qp [t] + pQp) / Q [t' t];  	p [t] += diff;  	pQp = (pQp + diff * (diff * Q [t' t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);  	for (j = 0; j < k; j++) {  		Qp [j] = (Qp [j] + diff * Q [t' j]) / (1 + diff);  		p [j] /= (1 + diff);  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,multiclass_probability,The following statement contains a magic number: pQp = (pQp + diff * (diff * Q [t' t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_svr_probability,The following statement contains a magic number: for (i = 0; i < prob.Count; i++)  	if (Math.Abs (ymv [i]) > 5 * std)  		count = count + 1;  	else  		mae += Math.Abs (ymv [i]);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_svr_probability,The following statement contains a magic number: if (Math.Abs (ymv [i]) > 5 * std)  	count = count + 1;  else  	mae += Math.Abs (ymv [i]);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,The following statement contains a magic number: for (i = 0; i < l; i++) {  	int this_label = (int)(prob.Y [i]);  	int j;  	for (j = 0; j < nr_class; j++) {  		if (this_label == label [j]) {  			++count [j];  			break;  		}  	}  	data_label [i] = j;  	if (j == nr_class) {  		if (nr_class == max_nr_class) {  			max_nr_class *= 2;  			int[] new_data = new int[max_nr_class];  			Array.Copy (label' 0' new_data' 0' label.Length);  			label = new_data;  			new_data = new int[max_nr_class];  			Array.Copy (count' 0' new_data' 0' count.Length);  			count = new_data;  		}  		label [nr_class] = this_label;  		count [nr_class] = 1;  		++nr_class;  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,The following statement contains a magic number: if (j == nr_class) {  	if (nr_class == max_nr_class) {  		max_nr_class *= 2;  		int[] new_data = new int[max_nr_class];  		Array.Copy (label' 0' new_data' 0' label.Length);  		label = new_data;  		new_data = new int[max_nr_class];  		Array.Copy (count' 0' new_data' 0' count.Length);  		count = new_data;  	}  	label [nr_class] = this_label;  	count [nr_class] = 1;  	++nr_class;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,The following statement contains a magic number: if (nr_class == max_nr_class) {  	max_nr_class *= 2;  	int[] new_data = new int[max_nr_class];  	Array.Copy (label' 0' new_data' 0' label.Length);  	label = new_data;  	new_data = new int[max_nr_class];  	Array.Copy (count' 0' new_data' 0' count.Length);  	count = new_data;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,The following statement contains a magic number: max_nr_class *= 2;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_group_classes,The following statement contains a magic number: if (nr_class == 2 && label [0] == -1 && label [1] == +1) {  	do {  		int _ = label [0];  		label [0] = label [1];  		label [1] = _;  	}  	while (false);  	do {  		int _ = count [0];  		count [0] = count [1];  		count [1] = _;  	}  	while (false);  	for (i = 0; i < l; i++) {  		if (data_label [i] == 0)  			data_label [i] = 1;  		else  			data_label [i] = 0;  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.SvmType == SvmType.ONE_CLASS || param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR) {  	// regression or one-class-svm  	model.NumberOfClasses = 2;  	model.ClassLabels = null;  	model.NumberOfSVPerClass = null;  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityB = null;  	model.SupportVectorCoefficients = new double[1][];  	if (param.Probability && (param.SvmType == SvmType.EPSILON_SVR || param.SvmType == SvmType.NU_SVR)) {  		model.PairwiseProbabilityA = new double[1];  		model.PairwiseProbabilityA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.Rho = new double[1];  	model.Rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.SupportVectorCount = nSV;  	model.SupportVectors = new Node[nSV][];  	model.SupportVectorCoefficients [0] = new double[nSV];  	model.SupportVectorIndices = new int[nSV];  	int j = 0;  	for (i = 0; i < prob.Count; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SupportVectors [j] = prob.X [i];  			model.SupportVectorCoefficients [0] [j] = f.alpha [i];  			model.SupportVectorIndices [j] = i + 1;  			++j;  		}  }  else {  	// classification  	int l = prob.Count;  	int nr_class;  	int[] label;  	int[] start;  	int[] count;  	int[] perm = new int[l];  	// group training data of the same class  	svm_group_classes (prob' out nr_class' out label' out start' out count' perm);  	if (nr_class == 1)  		info ("WARNING: training data in only one class. See README for details.\n");  	Node[][] x = new Node[l][];  	int i;  	for (i = 0; i < l; i++)  		x [i] = prob.X [perm [i]];  	// calculate weighted C  	double[] weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < nr_class; i++) {  		if (!param.Weights.ContainsKey (label [i]))  			Console.Error.Write ("WARNING: class label " + label [i] + " specified in weight is not found\n");  		else  			weighted_C [i] *= param.Weights [label [i]];  	}  	// train k*(k-1)/2 models  	bool[] nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	decision_function[] f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.Probability) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			Problem sub_prob = new Problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.Count = ci + cj;  			sub_prob.X = new Node[sub_prob.Count][];  			sub_prob.Y = new double[sub_prob.Count];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.X [k] = x [si + k];  				sub_prob.Y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.X [ci + k] = x [sj + k];  				sub_prob.Y [ci + k] = -1;  			}  			if (param.Probability) {  				double[] probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.NumberOfClasses = nr_class;  	model.ClassLabels = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.ClassLabels [i] = label [i];  	model.Rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.Rho [i] = f [i].rho;  	if (param.Probability) {  		model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  		model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.PairwiseProbabilityA [i] = probA [i];  			model.PairwiseProbabilityB [i] = probB [i];  		}  	}  	else {  		model.PairwiseProbabilityA = null;  		model.PairwiseProbabilityA = null;  	}  	int nnz = 0;  	int[] nz_count = new int[nr_class];  	model.NumberOfSVPerClass = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.NumberOfSVPerClass [i] = nSV;  		nz_count [i] = nSV;  	}  	info ("Total nSV = " + nnz + "\n");  	model.SupportVectorCount = nnz;  	model.SupportVectors = new Node[nnz][];  	model.SupportVectorIndices = new int[nnz];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i]) {  			model.SupportVectors [p] = x [i];  			model.SupportVectorIndices [p++] = perm [i] + 1;  		}  	int[] nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.SupportVectorCoefficients = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.SupportVectorCoefficients [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.SupportVectorCoefficients [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.SupportVectorCoefficients [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: model.NumberOfClasses = 2;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.Probability) {  	probA = new double[nr_class * (nr_class - 1) / 2];  	probB = new double[nr_class * (nr_class - 1) / 2];  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.Probability) {  	probA = new double[nr_class * (nr_class - 1) / 2];  	probB = new double[nr_class * (nr_class - 1) / 2];  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: probA = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: probB = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: for (i = 0; i < nr_class; i++)  	for (int j = i + 1; j < nr_class; j++) {  		Problem sub_prob = new Problem ();  		int si = start [i]' sj = start [j];  		int ci = count [i]' cj = count [j];  		sub_prob.Count = ci + cj;  		sub_prob.X = new Node[sub_prob.Count][];  		sub_prob.Y = new double[sub_prob.Count];  		int k;  		for (k = 0; k < ci; k++) {  			sub_prob.X [k] = x [si + k];  			sub_prob.Y [k] = +1;  		}  		for (k = 0; k < cj; k++) {  			sub_prob.X [ci + k] = x [sj + k];  			sub_prob.Y [ci + k] = -1;  		}  		if (param.Probability) {  			double[] probAB = new double[2];  			svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  			probA [p] = probAB [0];  			probB [p] = probAB [1];  		}  		f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  		for (k = 0; k < ci; k++)  			if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  				nonzero [si + k] = true;  		for (k = 0; k < cj; k++)  			if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  				nonzero [sj + k] = true;  		++p;  	}  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: for (int j = i + 1; j < nr_class; j++) {  	Problem sub_prob = new Problem ();  	int si = start [i]' sj = start [j];  	int ci = count [i]' cj = count [j];  	sub_prob.Count = ci + cj;  	sub_prob.X = new Node[sub_prob.Count][];  	sub_prob.Y = new double[sub_prob.Count];  	int k;  	for (k = 0; k < ci; k++) {  		sub_prob.X [k] = x [si + k];  		sub_prob.Y [k] = +1;  	}  	for (k = 0; k < cj; k++) {  		sub_prob.X [ci + k] = x [sj + k];  		sub_prob.Y [ci + k] = -1;  	}  	if (param.Probability) {  		double[] probAB = new double[2];  		svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  		probA [p] = probAB [0];  		probB [p] = probAB [1];  	}  	f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  	for (k = 0; k < ci; k++)  		if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  			nonzero [si + k] = true;  	for (k = 0; k < cj; k++)  		if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  			nonzero [sj + k] = true;  	++p;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.Probability) {  	double[] probAB = new double[2];  	svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  	probA [p] = probAB [0];  	probB [p] = probAB [1];  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: model.Rho = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	model.Rho [i] = f [i].rho;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.Probability) {  	model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  	model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  		model.PairwiseProbabilityA [i] = probA [i];  		model.PairwiseProbabilityB [i] = probB [i];  	}  }  else {  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityA = null;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.Probability) {  	model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  	model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  		model.PairwiseProbabilityA [i] = probA [i];  		model.PairwiseProbabilityB [i] = probB [i];  	}  }  else {  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityA = null;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: if (param.Probability) {  	model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  	model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  		model.PairwiseProbabilityA [i] = probA [i];  		model.PairwiseProbabilityB [i] = probB [i];  	}  }  else {  	model.PairwiseProbabilityA = null;  	model.PairwiseProbabilityA = null;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: model.PairwiseProbabilityA = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: model.PairwiseProbabilityB = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train,The following statement contains a magic number: for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  	model.PairwiseProbabilityA [i] = probA [i];  	model.PairwiseProbabilityB [i] = probB [i];  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict,The following statement contains a magic number: if (model.Parameter.SvmType == SvmType.ONE_CLASS || model.Parameter.SvmType == SvmType.EPSILON_SVR || model.Parameter.SvmType == SvmType.NU_SVR)  	dec_values = new double[1];  else  	dec_values = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict,The following statement contains a magic number: dec_values = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_probability,The following statement contains a magic number: if ((model.Parameter.SvmType == SvmType.C_SVC || model.Parameter.SvmType == SvmType.NU_SVC) && model.PairwiseProbabilityA != null && model.PairwiseProbabilityB != null) {  	int i;  	int nr_class = model.NumberOfClasses;  	double[] dec_values = new double[nr_class * (nr_class - 1) / 2];  	svm_predict_values (model' x' dec_values);  	double min_prob = 1e-7;  	double['] pairwise_prob = new double[nr_class' nr_class];  	int k = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			pairwise_prob [i' j] = Math.Min (Math.Max (sigmoid_predict (dec_values [k]' model.PairwiseProbabilityA [k]' model.PairwiseProbabilityB [k])' min_prob)' 1 - min_prob);  			pairwise_prob [j' i] = 1 - pairwise_prob [i' j];  			k++;  		}  	multiclass_probability (nr_class' pairwise_prob' prob_estimates);  	int prob_max_idx = 0;  	for (i = 1; i < nr_class; i++)  		if (prob_estimates [i] > prob_estimates [prob_max_idx])  			prob_max_idx = i;  	return model.ClassLabels [prob_max_idx];  }  else  	return svm_predict (model' x);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_predict_probability,The following statement contains a magic number: if ((model.Parameter.SvmType == SvmType.C_SVC || model.Parameter.SvmType == SvmType.NU_SVC) && model.PairwiseProbabilityA != null && model.PairwiseProbabilityB != null) {  	int i;  	int nr_class = model.NumberOfClasses;  	double[] dec_values = new double[nr_class * (nr_class - 1) / 2];  	svm_predict_values (model' x' dec_values);  	double min_prob = 1e-7;  	double['] pairwise_prob = new double[nr_class' nr_class];  	int k = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			pairwise_prob [i' j] = Math.Min (Math.Max (sigmoid_predict (dec_values [k]' model.PairwiseProbabilityA [k]' model.PairwiseProbabilityB [k])' min_prob)' 1 - min_prob);  			pairwise_prob [j' i] = 1 - pairwise_prob [i' j];  			k++;  		}  	multiclass_probability (nr_class' pairwise_prob' prob_estimates);  	int prob_max_idx = 0;  	for (i = 1; i < nr_class; i++)  		if (prob_estimates [i] > prob_estimates [prob_max_idx])  			prob_max_idx = i;  	return model.ClassLabels [prob_max_idx];  }  else  	return svm_predict (model' x);  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == SvmType.NU_SVC) {  	int l = prob.Count;  	int max_nr_class = 16;  	int nr_class = 0;  	int[] label = new int[max_nr_class];  	int[] count = new int[max_nr_class];  	int i;  	for (i = 0; i < l; i++) {  		int this_label = (int)prob.Y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				int[] new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	for (i = 0; i < nr_class; i++) {  		int n1 = count [i];  		for (int j = i + 1; j < nr_class; j++) {  			int n2 = count [j];  			if (param.Nu * (n1 + n2) / 2 > Math.Min (n1' n2))  				return "specified nu is infeasible";  		}  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == SvmType.NU_SVC) {  	int l = prob.Count;  	int max_nr_class = 16;  	int nr_class = 0;  	int[] label = new int[max_nr_class];  	int[] count = new int[max_nr_class];  	int i;  	for (i = 0; i < l; i++) {  		int this_label = (int)prob.Y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				int[] new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	for (i = 0; i < nr_class; i++) {  		int n1 = count [i];  		for (int j = i + 1; j < nr_class; j++) {  			int n2 = count [j];  			if (param.Nu * (n1 + n2) / 2 > Math.Min (n1' n2))  				return "specified nu is infeasible";  		}  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == SvmType.NU_SVC) {  	int l = prob.Count;  	int max_nr_class = 16;  	int nr_class = 0;  	int[] label = new int[max_nr_class];  	int[] count = new int[max_nr_class];  	int i;  	for (i = 0; i < l; i++) {  		int this_label = (int)prob.Y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				int[] new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	for (i = 0; i < nr_class; i++) {  		int n1 = count [i];  		for (int j = i + 1; j < nr_class; j++) {  			int n2 = count [j];  			if (param.Nu * (n1 + n2) / 2 > Math.Min (n1' n2))  				return "specified nu is infeasible";  		}  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: for (i = 0; i < l; i++) {  	int this_label = (int)prob.Y [i];  	int j;  	for (j = 0; j < nr_class; j++)  		if (this_label == label [j]) {  			++count [j];  			break;  		}  	if (j == nr_class) {  		if (nr_class == max_nr_class) {  			max_nr_class *= 2;  			int[] new_data = new int[max_nr_class];  			Array.Copy (label' 0' new_data' 0' label.Length);  			label = new_data;  			new_data = new int[max_nr_class];  			Array.Copy (count' 0' new_data' 0' count.Length);  			count = new_data;  		}  		label [nr_class] = this_label;  		count [nr_class] = 1;  		++nr_class;  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: if (j == nr_class) {  	if (nr_class == max_nr_class) {  		max_nr_class *= 2;  		int[] new_data = new int[max_nr_class];  		Array.Copy (label' 0' new_data' 0' label.Length);  		label = new_data;  		new_data = new int[max_nr_class];  		Array.Copy (count' 0' new_data' 0' count.Length);  		count = new_data;  	}  	label [nr_class] = this_label;  	count [nr_class] = 1;  	++nr_class;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: if (nr_class == max_nr_class) {  	max_nr_class *= 2;  	int[] new_data = new int[max_nr_class];  	Array.Copy (label' 0' new_data' 0' label.Length);  	label = new_data;  	new_data = new int[max_nr_class];  	Array.Copy (count' 0' new_data' 0' count.Length);  	count = new_data;  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: max_nr_class *= 2;  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: for (i = 0; i < nr_class; i++) {  	int n1 = count [i];  	for (int j = i + 1; j < nr_class; j++) {  		int n2 = count [j];  		if (param.Nu * (n1 + n2) / 2 > Math.Min (n1' n2))  			return "specified nu is infeasible";  	}  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: for (int j = i + 1; j < nr_class; j++) {  	int n2 = count [j];  	if (param.Nu * (n1 + n2) / 2 > Math.Min (n1' n2))  		return "specified nu is infeasible";  }  
Magic Number,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_check_parameter,The following statement contains a magic number: if (param.Nu * (n1 + n2) / 2 > Math.Min (n1' n2))  	return "specified nu is infeasible";  
Magic Number,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The following statement contains a magic number: for (i = 0; i < args.Length; i++) {  	if (args [i] [0] != '-')  		break;  	++i;  	switch (args [i - 1] [1]) {  	case 's':  		parameters.SvmType = (SvmType)int.Parse (args [i]);  		break;  	case 't':  		parameters.KernelType = (KernelType)int.Parse (args [i]);  		break;  	case 'd':  		parameters.Degree = int.Parse (args [i]);  		break;  	case 'g':  		parameters.Gamma = double.Parse (args [i]);  		break;  	case 'r':  		parameters.Coefficient0 = double.Parse (args [i]);  		break;  	case 'n':  		parameters.Nu = double.Parse (args [i]);  		break;  	case 'm':  		parameters.CacheSize = double.Parse (args [i]);  		break;  	case 'c':  		parameters.C = double.Parse (args [i]);  		break;  	case 'e':  		parameters.EPS = double.Parse (args [i]);  		break;  	case 'p':  		parameters.P = double.Parse (args [i]);  		break;  	case 'h':  		parameters.Shrinking = int.Parse (args [i]) == 1;  		break;  	case 'b':  		parameters.Probability = int.Parse (args [i]) == 1;  		break;  	case 'v':  		crossValidation = true;  		nrfold = int.Parse (args [i]);  		if (nrfold < 2) {  			throw new ArgumentException ("n-fold cross validation: n must >= 2");  		}  		break;  	case 'w':  		parameters.Weights [int.Parse (args [i - 1].Substring (2))] = double.Parse (args [1]);  		break;  	default:  		throw new ArgumentException ("Unknown Parameter");  	}  }  
Magic Number,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The following statement contains a magic number: for (i = 0; i < args.Length; i++) {  	if (args [i] [0] != '-')  		break;  	++i;  	switch (args [i - 1] [1]) {  	case 's':  		parameters.SvmType = (SvmType)int.Parse (args [i]);  		break;  	case 't':  		parameters.KernelType = (KernelType)int.Parse (args [i]);  		break;  	case 'd':  		parameters.Degree = int.Parse (args [i]);  		break;  	case 'g':  		parameters.Gamma = double.Parse (args [i]);  		break;  	case 'r':  		parameters.Coefficient0 = double.Parse (args [i]);  		break;  	case 'n':  		parameters.Nu = double.Parse (args [i]);  		break;  	case 'm':  		parameters.CacheSize = double.Parse (args [i]);  		break;  	case 'c':  		parameters.C = double.Parse (args [i]);  		break;  	case 'e':  		parameters.EPS = double.Parse (args [i]);  		break;  	case 'p':  		parameters.P = double.Parse (args [i]);  		break;  	case 'h':  		parameters.Shrinking = int.Parse (args [i]) == 1;  		break;  	case 'b':  		parameters.Probability = int.Parse (args [i]) == 1;  		break;  	case 'v':  		crossValidation = true;  		nrfold = int.Parse (args [i]);  		if (nrfold < 2) {  			throw new ArgumentException ("n-fold cross validation: n must >= 2");  		}  		break;  	case 'w':  		parameters.Weights [int.Parse (args [i - 1].Substring (2))] = double.Parse (args [1]);  		break;  	default:  		throw new ArgumentException ("Unknown Parameter");  	}  }  
Magic Number,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The following statement contains a magic number: switch (args [i - 1] [1]) {  case 's':  	parameters.SvmType = (SvmType)int.Parse (args [i]);  	break;  case 't':  	parameters.KernelType = (KernelType)int.Parse (args [i]);  	break;  case 'd':  	parameters.Degree = int.Parse (args [i]);  	break;  case 'g':  	parameters.Gamma = double.Parse (args [i]);  	break;  case 'r':  	parameters.Coefficient0 = double.Parse (args [i]);  	break;  case 'n':  	parameters.Nu = double.Parse (args [i]);  	break;  case 'm':  	parameters.CacheSize = double.Parse (args [i]);  	break;  case 'c':  	parameters.C = double.Parse (args [i]);  	break;  case 'e':  	parameters.EPS = double.Parse (args [i]);  	break;  case 'p':  	parameters.P = double.Parse (args [i]);  	break;  case 'h':  	parameters.Shrinking = int.Parse (args [i]) == 1;  	break;  case 'b':  	parameters.Probability = int.Parse (args [i]) == 1;  	break;  case 'v':  	crossValidation = true;  	nrfold = int.Parse (args [i]);  	if (nrfold < 2) {  		throw new ArgumentException ("n-fold cross validation: n must >= 2");  	}  	break;  case 'w':  	parameters.Weights [int.Parse (args [i - 1].Substring (2))] = double.Parse (args [1]);  	break;  default:  	throw new ArgumentException ("Unknown Parameter");  }  
Magic Number,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The following statement contains a magic number: switch (args [i - 1] [1]) {  case 's':  	parameters.SvmType = (SvmType)int.Parse (args [i]);  	break;  case 't':  	parameters.KernelType = (KernelType)int.Parse (args [i]);  	break;  case 'd':  	parameters.Degree = int.Parse (args [i]);  	break;  case 'g':  	parameters.Gamma = double.Parse (args [i]);  	break;  case 'r':  	parameters.Coefficient0 = double.Parse (args [i]);  	break;  case 'n':  	parameters.Nu = double.Parse (args [i]);  	break;  case 'm':  	parameters.CacheSize = double.Parse (args [i]);  	break;  case 'c':  	parameters.C = double.Parse (args [i]);  	break;  case 'e':  	parameters.EPS = double.Parse (args [i]);  	break;  case 'p':  	parameters.P = double.Parse (args [i]);  	break;  case 'h':  	parameters.Shrinking = int.Parse (args [i]) == 1;  	break;  case 'b':  	parameters.Probability = int.Parse (args [i]) == 1;  	break;  case 'v':  	crossValidation = true;  	nrfold = int.Parse (args [i]);  	if (nrfold < 2) {  		throw new ArgumentException ("n-fold cross validation: n must >= 2");  	}  	break;  case 'w':  	parameters.Weights [int.Parse (args [i - 1].Substring (2))] = double.Parse (args [1]);  	break;  default:  	throw new ArgumentException ("Unknown Parameter");  }  
Magic Number,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The following statement contains a magic number: if (nrfold < 2) {  	throw new ArgumentException ("n-fold cross validation: n must >= 2");  }  
Magic Number,SVM,Training,C:\repos\borfudin_svmnet\SVM\SVM\Training.cs,parseCommandLine,The following statement contains a magic number: parameters.Weights [int.Parse (args [i - 1].Substring (2))] = double.Parse (args [1]);  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateTwoClassProblem,The following statement contains a magic number: prob.MaxIndex = 2;  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateTwoClassProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE - (SCALE * .5);  	x = i < positive ? x : -x;  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)  	});  	labels.Add (i < positive ? 1 : -1);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateTwoClassProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE - (SCALE * .5);  	x = i < positive ? x : -x;  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)  	});  	labels.Add (i < positive ? 1 : -1);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateTwoClassProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE - (SCALE * .5);  	x = i < positive ? x : -x;  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)  	});  	labels.Add (i < positive ? 1 : -1);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateTwoClassProblem,The following statement contains a magic number: data.Add (new Node[] {  	new Node (1' x)'  	new Node (2' y)  });  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: if (numberOfClasses > 8)  	throw new ArgumentException ("Number of classes must be < 8");  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: prob.MaxIndex = 3;  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int i = 0; i < numberOfClasses; i++) {  	for (int j = 0; j < samplesPerClass [i]; j++) {  		double x = rand.NextDouble () * SCALE + 10;  		double y = rand.NextDouble () * SCALE + 10;  		double z = rand.NextDouble () * SCALE + 10;  		x *= xSigns [i];  		y *= ySigns [i];  		z *= zSigns [i];  		data.Add (new Node[] {  			new Node (1' x)'  			new Node (2' y)'  			new Node (3' z)  		});  		labels.Add (i);  	}  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int i = 0; i < numberOfClasses; i++) {  	for (int j = 0; j < samplesPerClass [i]; j++) {  		double x = rand.NextDouble () * SCALE + 10;  		double y = rand.NextDouble () * SCALE + 10;  		double z = rand.NextDouble () * SCALE + 10;  		x *= xSigns [i];  		y *= ySigns [i];  		z *= zSigns [i];  		data.Add (new Node[] {  			new Node (1' x)'  			new Node (2' y)'  			new Node (3' z)  		});  		labels.Add (i);  	}  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int i = 0; i < numberOfClasses; i++) {  	for (int j = 0; j < samplesPerClass [i]; j++) {  		double x = rand.NextDouble () * SCALE + 10;  		double y = rand.NextDouble () * SCALE + 10;  		double z = rand.NextDouble () * SCALE + 10;  		x *= xSigns [i];  		y *= ySigns [i];  		z *= zSigns [i];  		data.Add (new Node[] {  			new Node (1' x)'  			new Node (2' y)'  			new Node (3' z)  		});  		labels.Add (i);  	}  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int i = 0; i < numberOfClasses; i++) {  	for (int j = 0; j < samplesPerClass [i]; j++) {  		double x = rand.NextDouble () * SCALE + 10;  		double y = rand.NextDouble () * SCALE + 10;  		double z = rand.NextDouble () * SCALE + 10;  		x *= xSigns [i];  		y *= ySigns [i];  		z *= zSigns [i];  		data.Add (new Node[] {  			new Node (1' x)'  			new Node (2' y)'  			new Node (3' z)  		});  		labels.Add (i);  	}  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int i = 0; i < numberOfClasses; i++) {  	for (int j = 0; j < samplesPerClass [i]; j++) {  		double x = rand.NextDouble () * SCALE + 10;  		double y = rand.NextDouble () * SCALE + 10;  		double z = rand.NextDouble () * SCALE + 10;  		x *= xSigns [i];  		y *= ySigns [i];  		z *= zSigns [i];  		data.Add (new Node[] {  			new Node (1' x)'  			new Node (2' y)'  			new Node (3' z)  		});  		labels.Add (i);  	}  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int j = 0; j < samplesPerClass [i]; j++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE + 10;  	double z = rand.NextDouble () * SCALE + 10;  	x *= xSigns [i];  	y *= ySigns [i];  	z *= zSigns [i];  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)'  		new Node (3' z)  	});  	labels.Add (i);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int j = 0; j < samplesPerClass [i]; j++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE + 10;  	double z = rand.NextDouble () * SCALE + 10;  	x *= xSigns [i];  	y *= ySigns [i];  	z *= zSigns [i];  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)'  		new Node (3' z)  	});  	labels.Add (i);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int j = 0; j < samplesPerClass [i]; j++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE + 10;  	double z = rand.NextDouble () * SCALE + 10;  	x *= xSigns [i];  	y *= ySigns [i];  	z *= zSigns [i];  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)'  		new Node (3' z)  	});  	labels.Add (i);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int j = 0; j < samplesPerClass [i]; j++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE + 10;  	double z = rand.NextDouble () * SCALE + 10;  	x *= xSigns [i];  	y *= ySigns [i];  	z *= zSigns [i];  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)'  		new Node (3' z)  	});  	labels.Add (i);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: for (int j = 0; j < samplesPerClass [i]; j++) {  	double x = rand.NextDouble () * SCALE + 10;  	double y = rand.NextDouble () * SCALE + 10;  	double z = rand.NextDouble () * SCALE + 10;  	x *= xSigns [i];  	y *= ySigns [i];  	z *= zSigns [i];  	data.Add (new Node[] {  		new Node (1' x)'  		new Node (2' y)'  		new Node (3' z)  	});  	labels.Add (i);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: data.Add (new Node[] {  	new Node (1' x)'  	new Node (2' y)'  	new Node (3' z)  });  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateMulticlassProblem,The following statement contains a magic number: data.Add (new Node[] {  	new Node (1' x)'  	new Node (2' y)'  	new Node (3' z)  });  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: prob.MaxIndex = 2;  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double y = rand.NextDouble () * 10 - 5;  	double z = rand.NextDouble () * 10 - 5;  	double x = 2 * y + z;  	data.Add (new Node[] {  		new Node (1' y)'  		new Node (2' z)  	});  	labels.Add (x);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double y = rand.NextDouble () * 10 - 5;  	double z = rand.NextDouble () * 10 - 5;  	double x = 2 * y + z;  	data.Add (new Node[] {  		new Node (1' y)'  		new Node (2' z)  	});  	labels.Add (x);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double y = rand.NextDouble () * 10 - 5;  	double z = rand.NextDouble () * 10 - 5;  	double x = 2 * y + z;  	data.Add (new Node[] {  		new Node (1' y)'  		new Node (2' z)  	});  	labels.Add (x);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double y = rand.NextDouble () * 10 - 5;  	double z = rand.NextDouble () * 10 - 5;  	double x = 2 * y + z;  	data.Add (new Node[] {  		new Node (1' y)'  		new Node (2' z)  	});  	labels.Add (x);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double y = rand.NextDouble () * 10 - 5;  	double z = rand.NextDouble () * 10 - 5;  	double x = 2 * y + z;  	data.Add (new Node[] {  		new Node (1' y)'  		new Node (2' z)  	});  	labels.Add (x);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	double y = rand.NextDouble () * 10 - 5;  	double z = rand.NextDouble () * 10 - 5;  	double x = 2 * y + z;  	data.Add (new Node[] {  		new Node (1' y)'  		new Node (2' z)  	});  	labels.Add (x);  }  
Magic Number,SVMTest,SVMUtilities,C:\repos\borfudin_svmnet\SVM\SVM\SVMUtilities.cs,CreateRegressionProblem,The following statement contains a magic number: data.Add (new Node[] {  	new Node (1' y)'  	new Node (2' z)  });  
Missing Default,SVM,Procedures,C:\repos\borfudin_svmnet\SVM\SVM\Solver.cs,svm_train_one,The following switch statement is missing a default case: switch (param.SvmType) {  case SvmType.C_SVC:  	solve_c_svc (prob' param' alpha' si' Cp' Cn);  	break;  case SvmType.NU_SVC:  	solve_nu_svc (prob' param' alpha' si);  	break;  case SvmType.ONE_CLASS:  	solve_one_class (prob' param' alpha' si);  	break;  case SvmType.EPSILON_SVR:  	solve_epsilon_svr (prob' param' alpha' si);  	break;  case SvmType.NU_SVR:  	solve_nu_svr (prob' param' alpha' si);  	break;  }  
