Implementation smell,Namespace,Class,File,Method,Description
Long Statement,Mvc.Server.Helpers,FormValueRequiredAttribute,D:\research\architectureSmells\repos\aspnet-contrib_AspNet.Security.OpenIdConnect.Server\samples\Mvc\Mvc.Server\Helpers\FormValueRequiredAttribute.cs,IsValidForRequest,The length of the statement  "            if (!context.HttpContext.Request.ContentType.StartsWith("application/x-www-form-urlencoded"' StringComparison.OrdinalIgnoreCase)) " is 129.
Complex Conditional,Mvc.Server.Helpers,FormValueRequiredAttribute,D:\research\architectureSmells\repos\aspnet-contrib_AspNet.Security.OpenIdConnect.Server\samples\Mvc\Mvc.Server\Helpers\FormValueRequiredAttribute.cs,IsValidForRequest,The conditional expression  "string.Equals(context.HttpContext.Request.Method' "GET"' StringComparison.OrdinalIgnoreCase) ||                  string.Equals(context.HttpContext.Request.Method' "HEAD"' StringComparison.OrdinalIgnoreCase) ||                  string.Equals(context.HttpContext.Request.Method' "DELETE"' StringComparison.OrdinalIgnoreCase) ||                  string.Equals(context.HttpContext.Request.Method' "TRACE"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,Mvc.Server.Providers,AuthorizationProvider,D:\research\architectureSmells\repos\aspnet-contrib_AspNet.Security.OpenIdConnect.Server\samples\Mvc\Mvc.Server\Providers\AuthorizationProvider.cs,ValidateAuthorizationRequest,The conditional expression  "!string.IsNullOrEmpty(context.Request.ResponseMode) && !context.Request.IsFormPostResponseMode() &&                                                                         !context.Request.IsFragmentResponseMode() &&                                                                         !context.Request.IsQueryResponseMode()"  is complex.
Magic Number,Mvc.Server,Startup,D:\research\architectureSmells\repos\aspnet-contrib_AspNet.Security.OpenIdConnect.Server\samples\Mvc\Mvc.Server\Startup.cs,ConfigureServices,The following statement contains a magic number: services.AddAuthentication(options =>              {                  options.DefaultScheme = "ServerCookie";              })                .AddCookie("ServerCookie"' options =>              {                  options.Cookie.Name = CookieAuthenticationDefaults.CookiePrefix + "ServerCookie";                  options.ExpireTimeSpan = TimeSpan.FromMinutes(5);                  options.LoginPath = new PathString("/signin");                  options.LogoutPath = new PathString("/signout");              })                .AddGoogle(options =>              {                  options.ClientId = "560027070069-37ldt4kfuohhu3m495hk2j4pjp92d382.apps.googleusercontent.com";                  options.ClientSecret = "n2Q-GEw9RQjzcRbU3qhfTj8f";              })                .AddTwitter(options =>              {                  options.ConsumerKey = "6XaCTaLbMqfj6ww3zvZ5g";                  options.ConsumerSecret = "Il2eFzGIrYhz6BWjYhVXBPQSfZuS4xoHpSSyD9PI";              })                .AddOAuthValidation()                .AddOpenIdConnectServer(options =>              {                  options.ProviderType = typeof(AuthorizationProvider);                    // Enable the authorization' logout' token and userinfo endpoints.                  options.AuthorizationEndpointPath = "/connect/authorize";                  options.LogoutEndpointPath = "/connect/logout";                  options.TokenEndpointPath = "/connect/token";                  options.UserinfoEndpointPath = "/connect/userinfo";                    // Note: see AuthorizationController.cs for more                  // information concerning ApplicationCanDisplayErrors.                  options.ApplicationCanDisplayErrors = true;                  options.AllowInsecureHttp = true;                    // Note: to override the default access token format and use JWT' assign AccessTokenHandler:                  //                  // options.AccessTokenHandler = new JwtSecurityTokenHandler                  // {                  //     InboundClaimTypeMap = new Dictionary<string' string>()'                  //     OutboundClaimTypeMap = new Dictionary<string' string>()                  // };                  //                  // Note: when using JWT as the access token format' you have to register a signing key.                  //                  // You can register a new ephemeral key' that is discarded when the application shuts down.                  // Tokens signed using this key are automatically invalidated and thus this method                  // should only be used during development:                  //                  // options.SigningCredentials.AddEphemeralKey();                  //                  // On production' using a X.509 certificate stored in the machine store is recommended.                  // You can generate a self-signed certificate using Pluralsight's self-cert utility:                  // https://s3.amazonaws.com/pluralsight-free/keith-brown/samples/SelfCert.zip                  //                  // options.SigningCredentials.AddCertificate("7D2A741FE34CC2C7369237A5F2078988E17A6A75");                  //                  // Alternatively' you can also store the certificate as an embedded .pfx resource                  // directly in this assembly or in a file published alongside this project:                  //                  // options.SigningCredentials.AddCertificate(                  //     assembly: typeof(Startup).GetTypeInfo().Assembly'                  //     resource: "Mvc.Server.Certificate.pfx"'                  //     password: "Owin.Security.OpenIdConnect.Server");              });
