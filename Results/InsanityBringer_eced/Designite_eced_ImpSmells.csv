Implementation smell,Namespace,Class,File,Method,Description
Long Method,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The method has 107 lines of code.
Long Method,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The method has 105 lines of code.
Long Method,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The method has 516 lines of code.
Long Method,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,OutputStructure,The method has 112 lines of code.
Complex Method,eced,LevelIO,C:\repos\InsanityBringer_eced\eced\LevelIO.cs,makeNewLevel,Cyclomatic complexity of the method is 32
Complex Method,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,Cyclomatic complexity of the method is 10
Complex Method,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,Cyclomatic complexity of the method is 9
Complex Method,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,saveMapToFile,Cyclomatic complexity of the method is 9
Complex Method,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,Cyclomatic complexity of the method is 34
Complex Method,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,setMouseButton,Cyclomatic complexity of the method is 9
Complex Method,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,Cyclomatic complexity of the method is 10
Complex Method,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,Cyclomatic complexity of the method is 9
Complex Method,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,saveToUWMFFile,Cyclomatic complexity of the method is 10
Complex Method,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,writeUWMF,Cyclomatic complexity of the method is 10
Complex Method,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,allocateAtlasSpace,Cyclomatic complexity of the method is 8
Complex Method,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,Cyclomatic complexity of the method is 35
Complex Method,eced,Tile,C:\repos\InsanityBringer_eced\eced\Tile.cs,processData,Cyclomatic complexity of the method is 11
Complex Method,CodeImp.DoomBuilder.IO,DirectoryFilesList,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\DirectoryFilesList.cs,GetAllFiles,Cyclomatic complexity of the method is 8
Complex Method,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,Cyclomatic complexity of the method is 10
Complex Method,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,Cyclomatic complexity of the method is 140
Complex Method,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,OutputStructure,Cyclomatic complexity of the method is 15
Complex Method,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,Dispose,Cyclomatic complexity of the method is 8
Complex Method,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,ReadHeaders,Cyclomatic complexity of the method is 8
Complex Method,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,findSpecialMapLumps,Cyclomatic complexity of the method is 9
Complex Method,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,deleteMap,Cyclomatic complexity of the method is 8
Complex Method,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,Cyclomatic complexity of the method is 10
Long Parameter List,eced,LineDrawer,C:\repos\InsanityBringer_eced\eced\LineDrawer.cs,applyBrushOverLine,The method has 5 parameters.
Long Parameter List,eced,LineDrawer,C:\repos\InsanityBringer_eced\eced\LineDrawer.cs,lineOctant0,The method has 7 parameters.
Long Parameter List,eced,LineDrawer,C:\repos\InsanityBringer_eced\eced\LineDrawer.cs,lineOctant1,The method has 7 parameters.
Long Parameter List,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLine,The method has 6 parameters.
Long Parameter List,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The method has 5 parameters.
Long Parameter List,eced,Tile,C:\repos\InsanityBringer_eced\eced\Tile.cs,processData,The method has 10 parameters.
Long Parameter List,eced,TriggerType,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerType,The method has 6 parameters.
Long Parameter List,CodeImp.DoomBuilder.IO,ClippedStream,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\ClippedStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,CodeImp.DoomBuilder.IO,ClippedStream,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\ClippedStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,Lump,The method has 5 parameters.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,createNewLevel,The length of the statement  "	renderer.setupLevelRendering (currentLevel' (uint)sm.programList ["WorldRender"]' new OpenTK.Vector2 (mainLevelPanel.Width' mainLevelPanel.Height)); " is 148.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,saveMapToFile,The length of the statement  "            ((ResourceFiles.WADResourceFile)currentLevel.loadedResources[0]).updateToNewWad("c:/dev/flargh.wad"' ref boguslumps' ref bogusdata);*///TODO: Temp " is 146.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,saveMapToFile,The length of the statement  "	ResourceFiles.ResourceFile mapheader = new ResourceFiles.ResourceFile (this.currentMapinfo.lumpname' ResourceFiles.ResourceType.RES_GENERIC' 0); " is 144.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,saveMapToFile,The length of the statement  "	ResourceFiles.ResourceFile mapdatal = new ResourceFiles.ResourceFile ("TEXTMAP"' ResourceFiles.ResourceType.RES_GENERIC' mapdata.Length); " is 137.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,saveMapToFile,The length of the statement  "	ResourceFiles.ResourceFile mapend = new ResourceFiles.ResourceFile ("ENDMAP"' ResourceFiles.ResourceType.RES_GENERIC' 0); " is 121.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The length of the statement  "                            renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));" is 145.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_Paint,The length of the statement  "		renderer.drawLevel (currentLevel' (uint)sm.programList ["WorldRender"]' new OpenTK.Vector2 (mainLevelPanel.Width' mainLevelPanel.Height)); " is 138.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_Paint,The length of the statement  "		renderer.drawGrid (currentLevel' sm.programList ["BasicRender"]' new OpenTK.Vector2 (mainLevelPanel.Width' mainLevelPanel.Height)); " is 131.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_Paint,The length of the statement  "			renderer.drawThing (thing' currentLevel' sm.programList ["ThingRender"]' new OpenTK.Vector2 (mainLevelPanel.Width' mainLevelPanel.Height)); " is 139.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_Paint,The length of the statement  "			renderer.drawTrigger (triggerList [i]' currentLevel' sm.programList ["ThingRender"]' new OpenTK.Vector2 (mainLevelPanel.Width' mainLevelPanel.Height)); " is 151.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_Paint,The length of the statement  "		//renderer.drawTrigger(new Vector2(2.0f' 2.0f)' currentLevel' sm.programList["ThingRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height)); " is 158.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,pick,The length of the statement  "	Vector2 bstart = new Vector2 (center.X - (sizex * 8 * zoom) + (pan.X * 64 * 8 * zoom)' center.Y - (sizey * 8 * zoom) + (pan.Y * 64 * 8 * zoom)); " is 144.
Long Statement,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_MouseMove,The length of the statement  "		statusBarPanel1.Text = String.Format ("tileid: {0}' zonenum: {1}' tag: {2}"' currentLevel.getTileId (cell.tile)' currentLevel.getZoneId (cell)' cell.tag); " is 154.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupLevelRendering,The length of the statement  "	GL.BufferData (BufferTarget.ArrayBuffer' (IntPtr)(sizeof(float) * levelVBO.Length)' levelVBO' BufferUsageHint.StaticDraw); " is 122.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupTextures,The length of the statement  "	GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba16i' level.width' level.height' 0' PixelFormat.RgbaInteger' PixelType.Short' mapTexture); " is 156.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The length of the statement  "		GL.TexSubImage2D (TextureTarget.Texture2D' 0' (int)loc.X' (int)loc.Y' 1' 1' PixelFormat.RgbaInteger' PixelType.Short' id); " is 122.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupThingRendering,The length of the statement  "	GL.BufferData (BufferTarget.ArrayBuffer' (IntPtr)(sizeof(float) * arrowVBO.Length)' arrowVBO' BufferUsageHint.StaticDraw); " is 122.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupThingRendering,The length of the statement  "	GL.BufferData (BufferTarget.ArrayBuffer' (IntPtr)(sizeof(float) * levelVBO.Length)' levelVBO' BufferUsageHint.StaticDraw); " is 122.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupTriggerRendering,The length of the statement  "	GL.BufferData (BufferTarget.ArrayBuffer' (IntPtr)(sizeof(float) * triggersVBO.Length)' triggersVBO' BufferUsageHint.StaticDraw); " is 128.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The length of the statement  "		GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 ((thingdef.r + 128) / 255f' (thingdef.g + 128) / 255f' thingdef.b / 255f' 1.0f)); " is 147.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The length of the statement  "		GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 (thingdef.r / 255f' thingdef.g / 255f' thingdef.b / 255f' 1.0f)); " is 131.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The length of the statement  "	GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 (thingdef.r / 255f / 4f' thingdef.g / 255f / 4f' thingdef.b / 255f / 4f' 1.0f)); " is 146.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLine,The length of the statement  "	GL.BufferData (BufferTarget.ArrayBuffer' (IntPtr)(sizeof(float) * lineVBOTemplate.Length)' lineVBOTemplate' BufferUsageHint.DynamicDraw); " is 137.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawTrigger,The length of the statement  "		Console.WriteLine ("TRIGGER UNIFORM FIND DRAW GL Error: {0} {1} {2} {3} {4} {5}"' error.ToString ()' panUL' zoomUL' thingposUL' thingradUL' thingcolorUL); " is 154.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawTrigger,The length of the statement  "                GL.Uniform4(thingcolorUL' new OpenTK.Vector4((thingdef.r + 128) / 255f' (thingdef.g + 128) / 255f' thingdef.b / 255f' 1.0f));" is 125.
Long Statement,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawTrigger,The length of the statement  "		Console.WriteLine ("TRIGGER UNIFORMS DRAW GL Error: {0} {1} {2} {3} {4} {5}"' error.ToString ()' panUL' zoomUL' thingposUL' thingradUL' thingcolorUL); " is 150.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,getTexture,The length of the statement  "	BitmapData bmp_data = bmp.LockBits (new Rectangle (0' 0' bmp.Width' bmp.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 157.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,getTexture,The length of the statement  "	GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' bmp_data.Width' bmp_data.Height' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' bmp_data.Scan0); " is 186.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,allocateAtlasTexture,The length of the statement  "	GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' baseAtlasSize' baseAtlasSize' 0' OpenTK.Graphics.OpenGL.PixelFormat.Rgba' PixelType.UnsignedByte' bogusArray); " is 179.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadImageToAtlas,The length of the statement  "	BitmapData imageData = image.LockBits (new Rectangle (0' 0' image.Width' image.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 164.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadImageToAtlas,The length of the statement  "	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x' cell.y' cell.w' cell.h' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' imageData.Scan0); " is 160.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The length of the statement  "				finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255); " is 131.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The length of the statement  "			GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan); " is 158.
Long Statement,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The length of the statement  "	GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba16i' 1' numResources' 0' OpenTK.Graphics.OpenGL.PixelFormat.RgbaInteger' PixelType.Short' data); " is 163.
Long Statement,eced,ThingManager,C:\repos\InsanityBringer_eced\eced\ThingManager.cs,processData,The length of the statement  "							thing.setData (thingdata.Element ("radius").Value' thingdata.Element ("height").Value' thingdata.Element ("name").Value' thingdata.Element ("type").Value' thingdata.Element ("id").Value); " is 187.
Long Statement,eced,TileManager,C:\repos\InsanityBringer_eced\eced\TileManager.cs,loadTileset,The length of the statement  "							tile.processData (tiledata.Element ("texn").Value' tiledata.Element ("texs").Value' tiledata.Element ("texe").Value' tiledata.Element ("texw").Value' tiledata.Element ("offh").Value' tiledata.Element ("offv").Value' tiledata.Element ("blockn").Value' tiledata.Element ("blockn").Value' tiledata.Element ("blockn").Value' tiledata.Element ("blockn").Value); " is 356.
Long Statement,CodeImp.DoomBuilder.IO,DirectoryFilesList,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\DirectoryFilesList.cs,CorrectPath,The length of the statement  "		if ((path [path.Length - 1] == Path.DirectorySeparatorChar) || (path [path.Length - 1] == Path.AltDirectorySeparatorChar)) " is 122.
Complex Conditional,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_MouseMove,The conditional expression  "tile.X >= 0 && tile.Y >= 0 && tile.X < currentLevel.width && tile.Y < currentLevel.height"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,setCell,The conditional expression  "x >= 0 && y >= 0 && x < width && y < height"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,getTile,The conditional expression  "x >= 0 && y >= 0 && x < width && y < height"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,setTile,The conditional expression  "x >= 0 && y >= 0 && x < width && y < height"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,setTag,The conditional expression  "x >= 0 && y >= 0 && x < width && y < height"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,setSector,The conditional expression  "x >= 0 && y >= 0 && x < width && y < height"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,getThingsInRange,The conditional expression  "thing.x >= sx && thing.x < ex && thing.y >= sy && thing.y < ey"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,highlightThing,The conditional expression  "x >= sx && x < ex && y >= sy && y < ey"  is complex.
Complex Conditional,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,updateHighlight,The conditional expression  "(x < sx || x >= ex || y < sy || y >= ey) && !this.highlighted.moving"  is complex.
Complex Conditional,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The conditional expression  "data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71"  is complex.
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getInt32,The following statement contains a magic number: return b1 + (b2 << 8) + (b3 << 16) + (b4 << 24);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getInt32,The following statement contains a magic number: return b1 + (b2 << 8) + (b3 << 16) + (b4 << 24);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getInt32,The following statement contains a magic number: return b1 + (b2 << 8) + (b3 << 16) + (b4 << 24);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getInt16,The following statement contains a magic number: return (short)(b1 + (b2 << 8));  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [0] = (byte)(num & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [1] = (byte)((num >> 8) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [1] = (byte)((num >> 8) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [2] = (byte)((num >> 16) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [2] = (byte)((num >> 16) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [2] = (byte)((num >> 16) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [3] = (byte)((num >> 24) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [3] = (byte)((num >> 24) & 255);  
Magic Number,eced,BinaryHelper,C:\repos\InsanityBringer_eced\eced\BinaryHelper.cs,getBytes,The following statement contains a magic number: res [3] = (byte)((num >> 24) & 255);  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (this.ndThingAngle.Value == 360)  	this.ndThingAngle.Value = 0;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 90)  	this.rbThingNorth.Checked = true;  else  	this.rbThingNorth.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 180)  	this.rbThingWest.Checked = true;  else  	this.rbThingWest.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 270)  	this.rbThingSouth.Checked = true;  else  	this.rbThingSouth.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 45)  	this.rbThingNE.Checked = true;  else  	this.rbThingNE.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 135)  	this.rbThingNW.Checked = true;  else  	this.rbThingNW.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 225)  	this.rbThingSW.Checked = true;  else  	this.rbThingSW.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thing.angle == 315)  	this.rbThingSE.Checked = true;  else  	this.rbThingSE.Checked = false;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingNorth.Checked)  	this.ndThingAngle.Value = 90;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 90;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingWest.Checked)  	this.ndThingAngle.Value = 180;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 180;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingSouth.Checked)  	this.ndThingAngle.Value = 270;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 270;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingNE.Checked)  	this.ndThingAngle.Value = 45;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 45;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingNW.Checked)  	this.ndThingAngle.Value = 135;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 135;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingSW.Checked)  	this.ndThingAngle.Value = 225;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 225;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingSE.Checked)  	this.ndThingAngle.Value = 315;  
Magic Number,eced,ThingEditor,C:\repos\InsanityBringer_eced\eced\ThingEditor.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 315;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,Form1_Load,The following statement contains a magic number: tbToolPanel.Buttons [5].Pushed = true;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (e.Button.Tag != null) {  	oldtoolid = toolid;  	int ltag = Int32.Parse ((String)e.Button.Tag);  	if (ltag < 20) {  		toolid = ltag;  		tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  		tbToolPanel.Buttons [toolid + 4].Pushed = true;  		this.gbThingSelect.Visible = false;  		this.gbTileSelection.Visible = false;  		this.gbTriggerData.Visible = false;  		this.gbZoneList.Visible = false;  		this.gbSectorPanel.Visible = false;  		this.gbTag.Visible = false;  		switch (toolid) {  		case 1:  			this.defaultBrush = new Brush ();  			this.gbTileSelection.Visible = true;  			break;  		case 2:  			this.defaultBrush = new TileBrush ();  			this.gbTileSelection.Visible = true;  			break;  		case 4:  			this.defaultBrush = thingBrush;  			this.gbThingSelect.Visible = true;  			break;  		case 5:  			this.defaultBrush = triggerBrush;  			this.gbTriggerData.Visible = true;  			break;  		case 6:  			this.defaultBrush = sectorBrush;  			this.gbSectorPanel.Visible = true;  			break;  		case 7:  			this.defaultBrush = zoneBrush;  			this.gbZoneList.Visible = true;  			break;  		case 8:  			this.defaultBrush = tagBrush;  			this.gbTag.Visible = true;  			break;  		}  	}  	if (ltag == 22) {  		if (this.currentFilename != "") {  			saveMapToFile (this.currentFilename' true);  		}  		else {  			doSaveDialog (true);  		}  	}  	if (ltag == 21) {  		/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  	if (ltag == 20) {  		doNewMapDialog ();  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag < 20) {  	toolid = ltag;  	tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  	tbToolPanel.Buttons [toolid + 4].Pushed = true;  	this.gbThingSelect.Visible = false;  	this.gbTileSelection.Visible = false;  	this.gbTriggerData.Visible = false;  	this.gbZoneList.Visible = false;  	this.gbSectorPanel.Visible = false;  	this.gbTag.Visible = false;  	switch (toolid) {  	case 1:  		this.defaultBrush = new Brush ();  		this.gbTileSelection.Visible = true;  		break;  	case 2:  		this.defaultBrush = new TileBrush ();  		this.gbTileSelection.Visible = true;  		break;  	case 4:  		this.defaultBrush = thingBrush;  		this.gbThingSelect.Visible = true;  		break;  	case 5:  		this.defaultBrush = triggerBrush;  		this.gbTriggerData.Visible = true;  		break;  	case 6:  		this.defaultBrush = sectorBrush;  		this.gbSectorPanel.Visible = true;  		break;  	case 7:  		this.defaultBrush = zoneBrush;  		this.gbZoneList.Visible = true;  		break;  	case 8:  		this.defaultBrush = tagBrush;  		this.gbTag.Visible = true;  		break;  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: tbToolPanel.Buttons [oldtoolid + 4].Pushed = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: tbToolPanel.Buttons [toolid + 4].Pushed = true;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag == 22) {  	if (this.currentFilename != "") {  		saveMapToFile (this.currentFilename' true);  	}  	else {  		doSaveDialog (true);  	}  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag == 21) {  	/*                     //TODO: Absolute path                     CodeImp.DoomBuilder.IO.UniversalParser parser = new CodeImp.DoomBuilder.IO.UniversalParser("c:/dev/textmap.txt");                      Console.WriteLine("Errors: {0}' line {1}"' parser.ErrorDescription' parser.ErrorLine);                     for (int x = 0; x < parser.Root.Count; x++)                     {                         Console.WriteLine("Found key {0}"' parser.Root[x].Key);                     }                      //reconstruct the level                     if (parser.ErrorDescription == "")                     {                         //try                         {                             //TODO: Redundant code with level creation                             closeLevel();                             tm.cleanup();                             //TODO: Absolute path                             ResourceFiles.ResourceArchive arc = ResourceFiles.WADResourceFile.loadResourceFile("c:/games/ecwolf/sneswolf.wad");                              Level newLevel = LevelIO.makeNewLevel(parser.Root);                             newLevel.localThingList = this.thinglist;                              tm.allocateAtlasTexture();                             tm.readyAtlasCreation();                             tm.getTextureList(arc);                             tm.createInfoTexture();                             tm.uploadNumberTexture();                              newLevel.tm = this.tm;                              renderer.setupTextures(newLevel' tm.resourceInfoID' tm.atlasTextureID' tm.numberTextureID);                              currentLevel = newLevel;                              renderer.setupLevelRendering(currentLevel' (uint)sm.programList["WorldRender"]' new OpenTK.Vector2(mainLevelPanel.Width' mainLevelPanel.Height));                             renderer.setupThingUniforms(sm.programList["ThingRender"]);                              this.updateZoneList();                         }                         catch (Exception exc)                         {                             statusBar1.Panels[0].Text = "Error loading map: " + exc.Message;                             Console.WriteLine(exc.ToString());                         }                     }                     Console.WriteLine("heh");*/}  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following statement contains a magic number: if (ltag == 20) {  	doNewMapDialog ();  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,setMouseButton,The following statement contains a magic number: switch (e.Button) {  case MouseButtons.Left:  	this.heldMouseButton = 0;  	break;  case MouseButtons.Right:  	this.heldMouseButton = 1;  	break;  case MouseButtons.Middle:  	this.heldMouseButton = 2;  	break;  }  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,setMouseButton,The following statement contains a magic number: this.heldMouseButton = 2;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_MouseMove,The following statement contains a magic number: currentLevel.updateHighlight ((int)((tile.X + .5) * 64)' (int)((tile.Y + .5) * 64));  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_MouseMove,The following statement contains a magic number: currentLevel.updateHighlight ((int)((tile.X + .5) * 64)' (int)((tile.Y + .5) * 64));  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_MouseMove,The following statement contains a magic number: currentLevel.updateHighlight ((int)((tile.X + .5) * 64)' (int)((tile.Y + .5) * 64));  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,mainLevelPanel_MouseMove,The following statement contains a magic number: currentLevel.updateHighlight ((int)((tile.X + .5) * 64)' (int)((tile.Y + .5) * 64));  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (this.ndThingAngle.Value == 360)  	this.ndThingAngle.Value = 0;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 90)  	this.rbThingNorth.Checked = true;  else  	this.rbThingNorth.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 180)  	this.rbThingWest.Checked = true;  else  	this.rbThingWest.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 270)  	this.rbThingSouth.Checked = true;  else  	this.rbThingSouth.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 45)  	this.rbThingNE.Checked = true;  else  	this.rbThingNE.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 135)  	this.rbThingNW.Checked = true;  else  	this.rbThingNW.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 225)  	this.rbThingSW.Checked = true;  else  	this.rbThingSW.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,ndThingAngle_ValueChanged,The following statement contains a magic number: if (thingBrush.flags.angle == 315)  	this.rbThingSE.Checked = true;  else  	this.rbThingSE.Checked = false;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingNorth.Checked)  	this.ndThingAngle.Value = 90;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 90;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingWest.Checked)  	this.ndThingAngle.Value = 180;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 180;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingSouth.Checked)  	this.ndThingAngle.Value = 270;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 270;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingNE.Checked)  	this.ndThingAngle.Value = 45;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 45;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingNW.Checked)  	this.ndThingAngle.Value = 135;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 135;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingSW.Checked)  	this.ndThingAngle.Value = 225;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 225;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: if (rbThingSE.Checked)  	this.ndThingAngle.Value = 315;  
Magic Number,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,rbThingEast_CheckedChanged,The following statement contains a magic number: this.ndThingAngle.Value = 315;  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupLevelRendering,The following statement contains a magic number: GL.Uniform1 (uniformsBasicRender.texInfoUL' 2);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,setupLevelRendering,The following statement contains a magic number: GL.Uniform1 (uniformsBasicRender.numbersUL' 3);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLevel,The following statement contains a magic number: GL.VertexAttribPointer (0' 4' VertexAttribPointerType.Float' false' 0' 0);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLevel,The following statement contains a magic number: GL.DrawArrays (PrimitiveType.Triangles' 0' 6);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: for (int i = 0; i < level.updateCells.Count; i++) {  	OpenTK.Vector2 loc = level.updateCells [i];  	Tile tile = level.getTile ((int)loc.X' (int)loc.Y' 0);  	short[] id = new short[4];  	if (tile != null) {  		id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  	}  	else {  		id [0] = id [2] = id [3] = (short)-1;  		id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  	}  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' (int)loc.X' (int)loc.Y' 1' 1' PixelFormat.RgbaInteger' PixelType.Short' id);  	//Console.WriteLine("pushing {0} cell {1} {2}"' id[0]' loc.X' loc.Y);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: for (int i = 0; i < level.updateCells.Count; i++) {  	OpenTK.Vector2 loc = level.updateCells [i];  	Tile tile = level.getTile ((int)loc.X' (int)loc.Y' 0);  	short[] id = new short[4];  	if (tile != null) {  		id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  	}  	else {  		id [0] = id [2] = id [3] = (short)-1;  		id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  	}  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' (int)loc.X' (int)loc.Y' 1' 1' PixelFormat.RgbaInteger' PixelType.Short' id);  	//Console.WriteLine("pushing {0} cell {1} {2}"' id[0]' loc.X' loc.Y);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: for (int i = 0; i < level.updateCells.Count; i++) {  	OpenTK.Vector2 loc = level.updateCells [i];  	Tile tile = level.getTile ((int)loc.X' (int)loc.Y' 0);  	short[] id = new short[4];  	if (tile != null) {  		id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  	}  	else {  		id [0] = id [2] = id [3] = (short)-1;  		id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  	}  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' (int)loc.X' (int)loc.Y' 1' 1' PixelFormat.RgbaInteger' PixelType.Short' id);  	//Console.WriteLine("pushing {0} cell {1} {2}"' id[0]' loc.X' loc.Y);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: for (int i = 0; i < level.updateCells.Count; i++) {  	OpenTK.Vector2 loc = level.updateCells [i];  	Tile tile = level.getTile ((int)loc.X' (int)loc.Y' 0);  	short[] id = new short[4];  	if (tile != null) {  		id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  	}  	else {  		id [0] = id [2] = id [3] = (short)-1;  		id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  	}  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' (int)loc.X' (int)loc.Y' 1' 1' PixelFormat.RgbaInteger' PixelType.Short' id);  	//Console.WriteLine("pushing {0} cell {1} {2}"' id[0]' loc.X' loc.Y);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: for (int i = 0; i < level.updateCells.Count; i++) {  	OpenTK.Vector2 loc = level.updateCells [i];  	Tile tile = level.getTile ((int)loc.X' (int)loc.Y' 0);  	short[] id = new short[4];  	if (tile != null) {  		id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  	}  	else {  		id [0] = id [2] = id [3] = (short)-1;  		id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  	}  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' (int)loc.X' (int)loc.Y' 1' 1' PixelFormat.RgbaInteger' PixelType.Short' id);  	//Console.WriteLine("pushing {0} cell {1} {2}"' id[0]' loc.X' loc.Y);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: if (tile != null) {  	id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  }  else {  	id [0] = id [2] = id [3] = (short)-1;  	id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: if (tile != null) {  	id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  }  else {  	id [0] = id [2] = id [3] = (short)-1;  	id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: if (tile != null) {  	id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  }  else {  	id [0] = id [2] = id [3] = (short)-1;  	id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: if (tile != null) {  	id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  }  else {  	id [0] = id [2] = id [3] = (short)-1;  	id [1] = (short)level.getZoneID ((int)loc.X' (int)loc.Y' 0);  }  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: id [0] = id [1] = id [2] = id [3] = (short)level.tm.getTextureID (tile.texn);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: id [0] = id [2] = id [3] = (short)-1;  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,updateWorldTexture,The following statement contains a magic number: id [0] = id [2] = id [3] = (short)-1;  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: if (thing.highlighted)  	GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 ((thingdef.r + 128) / 255f' (thingdef.g + 128) / 255f' thingdef.b / 255f' 1.0f));  else  	GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 (thingdef.r / 255f' thingdef.g / 255f' thingdef.b / 255f' 1.0f));  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: if (thing.highlighted)  	GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 ((thingdef.r + 128) / 255f' (thingdef.g + 128) / 255f' thingdef.b / 255f' 1.0f));  else  	GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 (thingdef.r / 255f' thingdef.g / 255f' thingdef.b / 255f' 1.0f));  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 ((thingdef.r + 128) / 255f' (thingdef.g + 128) / 255f' thingdef.b / 255f' 1.0f));  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: GL.Uniform4 (uniformsThingRender.thingcolorUL' new OpenTK.Vector4 ((thingdef.r + 128) / 255f' (thingdef.g + 128) / 255f' thingdef.b / 255f' 1.0f));  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: GL.VertexAttribPointer (0' 4' VertexAttribPointerType.Float' false' 0' 0);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: GL.DrawArrays (PrimitiveType.Triangles' 0' 6);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: GL.VertexAttribPointer (0' 4' VertexAttribPointerType.Float' false' 0' 0);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawThing,The following statement contains a magic number: GL.DrawArrays (PrimitiveType.Lines' 0' 6);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLine,The following statement contains a magic number: lineVBOTemplate [4] = dst.X;  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLine,The following statement contains a magic number: lineVBOTemplate [5] = dst.Y;  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLine,The following statement contains a magic number: GL.VertexAttribPointer (0' 4' VertexAttribPointerType.Float' false' 0' 0);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawLine,The following statement contains a magic number: GL.DrawArrays (PrimitiveType.Lines' 0' 6);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawTrigger,The following statement contains a magic number: GL.VertexAttribPointer (0' 4' VertexAttribPointerType.Float' false' 0' 0);  
Magic Number,eced,GraphicsManager,C:\repos\InsanityBringer_eced\eced\GraphicsManager.cs,drawTrigger,The following statement contains a magic number: GL.DrawArrays (PrimitiveType.Lines' 0' 4);  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: for (int x = 0; x < this.width; x++) {  	for (int y = 0; y < this.height; y++) {  		//planeData[(x * width + y) * 4] = (short)planes[layer].cells[x' y].tile.id;  		if (planes [layer].cells [x' y].tile != null)  			planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  		else  			planeData [(y * width + x) * 4] = -1;  		if (planes [layer].cells [x' y].tile == null)  			planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  	}  }  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: for (int x = 0; x < this.width; x++) {  	for (int y = 0; y < this.height; y++) {  		//planeData[(x * width + y) * 4] = (short)planes[layer].cells[x' y].tile.id;  		if (planes [layer].cells [x' y].tile != null)  			planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  		else  			planeData [(y * width + x) * 4] = -1;  		if (planes [layer].cells [x' y].tile == null)  			planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  	}  }  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: for (int x = 0; x < this.width; x++) {  	for (int y = 0; y < this.height; y++) {  		//planeData[(x * width + y) * 4] = (short)planes[layer].cells[x' y].tile.id;  		if (planes [layer].cells [x' y].tile != null)  			planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  		else  			planeData [(y * width + x) * 4] = -1;  		if (planes [layer].cells [x' y].tile == null)  			planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  	}  }  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: for (int y = 0; y < this.height; y++) {  	//planeData[(x * width + y) * 4] = (short)planes[layer].cells[x' y].tile.id;  	if (planes [layer].cells [x' y].tile != null)  		planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  	else  		planeData [(y * width + x) * 4] = -1;  	if (planes [layer].cells [x' y].tile == null)  		planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  }  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: for (int y = 0; y < this.height; y++) {  	//planeData[(x * width + y) * 4] = (short)planes[layer].cells[x' y].tile.id;  	if (planes [layer].cells [x' y].tile != null)  		planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  	else  		planeData [(y * width + x) * 4] = -1;  	if (planes [layer].cells [x' y].tile == null)  		planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  }  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: for (int y = 0; y < this.height; y++) {  	//planeData[(x * width + y) * 4] = (short)planes[layer].cells[x' y].tile.id;  	if (planes [layer].cells [x' y].tile != null)  		planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  	else  		planeData [(y * width + x) * 4] = -1;  	if (planes [layer].cells [x' y].tile == null)  		planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  }  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: if (planes [layer].cells [x' y].tile != null)  	planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  else  	planeData [(y * width + x) * 4] = -1;  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: if (planes [layer].cells [x' y].tile != null)  	planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  else  	planeData [(y * width + x) * 4] = -1;  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: planeData [(y * width + x) * 4] = (short)tm.getTextureID (planes [layer].cells [x' y].tile.texn);  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: planeData [(y * width + x) * 4] = -1;  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: if (planes [layer].cells [x' y].tile == null)  	planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  
Magic Number,eced,Level,C:\repos\InsanityBringer_eced\eced\Level.cs,buildPlaneData,The following statement contains a magic number: planeData [(y * width + x) * 4 + 1] = (short)zonedefs.IndexOf (planes [layer].cells [x' y].zone);  
Magic Number,eced,Plane,C:\repos\InsanityBringer_eced\eced\Plane.cs,Reconstruct,The following statement contains a magic number: plane.height = UWMFSearch.getIntTag (data' "height"' 64);  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,TextureManager,The following statement contains a magic number: palette [i * 3] = palette [i * 3 + 1] = palette [i * 3 + 2] = (byte)i;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int i = 0; i < w; i++) {  	int pointer = BinaryHelper.getInt32 (patch [offset]' patch [offset + 1]' patch [offset + 2]' patch [offset + 3]);  	offset += 4;  	int newoffset = pointer;  	//Load the offset and length of the patch  	byte yoffs = patch [pointer];  	pointer++;  	while (yoffs != 255) {  		byte len = patch [pointer];  		pointer++;  		pointer++;  		//Garbage byte  		byte[] spandata = new byte[len];  		//Resultant 32bit span  		int[] finalspan = new int[len];  		//copy the span into the array  		Array.Copy (patch' pointer' spandata' 0' len);  		//Use the current palette to build a 32bit patch  		for (int p = 0; p < len; p++) {  			byte patchbyte = spandata [p];  			finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  		}  		pointer += len + 1;  		GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  		yoffs = patch [pointer];  		pointer++;  	}  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: offset += 4;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: while (yoffs != 255) {  	byte len = patch [pointer];  	pointer++;  	pointer++;  	//Garbage byte  	byte[] spandata = new byte[len];  	//Resultant 32bit span  	int[] finalspan = new int[len];  	//copy the span into the array  	Array.Copy (patch' pointer' spandata' 0' len);  	//Use the current palette to build a 32bit patch  	for (int p = 0; p < len; p++) {  		byte patchbyte = spandata [p];  		finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  	}  	pointer += len + 1;  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  	yoffs = patch [pointer];  	pointer++;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: while (yoffs != 255) {  	byte len = patch [pointer];  	pointer++;  	pointer++;  	//Garbage byte  	byte[] spandata = new byte[len];  	//Resultant 32bit span  	int[] finalspan = new int[len];  	//copy the span into the array  	Array.Copy (patch' pointer' spandata' 0' len);  	//Use the current palette to build a 32bit patch  	for (int p = 0; p < len; p++) {  		byte patchbyte = spandata [p];  		finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  	}  	pointer += len + 1;  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  	yoffs = patch [pointer];  	pointer++;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: while (yoffs != 255) {  	byte len = patch [pointer];  	pointer++;  	pointer++;  	//Garbage byte  	byte[] spandata = new byte[len];  	//Resultant 32bit span  	int[] finalspan = new int[len];  	//copy the span into the array  	Array.Copy (patch' pointer' spandata' 0' len);  	//Use the current palette to build a 32bit patch  	for (int p = 0; p < len; p++) {  		byte patchbyte = spandata [p];  		finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  	}  	pointer += len + 1;  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  	yoffs = patch [pointer];  	pointer++;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: while (yoffs != 255) {  	byte len = patch [pointer];  	pointer++;  	pointer++;  	//Garbage byte  	byte[] spandata = new byte[len];  	//Resultant 32bit span  	int[] finalspan = new int[len];  	//copy the span into the array  	Array.Copy (patch' pointer' spandata' 0' len);  	//Use the current palette to build a 32bit patch  	for (int p = 0; p < len; p++) {  		byte patchbyte = spandata [p];  		finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  	}  	pointer += len + 1;  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  	yoffs = patch [pointer];  	pointer++;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: while (yoffs != 255) {  	byte len = patch [pointer];  	pointer++;  	pointer++;  	//Garbage byte  	byte[] spandata = new byte[len];  	//Resultant 32bit span  	int[] finalspan = new int[len];  	//copy the span into the array  	Array.Copy (patch' pointer' spandata' 0' len);  	//Use the current palette to build a 32bit patch  	for (int p = 0; p < len; p++) {  		byte patchbyte = spandata [p];  		finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  	}  	pointer += len + 1;  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  	yoffs = patch [pointer];  	pointer++;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: while (yoffs != 255) {  	byte len = patch [pointer];  	pointer++;  	pointer++;  	//Garbage byte  	byte[] spandata = new byte[len];  	//Resultant 32bit span  	int[] finalspan = new int[len];  	//copy the span into the array  	Array.Copy (patch' pointer' spandata' 0' len);  	//Use the current palette to build a 32bit patch  	for (int p = 0; p < len; p++) {  		byte patchbyte = spandata [p];  		finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  	}  	pointer += len + 1;  	GL.TexSubImage2D (TextureTarget.Texture2D' 0' cell.x + i' cell.y + yoffs' 1' len' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' finalspan);  	yoffs = patch [pointer];  	pointer++;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int p = 0; p < len; p++) {  	byte patchbyte = spandata [p];  	finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int p = 0; p < len; p++) {  	byte patchbyte = spandata [p];  	finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int p = 0; p < len; p++) {  	byte patchbyte = spandata [p];  	finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int p = 0; p < len; p++) {  	byte patchbyte = spandata [p];  	finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: for (int p = 0; p < len; p++) {  	byte patchbyte = spandata [p];  	finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,uploadPatchToAtlas,The following statement contains a magic number: finalspan [p] = BinaryHelper.getInt32 (palette [patchbyte * 3 + 2]' palette [patchbyte * 3 + 1]' palette [patchbyte * 3 + 0]' 255);  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: for (int i = 0; i < numResources; i++) {  	data [i * 4 + 0] = (short)cells [i].w;  	data [i * 4 + 1] = (short)cells [i].h;  	data [i * 4 + 2] = (short)cells [i].x;  	data [i * 4 + 3] = (short)cells [i].y;  	//Console.WriteLine("{0} {1} {2} {3}"' cells[i].w' cells[i].h' cells[i].x' cells[i].y);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: for (int i = 0; i < numResources; i++) {  	data [i * 4 + 0] = (short)cells [i].w;  	data [i * 4 + 1] = (short)cells [i].h;  	data [i * 4 + 2] = (short)cells [i].x;  	data [i * 4 + 3] = (short)cells [i].y;  	//Console.WriteLine("{0} {1} {2} {3}"' cells[i].w' cells[i].h' cells[i].x' cells[i].y);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: for (int i = 0; i < numResources; i++) {  	data [i * 4 + 0] = (short)cells [i].w;  	data [i * 4 + 1] = (short)cells [i].h;  	data [i * 4 + 2] = (short)cells [i].x;  	data [i * 4 + 3] = (short)cells [i].y;  	//Console.WriteLine("{0} {1} {2} {3}"' cells[i].w' cells[i].h' cells[i].x' cells[i].y);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: for (int i = 0; i < numResources; i++) {  	data [i * 4 + 0] = (short)cells [i].w;  	data [i * 4 + 1] = (short)cells [i].h;  	data [i * 4 + 2] = (short)cells [i].x;  	data [i * 4 + 3] = (short)cells [i].y;  	//Console.WriteLine("{0} {1} {2} {3}"' cells[i].w' cells[i].h' cells[i].x' cells[i].y);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: for (int i = 0; i < numResources; i++) {  	data [i * 4 + 0] = (short)cells [i].w;  	data [i * 4 + 1] = (short)cells [i].h;  	data [i * 4 + 2] = (short)cells [i].x;  	data [i * 4 + 3] = (short)cells [i].y;  	//Console.WriteLine("{0} {1} {2} {3}"' cells[i].w' cells[i].h' cells[i].x' cells[i].y);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: for (int i = 0; i < numResources; i++) {  	data [i * 4 + 0] = (short)cells [i].w;  	data [i * 4 + 1] = (short)cells [i].h;  	data [i * 4 + 2] = (short)cells [i].x;  	data [i * 4 + 3] = (short)cells [i].y;  	//Console.WriteLine("{0} {1} {2} {3}"' cells[i].w' cells[i].h' cells[i].x' cells[i].y);  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: data [i * 4 + 0] = (short)cells [i].w;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: data [i * 4 + 1] = (short)cells [i].h;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: data [i * 4 + 2] = (short)cells [i].x;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: data [i * 4 + 2] = (short)cells [i].x;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: data [i * 4 + 3] = (short)cells [i].y;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,createInfoTexture,The following statement contains a magic number: data [i * 4 + 3] = (short)cells [i].y;  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The following statement contains a magic number: if (data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71) {  	return TextureFormat.FORMAT_PNG;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The following statement contains a magic number: if (data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71) {  	return TextureFormat.FORMAT_PNG;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The following statement contains a magic number: if (data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71) {  	return TextureFormat.FORMAT_PNG;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The following statement contains a magic number: if (data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71) {  	return TextureFormat.FORMAT_PNG;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The following statement contains a magic number: if (data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71) {  	return TextureFormat.FORMAT_PNG;  }  
Magic Number,eced,TextureManager,C:\repos\InsanityBringer_eced\eced\TextureManager.cs,checkFormat,The following statement contains a magic number: if (data [0] == 137 && data [1] == 80 && data [2] == 78 && data [3] == 71) {  	return TextureFormat.FORMAT_PNG;  }  
Magic Number,eced,Thing,C:\repos\InsanityBringer_eced\eced\Thing.cs,getXCoord,The following statement contains a magic number: return x * 64f + 32;  
Magic Number,eced,Thing,C:\repos\InsanityBringer_eced\eced\Thing.cs,getYCoord,The following statement contains a magic number: return y * 64f + 32;  
Magic Number,eced,Thing,C:\repos\InsanityBringer_eced\eced\Thing.cs,Reconstruct,The following statement contains a magic number: thing.typeid = UWMFSearch.getIntTag (data' "type"' 10);  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: if (type != null) {  	switch (type) {  	case "Unknown":  		r = 64;  		g = 64;  		b = 64;  		break;  	case "Spawn":  		r = 0;  		g = 128;  		b = 0;  		break;  	case "Internal":  		r = 128;  		g = 128;  		b = 128;  		break;  	case "Enemy":  		r = 128;  		g = 0;  		b = 0;  		break;  	case "Treasure":  		r = 128;  		g = 128;  		b = 0;  		break;  	case "Powerup":  		r = 0;  		g = 128;  		b = 128;  		break;  	}  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: r = 64;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: g = 64;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: b = 64;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: g = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: r = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: g = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: b = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: r = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: r = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: g = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: g = 128;  
Magic Number,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following statement contains a magic number: b = 128;  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (2' new TriggerType ("Pushwall_Move"' "speed"' "direction"' "distance"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (3' new TriggerType ("Exit_Normal"' "pos"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (4' new TriggerType ("Exit_Secret"' "pos"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (5' new TriggerType ("Teleport_NewMap"' "map"' "pos"' "flags"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (6' new TriggerType ("Exit_VictorySpin"' "<none>"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (7' new TriggerType ("Exit_Victory"' "<none>"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (8' new TriggerType ("Trigger_Execute"' "<none>"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (9' new TriggerType ("StartConversation"' "<none>"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (10' new TriggerType ("Door_Elevator"' "<none>"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,eced,TriggerTypeList,C:\repos\InsanityBringer_eced\eced\TriggerTypeList.cs,TriggerTypeList,The following statement contains a magic number: addTrigger (11' new TriggerType ("Elevator_SwitchFloor"' "<none>"' "<none>"' "<none>"' "<none>"' "<none>"));  
Magic Number,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,MakeLongName,The following statement contains a magic number: if (bytes > 8)  	bytes = 8;  
Magic Number,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,MakeLongName,The following statement contains a magic number: if (bytes > 8)  	bytes = 8;  
Magic Number,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,MakeLongName,The following statement contains a magic number: bytes = 8;  
Magic Number,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,MakeFixedName,The following statement contains a magic number: if (bytes < 8)  	bytes = 8;  
Magic Number,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,MakeFixedName,The following statement contains a magic number: if (bytes < 8)  	bytes = 8;  
Magic Number,CodeImp.DoomBuilder.IO,Lump,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\Lump.cs,MakeFixedName,The following statement contains a magic number: bytes = 8;  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	if (c == ''' || c == '}')//read data  	 {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  		endofstruct = true;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  	if (!endofstruct) {  		// Next character  		pos++;  		c = data [pos];  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	if (c == ''' || c == '}')//read data  	 {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  		endofstruct = true;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  	if (!endofstruct) {  		// Next character  		pos++;  		c = data [pos];  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	if (c == ''' || c == '}')//read data  	 {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  		endofstruct = true;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  	if (!endofstruct) {  		// Next character  		pos++;  		c = data [pos];  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	if (c == ''' || c == '}')//read data  	 {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  		endofstruct = true;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  	if (!endofstruct) {  		// Next character  		pos++;  		c = data [pos];  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	if (c == ''' || c == '}')//read data  	 {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = ival;  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					number = lval;  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  		endofstruct = true;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  	if (!endofstruct) {  		// Next character  		pos++;  		c = data [pos];  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if (c == ''' || c == '}')//read data   {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  	endofstruct = true;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if (c == ''' || c == '}')//read data   {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  	endofstruct = true;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if (c == ''' || c == '}')//read data   {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  	endofstruct = true;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if (c == ''' || c == '}')//read data   {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  	endofstruct = true;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if (c == ''' || c == '}')//read data   {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = ival;  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				number = lval;  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  	endofstruct = true;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		number = ival;  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			number = lval;  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	number = ival;  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = lval;  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	number = ival;  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = lval;  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	number = ival;  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = lval;  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	number = ival;  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		number = lval;  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: try {  	// Convert to value  	lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	number = lval;  }  catch (System.OverflowException) {  	// Too large for Int64' return error  	RaiseError (line' ERROR_VALUETOOBIG);  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: try {  	// Convert to value  	lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	number = lval;  }  catch (System.OverflowException) {  	// Too large for Int64' return error  	RaiseError (line' ERROR_VALUETOOBIG);  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,GetNumber,The following statement contains a magic number: lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: while ((pos < data.Length) && (cpErrorResult == 0) && (endofstruct == false)) {  	// Get current character  	c = data [pos];  	// ================ What parse mode are we at?  	if (pm == PM_NOTHING) {  		// Now check what character this is  		switch (c) {  		case '{':  			// Begin of new struct  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Next character  				pos++;  				// Parse this struct and add it  				//[IB] oh dear' special handling for planemaps  				if (key.Trim () == "planemap")  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  				//[IB] oh well  				else  					cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  				// Check the last character  				pos--;  				// Reset the key  				key = "";  			}  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			endofstruct = true;  			// Leave the loop  			break;  		case '=':  			// Assignment  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Now parsing assignment  				pm = PM_ASSIGNMENT;  			}  			// Leave switch  			break;  		case ';':  			// Terminator  			// Validate key  			if (ValidateKey (key.Trim ()' line)) {  				// Error: No value  				RaiseError (line' ERROR_KEYWITHOUTVALUE);  			}  			// Leave switch  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	//[IB]Handle planemaps  	else if (pm == PM_PLANEMAPS) {  		// Now check what character this is  		switch (c) {  		case '{':  			// beginning of a planemap cell  			int tag = 0;  			pos++;  			planephase++;  			terminateWhitespace (ref data' ref pos' ref line);  			int til = (int)GetNumber (ref data' ref pos' ref line);  			//Console.Write("tile: " + til.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int sec = (int)GetNumber (ref data' ref pos' ref line);  			//Console.WriteLine(" sec: " + sec.ToString());  			c = data [pos];  			pos++;  			if (c != ''') {  				RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  				break;  			}  			terminateWhitespace (ref data' ref pos' ref line);  			int zone = (int)GetNumber (ref data' ref pos' ref line);  			c = data [pos];  			pos++;  			//handle optional tag  			if (c == ''') {  				terminateWhitespace (ref data' ref pos' ref line);  				tag = (int)GetNumber (ref data' ref pos' ref line);  				terminateWhitespace (ref data' ref pos' ref line);  				c = data [pos];  				Console.WriteLine ("tag {0}"' tag);  			}  			if (c != '}') {  				RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  				break;  			}  			eced.NumberCell cell = new eced.NumberCell ();  			cell.tile = til;  			cell.sector = sec;  			cell.zone = zone;  			cell.tag = tag;  			cells.Add (cell);  			planephase = 0;  			// Leave switch  			break;  		case ''':  			planephase = 1;  			// Leave switch  			break;  		case '}':  			// End of this struct  			// Stop parsing in this struct  			if (planephase == 0) {  				endofstruct = true;  				cs.Add (new UniversalEntry ("planedata"' cells));  			}  			else  				planephase = 0;  			// Leave the loop  			break;  		case '\n':  			// New line  			// Count the line  			line++;  			// Add this to the key as a space.  			// Spaces are not allowed' but it will be trimmed  			// when its the first or last character.  			key += " ";  			// Leave switch  			break;  		case '\\':  		// Possible comment  		case '/':  			// Check for the line comment //  			if (data.Substring (pos' 2) == "//") {  				// Find the next line  				int np = data.IndexOf ("\n"' pos);  				// Next line found?  				if (np > -1) {  					// Count the line  					line++;  					// Skip everything on this line  					pos = np;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Check for the block comment /* */  			else if (data.Substring (pos' 2) == "/*") {  				// Find the next closing block comment  				int np = data.IndexOf ("*/"' pos);  				// Closing block comment found?  				if (np > -1) {  					// Count the lines in the block comment  					string blockdata = data.Substring (pos' np - pos + 2);  					line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  					// Skip everything in this block  					pos = np + 1;  				}  				else {  					// No end of line  					// Skip everything else  					pos = data.Length;  				}  			}  			// Leave switch  			break;  		default:  			// Everything else  			// Add character to key  			key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  			// Leave switch  			break;  		}  	}  	// ================ Parsing an assignment  	else if (pm == PM_ASSIGNMENT) {  		// Check for string opening  		if (c == '\"') {  			// Now parsing string  			pm = PM_STRING;  		}  		// Check for numeric character  		else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			// Now parsing number  			pm = PM_NUMBER;  			// Go one byte back' because this  			// byte is part of the number!  			pos--;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Check if assignment ends  		else if (c == ';') {  			// End of assignment  			pm = PM_NOTHING;  			// Remove this if it causes problems  			key = "";  			val = "";  		}  		// Otherwise (if not whitespace) it will be a keyword  		else if ((c != ' ') && (c != '\t')) {  			// Now parsing a keyword  			pm = PM_KEYWORD;  			// Go one byte back' because this  			// byte is part of the keyword!  			pos--;  		}  	}  	// ================ Parsing a number  	else if (pm == PM_NUMBER) {  		// Check if number ends here  		if (c == ';') {  			// Hexadecimal?  			if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Floating point?  			else if (val.IndexOf (".") > -1) {  				float fval = 0;  				// Convert to float (remove the f first)  				try {  					fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' fval));  			}  			else {  				int ival = 0;  				long lval = 0;  				// Convert to int  				try {  					// Convert to value  					ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' ival));  				}  				catch (System.OverflowException) {  					// Too large for Int32' try Int64  					try {  						// Convert to value  						lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  						// Add it to struct  						cs.Add (new UniversalEntry (key.Trim ()' lval));  					}  					catch (System.OverflowException) {  						// Too large for Int64' return error  						RaiseError (line' ERROR_VALUETOOBIG);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			// Reset key and value  			key = "";  			val = "";  			// End of assignment  			pm = PM_NOTHING;  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is part of the value  		else {  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// ================ Parsing a string  	else if (pm == PM_STRING) {  		// Check if in an escape sequence  		if (escape) {  			// What character?  			switch (c) {  			case '\\':  				val += "\\";  				break;  			case 'n':  				val += "\n";  				break;  			case '\"':  				val += "\"";  				break;  			case 'r':  				val += "\r";  				break;  			case 't':  				val += "\t";  				break;  			default:  				// Is it a number?  				if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  					int vv = 0;  					char vc = '0';  					// Convert the next 3 characters to a number  					string v = data.Substring (pos' 3);  					try {  						vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Convert the number to a char  					try {  						vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  					}  					catch (System.FormatException) {  						// ERROR: Invalid value in assignment  						RaiseError (line' ERROR_VALUEINVALID);  					}  					// Add the char  					val += vc.ToString (CultureInfo.InvariantCulture);  				}  				else {  					// Add the character as it is  					val += c.ToString (CultureInfo.InvariantCulture);  				}  				// Leave switch  				break;  			}  			// End of escape sequence  			escape = false;  		}  		else {  			// Check for sequence start  			if (c == '\\') {  				// Next character is of escape sequence  				escape = true;  			}  			// Check if string ends  			else if (c == '\"') {  				// Add string to struct  				cs.Add (new UniversalEntry (key.Trim ()' val));  				// End of assignment  				pm = PM_ASSIGNMENT;  				// Reset key and value  				key = "";  				val = "";  			}  			// Check for new line  			else if (c == '\n') {  				// Count the new line  				line++;  			}  			// Everything else is just part of string  			else {  				// Add to value  				val += c.ToString (CultureInfo.InvariantCulture);  			}  		}  	}  	// ================ Parsing a keyword  	else if (pm == PM_KEYWORD) {  		// Check if keyword ends  		if (c == ';') {  			// Add to the struct depending on the keyword  			switch (val.Trim ().ToLowerInvariant ()) {  			case "true":  				// Add boolean true  				cs.Add (new UniversalEntry (key.Trim ()' true));  				break;  			case "false":  				// Add boolean false  				cs.Add (new UniversalEntry (key.Trim ()' false));  				break;  			default:  				// Unknown keyword  				RaiseError (line' ERROR_KEYWORDUNKNOWN);  				break;  			}  			// End of assignment  			pm = PM_NOTHING;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of keyword  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  	// Next character  	pos++;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NOTHING) {  	// Now check what character this is  	switch (c) {  	case '{':  		// Begin of new struct  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Next character  			pos++;  			// Parse this struct and add it  			//[IB] oh dear' special handling for planemaps  			if (key.Trim () == "planemap")  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  			//[IB] oh well  			else  				cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  			// Check the last character  			pos--;  			// Reset the key  			key = "";  		}  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		endofstruct = true;  		// Leave the loop  		break;  	case '=':  		// Assignment  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Now parsing assignment  			pm = PM_ASSIGNMENT;  		}  		// Leave switch  		break;  	case ';':  		// Terminator  		// Validate key  		if (ValidateKey (key.Trim ()' line)) {  			// Error: No value  			RaiseError (line' ERROR_KEYWITHOUTVALUE);  		}  		// Leave switch  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  //[IB]Handle planemaps  else if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '{':  	// Begin of new struct  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Next character  		pos++;  		// Parse this struct and add it  		//[IB] oh dear' special handling for planemaps  		if (key.Trim () == "planemap")  			cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  		//[IB] oh well  		else  			cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  		// Check the last character  		pos--;  		// Reset the key  		key = "";  	}  	// Leave switch  	break;  case '}':  	// End of this struct  	// Stop parsing in this struct  	endofstruct = true;  	// Leave the loop  	break;  case '=':  	// Assignment  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Now parsing assignment  		pm = PM_ASSIGNMENT;  	}  	// Leave switch  	break;  case ';':  	// Terminator  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Error: No value  		RaiseError (line' ERROR_KEYWITHOUTVALUE);  	}  	// Leave switch  	break;  case '\n':  	// New line  	// Count the line  	line++;  	// Add this to the key as a space.  	// Spaces are not allowed' but it will be trimmed  	// when its the first or last character.  	key += " ";  	// Leave switch  	break;  case '\\':  // Possible comment  case '/':  	// Check for the line comment //  	if (data.Substring (pos' 2) == "//") {  		// Find the next line  		int np = data.IndexOf ("\n"' pos);  		// Next line found?  		if (np > -1) {  			// Count the line  			line++;  			// Skip everything on this line  			pos = np;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Check for the block comment /* */  	else if (data.Substring (pos' 2) == "/*") {  		// Find the next closing block comment  		int np = data.IndexOf ("*/"' pos);  		// Closing block comment found?  		if (np > -1) {  			// Count the lines in the block comment  			string blockdata = data.Substring (pos' np - pos + 2);  			line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  			// Skip everything in this block  			pos = np + 1;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Leave switch  	break;  default:  	// Everything else  	// Add character to key  	key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '{':  	// Begin of new struct  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Next character  		pos++;  		// Parse this struct and add it  		//[IB] oh dear' special handling for planemaps  		if (key.Trim () == "planemap")  			cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  		//[IB] oh well  		else  			cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  		// Check the last character  		pos--;  		// Reset the key  		key = "";  	}  	// Leave switch  	break;  case '}':  	// End of this struct  	// Stop parsing in this struct  	endofstruct = true;  	// Leave the loop  	break;  case '=':  	// Assignment  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Now parsing assignment  		pm = PM_ASSIGNMENT;  	}  	// Leave switch  	break;  case ';':  	// Terminator  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Error: No value  		RaiseError (line' ERROR_KEYWITHOUTVALUE);  	}  	// Leave switch  	break;  case '\n':  	// New line  	// Count the line  	line++;  	// Add this to the key as a space.  	// Spaces are not allowed' but it will be trimmed  	// when its the first or last character.  	key += " ";  	// Leave switch  	break;  case '\\':  // Possible comment  case '/':  	// Check for the line comment //  	if (data.Substring (pos' 2) == "//") {  		// Find the next line  		int np = data.IndexOf ("\n"' pos);  		// Next line found?  		if (np > -1) {  			// Count the line  			line++;  			// Skip everything on this line  			pos = np;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Check for the block comment /* */  	else if (data.Substring (pos' 2) == "/*") {  		// Find the next closing block comment  		int np = data.IndexOf ("*/"' pos);  		// Closing block comment found?  		if (np > -1) {  			// Count the lines in the block comment  			string blockdata = data.Substring (pos' np - pos + 2);  			line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  			// Skip everything in this block  			pos = np + 1;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Leave switch  	break;  default:  	// Everything else  	// Add character to key  	key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '{':  	// Begin of new struct  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Next character  		pos++;  		// Parse this struct and add it  		//[IB] oh dear' special handling for planemaps  		if (key.Trim () == "planemap")  			cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line' true)));  		//[IB] oh well  		else  			cs.Add (new UniversalEntry (key.Trim ()' InputStructure (ref data' ref pos' ref line)));  		// Check the last character  		pos--;  		// Reset the key  		key = "";  	}  	// Leave switch  	break;  case '}':  	// End of this struct  	// Stop parsing in this struct  	endofstruct = true;  	// Leave the loop  	break;  case '=':  	// Assignment  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Now parsing assignment  		pm = PM_ASSIGNMENT;  	}  	// Leave switch  	break;  case ';':  	// Terminator  	// Validate key  	if (ValidateKey (key.Trim ()' line)) {  		// Error: No value  		RaiseError (line' ERROR_KEYWITHOUTVALUE);  	}  	// Leave switch  	break;  case '\n':  	// New line  	// Count the line  	line++;  	// Add this to the key as a space.  	// Spaces are not allowed' but it will be trimmed  	// when its the first or last character.  	key += " ";  	// Leave switch  	break;  case '\\':  // Possible comment  case '/':  	// Check for the line comment //  	if (data.Substring (pos' 2) == "//") {  		// Find the next line  		int np = data.IndexOf ("\n"' pos);  		// Next line found?  		if (np > -1) {  			// Count the line  			line++;  			// Skip everything on this line  			pos = np;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Check for the block comment /* */  	else if (data.Substring (pos' 2) == "/*") {  		// Find the next closing block comment  		int np = data.IndexOf ("*/"' pos);  		// Closing block comment found?  		if (np > -1) {  			// Count the lines in the block comment  			string blockdata = data.Substring (pos' np - pos + 2);  			line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  			// Skip everything in this block  			pos = np + 1;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Leave switch  	break;  default:  	// Everything else  	// Add character to key  	key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "//") {  	// Find the next line  	int np = data.IndexOf ("\n"' pos);  	// Next line found?  	if (np > -1) {  		// Count the line  		line++;  		// Skip everything on this line  		pos = np;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  // Check for the block comment /* */  else if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "//") {  	// Find the next line  	int np = data.IndexOf ("\n"' pos);  	// Next line found?  	if (np > -1) {  		// Count the line  		line++;  		// Skip everything on this line  		pos = np;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  // Check for the block comment /* */  else if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "//") {  	// Find the next line  	int np = data.IndexOf ("\n"' pos);  	// Next line found?  	if (np > -1) {  		// Count the line  		line++;  		// Skip everything on this line  		pos = np;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  // Check for the block comment /* */  else if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (np > -1) {  	// Count the lines in the block comment  	string blockdata = data.Substring (pos' np - pos + 2);  	line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  	// Skip everything in this block  	pos = np + 1;  }  else {  	// No end of line  	// Skip everything else  	pos = data.Length;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_PLANEMAPS) {  	// Now check what character this is  	switch (c) {  	case '{':  		// beginning of a planemap cell  		int tag = 0;  		pos++;  		planephase++;  		terminateWhitespace (ref data' ref pos' ref line);  		int til = (int)GetNumber (ref data' ref pos' ref line);  		//Console.Write("tile: " + til.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int sec = (int)GetNumber (ref data' ref pos' ref line);  		//Console.WriteLine(" sec: " + sec.ToString());  		c = data [pos];  		pos++;  		if (c != ''') {  			RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  			break;  		}  		terminateWhitespace (ref data' ref pos' ref line);  		int zone = (int)GetNumber (ref data' ref pos' ref line);  		c = data [pos];  		pos++;  		//handle optional tag  		if (c == ''') {  			terminateWhitespace (ref data' ref pos' ref line);  			tag = (int)GetNumber (ref data' ref pos' ref line);  			terminateWhitespace (ref data' ref pos' ref line);  			c = data [pos];  			Console.WriteLine ("tag {0}"' tag);  		}  		if (c != '}') {  			RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  			break;  		}  		eced.NumberCell cell = new eced.NumberCell ();  		cell.tile = til;  		cell.sector = sec;  		cell.zone = zone;  		cell.tag = tag;  		cells.Add (cell);  		planephase = 0;  		// Leave switch  		break;  	case ''':  		planephase = 1;  		// Leave switch  		break;  	case '}':  		// End of this struct  		// Stop parsing in this struct  		if (planephase == 0) {  			endofstruct = true;  			cs.Add (new UniversalEntry ("planedata"' cells));  		}  		else  			planephase = 0;  		// Leave the loop  		break;  	case '\n':  		// New line  		// Count the line  		line++;  		// Add this to the key as a space.  		// Spaces are not allowed' but it will be trimmed  		// when its the first or last character.  		key += " ";  		// Leave switch  		break;  	case '\\':  	// Possible comment  	case '/':  		// Check for the line comment //  		if (data.Substring (pos' 2) == "//") {  			// Find the next line  			int np = data.IndexOf ("\n"' pos);  			// Next line found?  			if (np > -1) {  				// Count the line  				line++;  				// Skip everything on this line  				pos = np;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Check for the block comment /* */  		else if (data.Substring (pos' 2) == "/*") {  			// Find the next closing block comment  			int np = data.IndexOf ("*/"' pos);  			// Closing block comment found?  			if (np > -1) {  				// Count the lines in the block comment  				string blockdata = data.Substring (pos' np - pos + 2);  				line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  				// Skip everything in this block  				pos = np + 1;  			}  			else {  				// No end of line  				// Skip everything else  				pos = data.Length;  			}  		}  		// Leave switch  		break;  	default:  		// Everything else  		// Add character to key  		key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  		// Leave switch  		break;  	}  }  // ================ Parsing an assignment  else if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '{':  	// beginning of a planemap cell  	int tag = 0;  	pos++;  	planephase++;  	terminateWhitespace (ref data' ref pos' ref line);  	int til = (int)GetNumber (ref data' ref pos' ref line);  	//Console.Write("tile: " + til.ToString());  	c = data [pos];  	pos++;  	if (c != ''') {  		RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  		break;  	}  	terminateWhitespace (ref data' ref pos' ref line);  	int sec = (int)GetNumber (ref data' ref pos' ref line);  	//Console.WriteLine(" sec: " + sec.ToString());  	c = data [pos];  	pos++;  	if (c != ''') {  		RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  		break;  	}  	terminateWhitespace (ref data' ref pos' ref line);  	int zone = (int)GetNumber (ref data' ref pos' ref line);  	c = data [pos];  	pos++;  	//handle optional tag  	if (c == ''') {  		terminateWhitespace (ref data' ref pos' ref line);  		tag = (int)GetNumber (ref data' ref pos' ref line);  		terminateWhitespace (ref data' ref pos' ref line);  		c = data [pos];  		Console.WriteLine ("tag {0}"' tag);  	}  	if (c != '}') {  		RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  		break;  	}  	eced.NumberCell cell = new eced.NumberCell ();  	cell.tile = til;  	cell.sector = sec;  	cell.zone = zone;  	cell.tag = tag;  	cells.Add (cell);  	planephase = 0;  	// Leave switch  	break;  case ''':  	planephase = 1;  	// Leave switch  	break;  case '}':  	// End of this struct  	// Stop parsing in this struct  	if (planephase == 0) {  		endofstruct = true;  		cs.Add (new UniversalEntry ("planedata"' cells));  	}  	else  		planephase = 0;  	// Leave the loop  	break;  case '\n':  	// New line  	// Count the line  	line++;  	// Add this to the key as a space.  	// Spaces are not allowed' but it will be trimmed  	// when its the first or last character.  	key += " ";  	// Leave switch  	break;  case '\\':  // Possible comment  case '/':  	// Check for the line comment //  	if (data.Substring (pos' 2) == "//") {  		// Find the next line  		int np = data.IndexOf ("\n"' pos);  		// Next line found?  		if (np > -1) {  			// Count the line  			line++;  			// Skip everything on this line  			pos = np;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Check for the block comment /* */  	else if (data.Substring (pos' 2) == "/*") {  		// Find the next closing block comment  		int np = data.IndexOf ("*/"' pos);  		// Closing block comment found?  		if (np > -1) {  			// Count the lines in the block comment  			string blockdata = data.Substring (pos' np - pos + 2);  			line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  			// Skip everything in this block  			pos = np + 1;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Leave switch  	break;  default:  	// Everything else  	// Add character to key  	key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '{':  	// beginning of a planemap cell  	int tag = 0;  	pos++;  	planephase++;  	terminateWhitespace (ref data' ref pos' ref line);  	int til = (int)GetNumber (ref data' ref pos' ref line);  	//Console.Write("tile: " + til.ToString());  	c = data [pos];  	pos++;  	if (c != ''') {  		RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  		break;  	}  	terminateWhitespace (ref data' ref pos' ref line);  	int sec = (int)GetNumber (ref data' ref pos' ref line);  	//Console.WriteLine(" sec: " + sec.ToString());  	c = data [pos];  	pos++;  	if (c != ''') {  		RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  		break;  	}  	terminateWhitespace (ref data' ref pos' ref line);  	int zone = (int)GetNumber (ref data' ref pos' ref line);  	c = data [pos];  	pos++;  	//handle optional tag  	if (c == ''') {  		terminateWhitespace (ref data' ref pos' ref line);  		tag = (int)GetNumber (ref data' ref pos' ref line);  		terminateWhitespace (ref data' ref pos' ref line);  		c = data [pos];  		Console.WriteLine ("tag {0}"' tag);  	}  	if (c != '}') {  		RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  		break;  	}  	eced.NumberCell cell = new eced.NumberCell ();  	cell.tile = til;  	cell.sector = sec;  	cell.zone = zone;  	cell.tag = tag;  	cells.Add (cell);  	planephase = 0;  	// Leave switch  	break;  case ''':  	planephase = 1;  	// Leave switch  	break;  case '}':  	// End of this struct  	// Stop parsing in this struct  	if (planephase == 0) {  		endofstruct = true;  		cs.Add (new UniversalEntry ("planedata"' cells));  	}  	else  		planephase = 0;  	// Leave the loop  	break;  case '\n':  	// New line  	// Count the line  	line++;  	// Add this to the key as a space.  	// Spaces are not allowed' but it will be trimmed  	// when its the first or last character.  	key += " ";  	// Leave switch  	break;  case '\\':  // Possible comment  case '/':  	// Check for the line comment //  	if (data.Substring (pos' 2) == "//") {  		// Find the next line  		int np = data.IndexOf ("\n"' pos);  		// Next line found?  		if (np > -1) {  			// Count the line  			line++;  			// Skip everything on this line  			pos = np;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Check for the block comment /* */  	else if (data.Substring (pos' 2) == "/*") {  		// Find the next closing block comment  		int np = data.IndexOf ("*/"' pos);  		// Closing block comment found?  		if (np > -1) {  			// Count the lines in the block comment  			string blockdata = data.Substring (pos' np - pos + 2);  			line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  			// Skip everything in this block  			pos = np + 1;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Leave switch  	break;  default:  	// Everything else  	// Add character to key  	key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '{':  	// beginning of a planemap cell  	int tag = 0;  	pos++;  	planephase++;  	terminateWhitespace (ref data' ref pos' ref line);  	int til = (int)GetNumber (ref data' ref pos' ref line);  	//Console.Write("tile: " + til.ToString());  	c = data [pos];  	pos++;  	if (c != ''') {  		RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  		break;  	}  	terminateWhitespace (ref data' ref pos' ref line);  	int sec = (int)GetNumber (ref data' ref pos' ref line);  	//Console.WriteLine(" sec: " + sec.ToString());  	c = data [pos];  	pos++;  	if (c != ''') {  		RaiseError (line' String.Format ("It blew up: expected second \''\'' got {0}!"' c));  		break;  	}  	terminateWhitespace (ref data' ref pos' ref line);  	int zone = (int)GetNumber (ref data' ref pos' ref line);  	c = data [pos];  	pos++;  	//handle optional tag  	if (c == ''') {  		terminateWhitespace (ref data' ref pos' ref line);  		tag = (int)GetNumber (ref data' ref pos' ref line);  		terminateWhitespace (ref data' ref pos' ref line);  		c = data [pos];  		Console.WriteLine ("tag {0}"' tag);  	}  	if (c != '}') {  		RaiseError (line' String.Format ("It blew up: expected \'closing brace\'' got {0}!"' c));  		break;  	}  	eced.NumberCell cell = new eced.NumberCell ();  	cell.tile = til;  	cell.sector = sec;  	cell.zone = zone;  	cell.tag = tag;  	cells.Add (cell);  	planephase = 0;  	// Leave switch  	break;  case ''':  	planephase = 1;  	// Leave switch  	break;  case '}':  	// End of this struct  	// Stop parsing in this struct  	if (planephase == 0) {  		endofstruct = true;  		cs.Add (new UniversalEntry ("planedata"' cells));  	}  	else  		planephase = 0;  	// Leave the loop  	break;  case '\n':  	// New line  	// Count the line  	line++;  	// Add this to the key as a space.  	// Spaces are not allowed' but it will be trimmed  	// when its the first or last character.  	key += " ";  	// Leave switch  	break;  case '\\':  // Possible comment  case '/':  	// Check for the line comment //  	if (data.Substring (pos' 2) == "//") {  		// Find the next line  		int np = data.IndexOf ("\n"' pos);  		// Next line found?  		if (np > -1) {  			// Count the line  			line++;  			// Skip everything on this line  			pos = np;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Check for the block comment /* */  	else if (data.Substring (pos' 2) == "/*") {  		// Find the next closing block comment  		int np = data.IndexOf ("*/"' pos);  		// Closing block comment found?  		if (np > -1) {  			// Count the lines in the block comment  			string blockdata = data.Substring (pos' np - pos + 2);  			line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  			// Skip everything in this block  			pos = np + 1;  		}  		else {  			// No end of line  			// Skip everything else  			pos = data.Length;  		}  	}  	// Leave switch  	break;  default:  	// Everything else  	// Add character to key  	key += c.ToString (CultureInfo.InvariantCulture).ToLowerInvariant ();  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "//") {  	// Find the next line  	int np = data.IndexOf ("\n"' pos);  	// Next line found?  	if (np > -1) {  		// Count the line  		line++;  		// Skip everything on this line  		pos = np;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  // Check for the block comment /* */  else if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "//") {  	// Find the next line  	int np = data.IndexOf ("\n"' pos);  	// Next line found?  	if (np > -1) {  		// Count the line  		line++;  		// Skip everything on this line  		pos = np;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  // Check for the block comment /* */  else if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "//") {  	// Find the next line  	int np = data.IndexOf ("\n"' pos);  	// Next line found?  	if (np > -1) {  		// Count the line  		line++;  		// Skip everything on this line  		pos = np;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  // Check for the block comment /* */  else if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (data.Substring (pos' 2) == "/*") {  	// Find the next closing block comment  	int np = data.IndexOf ("*/"' pos);  	// Closing block comment found?  	if (np > -1) {  		// Count the lines in the block comment  		string blockdata = data.Substring (pos' np - pos + 2);  		line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  		// Skip everything in this block  		pos = np + 1;  	}  	else {  		// No end of line  		// Skip everything else  		pos = data.Length;  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (np > -1) {  	// Count the lines in the block comment  	string blockdata = data.Substring (pos' np - pos + 2);  	line += (blockdata.Split ("\n".ToCharArray ()).Length - 1);  	// Skip everything in this block  	pos = np + 1;  }  else {  	// No end of line  	// Skip everything else  	pos = data.Length;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_ASSIGNMENT) {  	// Check for string opening  	if (c == '\"') {  		// Now parsing string  		pm = PM_STRING;  	}  	// Check for numeric character  	else if ("0123456789-.&".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		// Now parsing number  		pm = PM_NUMBER;  		// Go one byte back' because this  		// byte is part of the number!  		pos--;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Check if assignment ends  	else if (c == ';') {  		// End of assignment  		pm = PM_NOTHING;  		// Remove this if it causes problems  		key = "";  		val = "";  	}  	// Otherwise (if not whitespace) it will be a keyword  	else if ((c != ' ') && (c != '\t')) {  		// Now parsing a keyword  		pm = PM_KEYWORD;  		// Go one byte back' because this  		// byte is part of the keyword!  		pos--;  	}  }  // ================ Parsing a number  else if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_NUMBER) {  	// Check if number ends here  	if (c == ';') {  		// Hexadecimal?  		if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Floating point?  		else if (val.IndexOf (".") > -1) {  			float fval = 0;  			// Convert to float (remove the f first)  			try {  				fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' fval));  		}  		else {  			int ival = 0;  			long lval = 0;  			// Convert to int  			try {  				// Convert to value  				ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' ival));  			}  			catch (System.OverflowException) {  				// Too large for Int32' try Int64  				try {  					// Convert to value  					lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  					// Add it to struct  					cs.Add (new UniversalEntry (key.Trim ()' lval));  				}  				catch (System.OverflowException) {  					// Too large for Int64' return error  					RaiseError (line' ERROR_VALUETOOBIG);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		// Reset key and value  		key = "";  		val = "";  		// End of assignment  		pm = PM_NOTHING;  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is part of the value  	else {  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  // ================ Parsing a string  else if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (c == ';') {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Floating point?  	else if (val.IndexOf (".") > -1) {  		float fval = 0;  		// Convert to float (remove the f first)  		try {  			fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' fval));  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (c == ';') {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Floating point?  	else if (val.IndexOf (".") > -1) {  		float fval = 0;  		// Convert to float (remove the f first)  		try {  			fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' fval));  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (c == ';') {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Floating point?  	else if (val.IndexOf (".") > -1) {  		float fval = 0;  		// Convert to float (remove the f first)  		try {  			fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' fval));  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (c == ';') {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Floating point?  	else if (val.IndexOf (".") > -1) {  		float fval = 0;  		// Convert to float (remove the f first)  		try {  			fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' fval));  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (c == ';') {  	// Hexadecimal?  	if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Floating point?  	else if (val.IndexOf (".") > -1) {  		float fval = 0;  		// Convert to float (remove the f first)  		try {  			fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' fval));  	}  	else {  		int ival = 0;  		long lval = 0;  		// Convert to int  		try {  			// Convert to value  			ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' ival));  		}  		catch (System.OverflowException) {  			// Too large for Int32' try Int64  			try {  				// Convert to value  				lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  				// Add it to struct  				cs.Add (new UniversalEntry (key.Trim ()' lval));  			}  			catch (System.OverflowException) {  				// Too large for Int64' return error  				RaiseError (line' ERROR_VALUETOOBIG);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	// Reset key and value  	key = "";  	val = "";  	// End of assignment  	pm = PM_NOTHING;  }  // Check for new line  else if (c == '\n') {  	// Count the new line  	line++;  }  // Everything else is part of the value  else {  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  // Floating point?  else if (val.IndexOf (".") > -1) {  	float fval = 0;  	// Convert to float (remove the f first)  	try {  		fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' fval));  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  // Floating point?  else if (val.IndexOf (".") > -1) {  	float fval = 0;  	// Convert to float (remove the f first)  	try {  		fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' fval));  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  // Floating point?  else if (val.IndexOf (".") > -1) {  	float fval = 0;  	// Convert to float (remove the f first)  	try {  		fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' fval));  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  // Floating point?  else if (val.IndexOf (".") > -1) {  	float fval = 0;  	// Convert to float (remove the f first)  	try {  		fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' fval));  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if ((val.Length > 2) && val.StartsWith ("0x"' StringComparison.InvariantCultureIgnoreCase)) {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  // Floating point?  else if (val.IndexOf (".") > -1) {  	float fval = 0;  	// Convert to float (remove the f first)  	try {  		fval = System.Convert.ToSingle (val.Trim ()' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' fval));  }  else {  	int ival = 0;  	long lval = 0;  	// Convert to int  	try {  		// Convert to value  		ival = System.Convert.ToInt32 (val.Trim ()' CultureInfo.InvariantCulture);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' ival));  	}  	catch (System.OverflowException) {  		// Too large for Int32' try Int64  		try {  			// Convert to value  			lval = System.Convert.ToInt64 (val.Trim ()' CultureInfo.InvariantCulture);  			// Add it to struct  			cs.Add (new UniversalEntry (key.Trim ()' lval));  		}  		catch (System.OverflowException) {  			// Too large for Int64' return error  			RaiseError (line' ERROR_VALUETOOBIG);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' ival));  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' lval));  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' ival));  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' lval));  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' ival));  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' lval));  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: try {  	// Convert to value  	ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' ival));  }  catch (System.OverflowException) {  	// Too large for Int32' try Int64  	try {  		// Convert to value  		lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  		// Add it to struct  		cs.Add (new UniversalEntry (key.Trim ()' lval));  	}  	catch (System.OverflowException) {  		// Too large for Int64' return error  		RaiseError (line' ERROR_VALUETOOBIG);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: ival = System.Convert.ToInt32 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: try {  	// Convert to value  	lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' lval));  }  catch (System.OverflowException) {  	// Too large for Int64' return error  	RaiseError (line' ERROR_VALUETOOBIG);  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: try {  	// Convert to value  	lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  	// Add it to struct  	cs.Add (new UniversalEntry (key.Trim ()' lval));  }  catch (System.OverflowException) {  	// Too large for Int64' return error  	RaiseError (line' ERROR_VALUETOOBIG);  }  catch (System.FormatException) {  	// ERROR: Invalid value in assignment  	RaiseError (line' ERROR_VALUEINVALID);  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: lval = System.Convert.ToInt64 (val.Substring (2).Trim ()' 16);  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (pm == PM_STRING) {  	// Check if in an escape sequence  	if (escape) {  		// What character?  		switch (c) {  		case '\\':  			val += "\\";  			break;  		case 'n':  			val += "\n";  			break;  		case '\"':  			val += "\"";  			break;  		case 'r':  			val += "\r";  			break;  		case 't':  			val += "\t";  			break;  		default:  			// Is it a number?  			if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  				int vv = 0;  				char vc = '0';  				// Convert the next 3 characters to a number  				string v = data.Substring (pos' 3);  				try {  					vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Convert the number to a char  				try {  					vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  				}  				catch (System.FormatException) {  					// ERROR: Invalid value in assignment  					RaiseError (line' ERROR_VALUEINVALID);  				}  				// Add the char  				val += vc.ToString (CultureInfo.InvariantCulture);  			}  			else {  				// Add the character as it is  				val += c.ToString (CultureInfo.InvariantCulture);  			}  			// Leave switch  			break;  		}  		// End of escape sequence  		escape = false;  	}  	else {  		// Check for sequence start  		if (c == '\\') {  			// Next character is of escape sequence  			escape = true;  		}  		// Check if string ends  		else if (c == '\"') {  			// Add string to struct  			cs.Add (new UniversalEntry (key.Trim ()' val));  			// End of assignment  			pm = PM_ASSIGNMENT;  			// Reset key and value  			key = "";  			val = "";  		}  		// Check for new line  		else if (c == '\n') {  			// Count the new line  			line++;  		}  		// Everything else is just part of string  		else {  			// Add to value  			val += c.ToString (CultureInfo.InvariantCulture);  		}  	}  }  // ================ Parsing a keyword  else if (pm == PM_KEYWORD) {  	// Check if keyword ends  	if (c == ';') {  		// Add to the struct depending on the keyword  		switch (val.Trim ().ToLowerInvariant ()) {  		case "true":  			// Add boolean true  			cs.Add (new UniversalEntry (key.Trim ()' true));  			break;  		case "false":  			// Add boolean false  			cs.Add (new UniversalEntry (key.Trim ()' false));  			break;  		default:  			// Unknown keyword  			RaiseError (line' ERROR_KEYWORDUNKNOWN);  			break;  		}  		// End of assignment  		pm = PM_NOTHING;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of keyword  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if (escape) {  	// What character?  	switch (c) {  	case '\\':  		val += "\\";  		break;  	case 'n':  		val += "\n";  		break;  	case '\"':  		val += "\"";  		break;  	case 'r':  		val += "\r";  		break;  	case 't':  		val += "\t";  		break;  	default:  		// Is it a number?  		if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  			int vv = 0;  			char vc = '0';  			// Convert the next 3 characters to a number  			string v = data.Substring (pos' 3);  			try {  				vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Convert the number to a char  			try {  				vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  			}  			catch (System.FormatException) {  				// ERROR: Invalid value in assignment  				RaiseError (line' ERROR_VALUEINVALID);  			}  			// Add the char  			val += vc.ToString (CultureInfo.InvariantCulture);  		}  		else {  			// Add the character as it is  			val += c.ToString (CultureInfo.InvariantCulture);  		}  		// Leave switch  		break;  	}  	// End of escape sequence  	escape = false;  }  else {  	// Check for sequence start  	if (c == '\\') {  		// Next character is of escape sequence  		escape = true;  	}  	// Check if string ends  	else if (c == '\"') {  		// Add string to struct  		cs.Add (new UniversalEntry (key.Trim ()' val));  		// End of assignment  		pm = PM_ASSIGNMENT;  		// Reset key and value  		key = "";  		val = "";  	}  	// Check for new line  	else if (c == '\n') {  		// Count the new line  		line++;  	}  	// Everything else is just part of string  	else {  		// Add to value  		val += c.ToString (CultureInfo.InvariantCulture);  	}  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: switch (c) {  case '\\':  	val += "\\";  	break;  case 'n':  	val += "\n";  	break;  case '\"':  	val += "\"";  	break;  case 'r':  	val += "\r";  	break;  case 't':  	val += "\t";  	break;  default:  	// Is it a number?  	if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  		int vv = 0;  		char vc = '0';  		// Convert the next 3 characters to a number  		string v = data.Substring (pos' 3);  		try {  			vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Convert the number to a char  		try {  			vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  		}  		catch (System.FormatException) {  			// ERROR: Invalid value in assignment  			RaiseError (line' ERROR_VALUEINVALID);  		}  		// Add the char  		val += vc.ToString (CultureInfo.InvariantCulture);  	}  	else {  		// Add the character as it is  		val += c.ToString (CultureInfo.InvariantCulture);  	}  	// Leave switch  	break;  }  
Magic Number,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The following statement contains a magic number: if ("0123456789".IndexOf (c.ToString (CultureInfo.InvariantCulture)) > -1) {  	int vv = 0;  	char vc = '0';  	// Convert the next 3 characters to a number  	string v = data.Substring (pos' 3);  	try {  		vv = System.Convert.ToInt32 (v.Trim ()' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Convert the number to a char  	try {  		vc = System.Convert.ToChar (vv' CultureInfo.InvariantCulture);  	}  	catch (System.FormatException) {  		// ERROR: Invalid value in assignment  		RaiseError (line' ERROR_VALUEINVALID);  	}  	// Add the char  	val += vc.ToString (CultureInfo.InvariantCulture);  }  else {  	// Add the character as it is  	val += c.ToString (CultureInfo.InvariantCulture);  }  
Magic Number,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,CreateHeaders,The following statement contains a magic number: lumpsoffset = 12;  
Magic Number,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,ReadHeaders,The following statement contains a magic number: type = ENCODING.GetString (reader.ReadBytes (4));  
Magic Number,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,ReadHeaders,The following statement contains a magic number: for (int i = 0; i < numlumps; i++) {  	// Read lump information  	offset = reader.ReadInt32 ();  	length = reader.ReadInt32 ();  	fixedname = reader.ReadBytes (8);  	// Create the lump  	lumps.Add (new Lump (file' this' fixedname' offset' length));  }  
Magic Number,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,ReadHeaders,The following statement contains a magic number: fixedname = reader.ReadBytes (8);  
Magic Number,CodeImp.DoomBuilder.IO,WAD,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\WAD.cs,Insert,The following statement contains a magic number: file.SetLength (file.Length + datalength + 16);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,loadResourceFile,The following statement contains a magic number: for (int i = 0; i < lumps; i++) {  	int ptr = br.ReadInt32 ();  	int size = br.ReadInt32 ();  	string name = new String (br.ReadChars (8));  	string fullname = name;  	ResourceNamespace ns = ResourceNamespace.NS_GENERIC;  	//eat null bytes for convenience  	name = name.Trim ('\0'' ' ');  	//maybe this will work  	fullname = fullname.Trim ('\0');  	//try to cut off null bytes at end of fullname  	if (name == "TX_START" || name == "S_START") {  		wad.saveToDirectory = "TEXTURES";  	}  	else if (name == "TX_END" || name == "S_END") {  		//no more saving to textures dir  		wad.saveToDirectory = "-";  	}  	else if (wad.saveToDirectory == "TEXTURES") {  		fullname = wad.saveToDirectory + "/" + name;  		ns = ResourceNamespace.NS_TEXTURE;  	}  	ResourceFile lump = new ResourceFile (name' ResourceType.RES_GENERIC' size);  	lump.fullname = fullname;  	lump.pointer = ptr;  	lump.ns = ns;  	lump.size = size;  	wad.lumps.Add (lump);  	Console.WriteLine ("{0}' {1} {2}"' lump.fullname' lump.pointer' lump.size);  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,findSpecialMapLumps,The following statement contains a magic number: if (lastelement != -1) {  	for (int li = firstelement + 2; li < lastelement; li++) {  		//just add the index to the list  		foundlumps.Add (li);  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,findSpecialMapLumps,The following statement contains a magic number: for (int li = firstelement + 2; li < lastelement; li++) {  	//just add the index to the list  	foundlumps.Add (li);  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,findAllMapNames,The following statement contains a magic number: for (int i = 0; i < lumps.Count - 2; i++) {  	//Check each luimp if a TEXTMAP follows it  	string checkmap = lumps [i].name;  	string nextlump = lumps [i + 1].name;  	if (nextlump.Equals ("TEXTMAP"' StringComparison.OrdinalIgnoreCase)) {  		maplumps.Add (checkmap);  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: block [2] = (byte)'A';  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: block [3] = (byte)'D';  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' 4' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' 4' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: BinaryHelper.getBytes (12' ref intblock);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' 8' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' 8' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: if (update) {  	foreach (ResourceFile lump in lumps) {  		//copy the data into the data block  		streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  		byte[] lumpdata = streamreader.ReadBytes (lump.size);  		if (lumpdata.Length != lump.size) {  			//TODO: Report error more formally  			Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  		}  		Array.Copy (lumpdata' 0' block' dataptr' lump.size);  		BinaryHelper.getBytes (dataptr' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		BinaryHelper.getBytes (lump.size' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		byte[] name = Encoding.ASCII.GetBytes (lump.name);  		Array.Copy (name' 0' block' ptr' name.Length);  		ptr += 8;  		dataptr += lump.size;  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: if (update) {  	foreach (ResourceFile lump in lumps) {  		//copy the data into the data block  		streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  		byte[] lumpdata = streamreader.ReadBytes (lump.size);  		if (lumpdata.Length != lump.size) {  			//TODO: Report error more formally  			Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  		}  		Array.Copy (lumpdata' 0' block' dataptr' lump.size);  		BinaryHelper.getBytes (dataptr' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		BinaryHelper.getBytes (lump.size' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		byte[] name = Encoding.ASCII.GetBytes (lump.name);  		Array.Copy (name' 0' block' ptr' name.Length);  		ptr += 8;  		dataptr += lump.size;  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: if (update) {  	foreach (ResourceFile lump in lumps) {  		//copy the data into the data block  		streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  		byte[] lumpdata = streamreader.ReadBytes (lump.size);  		if (lumpdata.Length != lump.size) {  			//TODO: Report error more formally  			Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  		}  		Array.Copy (lumpdata' 0' block' dataptr' lump.size);  		BinaryHelper.getBytes (dataptr' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		BinaryHelper.getBytes (lump.size' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		byte[] name = Encoding.ASCII.GetBytes (lump.name);  		Array.Copy (name' 0' block' ptr' name.Length);  		ptr += 8;  		dataptr += lump.size;  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: if (update) {  	foreach (ResourceFile lump in lumps) {  		//copy the data into the data block  		streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  		byte[] lumpdata = streamreader.ReadBytes (lump.size);  		if (lumpdata.Length != lump.size) {  			//TODO: Report error more formally  			Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  		}  		Array.Copy (lumpdata' 0' block' dataptr' lump.size);  		BinaryHelper.getBytes (dataptr' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		BinaryHelper.getBytes (lump.size' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		byte[] name = Encoding.ASCII.GetBytes (lump.name);  		Array.Copy (name' 0' block' ptr' name.Length);  		ptr += 8;  		dataptr += lump.size;  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: if (update) {  	foreach (ResourceFile lump in lumps) {  		//copy the data into the data block  		streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  		byte[] lumpdata = streamreader.ReadBytes (lump.size);  		if (lumpdata.Length != lump.size) {  			//TODO: Report error more formally  			Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  		}  		Array.Copy (lumpdata' 0' block' dataptr' lump.size);  		BinaryHelper.getBytes (dataptr' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		BinaryHelper.getBytes (lump.size' ref intblock);  		Array.Copy (intblock' 0' block' ptr' 4);  		ptr += 4;  		byte[] name = Encoding.ASCII.GetBytes (lump.name);  		Array.Copy (name' 0' block' ptr' name.Length);  		ptr += 8;  		dataptr += lump.size;  	}  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in lumps) {  	//copy the data into the data block  	streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  	byte[] lumpdata = streamreader.ReadBytes (lump.size);  	if (lumpdata.Length != lump.size) {  		//TODO: Report error more formally  		Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  	}  	Array.Copy (lumpdata' 0' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in lumps) {  	//copy the data into the data block  	streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  	byte[] lumpdata = streamreader.ReadBytes (lump.size);  	if (lumpdata.Length != lump.size) {  		//TODO: Report error more formally  		Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  	}  	Array.Copy (lumpdata' 0' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in lumps) {  	//copy the data into the data block  	streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  	byte[] lumpdata = streamreader.ReadBytes (lump.size);  	if (lumpdata.Length != lump.size) {  		//TODO: Report error more formally  		Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  	}  	Array.Copy (lumpdata' 0' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in lumps) {  	//copy the data into the data block  	streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  	byte[] lumpdata = streamreader.ReadBytes (lump.size);  	if (lumpdata.Length != lump.size) {  		//TODO: Report error more formally  		Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  	}  	Array.Copy (lumpdata' 0' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in lumps) {  	//copy the data into the data block  	streamreader.BaseStream.Seek ((long)lump.pointer' SeekOrigin.Begin);  	byte[] lumpdata = streamreader.ReadBytes (lump.size);  	if (lumpdata.Length != lump.size) {  		//TODO: Report error more formally  		Console.WriteLine ("ERROR: Loaded less bytes than expected reading lump {0}"' lump.name);  	}  	Array.Copy (lumpdata' 0' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' ptr' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: ptr += 4;  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' ptr' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: ptr += 4;  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: ptr += 8;  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in newLumps) {  	//copy the data into the data block  	Array.Copy (data' lump.pointer' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in newLumps) {  	//copy the data into the data block  	Array.Copy (data' lump.pointer' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in newLumps) {  	//copy the data into the data block  	Array.Copy (data' lump.pointer' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in newLumps) {  	//copy the data into the data block  	Array.Copy (data' lump.pointer' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: foreach (ResourceFile lump in newLumps) {  	//copy the data into the data block  	Array.Copy (data' lump.pointer' block' dataptr' lump.size);  	BinaryHelper.getBytes (dataptr' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	BinaryHelper.getBytes (lump.size' ref intblock);  	Array.Copy (intblock' 0' block' ptr' 4);  	ptr += 4;  	byte[] name = Encoding.ASCII.GetBytes (lump.name);  	Array.Copy (name' 0' block' ptr' name.Length);  	ptr += 8;  	dataptr += lump.size;  }  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' ptr' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: ptr += 4;  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: Array.Copy (intblock' 0' block' ptr' 4);  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: ptr += 4;  
Magic Number,eced.ResourceFiles,WADResourceFile,C:\repos\InsanityBringer_eced\eced\ResourceFiles\WADResourceFile.cs,updateToNewWad,The following statement contains a magic number: ptr += 8;  
Duplicate Code,CodeImp.DoomBuilder.IO,UniversalParser,C:\repos\InsanityBringer_eced\eced\CodeImp\DoomBuilder\IO\UniversalParser.cs,InputStructure,The method contains a code clone-set at the following line numbers (starting from the method definition): ((71' 129)' (196' 254))
Missing Default,eced,LevelIO,C:\repos\InsanityBringer_eced\eced\LevelIO.cs,makeNewLevel,The following switch statement is missing a default case: switch (entry.Key) {  case "tile":  	Console.WriteLine ("processing tile");  	Tile tile = Tile.Reconstruct ((UniversalCollection)entry.Value);  	level.addTile (tile);  	break;  case "sector":  	Console.WriteLine ("processing sector");  	Sector sector = Sector.Reconstruct ((UniversalCollection)entry.Value);  	//no sector management' heh  	break;  case "plane":  	Console.WriteLine ("processing plane");  	Plane plane = Plane.Reconstruct (level' (UniversalCollection)entry.Value);  	//no plane management' heh  	break;  case "zone":  	Console.WriteLine ("processing zone");  	level.addZone (new Zone ());  	break;  case "thing":  	Console.WriteLine ("processing thing");  	Thing thing = Thing.Reconstruct ((UniversalCollection)entry.Value);  	level.addThing (thing);  	break;  case "trigger":  	Console.WriteLine ("processing trigger");  	Trigger trigger = Trigger.Reconstruct ((UniversalCollection)entry.Value);  	level.addTrigger (trigger.x' trigger.y' trigger.z' trigger);  	break;  case "planemap":  	//special handling ahoy  	Console.WriteLine ("processing planemap");  	level.setTempPlaneMap ((List<NumberCell>)UWMFSearch.findElement ("planedata"' (UniversalCollection)entry.Value).Value);  	break;  }  
Missing Default,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,toolBar1_ButtonClick,The following switch statement is missing a default case: switch (toolid) {  case 1:  	this.defaultBrush = new Brush ();  	this.gbTileSelection.Visible = true;  	break;  case 2:  	this.defaultBrush = new TileBrush ();  	this.gbTileSelection.Visible = true;  	break;  case 4:  	this.defaultBrush = thingBrush;  	this.gbThingSelect.Visible = true;  	break;  case 5:  	this.defaultBrush = triggerBrush;  	this.gbTriggerData.Visible = true;  	break;  case 6:  	this.defaultBrush = sectorBrush;  	this.gbSectorPanel.Visible = true;  	break;  case 7:  	this.defaultBrush = zoneBrush;  	this.gbZoneList.Visible = true;  	break;  case 8:  	this.defaultBrush = tagBrush;  	this.gbTag.Visible = true;  	break;  }  
Missing Default,eced,Form1,C:\repos\InsanityBringer_eced\eced\Form1.cs,setMouseButton,The following switch statement is missing a default case: switch (e.Button) {  case MouseButtons.Left:  	this.heldMouseButton = 0;  	break;  case MouseButtons.Right:  	this.heldMouseButton = 1;  	break;  case MouseButtons.Middle:  	this.heldMouseButton = 2;  	break;  }  
Missing Default,eced,ThingDefinition,C:\repos\InsanityBringer_eced\eced\ThingDefinition.cs,setData,The following switch statement is missing a default case: switch (type) {  case "Unknown":  	r = 64;  	g = 64;  	b = 64;  	break;  case "Spawn":  	r = 0;  	g = 128;  	b = 0;  	break;  case "Internal":  	r = 128;  	g = 128;  	b = 128;  	break;  case "Enemy":  	r = 128;  	g = 0;  	b = 0;  	break;  case "Treasure":  	r = 128;  	g = 128;  	b = 0;  	break;  case "Powerup":  	r = 0;  	g = 128;  	b = 128;  	break;  }  
