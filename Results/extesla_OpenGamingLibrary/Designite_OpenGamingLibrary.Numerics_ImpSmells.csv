Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The method has 105 lines of code.
Long Method,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The method has 114 lines of code.
Complex Method,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,Cyclomatic complexity of the method is 15
Complex Method,OpenGamingLibrary.Numerics.Dividers,DividerBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\DividerBase.cs,DivMod,Cyclomatic complexity of the method is 12
Complex Method,OpenGamingLibrary.Numerics.Dividers,DividerBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\DividerBase.cs,DivMod,Cyclomatic complexity of the method is 16
Complex Method,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ConvertDoubleToDigits,Cyclomatic complexity of the method is 9
Complex Method,OpenGamingLibrary.Numerics.Parsers,ParserBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ParserBase.cs,Parse,Cyclomatic complexity of the method is 16
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,DividerBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\DividerBase.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,DividerBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\DividerBase.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,IDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\IDivider.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Dividers,IDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\IDivider.cs,DivMod,The method has 9 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Multipliers,AutoFhtMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\AutoFhtMultiplier.cs,Multiply,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Multipliers,ClassicMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\ClassicMultiplier.cs,Multiply,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Multipliers,IMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\IMultiplier.cs,Multiply,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Multipliers,IMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\IMultiplier.cs,Multiply,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Multipliers,MultiplierBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\MultiplierBase.cs,Multiply,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Multipliers,MultiplierBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\MultiplierBase.cs,Multiply,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Add,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Add,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Sub,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Sub,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,DivMod,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,DivMod,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Shr,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Shr,The method has 5 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,FhtButterfly,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFhtButterfly,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFhtButterfly2,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Parsers,ClassicParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ClassicParser.cs,Parse,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Parsers,FastParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\FastParser.cs,Parse,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Parsers,IParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\IParser.cs,Parse,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Parsers,ParserBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ParserBase.cs,Parse,The method has 6 parameters.
Long Parameter List,OpenGamingLibrary.Numerics.Parsers,Pow2Parser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\Pow2Parser.cs,Parse,The method has 6 parameters.
Long Statement,OpenGamingLibrary.Numerics.Converters,FastStringConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\FastStringConverter.cs,ToString,The length of the statement  "					*(ptr1 + innerStep) = divider.DivMod (ptr1' ptr2' ref loLength' baseIntPtr' tempBufferPtr' baseInt._length' ptr2 + innerStep' DivModResultFlags.Div | DivModResultFlags.Mod' -2); " is 177.
Long Statement,OpenGamingLibrary.Numerics.Converters,StringConverterBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\StringConverterBase.cs,ToString,The length of the statement  "	uint outputLength = (uint)System.Math.Ceiling (Constants.DigitBaseLog / System.Math.Log (numberBase) * BigInteger._length); " is 123.
Long Statement,OpenGamingLibrary.Numerics.Converters,StringConverterBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\StringConverterBase.cs,ToString,The length of the statement  "	return numberBase == 1U << Bits.Msb (numberBase) ? _pow2StringConverter.ToString (digits' length' numberBase' ref outputLength) : null; " is 135.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,IsClassicAlgorithmNeeded,The length of the statement  "	return length1 < Constants.AutoNewtonLengthLowerBound || length2 < Constants.AutoNewtonLengthLowerBound || length1 > Constants.AutoNewtonLengthUpperBound || length2 > Constants.AutoNewtonLengthUpperBound; " is 204.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The length of the statement  "		return _classicDivider.DivMod (digits1' digitsBuffer1' ref length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult); " is 136.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The length of the statement  "	fixed (uint* digitsPtr1 = digits1' digitsBufferPtr1 = digitsBuffer1' digitsPtr2 = digits2' digitsBufferPtr2 = digitsBuffer2 != null ? digitsBuffer2 : digits1' digitsResPtr = digitsRes != null ? digitsRes : digits1) { " is 216.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The length of the statement  "		return DivMod (digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2 == digitsPtr1 ? null : digitsBufferPtr2' length2' digitsResPtr == digitsPtr1 ? null : digitsResPtr' resultFlags' cmpResult); " is 211.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The length of the statement  "		return _classicDivider.DivMod (digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 151.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The length of the statement  "	uint resultLength = base.DivMod (digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 153.
Long Statement,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The length of the statement  "	uint[] int2OppositeDigits = NewtonHelper.GetIntegerOpposite (digitsPtr2' length2' length1' digitsBufferPtr1' out int2OppositeLength' out int2OppositeRightShift); " is 161.
Long Statement,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The length of the statement  "	fixed (uint* digitsPtr1 = digits1' digitsBufferPtr1 = digitsBuffer1' digitsPtr2 = digits2' digitsBufferPtr2 = digitsBuffer2' digitsResPtr = digitsRes != null ? digitsRes : digits1) { " is 182.
Long Statement,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The length of the statement  "		return DivMod (digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr == digitsPtr1 ? null : digitsResPtr' resultFlags' cmpResult); " is 171.
Long Statement,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The length of the statement  "	uint resultLength = base.DivMod (digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 153.
Long Statement,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The length of the statement  "			if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1 [iLen2 - 2]) { " is 137.
Long Statement,OpenGamingLibrary.Numerics.Dividers,DividerBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\DividerBase.cs,DivMod,The length of the statement  "	uint divLength = DivMod (int1._digits' modNeeded ? modRes._digits : null' ref modLength' int2._digits' null' int2._length' divNeeded ? divRes._digits : null' resultFlags' compareResult); " is 186.
Long Statement,OpenGamingLibrary.Numerics.Multipliers,AutoFhtMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\AutoFhtMultiplier.cs,Multiply,The length of the statement  "	if (length1 < Constants.AutoFhtLengthLowerBound || length2 < Constants.AutoFhtLengthLowerBound || length1 > Constants.AutoFhtLengthUpperBound || length2 > Constants.AutoFhtLengthUpperBound) { " is 191.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The length of the statement  "	fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf) { " is 120.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The length of the statement  "				nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift); " is 128.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The length of the statement  "			resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr); " is 123.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The length of the statement  "			resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true); " is 186.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The length of the statement  "				resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false); " is 172.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Add,The length of the statement  "	newInt._length = DigitOpHelper.Add (biggerInt._digits' biggerInt._length' smallerInt._digits' smallerInt._length' newInt._digits); " is 130.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Sub,The length of the statement  "	newInt._length = DigitOpHelper.Sub (biggerInt._digits' biggerInt._length' smallerInt._digits' smallerInt._length' newInt._digits); " is 130.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Sh,The length of the statement  "	uint newLength = (uint)(newBitCount / Constants.DigitBitCount + (newBitCount % Constants.DigitBitCount == 0 ? 0UL : 1UL)); " is 122.
Long Statement,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Sh,The length of the statement  "			DigitOpHelper.Shr (BigInteger._digits' 0' BigInteger._length' newInt._digits' fullDigits + 1' Constants.DigitBitCount - smallShift); " is 132.
Long Statement,OpenGamingLibrary.Numerics.Parsers,ParserBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ParserBase.cs,Parse,The length of the statement  "	return numberBase == 1U << Bits.Msb (numberBase) ? _pow2Parser.Parse (value' startIndex' endIndex' numberBase' charToDigits' digitsRes) : 0; " is 140.
Long Statement,OpenGamingLibrary.Numerics,BigInteger,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\BigInteger.cs,DivideModulo,The length of the statement  "	return DivideManager.GetCurrentDivider ().DivMod (int1' int2' out modRes' DivModResultFlags.Div | DivModResultFlags.Mod); " is 121.
Long Statement,OpenGamingLibrary.Numerics,BigInteger,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\BigInteger.cs,ToString,The length of the statement  "	return StringConvertManager.GetStringConverter (ToStringMode).ToString (this' numberBase' upperCase ? Constants.BaseUpperChars : Constants.BaseLowerChars); " is 155.
Long Statement,OpenGamingLibrary.Numerics,BigInteger,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\BigInteger.cs,Parse,The length of the statement  "	return ParseManager.GetCurrentParser ().Parse (value' numberBase' StrRepHelper.CharDictionaryFromAlphabet (alphabet' numberBase)' false); " is 137.
Long Statement,OpenGamingLibrary.Numerics,BigInteger,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\BigInteger.cs,Parse,The length of the statement  "	return ParseManager.GetParser (mode).Parse (value' numberBase' StrRepHelper.CharDictionaryFromAlphabet (alphabet' numberBase)' false); " is 134.
Complex Conditional,OpenGamingLibrary.Numerics.Multipliers,AutoFhtMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\AutoFhtMultiplier.cs,Multiply,The conditional expression  "length1 < Constants.AutoFhtLengthLowerBound || length2 < Constants.AutoFhtLengthLowerBound || length1 > Constants.AutoFhtLengthUpperBound || length2 > Constants.AutoFhtLengthUpperBound"  is complex.
Magic Number,OpenGamingLibrary.Numerics.Converters,FastStringConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\FastStringConverter.cs,ToString,The following statement contains a magic number: fixed (uint* resultPtr1Const = resultArray' resultPtr2Const = resultArray2' tempBufferPtr = tempBuffer) {  	// Results pointers which will be modified (on swap)  	uint* resultPtr1 = resultPtr1Const;  	uint* resultPtr2 = resultPtr2Const;  	// Temporary variables used on swapping  	uint[] tempArray;  	uint* tempPtr;  	// Variables used in cycle  	uint* ptr1' ptr2' ptr1end;  	uint loLength;  	// Outer cycle instead of recursion  	for (uint innerStep = resultLength >> 1' outerStep = resultLength; innerStep > 0; innerStep >>= 1' outerStep >>= 1) {  		// Prepare pointers  		ptr1 = resultPtr1;  		ptr2 = resultPtr2;  		ptr1end = resultPtr1 + resultLength;  		// Get baseInt from stack and fix it too  		baseInt = (BigInteger)baseIntStack.Pop ();  		fixed (uint* baseIntPtr = baseInt._digits) {  			// Cycle thru all digits and their lengths  			for (; ptr1 < ptr1end; ptr1 += outerStep' ptr2 += outerStep) {  				// Divide ptr1 (with length in *ptr2) by baseIntPtr here.  				// Results are stored in ptr2 & (ptr2 + innerStep)' lengths - in *ptr1 and (*ptr1 + innerStep)  				loLength = *ptr2;  				*(ptr1 + innerStep) = divider.DivMod (ptr1' ptr2' ref loLength' baseIntPtr' tempBufferPtr' baseInt._length' ptr2 + innerStep' DivModResultFlags.Div | DivModResultFlags.Mod' -2);  				*ptr1 = loLength;  			}  		}  		// After inner cycle resultArray will contain lengths and resultArray2 will contain actual values  		// so we need to swap them here  		tempArray = resultArray;  		resultArray = resultArray2;  		resultArray2 = tempArray;  		tempPtr = resultPtr1;  		resultPtr1 = resultPtr2;  		resultPtr2 = tempPtr;  	}  	// Retrieve real output length  	outputLength = DigitHelper.GetRealDigitsLength (resultArray2' outputLength);  	// Create output array  	outputArray = new uint[outputLength];  	// Copy each digit but only if length is not null  	fixed (uint* outputPtr = outputArray) {  		for (uint i = 0; i < outputLength; ++i) {  			if (resultPtr2 [i] != 0) {  				outputPtr [i] = resultPtr1 [i];  			}  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Converters,FastStringConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\FastStringConverter.cs,ToString,The following statement contains a magic number: for (uint innerStep = resultLength >> 1' outerStep = resultLength; innerStep > 0; innerStep >>= 1' outerStep >>= 1) {  	// Prepare pointers  	ptr1 = resultPtr1;  	ptr2 = resultPtr2;  	ptr1end = resultPtr1 + resultLength;  	// Get baseInt from stack and fix it too  	baseInt = (BigInteger)baseIntStack.Pop ();  	fixed (uint* baseIntPtr = baseInt._digits) {  		// Cycle thru all digits and their lengths  		for (; ptr1 < ptr1end; ptr1 += outerStep' ptr2 += outerStep) {  			// Divide ptr1 (with length in *ptr2) by baseIntPtr here.  			// Results are stored in ptr2 & (ptr2 + innerStep)' lengths - in *ptr1 and (*ptr1 + innerStep)  			loLength = *ptr2;  			*(ptr1 + innerStep) = divider.DivMod (ptr1' ptr2' ref loLength' baseIntPtr' tempBufferPtr' baseInt._length' ptr2 + innerStep' DivModResultFlags.Div | DivModResultFlags.Mod' -2);  			*ptr1 = loLength;  		}  	}  	// After inner cycle resultArray will contain lengths and resultArray2 will contain actual values  	// so we need to swap them here  	tempArray = resultArray;  	resultArray = resultArray2;  	resultArray2 = tempArray;  	tempPtr = resultPtr1;  	resultPtr1 = resultPtr2;  	resultPtr2 = tempPtr;  }  
Magic Number,OpenGamingLibrary.Numerics.Converters,FastStringConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\FastStringConverter.cs,ToString,The following statement contains a magic number: fixed (uint* baseIntPtr = baseInt._digits) {  	// Cycle thru all digits and their lengths  	for (; ptr1 < ptr1end; ptr1 += outerStep' ptr2 += outerStep) {  		// Divide ptr1 (with length in *ptr2) by baseIntPtr here.  		// Results are stored in ptr2 & (ptr2 + innerStep)' lengths - in *ptr1 and (*ptr1 + innerStep)  		loLength = *ptr2;  		*(ptr1 + innerStep) = divider.DivMod (ptr1' ptr2' ref loLength' baseIntPtr' tempBufferPtr' baseInt._length' ptr2 + innerStep' DivModResultFlags.Div | DivModResultFlags.Mod' -2);  		*ptr1 = loLength;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Converters,FastStringConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\FastStringConverter.cs,ToString,The following statement contains a magic number: for (; ptr1 < ptr1end; ptr1 += outerStep' ptr2 += outerStep) {  	// Divide ptr1 (with length in *ptr2) by baseIntPtr here.  	// Results are stored in ptr2 & (ptr2 + innerStep)' lengths - in *ptr1 and (*ptr1 + innerStep)  	loLength = *ptr2;  	*(ptr1 + innerStep) = divider.DivMod (ptr1' ptr2' ref loLength' baseIntPtr' tempBufferPtr' baseInt._length' ptr2 + innerStep' DivModResultFlags.Div | DivModResultFlags.Mod' -2);  	*ptr1 = loLength;  }  
Magic Number,OpenGamingLibrary.Numerics.Converters,FastStringConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\FastStringConverter.cs,ToString,The following statement contains a magic number: *(ptr1 + innerStep) = divider.DivMod (ptr1' ptr2' ref loLength' baseIntPtr' tempBufferPtr' baseInt._length' ptr2 + innerStep' DivModResultFlags.Div | DivModResultFlags.Mod' -2);  
Magic Number,OpenGamingLibrary.Numerics.Converters,StringConverterBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\StringConverterBase.cs,ToString,The following statement contains a magic number: if (numberBase < 2 || numberBase > 65536) {  	throw new ArgumentException (Strings.ToStringSmallBase' "numberBase");  }  
Magic Number,OpenGamingLibrary.Numerics.Converters,StringConverterBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Converters\StringConverterBase.cs,ToString,The following statement contains a magic number: if (numberBase < 2 || numberBase > 65536) {  	throw new ArgumentException (Strings.ToStringSmallBase' "numberBase");  }  
Magic Number,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The following statement contains a magic number: fixed (uint* oppositePtr = int2OppositeDigits' quotPtr = quotDigits) {  	// Multiply  	quotLength = multiplier.Multiply (oppositePtr' int2OppositeLength' digitsPtr1' length1' quotPtr);  	// Calculate shift  	uint shiftOffset = (uint)(int2OppositeRightShift / Constants.DigitBitCount);  	int shiftCount = (int)(int2OppositeRightShift % Constants.DigitBitCount);  	// Get the very first bit of the shifted part  	uint highestLostBit;  	if (shiftCount == 0) {  		highestLostBit = quotPtr [shiftOffset - 1] >> 31;  	}  	else {  		highestLostBit = quotPtr [shiftOffset] >> (shiftCount - 1) & 1U;  	}  	// After this result must be shifted to the right - this is required  	quotLength = DigitOpHelper.Shr (quotPtr + shiftOffset' quotLength - shiftOffset' quotPtr' shiftCount' false);  	// Maybe quotient must be corrected  	if (highestLostBit == 1U) {  		quotLength = DigitOpHelper.Add (quotPtr' quotLength' &highestLostBit' 1U' quotPtr);  	}  	// Check quotient - finally it might be too big.  	// For this we must multiply quotient by divider  	uint quotDivLength;  	uint[] quotDivDigits = new uint[quotLength + length2];  	fixed (uint* quotDivPtr = quotDivDigits) {  		quotDivLength = multiplier.Multiply (quotPtr' quotLength' digitsPtr2' length2' quotDivPtr);  		int cmpRes = DigitOpHelper.Cmp (quotDivPtr' quotDivLength' digitsPtr1' length1);  		if (cmpRes > 0) {  			highestLostBit = 1;  			quotLength = DigitOpHelper.Sub (quotPtr' quotLength' &highestLostBit' 1U' quotPtr);  			quotDivLength = DigitOpHelper.Sub (quotDivPtr' quotDivLength' digitsPtr2' length2' quotDivPtr);  		}  		// Now everything is ready and prepared to return results  		// First maybe fill remainder  		if ((resultFlags & DivModResultFlags.Mod) != 0) {  			length1 = DigitOpHelper.Sub (digitsPtr1' length1' quotDivPtr' quotDivLength' digitsBufferPtr1);  		}  		// And finally fill quotient  		if ((resultFlags & DivModResultFlags.Div) != 0) {  			DigitHelper.DigitsBlockCopy (quotPtr' digitsResPtr' quotLength);  		}  		else {  			quotLength = 0;  		}  		// Return some arrays to pool  		ArrayPool<uint>.Instance.AddArray (int2OppositeDigits);  		return quotLength;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The following statement contains a magic number: if (shiftCount == 0) {  	highestLostBit = quotPtr [shiftOffset - 1] >> 31;  }  else {  	highestLostBit = quotPtr [shiftOffset] >> (shiftCount - 1) & 1U;  }  
Magic Number,OpenGamingLibrary.Numerics.Dividers,AutoNewtonDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\AutoNewtonDivider.cs,DivMod,The following statement contains a magic number: highestLostBit = quotPtr [shiftOffset - 1] >> 31;  
Magic Number,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The following statement contains a magic number: for (uint i = maxLength' iLen2 = length1' j' ji; i <= maxLength; --i' --iLen2) {  	isMaxLength = iLen2 == length1;  	// Calculate estimates  	if (isMaxLength) {  		longDigit = digitsBufferPtr1 [iLen2 - 1];  	}  	else {  		longDigit = (ulong)digitsBufferPtr1 [iLen2] << Constants.DigitBitCount | digitsBufferPtr1 [iLen2 - 1];  	}  	divEst = longDigit / lastDigit2;  	modEst = longDigit - divEst * lastDigit2;  	// Check estimate (maybe correct it)  	for (; ;) {  		if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1 [iLen2 - 2]) {  			--divEst;  			modEst += lastDigit2;  			if (modEst < Constants.BitCountStepOf2)  				continue;  		}  		break;  	}  	divRes = (uint)divEst;  	// Multiply and subtract  	k = 0;  	for (j = 0' ji = i; j < length2; ++j' ++ji) {  		mulRes = (ulong)divRes * digitsBufferPtr2 [j];  		t = digitsBufferPtr1 [ji] - k - (long)(mulRes & 0xFFFFFFFF);  		digitsBufferPtr1 [ji] = (uint)t;  		k = (long)(mulRes >> Constants.DigitBitCount) - (t >> Constants.DigitBitCount);  	}  	if (!isMaxLength) {  		t = digitsBufferPtr1 [iLen2] - k;  		digitsBufferPtr1 [iLen2] = (uint)t;  	}  	else {  		t = -k;  	}  	// Correct result if subtracted too much  	if (t < 0) {  		--divRes;  		k = 0;  		for (j = 0' ji = i; j < length2; ++j' ++ji) {  			t = (long)digitsBufferPtr1 [ji] + digitsBufferPtr2 [j] + k;  			digitsBufferPtr1 [ji] = (uint)t;  			k = t >> Constants.DigitBitCount;  		}  		if (!isMaxLength) {  			digitsBufferPtr1 [iLen2] = (uint)(k + digitsBufferPtr1 [iLen2]);  		}  	}  	// Maybe save div result  	if (divNeeded) {  		digitsResPtr [i] = divRes;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The following statement contains a magic number: for (; ;) {  	if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1 [iLen2 - 2]) {  		--divEst;  		modEst += lastDigit2;  		if (modEst < Constants.BitCountStepOf2)  			continue;  	}  	break;  }  
Magic Number,OpenGamingLibrary.Numerics.Dividers,ClassicDivider,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\ClassicDivider.cs,DivMod,The following statement contains a magic number: if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1 [iLen2 - 2]) {  	--divEst;  	modEst += lastDigit2;  	if (modEst < Constants.BitCountStepOf2)  		continue;  }  
Magic Number,OpenGamingLibrary.Numerics.Dividers,DividerBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Dividers\DividerBase.cs,DivMod,The following statement contains a magic number: if (cmpResult == -2) {  	cmpResult = DigitOpHelper.Cmp (digitsPtr1' length1' digitsPtr2' length2);  }  
Magic Number,OpenGamingLibrary.Numerics.Multipliers,AutoFhtMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\AutoFhtMultiplier.cs,Multiply,The following statement contains a magic number: if (BigInteger.GlobalSettings.ApplyFhtValidityCheck) {  	uint lowerDigitCount = System.Math.Min (length2' System.Math.Min (length1' Constants.FhtValidityCheckDigitCount));  	// Validate result by multiplying lowerDigitCount digits using classic algorithm and comparing  	uint[] validationResult = new uint[lowerDigitCount * 2];  	fixed (uint* validationResultPtr = validationResult) {  		_classicMultiplier.Multiply (digitsPtr1' lowerDigitCount' digitsPtr2' lowerDigitCount' validationResultPtr);  		if (DigitOpHelper.Cmp (validationResultPtr' lowerDigitCount' digitsResPtr' lowerDigitCount) != 0) {  			throw new FhtMultiplicationException (string.Format (Strings.FhtMultiplicationError' length1' length2));  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Multipliers,ClassicMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\ClassicMultiplier.cs,Multiply,The following statement contains a magic number: for (; digitsPtr2 < digitsPtr2End; ++digitsPtr2' ++digitsResPtr) {  	// Check for zero (sometimes may help). There is no sense to make this check in internal cycle -  	// it would give performance gain only here  	if (*digitsPtr2 == 0)  		continue;  	c = 0;  	for (ptr1 = digitsPtr1' ptrRes = digitsResPtr; ptr1 < digitsPtr1End; ++ptr1' ++ptrRes) {  		c += (ulong)*digitsPtr2 * *ptr1 + *ptrRes;  		*ptrRes = (uint)c;  		c >>= 32;  	}  	*ptrRes = (uint)c;  }  
Magic Number,OpenGamingLibrary.Numerics.Multipliers,ClassicMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\ClassicMultiplier.cs,Multiply,The following statement contains a magic number: for (ptr1 = digitsPtr1' ptrRes = digitsResPtr; ptr1 < digitsPtr1End; ++ptr1' ++ptrRes) {  	c += (ulong)*digitsPtr2 * *ptr1 + *ptrRes;  	*ptrRes = (uint)c;  	c >>= 32;  }  
Magic Number,OpenGamingLibrary.Numerics.Multipliers,ClassicMultiplier,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\ClassicMultiplier.cs,Multiply,The following statement contains a magic number: c >>= 32;  
Magic Number,OpenGamingLibrary.Numerics.Multipliers,MultiplierBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Multipliers\MultiplierBase.cs,Multiply,The following statement contains a magic number: if (newLength >> 32 != 0) {  	throw new ArgumentException (Strings.IntegerTooBig);  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Add,The following statement contains a magic number: for (uint i = 0; i < length2; ++i) {  	c += (ulong)digitsPtr1 [i] + digitsPtr2 [i];  	digitsResPtr [i] = (uint)c;  	c >>= 32;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Add,The following statement contains a magic number: c >>= 32;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Add,The following statement contains a magic number: for (uint i = length2; i < length1; ++i) {  	c += digitsPtr1 [i];  	digitsResPtr [i] = (uint)c;  	c >>= 32;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Add,The following statement contains a magic number: c >>= 32;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Sub,The following statement contains a magic number: for (uint i = 0; i < length2; ++i) {  	c = (ulong)digitsPtr1 [i] - digitsPtr2 [i] - c;  	digitsResPtr [i] = (uint)c;  	c >>= 63;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Sub,The following statement contains a magic number: c >>= 63;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Sub,The following statement contains a magic number: for (uint i = length2; i < length1; ++i) {  	c = digitsPtr1 [i] - c;  	digitsResPtr [i] = (uint)c;  	c >>= 63;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Sub,The following statement contains a magic number: c >>= 63;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,Cmp,The following statement contains a magic number: if (res != -2)  	return res;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,DigitOpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\DigitOpHelper.cs,CmpLen,The following statement contains a magic number: return length1 == 0 ? 0 : -2;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ConvertDoubleToDigits,The following statement contains a magic number: for (uint i = 0; i < length; ++i) {  	// Get data digit (don't forget it might be balanced)  	dataDigit = slice [i] * normalizeMultiplier;  	#if DEBUG  	// Round to the nearest  	dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5);  	// Calculate and (maybe) store max error  	error = System.Math.Abs (dataDigit - dataDigitInt);  	if (error > maxError) {  		maxError = error;  	}  	// Add carry  	dataDigitInt += carryInt;  	#else  					// Round to the nearest 				dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5) + carryInt; #endif  	// Get next carry floored; maybe modify data digit  	carry = dataDigitInt / DoubleDataBase;  	if (carry < 0) {  		carry += carry % 1.0;  	}  	carryInt = (long)carry;  	dataDigitInt -= carryInt << DoubleDataDigitShift;  	if (dataDigitInt < 0) {  		dataDigitInt += DoubleDataBaseInt;  		--carryInt;  	}  	// Maybe add to the digits  	if (i < unitCount) {  		unitDigitsPtr [i] = (byte)dataDigitInt;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ConvertDoubleToDigits,The following statement contains a magic number: for (uint i = 0; i < length; ++i) {  	// Get data digit (don't forget it might be balanced)  	dataDigit = slice [i] * normalizeMultiplier;  	#if DEBUG  	// Round to the nearest  	dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5);  	// Calculate and (maybe) store max error  	error = System.Math.Abs (dataDigit - dataDigitInt);  	if (error > maxError) {  		maxError = error;  	}  	// Add carry  	dataDigitInt += carryInt;  	#else  					// Round to the nearest 				dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5) + carryInt; #endif  	// Get next carry floored; maybe modify data digit  	carry = dataDigitInt / DoubleDataBase;  	if (carry < 0) {  		carry += carry % 1.0;  	}  	carryInt = (long)carry;  	dataDigitInt -= carryInt << DoubleDataDigitShift;  	if (dataDigitInt < 0) {  		dataDigitInt += DoubleDataBaseInt;  		--carryInt;  	}  	// Maybe add to the digits  	if (i < unitCount) {  		unitDigitsPtr [i] = (byte)dataDigitInt;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ConvertDoubleToDigits,The following statement contains a magic number: dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5);  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ConvertDoubleToDigits,The following statement contains a magic number: dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5);  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,Fht,The following statement contains a magic number: if (length == 4) {  	Fht4 (slice);  	return;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,Fht4,The following statement contains a magic number: slice [2] = d02 + d13;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,Fht4,The following statement contains a magic number: slice [3] = d02 - d13;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: slice [0] *= 2.0 * slice2 [0];  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: slice [1] *= 2.0 * slice2 [1];  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2) {  	for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  		d11 = slice [index1];  		d12 = slice [index2];  		d21 = slice2 [index1];  		d22 = slice2 [index2];  		ad = d11 + d12;  		sd = d11 - d12;  		slice [index1] = d21 * ad + d22 * sd;  		slice [index2] = d22 * ad - d21 * sd;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2) {  	for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  		d11 = slice [index1];  		d12 = slice [index2];  		d21 = slice2 [index1];  		d22 = slice2 [index2];  		ad = d11 + d12;  		sd = d11 - d12;  		slice [index1] = d21 * ad + d22 * sd;  		slice [index2] = d22 * ad - d21 * sd;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2) {  	for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  		d11 = slice [index1];  		d12 = slice [index2];  		d21 = slice2 [index1];  		d22 = slice2 [index2];  		ad = d11 + d12;  		sd = d11 - d12;  		slice [index1] = d21 * ad + d22 * sd;  		slice [index2] = d22 * ad - d21 * sd;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2) {  	for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  		d11 = slice [index1];  		d12 = slice [index2];  		d21 = slice2 [index1];  		d22 = slice2 [index2];  		ad = d11 + d12;  		sd = d11 - d12;  		slice [index1] = d21 * ad + d22 * sd;  		slice [index2] = d22 * ad - d21 * sd;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2) {  	for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  		d11 = slice [index1];  		d12 = slice [index2];  		d21 = slice2 [index1];  		d22 = slice2 [index2];  		ad = d11 + d12;  		sd = d11 - d12;  		slice [index1] = d21 * ad + d22 * sd;  		slice [index2] = d22 * ad - d21 * sd;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2) {  	for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  		d11 = slice [index1];  		d12 = slice [index2];  		d21 = slice2 [index1];  		d22 = slice2 [index2];  		ad = d11 + d12;  		sd = d11 - d12;  		slice [index1] = d21 * ad + d22 * sd;  		slice [index2] = d22 * ad - d21 * sd;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: stepStart *= 2
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: stepEnd *= 2
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  	d11 = slice [index1];  	d12 = slice [index2];  	d21 = slice2 [index1];  	d22 = slice2 [index2];  	ad = d11 + d12;  	sd = d11 - d12;  	slice [index1] = d21 * ad + d22 * sd;  	slice [index2] = d22 * ad - d21 * sd;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2) {  	d11 = slice [index1];  	d12 = slice [index2];  	d21 = slice2 [index1];  	d22 = slice2 [index2];  	ad = d11 + d12;  	sd = d11 - d12;  	slice [index1] = d21 * ad + d22 * sd;  	slice [index2] = d22 * ad - d21 * sd;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: index1 += 2
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,MultiplyFhtResults,The following statement contains a magic number: index2 -= 2
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht,The following statement contains a magic number: if (length == 8) {  	ReverseFht8 (slice);  	return;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht8,The following statement contains a magic number: slice [4] = daa0123 - daa4567;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht8,The following statement contains a magic number: slice [2] = dsa0123 + dsa4567;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht8,The following statement contains a magic number: slice [6] = dsa0123 - dsa4567;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht8,The following statement contains a magic number: slice [5] = das0123 - ds45;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht8,The following statement contains a magic number: slice [3] = dss0123 + ds67;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,ReverseFht8,The following statement contains a magic number: slice [7] = dss0123 - ds67;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,FillSineTable,The following statement contains a magic number: for (int i = 0' p = 1; i < sineTable.Length; ++i' p *= 2) {  	sineTable [i] = System.Math.Sin (System.Math.PI / p);  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,FillSineTable,The following statement contains a magic number: p *= 2
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,FhtHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\FhtHelper.cs,GetInitialTrigValues,The following statement contains a magic number: valuesPtr->TableCos *= -2.0 * valuesPtr->TableCos;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: if (msb != 2) {  	// Shift to the left (via actually right shift)  	int leftShift = (2 - msb + Constants.DigitBitCount) % Constants.DigitBitCount;  	length = DigitOpHelper.Shr (digitsPtr' length' bufferPtr + 1' Constants.DigitBitCount - leftShift' true) + 1U;  }  else {  	// Simply use the same digits without any shifting  	bufferPtr = digitsPtr;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: if (msb != 2) {  	// Shift to the left (via actually right shift)  	int leftShift = (2 - msb + Constants.DigitBitCount) % Constants.DigitBitCount;  	length = DigitOpHelper.Shr (digitsPtr' length' bufferPtr + 1' Constants.DigitBitCount - leftShift' true) + 1U;  }  else {  	// Simply use the same digits without any shifting  	bufferPtr = digitsPtr;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf) {  	uint* resultPtr = resultPtrFixed;  	uint* resultSqrPtr = resultSqrPtrFixed;  	// Cache two first digits  	uint bufferDigitN1 = bufferPtr [length - 1];  	uint bufferDigitN2 = bufferPtr [length - 2];  	// Prepare result.  	// Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4  	// (last division is not floored - here we emulate fixed point)  	resultDigits [0] = 32 / bufferDigitN1;  	resultLength = 1;  	// Prepare variables  	uint nextBufferTempStorage = 0;  	int nextBufferTempShift;  	uint nextBufferLength = 1U;  	uint* nextBufferPtr = &nextBufferTempStorage;  	ulong bitsAfterDotResult;  	ulong bitsAfterDotResultSqr;  	ulong bitsAfterDotNextBuffer;  	ulong bitShift;  	uint shiftOffset;  	uint* tempPtr;  	uint[] tempDigits;  	// Iterate 'till result will be precise enough  	for (int k = 0; k < lengthLog2Bits; ++k) {  		// Get result squared  		resultLengthSqr = multiplier.Multiply (resultPtr' resultLength' resultPtr' resultLength' resultSqrPtr);  		// Calculate current result bits after dot  		bitsAfterDotResult = (1UL << k) + 1UL;  		bitsAfterDotResultSqr = bitsAfterDotResult << 1;  		// Here we will get the next portion of data from bufferPtr  		if (k < 4) {  			// For now buffer intermediate has length 1 and we will use this fact  			nextBufferTempShift = 1 << (k + 1);  			nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  		}  		else {  			// Determine length to get from bufferPtr  			nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  			nextBufferPtr = bufferPtr + (length - nextBufferLength);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  		}  		// Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot  		resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr);  		bitsAfterDotNextBuffer += bitsAfterDotResultSqr;  		// Now calculate 2 * result - resultSqrBufPtr  		--bitsAfterDotResult;  		--bitsAfterDotResultSqr;  		// Shift result on a needed amount of bits to the left  		bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true);  		// Swap resultPtr and resultSqrPtr pointers  		tempPtr = resultPtr;  		resultPtr = resultSqrPtr;  		resultSqrPtr = tempPtr;  		tempDigits = resultDigits;  		resultDigits = resultDigitsSqr;  		resultDigitsSqr = tempDigits;  		DigitHelper.SetBlockDigits (resultPtr' shiftOffset' 0U);  		bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		if (shiftOffset < resultLengthSqrBuf) {  			// Shift resultSqrBufPtr on a needed amount of bits to the right  			resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false);  			// Now perform actual subtraction  			resultLength = DigitOpHelper.Sub (resultPtr' resultLength' resultSqrBufPtr' resultLengthSqrBuf' resultPtr);  		}  		else {  			// Actually we can assume resultSqrBufPtr == 0 here and have nothing to do  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf) {  	uint* resultPtr = resultPtrFixed;  	uint* resultSqrPtr = resultSqrPtrFixed;  	// Cache two first digits  	uint bufferDigitN1 = bufferPtr [length - 1];  	uint bufferDigitN2 = bufferPtr [length - 2];  	// Prepare result.  	// Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4  	// (last division is not floored - here we emulate fixed point)  	resultDigits [0] = 32 / bufferDigitN1;  	resultLength = 1;  	// Prepare variables  	uint nextBufferTempStorage = 0;  	int nextBufferTempShift;  	uint nextBufferLength = 1U;  	uint* nextBufferPtr = &nextBufferTempStorage;  	ulong bitsAfterDotResult;  	ulong bitsAfterDotResultSqr;  	ulong bitsAfterDotNextBuffer;  	ulong bitShift;  	uint shiftOffset;  	uint* tempPtr;  	uint[] tempDigits;  	// Iterate 'till result will be precise enough  	for (int k = 0; k < lengthLog2Bits; ++k) {  		// Get result squared  		resultLengthSqr = multiplier.Multiply (resultPtr' resultLength' resultPtr' resultLength' resultSqrPtr);  		// Calculate current result bits after dot  		bitsAfterDotResult = (1UL << k) + 1UL;  		bitsAfterDotResultSqr = bitsAfterDotResult << 1;  		// Here we will get the next portion of data from bufferPtr  		if (k < 4) {  			// For now buffer intermediate has length 1 and we will use this fact  			nextBufferTempShift = 1 << (k + 1);  			nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  		}  		else {  			// Determine length to get from bufferPtr  			nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  			nextBufferPtr = bufferPtr + (length - nextBufferLength);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  		}  		// Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot  		resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr);  		bitsAfterDotNextBuffer += bitsAfterDotResultSqr;  		// Now calculate 2 * result - resultSqrBufPtr  		--bitsAfterDotResult;  		--bitsAfterDotResultSqr;  		// Shift result on a needed amount of bits to the left  		bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true);  		// Swap resultPtr and resultSqrPtr pointers  		tempPtr = resultPtr;  		resultPtr = resultSqrPtr;  		resultSqrPtr = tempPtr;  		tempDigits = resultDigits;  		resultDigits = resultDigitsSqr;  		resultDigitsSqr = tempDigits;  		DigitHelper.SetBlockDigits (resultPtr' shiftOffset' 0U);  		bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		if (shiftOffset < resultLengthSqrBuf) {  			// Shift resultSqrBufPtr on a needed amount of bits to the right  			resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false);  			// Now perform actual subtraction  			resultLength = DigitOpHelper.Sub (resultPtr' resultLength' resultSqrBufPtr' resultLengthSqrBuf' resultPtr);  		}  		else {  			// Actually we can assume resultSqrBufPtr == 0 here and have nothing to do  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf) {  	uint* resultPtr = resultPtrFixed;  	uint* resultSqrPtr = resultSqrPtrFixed;  	// Cache two first digits  	uint bufferDigitN1 = bufferPtr [length - 1];  	uint bufferDigitN2 = bufferPtr [length - 2];  	// Prepare result.  	// Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4  	// (last division is not floored - here we emulate fixed point)  	resultDigits [0] = 32 / bufferDigitN1;  	resultLength = 1;  	// Prepare variables  	uint nextBufferTempStorage = 0;  	int nextBufferTempShift;  	uint nextBufferLength = 1U;  	uint* nextBufferPtr = &nextBufferTempStorage;  	ulong bitsAfterDotResult;  	ulong bitsAfterDotResultSqr;  	ulong bitsAfterDotNextBuffer;  	ulong bitShift;  	uint shiftOffset;  	uint* tempPtr;  	uint[] tempDigits;  	// Iterate 'till result will be precise enough  	for (int k = 0; k < lengthLog2Bits; ++k) {  		// Get result squared  		resultLengthSqr = multiplier.Multiply (resultPtr' resultLength' resultPtr' resultLength' resultSqrPtr);  		// Calculate current result bits after dot  		bitsAfterDotResult = (1UL << k) + 1UL;  		bitsAfterDotResultSqr = bitsAfterDotResult << 1;  		// Here we will get the next portion of data from bufferPtr  		if (k < 4) {  			// For now buffer intermediate has length 1 and we will use this fact  			nextBufferTempShift = 1 << (k + 1);  			nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  		}  		else {  			// Determine length to get from bufferPtr  			nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  			nextBufferPtr = bufferPtr + (length - nextBufferLength);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  		}  		// Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot  		resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr);  		bitsAfterDotNextBuffer += bitsAfterDotResultSqr;  		// Now calculate 2 * result - resultSqrBufPtr  		--bitsAfterDotResult;  		--bitsAfterDotResultSqr;  		// Shift result on a needed amount of bits to the left  		bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true);  		// Swap resultPtr and resultSqrPtr pointers  		tempPtr = resultPtr;  		resultPtr = resultSqrPtr;  		resultSqrPtr = tempPtr;  		tempDigits = resultDigits;  		resultDigits = resultDigitsSqr;  		resultDigitsSqr = tempDigits;  		DigitHelper.SetBlockDigits (resultPtr' shiftOffset' 0U);  		bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		if (shiftOffset < resultLengthSqrBuf) {  			// Shift resultSqrBufPtr on a needed amount of bits to the right  			resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false);  			// Now perform actual subtraction  			resultLength = DigitOpHelper.Sub (resultPtr' resultLength' resultSqrBufPtr' resultLengthSqrBuf' resultPtr);  		}  		else {  			// Actually we can assume resultSqrBufPtr == 0 here and have nothing to do  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf) {  	uint* resultPtr = resultPtrFixed;  	uint* resultSqrPtr = resultSqrPtrFixed;  	// Cache two first digits  	uint bufferDigitN1 = bufferPtr [length - 1];  	uint bufferDigitN2 = bufferPtr [length - 2];  	// Prepare result.  	// Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4  	// (last division is not floored - here we emulate fixed point)  	resultDigits [0] = 32 / bufferDigitN1;  	resultLength = 1;  	// Prepare variables  	uint nextBufferTempStorage = 0;  	int nextBufferTempShift;  	uint nextBufferLength = 1U;  	uint* nextBufferPtr = &nextBufferTempStorage;  	ulong bitsAfterDotResult;  	ulong bitsAfterDotResultSqr;  	ulong bitsAfterDotNextBuffer;  	ulong bitShift;  	uint shiftOffset;  	uint* tempPtr;  	uint[] tempDigits;  	// Iterate 'till result will be precise enough  	for (int k = 0; k < lengthLog2Bits; ++k) {  		// Get result squared  		resultLengthSqr = multiplier.Multiply (resultPtr' resultLength' resultPtr' resultLength' resultSqrPtr);  		// Calculate current result bits after dot  		bitsAfterDotResult = (1UL << k) + 1UL;  		bitsAfterDotResultSqr = bitsAfterDotResult << 1;  		// Here we will get the next portion of data from bufferPtr  		if (k < 4) {  			// For now buffer intermediate has length 1 and we will use this fact  			nextBufferTempShift = 1 << (k + 1);  			nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  		}  		else {  			// Determine length to get from bufferPtr  			nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  			nextBufferPtr = bufferPtr + (length - nextBufferLength);  			// Calculate amount of bits after dot (simple formula here)  			bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  		}  		// Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot  		resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr);  		bitsAfterDotNextBuffer += bitsAfterDotResultSqr;  		// Now calculate 2 * result - resultSqrBufPtr  		--bitsAfterDotResult;  		--bitsAfterDotResultSqr;  		// Shift result on a needed amount of bits to the left  		bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true);  		// Swap resultPtr and resultSqrPtr pointers  		tempPtr = resultPtr;  		resultPtr = resultSqrPtr;  		resultSqrPtr = tempPtr;  		tempDigits = resultDigits;  		resultDigits = resultDigitsSqr;  		resultDigitsSqr = tempDigits;  		DigitHelper.SetBlockDigits (resultPtr' shiftOffset' 0U);  		bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;  		shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  		if (shiftOffset < resultLengthSqrBuf) {  			// Shift resultSqrBufPtr on a needed amount of bits to the right  			resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false);  			// Now perform actual subtraction  			resultLength = DigitOpHelper.Sub (resultPtr' resultLength' resultSqrBufPtr' resultLengthSqrBuf' resultPtr);  		}  		else {  			// Actually we can assume resultSqrBufPtr == 0 here and have nothing to do  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: resultDigits [0] = 32 / bufferDigitN1;  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: for (int k = 0; k < lengthLog2Bits; ++k) {  	// Get result squared  	resultLengthSqr = multiplier.Multiply (resultPtr' resultLength' resultPtr' resultLength' resultSqrPtr);  	// Calculate current result bits after dot  	bitsAfterDotResult = (1UL << k) + 1UL;  	bitsAfterDotResultSqr = bitsAfterDotResult << 1;  	// Here we will get the next portion of data from bufferPtr  	if (k < 4) {  		// For now buffer intermediate has length 1 and we will use this fact  		nextBufferTempShift = 1 << (k + 1);  		nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  		// Calculate amount of bits after dot (simple formula here)  		bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  	}  	else {  		// Determine length to get from bufferPtr  		nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  		nextBufferPtr = bufferPtr + (length - nextBufferLength);  		// Calculate amount of bits after dot (simple formula here)  		bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  	}  	// Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot  	resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr);  	bitsAfterDotNextBuffer += bitsAfterDotResultSqr;  	// Now calculate 2 * result - resultSqrBufPtr  	--bitsAfterDotResult;  	--bitsAfterDotResultSqr;  	// Shift result on a needed amount of bits to the left  	bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;  	shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  	resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true);  	// Swap resultPtr and resultSqrPtr pointers  	tempPtr = resultPtr;  	resultPtr = resultSqrPtr;  	resultSqrPtr = tempPtr;  	tempDigits = resultDigits;  	resultDigits = resultDigitsSqr;  	resultDigitsSqr = tempDigits;  	DigitHelper.SetBlockDigits (resultPtr' shiftOffset' 0U);  	bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;  	shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  	if (shiftOffset < resultLengthSqrBuf) {  		// Shift resultSqrBufPtr on a needed amount of bits to the right  		resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false);  		// Now perform actual subtraction  		resultLength = DigitOpHelper.Sub (resultPtr' resultLength' resultSqrBufPtr' resultLengthSqrBuf' resultPtr);  	}  	else {  		// Actually we can assume resultSqrBufPtr == 0 here and have nothing to do  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: for (int k = 0; k < lengthLog2Bits; ++k) {  	// Get result squared  	resultLengthSqr = multiplier.Multiply (resultPtr' resultLength' resultPtr' resultLength' resultSqrPtr);  	// Calculate current result bits after dot  	bitsAfterDotResult = (1UL << k) + 1UL;  	bitsAfterDotResultSqr = bitsAfterDotResult << 1;  	// Here we will get the next portion of data from bufferPtr  	if (k < 4) {  		// For now buffer intermediate has length 1 and we will use this fact  		nextBufferTempShift = 1 << (k + 1);  		nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  		// Calculate amount of bits after dot (simple formula here)  		bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  	}  	else {  		// Determine length to get from bufferPtr  		nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  		nextBufferPtr = bufferPtr + (length - nextBufferLength);  		// Calculate amount of bits after dot (simple formula here)  		bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  	}  	// Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot  	resultLengthSqrBuf = multiplier.Multiply (resultSqrPtr' resultLengthSqr' nextBufferPtr' nextBufferLength' resultSqrBufPtr);  	bitsAfterDotNextBuffer += bitsAfterDotResultSqr;  	// Now calculate 2 * result - resultSqrBufPtr  	--bitsAfterDotResult;  	--bitsAfterDotResultSqr;  	// Shift result on a needed amount of bits to the left  	bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;  	shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  	resultLength = shiftOffset + 1U + DigitOpHelper.Shr (resultPtr' resultLength' resultSqrPtr + shiftOffset + 1U' Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)' true);  	// Swap resultPtr and resultSqrPtr pointers  	tempPtr = resultPtr;  	resultPtr = resultSqrPtr;  	resultSqrPtr = tempPtr;  	tempDigits = resultDigits;  	resultDigits = resultDigitsSqr;  	resultDigitsSqr = tempDigits;  	DigitHelper.SetBlockDigits (resultPtr' shiftOffset' 0U);  	bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;  	shiftOffset = (uint)(bitShift / Constants.DigitBitCount);  	if (shiftOffset < resultLengthSqrBuf) {  		// Shift resultSqrBufPtr on a needed amount of bits to the right  		resultLengthSqrBuf = DigitOpHelper.Shr (resultSqrBufPtr + shiftOffset' resultLengthSqrBuf - shiftOffset' resultSqrBufPtr' (int)(bitShift % Constants.DigitBitCount)' false);  		// Now perform actual subtraction  		resultLength = DigitOpHelper.Sub (resultPtr' resultLength' resultSqrBufPtr' resultLengthSqrBuf' resultPtr);  	}  	else {  		// Actually we can assume resultSqrBufPtr == 0 here and have nothing to do  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: if (k < 4) {  	// For now buffer intermediate has length 1 and we will use this fact  	nextBufferTempShift = 1 << (k + 1);  	nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  	// Calculate amount of bits after dot (simple formula here)  	bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  }  else {  	// Determine length to get from bufferPtr  	nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  	nextBufferPtr = bufferPtr + (length - nextBufferLength);  	// Calculate amount of bits after dot (simple formula here)  	bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: if (k < 4) {  	// For now buffer intermediate has length 1 and we will use this fact  	nextBufferTempShift = 1 << (k + 1);  	nextBufferTempStorage = bufferDigitN1 << nextBufferTempShift | bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);  	// Calculate amount of bits after dot (simple formula here)  	bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;  }  else {  	// Determine length to get from bufferPtr  	nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  	nextBufferPtr = bufferPtr + (length - nextBufferLength);  	// Calculate amount of bits after dot (simple formula here)  	bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,NewtonHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\NewtonHelper.cs,GetIntegerOpposite,The following statement contains a magic number: nextBufferLength = System.Math.Min ((1U << (k - 4)) + 1U' length);  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Cmp,The following statement contains a magic number: if (isNull1 || isNull2) {  	if (throwNullException) {  		throw new ArgumentNullException (isNull1 ? "int1" : "int2"' Strings.CantBeNullCmp);  	}  	else {  		return isNull1 && isNull2 ? 0 : -2;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Cmp,The following statement contains a magic number: if (throwNullException) {  	throw new ArgumentNullException (isNull1 ? "int1" : "int2"' Strings.CantBeNullCmp);  }  else {  	return isNull1 && isNull2 ? 0 : -2;  }  
Magic Number,OpenGamingLibrary.Numerics.OpHelpers,OpHelper,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\OpHelpers\OpHelper.cs,Cmp,The following statement contains a magic number: return isNull1 && isNull2 ? 0 : -2;  
Magic Number,OpenGamingLibrary.Numerics.Parsers,ClassicParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ClassicParser.cs,Parse,The following statement contains a magic number: for (int i = startIndex; i <= endIndex; ++i) {  	digit = StrRepHelper.GetDigit (charToDigits' value [i]' numberBase);  	// Next multiply existing values by base and add this value to them  	if (newLength == 0) {  		if (digit != 0) {  			digitsRes [0] = (uint)digit;  			newLength = 1;  		}  	}  	else {  		for (uint j = 0; j < newLength; ++j) {  			digit += digitsRes [j] * numberBaseLong;  			digitsRes [j] = (uint)digit;  			digit >>= 32;  		}  		if (digit != 0) {  			digitsRes [newLength++] = (uint)digit;  		}  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Parsers,ClassicParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ClassicParser.cs,Parse,The following statement contains a magic number: if (newLength == 0) {  	if (digit != 0) {  		digitsRes [0] = (uint)digit;  		newLength = 1;  	}  }  else {  	for (uint j = 0; j < newLength; ++j) {  		digit += digitsRes [j] * numberBaseLong;  		digitsRes [j] = (uint)digit;  		digit >>= 32;  	}  	if (digit != 0) {  		digitsRes [newLength++] = (uint)digit;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Parsers,ClassicParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ClassicParser.cs,Parse,The following statement contains a magic number: for (uint j = 0; j < newLength; ++j) {  	digit += digitsRes [j] * numberBaseLong;  	digitsRes [j] = (uint)digit;  	digit >>= 32;  }  
Magic Number,OpenGamingLibrary.Numerics.Parsers,ClassicParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ClassicParser.cs,Parse,The following statement contains a magic number: digit >>= 32;  
Magic Number,OpenGamingLibrary.Numerics.Parsers,FastParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\FastParser.cs,Parse,The following statement contains a magic number: fixed (uint* valueDigitsStartPtr = valueDigits' valueDigitsStartPtr2 = valueDigits2) {  	// In the string first digit means last in digits array  	uint* valueDigitsPtr = valueDigitsStartPtr + valueLength - 1;  	uint* valueDigitsPtr2 = valueDigitsStartPtr2 + valueLength - 1;  	// Reverse copy characters into digits  	fixed (char* valueStartPtr = value) {  		char* valuePtr = valueStartPtr + startIndex;  		char* valueEndPtr = valuePtr + valueLength;  		for (; valuePtr < valueEndPtr; ++valuePtr' --valueDigitsPtr' --valueDigitsPtr2) {  			// Get digit itself - this call will throw an exception if char is invalid  			*valueDigitsPtr = StrRepHelper.GetDigit (charToDigits' *valuePtr' numberBase);  			// Set length of this digit (zero for zero)  			*valueDigitsPtr2 = *valueDigitsPtr == 0U ? 0U : 1U;  		}  	}  	// We have retrieved lengths array from pool - it needs to be cleared before using  	DigitHelper.SetBlockDigits (valueDigitsStartPtr2 + valueLength' digitsLength - valueLength' 0);  	// Now start from the digit arrays beginning  	valueDigitsPtr = valueDigitsStartPtr;  	valueDigitsPtr2 = valueDigitsStartPtr2;  	// Current multiplier (classic or fast) will be used  	IMultiplier multiplier = MultiplyManager.GetCurrentMultiplier ();  	// Here base in needed power will be stored  	BigInteger baseInt = null;  	// Temporary variables used on swapping  	uint[] tempDigits;  	uint* tempPtr;  	// Variables used in cycle  	uint* ptr1' ptr2' valueDigitsPtrEnd;  	uint loLength' hiLength;  	// Outer cycle instead of recursion  	for (uint innerStep = 1' outerStep = 2; innerStep < digitsLength; innerStep <<= 1' outerStep <<= 1) {  		// Maybe baseInt must be multiplied by itself  		baseInt = baseInt == null ? numberBase : baseInt * baseInt;  		// Using unsafe here  		fixed (uint* baseDigitsPtr = baseInt._digits) {  			// Start from arrays beginning  			ptr1 = valueDigitsPtr;  			ptr2 = valueDigitsPtr2;  			// vauleDigits array end  			valueDigitsPtrEnd = valueDigitsPtr + digitsLength;  			// Cycle thru all digits and their lengths  			for (; ptr1 < valueDigitsPtrEnd; ptr1 += outerStep' ptr2 += outerStep) {  				// Get lengths of "lower" and "higher" value parts  				loLength = *ptr2;  				hiLength = *(ptr2 + innerStep);  				if (hiLength != 0) {  					// We always must clear an array before multiply  					DigitHelper.SetBlockDigits (ptr2' outerStep' 0U);  					// Multiply per baseInt  					hiLength = multiplier.Multiply (baseDigitsPtr' baseInt._length' ptr1 + innerStep' hiLength' ptr2);  				}  				// Sum results  				if (hiLength != 0 || loLength != 0) {  					*ptr1 = DigitOpHelper.Add (ptr2' hiLength' ptr1' loLength' ptr2);  				}  				else {  					*ptr1 = 0U;  				}  			}  		}  		// After inner cycle valueDigits will contain lengths and valueDigits2 will contain actual values  		// so we need to swap them here  		tempDigits = valueDigits;  		valueDigits = valueDigits2;  		valueDigits2 = tempDigits;  		tempPtr = valueDigitsPtr;  		valueDigitsPtr = valueDigitsPtr2;  		valueDigitsPtr2 = tempPtr;  	}  }  
Magic Number,OpenGamingLibrary.Numerics.Parsers,FastParser,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\FastParser.cs,Parse,The following statement contains a magic number: for (uint innerStep = 1' outerStep = 2; innerStep < digitsLength; innerStep <<= 1' outerStep <<= 1) {  	// Maybe baseInt must be multiplied by itself  	baseInt = baseInt == null ? numberBase : baseInt * baseInt;  	// Using unsafe here  	fixed (uint* baseDigitsPtr = baseInt._digits) {  		// Start from arrays beginning  		ptr1 = valueDigitsPtr;  		ptr2 = valueDigitsPtr2;  		// vauleDigits array end  		valueDigitsPtrEnd = valueDigitsPtr + digitsLength;  		// Cycle thru all digits and their lengths  		for (; ptr1 < valueDigitsPtrEnd; ptr1 += outerStep' ptr2 += outerStep) {  			// Get lengths of "lower" and "higher" value parts  			loLength = *ptr2;  			hiLength = *(ptr2 + innerStep);  			if (hiLength != 0) {  				// We always must clear an array before multiply  				DigitHelper.SetBlockDigits (ptr2' outerStep' 0U);  				// Multiply per baseInt  				hiLength = multiplier.Multiply (baseDigitsPtr' baseInt._length' ptr1 + innerStep' hiLength' ptr2);  			}  			// Sum results  			if (hiLength != 0 || loLength != 0) {  				*ptr1 = DigitOpHelper.Add (ptr2' hiLength' ptr1' loLength' ptr2);  			}  			else {  				*ptr1 = 0U;  			}  		}  	}  	// After inner cycle valueDigits will contain lengths and valueDigits2 will contain actual values  	// so we need to swap them here  	tempDigits = valueDigits;  	valueDigits = valueDigits2;  	valueDigits2 = tempDigits;  	tempPtr = valueDigitsPtr;  	valueDigitsPtr = valueDigitsPtr2;  	valueDigitsPtr2 = tempPtr;  }  
Magic Number,OpenGamingLibrary.Numerics.Parsers,ParserBase,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Parsers\ParserBase.cs,Parse,The following statement contains a magic number: if (numberBase < 2 || numberBase > charToDigits.Count) {  	throw new ArgumentException (Strings.ParseBaseInvalid' "numberBase");  }  
Magic Number,OpenGamingLibrary.Numerics.Utils,Constants,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Utils\Constants.cs,Constants,The following statement contains a magic number: for (int i = 10; i < BaseLowerChars.Length; i++) {  	BaseCharToDigits.Add (BaseLowerChars [i]' (uint)i);  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if (x == 0)  	return 32;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: return 32;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 16) == 0) {  	n += 16;  	x <<= 16;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 16) == 0) {  	n += 16;  	x <<= 16;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 16) == 0) {  	n += 16;  	x <<= 16;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: n += 16;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: x <<= 16;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 24) == 0) {  	n += 8;  	x <<= 8;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 24) == 0) {  	n += 8;  	x <<= 8;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 24) == 0) {  	n += 8;  	x <<= 8;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: n += 8;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: x <<= 8;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 28) == 0) {  	n += 4;  	x <<= 4;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 28) == 0) {  	n += 4;  	x <<= 4;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 28) == 0) {  	n += 4;  	x <<= 4;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: n += 4;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: x <<= 4;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 30) == 0) {  	n += 2;  	x <<= 2;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 30) == 0) {  	n += 2;  	x <<= 2;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: if ((x >> 30) == 0) {  	n += 2;  	x <<= 2;  }  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: n += 2;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: x <<= 2;  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Nlz,The following statement contains a magic number: return n - (int)(x >> 31);  
Magic Number,OpenGamingLibrary.Numerics,Bits,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\Bits.cs,Msb,The following statement contains a magic number: return 31 - Nlz (x);  
Magic Number,OpenGamingLibrary.Numerics,DigitConverter,C:\repos\extesla_OpenGamingLibrary\Source\main\OpenGamingLibrary.Numerics\DigitConverter.cs,FromBytes,The following statement contains a magic number: if (bytes.Length % 4 != 0) {  	throw new ArgumentException (Strings.DigitBytesLengthInvalid' "bytes");  }  
